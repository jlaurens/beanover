% \iffalse meta-comment
% !TEX program  = LuaLaTeX
% !TEX encoding = UTF-8
%
% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2022 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of multiple time lines in |beamer| documents.
Time lines are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\generate{
  \nopreamble
  \nopostamble
  \file{\jobname-test.lua}{\from{\jobname.dtx}{test-lua}}
}
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay specifications

Copyright (C) 2023 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf,
                                beanoves.sty and
                                beanoves-debug.sty.

\endpostamble
\generate{
  \file{\jobname-debug.sty}{\from{\jobname.dtx}{package,debug}}
}
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package,gubed,final}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% !TeX proot = ...
\PassOptionsToPackage{enable-debug}{expl3}
\documentclass{l3doc}
\RequirePackage{luacode}
\RequirePackage{beanoves-debug}
\ExplSyntaxOn
\cs_new:Npn \BNVSNote {
  \msg_note:nnn { beanoves } { :n }
}
\ExplSyntaxOff
\ProvideDocumentEnvironment{bnvs.test}{+b}{}{}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\tcbuselibrary{minted}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specifications with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{\jobname-debug.sty}
\date{\fileversion \qquad \filedate}
\NewDocumentEnvironment{bnvs.macrocode}{}{
  \setlength{\topsep}{0.4em plus 0.15 em minus 0.15 em}
  \begin{trivlist}
  \setlist[trivlist]{nosep}
  \item\vspace{-\baselineskip}
}{
  \end{trivlist}
}
%\OnlyDescription
\begin{document}
\maketitle
\changes{v1.0}{2023/01/07}{First public release}
\begin{abstract}
This package allows the management of multiple named slide number sets in \pkg{beamer} documents.
Named slide number sets are very handy both during edition and to manage complex and variable \pkg{beamer} overlay specifications. In particular, they allow to replace raw numbers in \pkg{beamer} |<...>| overlay specifications by logical identifiers. Demonstration files are \href[pdfnewwindow]{https://github.com/jlaurens/beanoves/tree/main/demo}{available for download} as part of the
\href[pdfnewwindow]{https://github.com/jlaurens/beanoves/}{development repository}.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanoves}
\begin{document}
\Beanoves {
      A = 1:3,
      B = A.next::3,
      C = B.next,
    }
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.1)-?(B.last)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2:B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.next)-> {From slide 3}\\
\visible<?(B.3:B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare \emph{named overlay sets}.
On line 5, we declare an overlay set named `A', which is a range starting at slide 1 and ending at slide 3.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1 because 1 is the first index of the overlay set named A.
On line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.next)} stands for 3.
%
On line 6, we declare a second overlay set named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last slide number is 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide number after slide range `B' is 6
which is also the start of the third slide range
due to line 7.
\section{Named overlay sets}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn
according to overlay specifications. The main overlay sets is a range of integers
covering all the slide numbers, from one to the total amount of slides.
In general, an overlay set is a range of positive integers identified by a unique name.
The main practical interest is that such sets may be defined relative to one another, we can even have lists of overlay sets.
Finally, we can use these lists to build and organize \pkg{beamer} overlay
specifications logically.
\subsection{Named overlay reference}
|A.1|, |C.2| are \emph{named overlay references}, as well as |A| and |Y!C.2|.
More precisely, they are string identifiers, each one representing
a well defined static integer to be used in \pkg{beamer} overlay specifications.
They can take one of the next forms.
\begin{description}
\item[\texttt{\meta{short name}}]: like |A| and |C|,
\item[\texttt{\meta{frame id}|!|\meta{short name}}]: denoted by \emph{qualified names}, like |X!A| and |Y!C|.
\item[\texttt{\meta{short name}\meta{dotted path}}]:
  denoted by \emph{full names} like |A.1| and |C.2|,
\item[\texttt{\meta{frame id}|!|\meta{short name}\meta{dotted path}}]:
  denoted by \emph{qualified full names} like |X!A.1| and |Y!C.2|.
\end{description}
The \emph{short names} and \emph{frame ids} are alphanumerical case sensitive
identifiers, with possible underscores but no space nor leading digit.
Unicode symbols above \texttt{U+00A0} are allowed if the underlying \TeX\ engine
supports it. Identifiers consisting only of lowercase letters and underscores are reserved by the package.

The \emph{dotted path} is a string
\texttt{.\meta{component_1}.\meta{component_2}....\meta{component_n}},
where each \meta{component_i} denotes either an integer, eventually signed,
or a \meta{short name}. The \emph{dotted path} can be empty for which \texttt{n} is 0.

The mapping from \emph{named overlay references} to integers is defined
at the global \TeX\ level to allow its use in |\begin{frame}<...>| and to share the same overlay sets between different frames.
Hence the \emph{frame id} due to the need to possibly target a particular frame.

\subsection{Defining named overlay sets}
In order to define \emph{named overlay sets}, we can either execute the next |\Beanoves| command  before a \pkg{beamer} frame environment, or use the |beanoves| option of this environment.
The value of the |beanoves| option is similar to the argument of the |\Beanoves| commands, but the latter takes precedence on the former.
This behaviour may be useful to input the very same source code into different frames and have different combinations of slides.
%
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
\begin{function}{\Beanoves}
  \begin{syntax}
    \cs{Beanoves}\{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
Each \meta{ref} key is a \emph{named overlay reference} whereas each \meta{spec} value
is an \emph{overlay set specifier}.
When the same \meta{ref} key is used multiple times, only the last one is taken into account.
\subsubsection{Basic case}
In the possible values for \meta{spec} below, \meta{value}, \meta{first}, \meta{length} and \meta{last} are algebraic expression possibly
involving any \emph{named overlay reference} defined above.
\begin{description}
\item[\texttt{\meta{value}},]
the simple \emph{value specifiers} for the whole signed integers set.
If only the \meta{key} is provided, the \meta{value} defaults to 1.
\item[\texttt{\meta{first}:} and \texttt{\meta{first}::},]
for the infinite range of signed integers starting at and including \meta{first}.
\item[\texttt{:\meta{last}},]
for the infinite range of signed integers ending at and including \meta{last}.
\item[\texttt{\meta{first}:\meta{last}}, \texttt{\meta{first}::\meta{length}}, \texttt{:\meta{last}::\meta{length}}, \texttt{::\meta{length}:\meta{last}},]
are variants for the finite range of signed integers starting at and including \meta{first}, ending at and including \meta{last}.
At least one of \meta{first} or \meta{last} must be provided.
We always have \(\meta{first}+\meta{length}=\meta{last}+1\).
\end{description}

When performed at the document level, the \cs{Beanoves} command starts by cleaning 
what was set by previous calls. When performed inside \LaTeX\ environments,
each call cumulates with the previous.
Notice that the argument of this function can contain macros:
they will be exhaustively expanded at resolution time.

\subsubsection{List specifiers}
Also possible values are \emph{list specifiers} which
are comma separated lists of \meta{ref}=\meta{spec} definitions.
The definition
\\[0.2ex]
\hphantom{xx}\texttt{\meta{key}=\{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}}
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\texttt{\meta{key}.\meta{ref_1}=\meta{spec_1},}
\\\hphantom{xx}\texttt{\meta{key}.\meta{ref_2}=\meta{spec_2},}
\\\hphantom{xx}\texttt{...,}
\\\hphantom{xx}\texttt{\meta{key}.\meta{ref_n}=\meta{spec_n}.}
\\[0.2ex]
The rules above can apply individually to each line.

To support an array like syntax, we can omit the \meta{ref} key.
The first missing key is replaced by 1, the second by 2, and so on.

\subsubsection{\texttt{.n} specifiers}
\texttt{\meta{key}.n=\meta{value}} is used to set the value of
the index counter defined below.
%
\section{Named overlay resolution}
Turning a \emph{named overlay reference} into the static integer it represents,
as when above \texttt{<?(A.1)>} was replaced by 1, is denoted by \emph{named overlay resolution} or simply \emph{resolution}. This section is devoted to \emph{resolution rules} depending
on the definition of the named overlay set.
Here \meta{i} denotes an integer whereas \meta{first}, \meta{last} and \meta{length} stand for integers, or integer valued expressions.
%
\subsection{Simple definitions}
\begin{description}
\item[\texttt{\meta{key} = \meta{value}}]
For an unlimited range
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{value}\)\\
\meta{key}.2 & \(\meta{value}+1\) \\
\meta{key}.\meta{i} & \(\meta{value} + \meta{i} - 1\) \\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = \meta{first}:}] as well as \texttt{\meta{first}::}.
For a range limited from below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{first}\)\\
\meta{key}.2 & \(\meta{first}+1\) \\
\meta{key}.\meta{i} & \(\meta{first} + \meta{i} - 1\) \\
\meta{key}.previous & \(\meta{first}-1\)\\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = :\meta{last}}]
For a range limited from above:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{last}\)\\
\meta{key}.0 & \(\meta{last}-1\) \\
\meta{key}.\meta{i} & \(\meta{last} + \meta{i} - 1\) \\
\meta{key}.next & \(\meta{last}+1\)\\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = \meta{first}:\meta{last}}]
as well as variants \texttt{\meta{first}::\meta{length}},
\texttt{::\meta{length}:\meta{last}}
or \texttt{:\meta{last}::\meta{length}},
which are equivalent provided \(\meta{first}+\meta{length} = \meta{last}+1\).

For a range limited from both above and below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{first}\)\\
\meta{key}.2 & \(\meta{first}+1\) \\
\meta{key}.\meta{i} & \(\meta{first} + \meta{i} - 1\bigr)\) \\
\meta{key}.previous & \(\meta{first}-1\)\\
\meta{key}.last & \(\meta{last}\)\\
\meta{key}.next & \(\meta{last}+1\)\\
\meta{key}.length & \(\meta{length}\)\\
\meta{key}.range & \(\max(0,\meta{first})\) ''-'' \(\max(0,\meta{last})\)\\
\hline
\end{tabular}
\end{center}
Notice that the resolution of \texttt{\meta{key}.range} is not an algebraic difference,
and negative integers do not make sense there while in \pkg{beamer} context.

For example
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:8, % or equivalently A = 3::6, A = ::6:8 and A = :8::6
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval[see](A.1)        == 3,
\BeanovesEval[see](A.-1)       == 1,
\BeanovesEval[see](A.previous) == 2,
\BeanovesEval[see](A.last)     == 8,
\BeanovesEval[see](A.next)     == 9,
\BeanovesEval[see](A.length)   == 6,
\BeanovesEval[see](A.range)    == 3-8,
\end{frame}
\end{tcblisting}
%
\end{description}
For example both \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been properly defined with a starting value and a length.
\subsection{Counters}
Each named overlay set defined has a dedicated value counter
which is some kind of variable that can be used and incremented.
A simple \texttt{\meta{key}} \emph{named value reference} is resolved into
the position of this value counter.
For each frame, this variable is initialized to the
first available amongst 
\meta{value}, \texttt{\meta{key}.first} or \texttt{\meta{key}.last}.
If none is available, an error is raised.

For each named overlay set defined, we also have an implicit index counter always starting at 1,
its actual value is an integer denoted \meta{n}.
The \texttt{\meta{key}.n} \emph{named index reference} is resolved into \texttt{\meta{key}.\meta{n}},
which in turn is resolved according to the preceding rules.
%

Additionnaly, resolution rules are provided for the \emph{named value references}:
\begin{description}
\item[\texttt{\meta{key}+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the value counter by \meta{integer}
and use the new position.
Here \meta{integer expression} is the longest character sequence with no space%
\footnote{The parser for algebraic expression is very rudimentary.}.
\item[\texttt{++\meta{key}},] advance the value counter for \meta{key} by 1 and use the new position.
\item[\texttt{\meta{key}++},] use the actual position
and advance the value counter for \meta{key} by 1.
\end{description}

We have resolution rules as well for the \emph{named index references}:
\begin{description}
\item[\texttt{\meta{key}.n+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the implicit index counter associate to \meta{key} by \meta{integer} and use the resolution of \texttt{\meta{key}.n}.

Here again, \meta{integer expression} denotes the longest character sequence with no space.
\item[\texttt{\meta{key}.++n}, \texttt{++\meta{key}.n},] advance the implicit index counter associate to \meta{key} by 1 and use the resolution of \texttt{\meta{key}.n},
\item[\texttt{\meta{key}.n++},] use the resolution of \texttt{\meta{key}.n} and increment the implicit index counter associate to \meta{key} by 1.
\end{description}

In order to decrement a counter, one can increment with a negative value, no dedicated syntax is provided yet.

These counters are reset to their default value for each new frame, which is 1 for the \texttt{\meta{key}.n} counter, and whichever \texttt{\meta{key}.first} or \texttt{\meta{key}.last} is defined for the \texttt{\meta{key}} counter.
\subsection{Dotted paths}
\begin{description}
\item[\texttt{\meta{key}.\meta{i} = \meta{spec}},]
All the preceding rules are overriden by this particular one and \texttt{\meta{key}.\meta{i}} resolves to the resolution of \meta{spec}.

In the frame example below, we use the \cs{BeanovesEval} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3,
    A.3 = 0,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval[see](A.1) == 3,
\BeanovesEval[see](A.2) == 4,
\BeanovesEval[see](A.-1)== 1,
\BeanovesEval[see](A.3) == 0,
\end{frame}
\end{tcblisting}
Without line 3, |A.3| would be evaluated to 5.
%
\item[\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_k} = \meta{range spec}}]
When a dotted path has more than one component,
a \emph{named overlay reference} like |A.1.2| needs some well defined
resolution rule to avoid ambiguity.
To resolve one level of such a reference
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}},
we replace the longest \texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_k}}
where 0$≤$k$≤$n by its definition \texttt{\meta{name'}.\meta{c'_1}...\meta{c'_p}}
if any (the path can be empty). \pkg{beanoves} uses this one level resolution
as many times as possible, but no more than a predefined limit to catch
circular reference that would lead to an infinite \TeX\ loop.
One final resolution occurs with rules above if possible or an error is raised.

For a \emph{named indexed reference} like
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}.n},
we must first resolve \texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}}
into \texttt{\meta{name'}} with an empty dotted path, then retrieve the value of \texttt{\meta{name'}.n} denoted as \meta{n'} and finally use the resolved 
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}.\meta{n'}}.
\end{description}
%
%
\subsection{Frame id}
Except for very special situations, the \emph{frame ids} can be left unspecified.
When no \emph{frame id} was explicitly provided,
\pkg{beanoves} uses the \emph{last frame id}. At the beginning of each frame,
the \emph{last frame id} is set to the \emph{frame id} of the current frame,
which is denoted \emph{current frame id} and defaults to |?|.
Then it gets updated after each named reference resolution.
For example, the first time |A.1| reference is resolved within a given frame,
it is first translated to \texttt{\meta{current frame id}!A.1},
but when used just after \texttt{Y!C.2}, it becomes a shortcut to
\texttt{Y!A.1} because the \emph{last frame id} was then \texttt{Y}.

In order to set the \emph{frame id} of the current frame to \meta{frame id},
use the new \texttt{beanoves id} option of the \pkg{beamer} frame environment. 
\begin{function}{beanoves id}
  \begin{syntax}
    beanoves id=\meta{frame id},
  \end{syntax}
\end{function}
We can use the same \emph{frame id} for different frames to share named overlay sets. 
%
\section{\texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\meta{queries})}'. Each one is then evaluated and replaced by its resolved static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s of next table.
Sometimes, using \texttt{\meta{key}.range} is not allowed because
the resolution would be interpreted as an algebraic difference
instead of a \pkg{beamer} range.
If it is not possible, an error is raised.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{query} & \bfseries \textrm{resolution} & \bfseries \textrm{limitation}
\\\hline
\phantom{xxx}\meta{start expr} & \meta{start} & \\
\phantom{xxx}\meta{start expr}: & \meta{start} - & \textrm{no }\meta{key}.range \\
\phantom{xxx}\meta{start expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
::\meta{length expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{::\meta{length expr}}:\meta{end expr} & \phantom{\meta{start}} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{::\meta{length expr}}: & \phantom{\meta{start}} - & \\
\phantom{xx}\meta{start expr}:: & \meta{start} -  & \textrm{no }\meta{key}.range \\
\phantom{xx}\meta{start expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{xxx}:\meta{end expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{xxx:\meta{end expr}}:: & \phantom{\meta{start}} - & \\
\hline
\end{tabular}
\end{center}
Here \meta{start expr}, \meta{end expr} and \meta{length expr}
both denote algebraic expressions possibly involving named overlay references and counters.
As integers, they are respectively resolved into \meta{start}, \meta{end} and \meta{length}.

Notice that nesting \texttt{?(...)} query expressions is not supported.
\section{Support}
See \url{https://github.com/jlaurens/beanoves}.
One can report issues.
\end{documentation}
\DocInput{beanoves.dtx}
\begin{luacode}
local bnvs = require("./\jobname-test.lua")
tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
local ra = bnvs.check_variants("\jobname.sty")
tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
--[[
if ra then
  for _,v in ipairs(ra) do
    tex.print("\\verb|"..v.."|\\\\")
  end
end
]]
\end{luacode}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \NewDocumentEnvironment {bnvs.gobble} { +b } {} {}
% \begin{implementation}
% \begin{bnvs.gobble}
%<*package>
% \end{bnvs.gobble}
%
%\begin{bnvs.gobble}
%\begin{luacode}
%local bnvs = require("./\jobname-test.lua")
%tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
%local ra = bnvs.check_variants("\jobname-debug.sty")
%tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
%--[[
%if ra then
%  for _,v in ipairs(ra) do
%    tex.print("\\verb|"..v.."|\\\\")
%  end
%end
%]]
%\end{luacode}
%\end{bnvs.gobble}
%
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention, unused).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%<@@=bnvs>
%    \end{macrocode}
% \end{bnvs.macrocode}
% Reserved namespace:
% identifiers containing the case insensitive string |beanoves| or
% the case insensitive string |bnvs| delimited by two non characters.
%
% \subsection{Package declarations}
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!debug>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {beanoves}
%    \end{macrocode}
% \begin{bnvs.gobble}
%</!debug>
%<*!final>
  {beanoves-debug}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {2023/01/07}
  {1.0}
  {Named overlay specifications for beamer}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsection{Facility layer: definitions and naming}
% In order to make the code shorter and easier to read, we add a layer
% over \LaTeX3. The |c| and |v| argument specifiers take a different meaning when
% used in a function which name contains with |bnvs| or |BNVS|.
% Where \LaTeX3 would transform |l__bnvs_key_tl| into |\l__bnvs_key_tl|,
% \pkg{bnvs} will directly transform |name| into |\l__bnvs_key_tl|.
% The type of the local variable used depends on the context and may be
% |seq| or |int| for example.
% There are however a pair of exceptions mentionned below.
% For a better reading experience,
% `|key|' will generally stand for |\l__bnvs_key_tl|,
% whereas `|path| sequence' will generally stand for |\l__bnvs_path_seq|.
% Other similar shortcuts are used as well. 
%
% Functions with |BNVS| in their names are management functions.
% They belong to a deeper layer and do not contain any \pkg{beanoves}
% specific logic.
% \begin{function}{
%   \BNVS:c,
%   \BNVS_l:cn,
%   \BNVS_g:cn,
% }
% \begin{syntax}
% \cs{BNVS:c} \marg{cs core name}
% \cs{BNVS_l:cn} \marg{local variable core name} \marg{ type }
% \cs{BNVS_g:cn} \marg{global variable core name} \marg{ type }
% \cs{BNVS_g_prop:c} \marg{global prop core name}
% \end{syntax}
% These are naming functions.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS:c    #1    { __bnvs_#1     }
\cs_new:Npn \BNVS_l:cn #1 #2 { l__bnvs_#1_#2 }
\cs_new:Npn \BNVS_g:cn #1 #2 { g__bnvs_#1_#2 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use_raw:c,
%   \BNVS_use_raw:Nc,
%   \BNVS_use_raw:nc,
%   \BNVS_use:c,
%   \BNVS_use:Nc,
%   \BNVS_use:nc,
% }
% \begin{syntax}
% \cs{BNVS_use_raw:c} \marg{cs name}
% \cs{BNVS_use_raw:Nc} \meta{function} \marg{cs name}
% \cs{BNVS_use_raw:nc} \marg{tokens} \marg{cs name}
% \cs{BNVS_use:c} \marg{cs core}
% \cs{BNVS_use:Nc} \meta{function} \marg{cs core}
% \cs{BNVS_use:nc} \marg{tokens} \marg{cs core}
% \end{syntax}
% \cs{BNVS_use_raw:c} is a wrapper over \cs{use:c}.
% possibly prepended with some code.
% It needs 3 expansion steps just like \cs{BNVS_use:c}.
% The other are used to expand |\use:c| twice before usage by
% \meta{function} or \meta{tokens}.
% The first argument of \meta{function} has type |N|.
% The next token after \meta{tokens} will have type |N| too.
% \meta{cs name} is a full cs name
% whereas \meta{cs core} will be prepended with the appropriate prefix.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:N #1 { #1 }
\cs_new:Npn \BNVS_use_raw:c #1 {
  \exp_args:NNo
  \exp_last_unbraced:No
  \BNVS_use_raw:N { \use:c { #1 } }
}
\cs_new:Npn \BNVS_use:c #1 {
  \BNVS_use_raw:c { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_use:c, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use:c { TEST:n } { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_tl { XX } { 
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST:n }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:NN #1 #2 {
  #1 #2
}
\cs_new:Npn \BNVS_use_raw:nN #1 #2 {
  #1 #2
}
\cs_new:Npn \BNVS_use_raw:Nc #1 #2 {
  \exp_args:NNNo
  \exp_last_unbraced:NNo
  \BNVS_use_raw:NN #1 { \use:c { #2 } }
}
\exp_args_generate:n { NNno }
\cs_new:Npn \BNVS_use_raw:nc #1 #2 {
  \exp_args:NNno
  \exp_last_unbraced:Nno
  \BNVS_use_raw:nN { #1 } { \use:c { #2 } }
}
\cs_new:Npn \BNVS_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { \BNVS:c { #2 } }
}
\cs_new:Npn \BNVS_use:nc #1 #2 {
  \BNVS_use_raw:nc { #1 } { \BNVS:c { #2 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_use_raw_saved:N \BNVS_use_raw:N
\cs_set:Npn \BNVS_use_raw:N #1 {
  \cs_if_exist:NF #1 {
    \__bnvs_fatal:x { Unknown~command~\token_to_str:N #1~(c) }
  }
  #1
}
\cs_set_eq:NN \BNVS_use_raw_saved:NN \BNVS_use_raw:NN
\cs_set:Npn \BNVS_use_raw:NN #1 #2 {
  \cs_if_exist:NF #2 {
    \__bnvs_fatal:x { Unknown~command~\token_to_str:N #2~(N) }
  }
  \BNVS_use_raw_saved:NN #1 #2
}
\cs_set_eq:NN \BNVS_use_raw_saved:nN \BNVS_use_raw:nN
\cs_set:Npn \BNVS_use_raw:nN #1 #2 {
  \cs_if_exist:NF #2 {
    \__bnvs_fatal:x { Unknown~command~\token_to_str:N #2~(n) }
  }
  \BNVS_use_raw_saved:nN { #1 } #2
}

%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_use_tl:Nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x { NO_WAY \token_to_str:N #1 }
%   }
% }
% \BNVS_tl_use:Nc \BNVS_Test:N { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_use:nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x {
%       ^^J=>\token_to_str:N #1
%       ^^J=>\tl_to_str:N #1
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:x {
%       ^^J=>\tl_to_str:N \l__bnvs_TEST_tl
%       ^^J=>\tl_to_str:n { #1 }
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_raw:c, noigre}
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_Test: { SUCCESS }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A }
% \tl_clear:N \l__bnvs_TEST_tl
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use_raw:c { BNVS_Test: } }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A' }
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \__bnvs_fatal:x #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { FAILURE }
% }
% \cs_undefine:N \BNVS_Test:
% \BNVS_use_raw:c { BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { FAILURE } { B }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_use:Nc{/:nc}, noigre}
% \BNVS_new:cpn { TEST: } { SUCCESS }
% \cs_if_exist:cF { \BNVS:c { TEST: } } {
%   \__bnvs_fatal:x { Unknown~bnvs~command~TEST:~(ii-N) }
% }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \exp_args:No \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { E / \token_to_str:N #1 / }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \BNVS_set:cpn { TEST: } { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \cs_if_eq:NNF #1 \__bnvs_TEST: {
%     \test_fail:x { TEST / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_new:cpn,
%   \BNVS_set:cpn,
%   \BNVS_use:c,
% }
% \cs{BNVS_new:cpn} is like \cs{cs_new:cpn} except that the name
% argument is tagged for \pkg{beanoves} package.
% Similarly for \cs{BNVS_set:cpn} and \cs{BNVS_use:c}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_log:n #1 { }
\cs_generate_variant:Nn \BNVS_log:n { x }
\cs_new:Npn \BNVS_DEBUG_on: {
  \cs_set:Npn \BNVS_DEBUG_log:n { \BNVS_log:n }
}
\cs_new:Npn \BNVS_DEBUG_off: {
  \cs_set:Npn \BNVS_DEBUG_log:n { \use_none:n }
}
\BNVS_DEBUG_off:
\cs_new:Npn \BNVS_new:cpn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n {New=>#1}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_new:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine:c #1 {
  \cs_undefine:c { \BNVS:c { #1 } }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new:cpn, noigre}
% \BNVS_new:cpn { TEST: } { }
% \cs_if_exist:NF \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST: }
% \cs_if_exist:NT \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_set:cpn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n {Set=>#1}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_set:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_set:cpn, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \cs_if_exist:NF \__bnvs_TEST:n {
%   \test_fail:n { NO_WAY/1 }
% }
% \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_TEST:n { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { XX } { 
%   \test_fail:n { NO_WAY/2 }
% }
% \BNVS_undefine:c { TEST:n }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \cs_generate_variant:Nn { c }
\cs_new:Npn \BNVS_generate_variant:cn #1 {
  \cs_generate_variant:cn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsection{logging}
%
% Utility message.
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
\msg_new:nnn { beanoves } { :nn } { #1~(#2) }
\BNVS_new:cpn { warning:n } {
  \msg_warning:nnn { beanoves } { :n }
}
\BNVS_generate_variant:cn { warning:n } { x }
\BNVS_new:cpn { error:n } {
  \msg_error:nnn { beanoves } { :n }
}
\BNVS_new:cpn { error:x } {
  \msg_error:nnx { beanoves } { :n }
}
\BNVS_new:cpn { fatal:n } {
  \msg_fatal:nnn { beanoves } { :n }
}
\BNVS_new:cpn { fatal:x } {
  \msg_fatal:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.gobble}
% Next are unexposed functions.
%<*!final>
\cs_new:Npn \BNVS_log_a:nn #1 #2 {
  \msg_term:nnn { beanoves } { :n } { #1~#2 }
}
\cs_generate_variant:Nn \BNVS_log_a:nn { xn }
\int_zero_new:N \l__bnvs_group_int
\cs_set:Npn \BNVS_log:n {
  \BNVS_log_a:xn
  { ▃▃ \prg_replicate:nn {\l__bnvs_group_int} {▁▃} \space }
}
%</!final>
% \end{bnvs.gobble}
%
% \subsection{Facility layer: Variables}
% \begin{function}{
%   \BNVS_N_new:c,
%   \BNVS_v_new:c,
% }
% \begin{syntax}
% \cs{BNVS_N_new:n} \marg{type}
% \end{syntax}
% Creates typed utility functions, see usage below.
% Undefined when no longer used.
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_N_new:c #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_new:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nc } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nc } }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1:c } ##1 {
    l \BNVS:c{ ##1 } \tl_if_empty:nF { ##1 } { _ } #1
  }
  \cs_new:cpn { BNVS_#1_new:c } ##1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { \use:c { BNVS_#1:c } { ##1 } } }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \use:c { #1_new:c } { \use:c { BNVS_#1:c } { ##1 } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \cs_new:cpn { BNVS_#1_undefine:c } ##1 {
    \cs_undefine:c { \use:c { BNVS_#1:c } { ##1 } }  
  }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:c } ##1 {
    \use:c { \use:c { BNVS_#1:c } { ##1 } }
  }
  \cs_new:cpn { BNVS_#1_use:Nc } ##1 ##2 {
    \BNVS_use_raw:Nc
      ##1 { \use:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nc } ##1 ##2 {
    \BNVS_use_raw:nc
      { ##1 } { \use:c { BNVS_#1:c } { ##2 } }
  }
}
\cs_new:Npn \BNVS_v_new:c #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nv } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nv } }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:Nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NV ##1 }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NnV \use:n { ##1 } }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_use:Nv{|:nv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_all:c #1 {
  \cs_undefine:c { BNVS_#1:c }
  \cs_undefine:c { BNVS_#1_new:c }
  \cs_undefine:c { BNVS_#1_use:c }
  \cs_undefine:c { BNVS_#1_use:nc }
  \cs_undefine:c { BNVS_#1_use:Nc }
  \cs_undefine:c { BNVS_#1_use:nv }
  \cs_undefine:c { BNVS_#1_use:Nv }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_N_new:c { bool }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_bool:c, noigre}
% \exp_args:Nx \tl_if_eq:nnF { \BNVS_bool:c { TEST } } { l__bnvs_TEST_bool } {
%   \test_fail:x { TEST/\BNVS_bool:c { TEST } }
% }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_bool_use:Nc{/:nc}, noigre}
% \bool_set_true:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NF #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \bool_set_false:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NT #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_N_new:c { int }
\BNVS_v_new:c { int }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_int_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \int_add:Nn #1 { 245 }
%   \int_compare:nNnF { #1 } = { 666 } {
%     \test_fail:x { TEST / \int_use:N #1 / }
%   }
% }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:Nc   \BNVS_Test:N   { TEST }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_N_new:c { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \assert_equal:nnn { #1 } { \l__bnvs_TEST_tl } { A }
% }
% \BNVS_tl_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_v_new:c { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \assert_equal_tl:vnn { TEST } { #1 } { A }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_N_new:c { str }
\BNVS_v_new:c { str }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_str_use:nc{/:Nc}, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNF #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \str_set:Nn \l__bnvs_TEST_A_str { FAILURE }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNT #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A=B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_N_new:c { seq }
\BNVS_v_new:c { seq }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_seq_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { 421 }
%   \seq_pop_left:NNTF #1 \l__bnvs_TEST_tl {
%     \tl_if_eq:NnF \l__bnvs_TEST_tl { SUCCESS } {
%       \test_fail:n { TEST/1/\tl_to_str:N #1 }
%     }
%   } {
%     \test_fail:n { TEST/2/\token_to_str:N #1 }
%   }
% }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:Nc   \BNVS_Test:N   { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_undefine:N \BNVS_N_new:c
%    \end{macrocode}
% \begin{bnvs.gobble}
%</final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nc }   #1   { #2 }
}
\cs_new:Npn \BNVS_use:ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nc } { #1 } { #2 }
}
\cs_new:Npn \BNVS_use:Nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nv }   #1   { #2 }
}
\cs_new:Npn \BNVS_use:nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nv } { #1 } { #2 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:x { A / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Ncn   \BNVS_Test:N   { TEST_A } { tl }
% \BNVS_use:ncn { \BNVS_Test:N } { TEST_A } { tl }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_use:Nvn{/:nvn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { A / \tl_to_str:n { #1 } }
%   }
% }
% \BNVS_use:Nvn   \BNVS_Test:n   { TEST_A } { tl }
% \BNVS_use:nvn { \BNVS_Test:n } { TEST_A } { tl }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Ncn   #1   { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:ncn { #1 } { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:Nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Nvn   #1   { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:nvn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_use:Ncncn{/:ncncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:NN #1 #2 {
%   \tl_if_eq:NNF #1 #2 {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Ncncn   \BNVS_Test:NN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_Test:NN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_use_raw:c { BNVS_Test:NN } } { TEST_A } { tl } { TEST_B } { tl }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_use:Nvncn{/:nvncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:nN #1 #2 {
%   \tl_if_eq:NnF #2 { #1 } {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Nvncn   \BNVS_Test:nN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_Test:nN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_use_raw:c { BNVS_Test:nN } } { TEST_A } { tl } { TEST_B } { tl }
% \cs_undefine:N \BNVS_Test:nN
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:Ncncn   #1   { #2 } { #3 } { #4 } { #5 }
  }
}
\cs_new:Npn \BNVS_use:ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:ncncn { #1 } { #2 } { #3 } { #4 } { #5 }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_use:ncncncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:NNN #1 #2 #3 {
%   \tl_if_eq:NnF #1 { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:NnF #2 { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:NnF #3 { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_use:Ncncncn   \BNVS_Test:NNN   { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \BNVS_use:ncncncn { \BNVS_Test:NNN } { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_c:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:c } {
    \BNVS_use_raw:c { BNVS_#1_use:nc } { \BNVS_use_raw:c { #1_#2:N } }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_c:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_if_exist:NT \tl_BNVS_TEST_A:N {
%   \test_fail:n { NAME~CONFLICT:\token_to_str:N \tl_BNVS_TEST_A:N }
% }
% \cs_set:Npn \tl_BNVS_TEST_A:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:n { NO_WAY/1/\token_to_str:N #1 }
%   }
% }
% \BNVS_new_c:nc { tl } { BNVS_TEST_A }
% \cs_if_exist:NF \__bnvs_tl_BNVS_TEST_A:c {
%   \test_fail:n { NO_WAY/2 }
% }
% \__bnvs_tl_BNVS_TEST_A:c { TEST_A }
% \cs_undefine:N \tl_BNVS_TEST_A:N
% \cs_undefine:N \__bnvs_tl_TEST_A:c
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:cn } ##1 {
    \BNVS_use:ncn { \BNVS_use_raw:c { #1_#2:Nn } } { ##1 } { #1 }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_cn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_cn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \__bnvs_tl_TEST_A:cn
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnn:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnn } ##1 {
    \BNVS_use:Ncn { #3 } { ##1 } { #1 }
  }
}
\cs_new:Npn \BNVS_new_cnn:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnn:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
\cs_new:Npn \BNVS_new_cnv:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnv } ##1 ##2 {
    \BNVS_tl_use:nv {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
\cs_new:Npn \BNVS_new_cnv:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnv:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
\cs_new:Npn \BNVS_new_cnx:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnx } ##1 ##2 {
    \exp_args:Nnx \use:n {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
\cs_new:Npn \BNVS_new_cnx:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnx:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_cnn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_if_exist:NT \tl_TEST_A:Nnn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:Nnn }
% }
% \cs_set:Npn \tl_TEST_A:Nnn #1 #2 #3 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y }
%   }
%   \tl_if_eq:nnF { #3 } { Z } {
%     \test_fail:n { Z }
%   }
% }
% \BNVS_new_cnn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cnn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cnn { TEST_A } { Y } { Z }
% \cs_undefine:N \tl_TEST_A:Nnn
% \cs_undefine:N \__bnvs_tl_TEST_A:cnn
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cc } ##1 ##2 {
    \BNVS_use:Ncncn #3 { ##1 } { #1 } { ##2 } { #4 }
  }
}
\cs_new:Npn \BNVS_new_cc:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cc:ncNn { #1 } { #1_#2 }
  } { #1_#2:NN }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cc:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cc }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \BNVS_N_new:c { bnvs }
% \tl_new:N  \l__bnvs_TEST_A_bnvs
% \tl_set:Nn \l__bnvs_TEST_A_bnvs { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \tl_TEST_A:NN \l__bnvs_TEST_A_tl \l__bnvs_TEST_A_bnvs
% \BNVS_new_cc:ncn { tl } { TEST_A } { bnvs }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_A }
% \BNVS_undefine_all:c { bnvs }
% \cs_undefine:N \l__bnvs_TEST_A_bnvs
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:nc #1 #2 {
  \BNVS_new_cc:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \tl_set:Nn \l__bnvs_TEST_B_tl { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \BNVS_new_cc:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_B }
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cn } ##1 {
    \BNVS_use:Ncn #3 { ##1 } { #1 }
  }
}
\cs_new:Npn \BNVS_new_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cv } ##1 ##2 {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 }
    } { ##2 } { #4 }
  }
}
\cs_new:Npn \BNVS_new_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
\cs_new:Npn \BNVS_new_cv:nc #1 #2 {
  \BNVS_new_cv:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cv:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cv }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new_cv:ncn, noigre}
% \cs_if_exist:NT \tl_BNVS_TEST:Nn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_BNVS_TEST:Nn }
% }
% \cs_new:Npn \tl_BNVS_TEST:Nn { \tl_set:Nn }
% \tl_clear:N \l__bnvs_TEST_A_tl
% \tl_BNVS_TEST:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } {
%   \test_fail:n { 0 }
% }
% \BNVS_new_cv:ncn { tl } { BNVS_TEST } { tl }
% tl_clear:N \l__bnvs_TEST_A_tl
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESS }
% \__bnvs_tl_BNVS_TEST:cv { TEST_A } { TEST_B }
% \__bnvs_tl_if_eq:cvF { TEST_A } { TEST_B } {
%   \test_fail:n { 0 }
% }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } {
%   \test_fail:n { 0 }
% }
% \cs_undefine:N \tl_BNVS_TEST:Nn
% \BNVS_undefine_cv:nc { tl } { TEST }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_l_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_l:cn { #2 } { #3 } }
}
\cs_new:Npn \BNVS_l_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_l:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_l_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/l }
%   }
% }
% \BNVS_l_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_l_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_g:cn { #2 } { #3 } }
}
\cs_new:Npn \BNVS_g_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_g:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_g_use:Ncn{/:ncn}, noigre}
% \tl_gset:Nn \g__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/g }
%   }
% }
% \BNVS_g_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_g_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_prop_use:Nc #1 #2 {
  \BNVS_use_raw:Nc   #1   { \BNVS_g:cn { #2 } { prop } }
}
\cs_new:Npn \BNVS_g_prop_use:nc #1 #2 {
  \BNVS_use_raw:nc { #1 } { \BNVS_g:cn { #2 } { prop } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_g_prop_use:Nc{/:nc}, noigre}
% \prop_gput:Nnn \g__bnvs_TEST_prop { key } { value }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \prop_get:NnNTF #1 { key } \l__bnvs_TEST_tl {
%     \assert_equal_tl:vnn { TEST } { value } { TEST/1 }
%   } {
%     \test_fail:n { TEST/2 }
%   }
% }
% \BNVS_g_prop_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_g_prop_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_exp_args:Nvvv #1 #2 #3 #4 {
  \BNVS_use:ncncncn { \exp_args:NVVV #1 }
    { #2 } { tl } { #3 } { tl } { #4 } { tl }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_exp_args:Nvvv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:nnF { #2 } { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:nnF { #3 } { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_exp_args:Nvvv \BNVS_Test:nnn { TEST_A } { TEST_B } { TEST_C }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_new_conditional:Npnn { c }
\cs_new:Npn \BNVS_new_conditional:cpnn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x {New => \token_to_str:c { \BNVS:c { #1 } } [TF] }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_new_conditional:cpnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_generate_variant:Nn \cs_split_function:N { c }
\cs_new:Npn \BNVS_undefine_conditional:c #1 {
  \BNVS_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \BNVS_undefine:c { #1##1 }
  }
}
\cs_new:Npn \BNVS_prg_undefine_conditional:c #1 {
  \cs_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \cs_undefine:c { #1##1 }
  }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:N } \l__bnvs_TEST_A_tl }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:N#1 } \l__bnvs_TEST_A_tl }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_generate_conditional_variant:Nnn { c }
\cs_new:Npn \BNVS_generate_conditional_variant:cnn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n { Variant => #1[TF] }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_generate_conditional_variant:cnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_generate_conditional_variant:cnn { TEST_A:N } c { p, T, F, TF }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:c } { l__bnvs_TEST_A_tl } }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:c#1 } { l__bnvs_TEST_A_tl } }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \BNVS_undefine_conditional:c { TEST_A:c }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cnn #1 #2 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vn:cNnn { #1 }
  } { #1:nn TF } { #2 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_conditional_vn:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { S }
% \BNVS_new_conditional:cpnn { TEST:nn } #1 #2 { T, F, TF } {
%   \tl_if_eq:nnTF { #1 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vn:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { S } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { S } { }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { S }     { \test_fail:n { 3 } }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { F } { \test_fail:n { 4 } } { }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { F } { \test_fail:n { 5 } }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { F }                        { }
% \BNVS_undefine_conditional:c { TEST:nn }
% \BNVS_undefine_conditional:c { TEST:Vn }
% \BNVS_undefine_conditional:c { TEST:vn }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vc:cnn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNnn { #1 }
  } { #1:ncTF }
}
\cs_new:Npn \BNVS_new_conditional_vc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNn { #1 }
  } { #1:ncTF }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_conditional_vc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESS }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vc#1 } { TEST_A } { TEST_B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 4 } }
% \BNVS_TEST:n {  F }                        { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { TEST:nc }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_new_conditional_vc:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \BNVS_new_conditional:cpnn { TEST:n } #1 { TF } {
%   \tl_if_eq:nnTF { #1 } { SUCCESS } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_use:c { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { } { \test_fail:n { 1 } }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { \test_fail:n { 3 } } { }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { \test_fail:n { 4 } }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }                        { }
% \BNVS_undefine_conditional:c { TEST:n  }
% \BNVS_undefine_conditional:c { TEST:nN }
% \BNVS_undefine_conditional:c { TEST:VN }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Regex}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_regex_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { c \BNVS:c { #2 } _regex }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_match_once:Nn,
%   \__bnvs_match_once:Nv,
%   \__bnvs_match_once:nn,
%   \__bnvs_regex_split:cn,
% }
% \begin{syntax}
% \cs{__bnvs_match_once:NnTF} \meta{regex variable} \marg{expression}
% \marg{yes code} \marg {no code}
% \cs{__bnvs_match_once:nnTF} \marg{regex} \marg{expression}
% \marg{yes code} \marg {no code}
% \cs{__bnvs_regex_split:cncTF} \meta{regex core} \marg{expression} \meta{seq core} \marg{yes code} \marg {no code}
% \cs{__bnvs_regex_split:cnTF} \meta{regex core} \marg{expression} \marg{yes code} \marg {no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item \cs{regex_match_once:NnNTF} with the match sequence as N argument
% \item \cs{regex_match_once:nnNTF} with the match sequence as N argument
% \item \cs{regex_split:NnNTF} with the split sequence as last N argument
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_once:Nn } #1 #2 { T, F, TF } {
  \BNVS_use:ncn {
    \regex_extract_once:NnNTF #1 { #2 }
  } { match } { seq } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_match_once:NnTF, noigre}
% \__bnvs_match_once:NnTF \c__bnvs_TEST_comma_regex { , } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_once:Nv } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_tl_use:nv {
      \regex_extract_once:NnNTF #1 
    } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_match_once:NvTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \__bnvs_match_once:NvTF \c__bnvs_TEST_comma_regex { TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_once:nn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \regex_extract_once:nnNTF { #1 } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_match_once:nnTF, noigre}
% \__bnvs_match_once:nnTF { A } { A } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { A } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { regex_split:cnc } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { regex_split:cn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { split } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_regex_split:cnTF, noigre}
% \cs_set:Npn \BNVS_Test:nT #1 #2 {
%   \seq_pop_left:NNTF \l__bnvs_split_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { #1 } { #1/1 }
%     #2
%   } {
%     \test_fail:n { #1/2 }
%   }
% }
% \__bnvs_regex_split:cnTF { TEST_comma } { A,B,C } {
%   \BNVS_Test:nT { A } { \BNVS_Test:nT { B } { \BNVS_Test:nT { C } { } } }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Token lists}
% \begin{function}{
%   \__bnvs_tl_clear:c,
%   \__bnvs_tl_use:c,
%   \__bnvs_tl_set_eq:cc,
%   \__bnvs_tl_set:cn,
%   \__bnvs_tl_set:cv,
%   \__bnvs_tl_set:cx,
%   \__bnvs_tl_put_left:cn,
%   \__bnvs_tl_put_right:cn,
%   \__bnvs_tl_put_right:cx,
%   \__bnvs_tl_put_right:cv,
% }
% \begin{syntax}
% \cs{ __bnvs_tl_clear:c } \marg{core key_tl}
% \cs{ __bnvs_tl_use:c } \marg{core}
% \cs{ __bnvs_tl_count:c } \marg{core}
% \cs{ __bnvs_tl_set_eq:cc } \marg{lhs core name} \marg{rhs core name}
% \cs{ __bnvs_tl_set:cn } \marg{core} \marg{tl}
% \cs{ __bnvs_tl_set:cv } \marg{core} \marg{value core name}
% \cs{ __bnvs_tl_put_left:cn } \marg{core} \marg{tl}
% \cs{ __bnvs_tl_put_right:cn } \marg{core} \marg{tl}
% \cs{ __bnvs_tl_put_right:cv } \marg{core} \marg{value core name}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_clear:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_use:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_set_eq:cc {l__bnvs_|\texttt{\meta{lhs core}}|_tl}||{l__bnvs_|\texttt{\meta{rhs core}}|_tl}|
% \item |\tl_set:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \item |\tl_set:cx {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_left:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vnc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vnc:cNn { #1 }
  } { #1:nncTF }
}
\cs_new:Npn \BNVS_new_conditional_vvnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvnc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvnc:cNn { #1 }
  } { #1:nnncTF }
}
\cs_new:Npn \BNVS_new_conditional_vvvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvvc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:nv {
        \BNVS_tl_use:Nv #2 { ##1 }
      } { ##2 }
    } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvvc:cNn { #1 }
  } { #1:nnncTF }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_conditional_vnc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nnc } #1 #2 #3 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_set:Nn { TEST_#3 } { #1 }
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { TEST_#3 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_use:c { TEST:nncTF } { A } { A } { B } { } { \test_fail:n { 0 } }
% \BNVS_use:c { TEST:nncTF } { A } { B } { B } { \test_fail:n { 1 } } { }
% \BNVS_new_conditional_vnc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_TEST:vncTF { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnc TF } { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 3 } }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vnc#1 } { TEST_A } { SUCCESS } { B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { B/1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { B/2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { B/3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { B/4 } }
% \BNVS_TEST:n {  F }                          { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { BNVS_TEST:nnc }
% \BNVS_undefine_conditional:c { BNVS_TEST:vnc }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvc:cNn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_c:c {
  \BNVS_new_c:nc { tl }
}
\BNVS_new_tl_c:c { clear }
\BNVS_new_tl_c:c { use }
\BNVS_new_tl_c:c { count }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_tl_clear:c{|use:c|count:c}, noigre}
% \BNVS_tl_new:c { TEST_NCUC }
% \tl_set:Nn \l__bnvs_TEST_NCUC_tl { SUCCESS }
% \assert_size_equal:nnn { SUCCESS } { \__bnvs_tl_use:c { TEST_NCUC } } { 1 }
% \assert_size_equal:nnn { 7 } { \__bnvs_tl_count:c { TEST_NCUC } } { 2 }
% \__bnvs_tl_clear:c { TEST_NCUC }
% \assert_size_equal:nnn {   } { \__bnvs_tl_use:c   { TEST_NCUC } } { 3 }
% \assert_size_equal:nnn { 0 } { \__bnvs_tl_count:c { TEST_NCUC } } { 4 }
% \BNVS_tl_undefine:c { TEST_NCUC }
% \end{bnvs.test}
%    \begin{macrocode}

\BNVS_new:cpn { tl_set_eq:cc } #1 #2 {
  \BNVS_use:ncncn { \tl_set_eq:NN } { #1 } { tl } { #2 } { tl }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_tl_set_eq:cc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_tl_clear:c { TEST_B }
% \__bnvs_tl_set_eq:cc { TEST_B } { TEST_A }
% \tl_if_eq:NNF \l__bnvs_TEST_A_tl \l__bnvs_TEST_B_tl { \test_fail:n { 1 } }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_cn:c {
  \BNVS_new_cn:nc { tl }
}
\cs_new:Npn \BNVS_new_tl_cv:c #1 {
  \BNVS_new_cv:ncn { tl } { #1 } { tl }
}
\BNVS_new_tl_cn:c { set }
\BNVS_new_tl_cv:c { set }
\BNVS_new:cpn { tl_set:cx } {
  \exp_args:Nnx \__bnvs_tl_set:cn
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_tl_set:cn{|:cv|:cx}, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } { \test_fail:x { cn/\l__bnvs_TEST_A_tl } }
% \tl_clear:N \l__bnvs_TEST_B_tl
% \__bnvs_tl_set:cx { TEST_B } { \l__bnvs_TEST_A_tl }
% \tl_if_eq:NnF \l__bnvs_TEST_B_tl { SUCCESS } { \test_fail:n { cx } }
% \tl_clear:N \l__bnvs_TEST_C_tl
% \__bnvs_tl_set:cv { TEST_C } { TEST_A }
% \tl_if_eq:NnF \l__bnvs_TEST_C_tl { SUCCESS } { \test_fail:n { cv } }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_tl_cn:c { put_right }
\BNVS_new_tl_cv:c { put_right }
% \BNVS_generate_variant:cn { tl_put_right:cn } { cx }
\BNVS_new:cpn { tl_put_right:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_right:cn }
}
\BNVS_new_tl_cn:c { put_left }
\BNVS_new_tl_cv:c { put_left }
% \BNVS_generate_variant:cn { tl_put_left:cn } { cx }
\BNVS_new:cpn { tl_put_left:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_left:cn }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_tl_if_empty:c,
%   \__bnvs_tl_if_blank:v,
%   \__bnvs_tl_if_eq:cn,
% }
% \begin{syntax}
% \cs{ __bnvs_tl_if_empty:cTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{ __bnvs_tl_if_blank:vTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{ __bnvs_tl_if_eq:cnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:cTF {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{yes code} \marg{no code}}
% \item |\tl_if_eq:cnTF {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl} \marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_c:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2 } ##1 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_c:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_c:ncNn { #1 } { #1_#2:c }
  } { #1_#2:NTF }
}
\BNVS_new_conditional_c:ncn { tl } { if_empty } { p, T, F, TF }
\BNVS_new_conditional:cpnn { tl_if_blank:v } #1 { T, F, TF } {
  \BNVS_tl_use:Nv \tl_if_blank:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_tl_if_empty:c, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_empty:c#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_empty:cTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_tl_if_blank:v, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_blank:v#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_blank:vTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cn } ##1 ##2 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cn:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 } 
    } { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cv:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_tl_if_eq:cn{|:cv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { A } { } { \test_fail:n { 1/A } }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { A } { } 
% \__bnvs_tl_if_eq:cnF  { TEST_A } { A }     { \test_fail:n { 1/B } }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { B } { \test_fail:n { 2/A } } { }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { B } { \test_fail:n { 2/B } }
% \__bnvs_tl_if_eq:cnF  { TEST_A } { B }                          { }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { } { \test_fail:n { 3/A } }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { } 
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }     { \test_fail:n { 3/B } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { \test_fail:n { 4/A } } { }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { \test_fail:n { 4/B } }
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }                          { }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Strings}
% \begin{function}[TF]{
%   \__bnvs_str_if_eq:vn,
% }
% \begin{syntax}
% \cs{ __bnvs_str_if_eq:vnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:cTF {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vn:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vn:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Nvn #3 { ##1 } { #1 }
    }  { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vv:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vv:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_str_if_eq:vn/:vv, noigre, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_str_if_eq:vn#1 } { TEST_A }
% }
% \BNVS_Test:n { TF } { SUCCESS } { } { \test_fail:n { 1/A } }
% \BNVS_Test:n { T  } { SUCCESS } { } 
% \BNVS_Test:n {  F } { SUCCESS }     { \test_fail:n { 1/B } }
% \BNVS_Test:n { TF } { FAILURE } { \test_fail:n { 2/A } } { }
% \BNVS_Test:n { T  } { FAILURE } { \test_fail:n { 2/B } }
% \BNVS_Test:n {  F } { FAILURE }                          { }
% \cs_set:Npn \BNVS_Test:n #1 { \BNVS_use_raw:c { __bnvs_str_if_eq:vv#1 } { TEST_A } }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \BNVS_Test:n { TF } { TEST_B } { } { \test_fail:n { 3/A } }
% \BNVS_Test:n {  T } { TEST_B } { }
% \BNVS_Test:n { F  } { TEST_B }     { \test_fail:n { 3/B } }
% \str_set:Nn \l__bnvs_TEST_B_str { FAILURE }
% \BNVS_Test:n { TF } { TEST_B } { \test_fail:n { 4/A } } { }
% \BNVS_Test:n { T  } { TEST_B } { \test_fail:n { 4/B } }
% \BNVS_Test:n {  F } { TEST_B }                          { }
% \cs_undefine:c { Test:n }
% \end{bnvs.test}
%    \begin{macrocode}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Sequences}
% \begin{function}{
%   \__bnvs_seq_count:c,
%   \__bnvs_seq_clear:c,
%   \__bnvs_seq_set_eq:cc,
%   \__bnvs_seq_use:cn,
%   \__bnvs_seq_item:cn,
%   \__bnvs_seq_remove_all:cn,
%   \__bnvs_seq_put_left:cv,
%   \__bnvs_seq_put_right:cn,
%   \__bnvs_seq_put_right:cv,
%   \__bnvs_seq_set_split:cnn,
%   \__bnvs_seq_set_split:cnv,
%   \__bnvs_seq_set_split:cnx,
%   \__bnvs_seq_pop_left:cc,
% }
% \begin{syntax}
% \cs{ __bnvs_seq_new:c } \marg{core}
% \cs{ __bnvs_seq_count:c } \marg{core}
% \cs{ __bnvs_seq_clear:c } \marg{core}
% \cs{ __bnvs_seq_set_eq:cc } \marg{core_1} \marg{core_2}
% \cs{ __bnvs_seq_use:cn } \marg{core} \marg{separator}
% \cs{ __bnvs_seq_item:cn } \marg{core} \marg{integer expression}
% \cs{ __bnvs_seq_remove_all:cn } \marg{core} \marg{tl}
% \cs{ __bnvs_seq_put_right:cn } \marg{seq core} \marg{tl}
% \cs{ __bnvs_seq_put_right:cv } \marg{seq core} \marg{tl core}
% \cs{ __bnvs_seq_set_split:cnn } \marg{seq core} \marg{tl} \marg{separator}
% \cs{ __bnvs_seq_pop_left:cc } \marg{core_1} \marg{core_2}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\seq_set_eq:cc {l__bnvs_|\texttt{\meta{core_1}}|_seq} {l__bnvs_|\texttt{\meta{core_2}}|_seq}|
% \item |\seq_count:c {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_use:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{separator}}
% \item |\seq_item:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{integer expression}}
% \item |\seq_remove_all:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{tl}}
% \item |\__bnvs_seq_clear:c {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_put_right:cv {l__bnvs_|\texttt{\meta{seq core}}|_seq} {l__bnvs_|\texttt{\meta{tl core}}|_tl}|
% \item |\seq_set_split:cnn{l__bnvs_|\texttt{\meta{seq core}}|_seq}{l__bnvs_|\texttt{\meta{tl core}}|_tl}{|\texttt{\meta{tl}}|}|
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { seq } { count }
\BNVS_new_c:nc   { seq } { clear }
\BNVS_new_cn:nc  { seq } { use }
\BNVS_new_cn:nc  { seq } { item }
\BNVS_new_cn:nc  { seq } { remove_all }
\BNVS_new_cn:nc  { seq } { map_inline }
\BNVS_new_cc:nc  { seq } { set_eq }
\BNVS_new_cv:ncn { seq } { put_left  } { tl }
\BNVS_new_cn:ncn { seq } { put_right } { tl }
\BNVS_new_cv:ncn { seq } { put_right } { tl }
\BNVS_new_cnn:nc { seq } { set_split }
\BNVS_new_cnv:nc { seq } { set_split }
\BNVS_new_cnx:nc { seq } { set_split }
\BNVS_new_cc:ncn { seq } { pop_left  } { tl }
\BNVS_new_cc:ncn { seq } { pop_right } { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_seq{...}, noigre}
% \BNVS_seq_new:c { A_TEST }
% \BNVS_seq_new:c { B_TEST }
% \__bnvs_seq_clear:c { A_TEST }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \assert_size_not_equal:nnn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { 0 }
% \__bnvs_seq_put_right:cv { A_TEST } { TEST_B }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 1 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { FAILURE } { 1 }
% \__bnvs_seq_put_left:cv { A_TEST } { TEST_A }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 2 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \seq_use:Nn \l__bnvs_A_TEST_seq { , } } { SUCCESS , FAILURE } { 5 }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { SUCCESS , FAILURE } { 6 }
% \__bnvs_seq_set_eq:cc { B_TEST } { A_TEST }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { B_TEST } { , } } { SUCCESS , FAILURE } { 7 }
% \BNVS_seq_undefine:c { A_TEST }
% \BNVS_seq_undefine:c { B_TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_seq_split:cnn/pop_right:cc, noigre}
% \__bnvs_seq_clear:c { TEST }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 1 } } { A } { 1 }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 2 } } { B } { 2 }
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { B } { \test_fail:n { 3 } }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { A } { \test_fail:n { 4 } }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_seq_if_empty:c,
%   \__bnvs_seq_get_right:cc,
%   \__bnvs_seq_pop_left:cc,
%   \__bnvs_seq_pop_right:cc,
% }
% \begin{syntax}
% \cs{ __bnvs_seq_if_empty:cTF } \marg{seq core name} \marg{yes code} \marg{no code}
% \cs{ __bnvs_seq_get_right:ccTF } \marg{seq core name} \marg{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cc:ncnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1_#2:cc } ##1 ##2 { #4 } {
    \BNVS_use:ncncn {
      \BNVS_use_raw:c { #1_#2:NNTF }
    } { ##1 } { #1 } { ##2 } { #3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\BNVS_new_conditional_c:ncn { seq } { if_empty } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { get_right } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_left  } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_right } { tl } { T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_seq_get_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_get_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { B } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_seq_pop_left:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_left:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { A } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_seq_pop_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { C } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \BNVS_Test:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 4 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Integers}
% \begin{function}{
%   \__bnvs_int_new:c,
%   \__bnvs_int_use:c,
%   \__bnvs_int_inc:c,
%   \__bnvs_int_decr:c,
%   \__bnvs_int_set:cn,
%   \__bnvs_int_set:cv
% }
% \begin{syntax}
% \cs{ __bnvs_int_new:c  } \marg{core}
% \cs{ __bnvs_int_use:c  } \marg{core}
% \cs{ __bnvs_int_incr:c } \marg{core}
% \cs{ __bnvs_int_decr:c } \marg{core}
% \cs{ __bnvs_int_set:cn } \marg{core} \marg{value}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\int_new:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_use:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_incr:c  {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_idecr:c {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_set:cn  {l__bnvs_|\texttt{\meta{core}}|_int}| \texttt{\meta{value}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { int } { new  }
\BNVS_new_c:nc   { int } { use  }
\BNVS_new_c:nc   { int } { zero }
\BNVS_new_c:nc   { int } { incr }
\BNVS_new_c:nc   { int } { decr }
\BNVS_new_cn:nc  { int } { set  }
\BNVS_new_cv:ncn { int } { set  } { int }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_int_new:c/use:c/set:cn, noigre}
% \BNVS_int_new:c  { A_TEST }
% \__bnvs_int_set:cn { A_TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { A_TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_set:cn { A_TEST } { 2 }
% \BNVS_Test:nn { 2 } { 2 }
% \cs_undefine:N \BNVS_Test:nn
% \BNVS_int_undefine:c { A_TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_int_incr:c/decr:c, noigre}
% \__bnvs_int_set:cn { TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_incr:c { TEST }
% \BNVS_Test:nn { 2 } { 2 }
% \__bnvs_int_decr:c { TEST }
% \BNVS_Test:nn { 1 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_int_set:cv, noigre}
% \__bnvs_int_set:cn { TEST_A } { 421 }
% \__bnvs_int_set:cv { TEST_B } { TEST_A }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST_B } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 421 } { 1 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Prop}
% \begin{function}[TF]{
%   \__bnvs_prop_get:Nnc,
% }
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { prop_get:Nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_use:ncn {
    \prop_get:NnNTF #1 { #2 }
  } { #3 } { tl } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_prop_get:NncTF, noigre}
% \prop_clear:N \l__bnvs_TEST_prop
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_use_raw:c { __bnvs_prop_get:Nnc#1 }
%     \l__bnvs_TEST_prop { #2 } { TEST }
% }
% \BNVS_Test:nn { TF } { key } { \test_fail:n { A/1 } } { }
% \BNVS_Test:nn { T  } { key } { \test_fail:n { A/2 } }
% \BNVS_Test:nn {  F } { key }                        { }
% \prop_put:Nnn \l__bnvs_TEST_prop { key } { value }
% \cs_set:Npn \Test_a:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:nn { TF } { key } { \Test_a:nn { value } { A/3 } } { \test_fail:n { B/3 } }
% \BNVS_Test:nn { T  } { key } { \Test_a:nn { value } { A/3 } }
% \BNVS_Test:nn {  F } { key }     { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \Test_a:nn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsection{Debug facilities}
% Typesetting file |beanoves.dtx| creates both \pkg{beanoves}
% and \pkg{beanoves-debug} style files. The former is intended for everyday
% use whereas the latter contains supplemental debugging and testing
% facilities which are intentionally left undocumented.
% In particular, we have aliases for |\group_begin:| and |\group_end:|
% to allow the display of supplemental informations while debugging.
%
% \subsection{Debug messages}
% \begin{bnvs.gobble}
%<*!debug>
\cs_new:Npn \BeanovesDebugOn {
  \__bnvs_warning:x { Debugging~mode~requires~\jobname-debug.sty,~typeset~\jobname.dtx}
}
\cs_new:Npn \BeanovesDebugOff { \BeanovesDebugOn }
%</!debug>
%<*!final>
\cs_set_eq:NN \BeanovesDebugOn \BNVS_DEBUG_on:
\cs_set_eq:NN \BeanovesDebugOff \BNVS_DEBUG_off:
\cs_generate_variant:Nn \BNVS_DEBUG_log:n { x, V }
\cs_new:Npn \BNVS_DEBUG_b:nn #1 #2 {
  \BNVS_DEBUG_log:x { #1~#2 }
}
%</!final>
% \end{bnvs.gobble}
%
% \subsection{Variable facilities}
%
%
% \subsection{Testing facilities}
% \begin{bnvs.gobble}
%<*final>
\cs_set_eq:NN \BNVS_begin: \group_begin:
\cs_set_eq:NN \BNVS_end: \group_end:
%</final>
%<*!final>
\cs_new:Npn \BNVS_begin: {
  \group_begin:
  \int_incr:N \l__bnvs_group_int
}
\cs_set_eq:NN \BNVS_end: \group_end:
\bool_new:N \l__bnvs_TEST_ignore_bool
\bool_set_false:N \l__bnvs_TEST_ignore_bool
\cs_new:Npn \BNVS_DEBUG_log:nn #1 {
  \exp_args:Nx
  \BNVS_DEBUG_b:nn
  { ▄▄ \prg_replicate:nn {\l__bnvs_group_int + 1} {#1} }
}
\cs_generate_variant:Nn \BNVS_DEBUG_log:nn { nx, nV }
\ProvideDocumentEnvironment {beanoves.failure} {} {} {}
\bool_new:N \l__bnvs_TEST_bool
\tl_new:N \g__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_banner_tl
\tl_new:N \l__bnvs_TEST_done_tl
\tl_clear:N \l__bnvs_TEST_done_tl
\tl_new:N \l__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_A_tl
\tl_new:N \l__bnvs_TEST_B_tl
\tl_new:N \l__bnvs_TEST_C_tl
\str_new:N \l__bnvs_TEST_str
\str_new:N \l__bnvs_TEST_A_str
\str_new:N \l__bnvs_TEST_B_str
\seq_new:N \l__bnvs_TEST_seq
\seq_new:N \l__bnvs_TEST_A_seq
\seq_new:N \l__bnvs_TEST_B_seq
\int_new:N \l__bnvs_TEST_int
\int_new:N \l__bnvs_TEST_group_int
\prop_new:N \l__bnvs_TEST_prop
\prop_new:N \g__bnvs_TEST_prop
\regex_const:Nn \c__bnvs_TEST_comma_regex { , }
\NewDocumentEnvironment{bnvs.test} {} {
  \color{red}\bfseries\ExplSyntaxOn
  \debug_on:n { check-declarations }
  \__bnvs_gclear_all:
  \int_gset:Nn \g__bnvs_call_int { 128 }
  \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
  \__bnvs_provide_off:
  \BNVS_DEBUG_log_set:cnnc { query_eval:ncTF } { QUERY } { ? } { ans }
  \BNVS_TEST_BEGIN:n
} {
  \assert_equal:xxn {
    \int_use:N \l__bnvs_group_int
  } {
    \int_use:N \l__bnvs_TEST_group_int
  } { Bad~group~nesting }
  \tl_use:N \l__bnvs_TEST_done_tl
  \__bnvs_gclear:
  \ExplSyntaxOff\ignorespacesafterend
}
\keys_define:nn { bnvs.test } {
  banner  .code:n = \tl_set:Nn \l__bnvs_TEST_banner_tl { #1 },
  :N      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:N #1
  },
  :Nn     .code:n = \exp_args:NNo \tl_set:No \l__bnvs_TEST_banner_tl { 
    \exp_last_unbraced:No \token_to_str:N { \use_i:nn #1 }
    \use_ii:nn #1
  },
  :c      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { #1 }
  },
  :cn     .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \use_i:nn #1 } \use_ii:nn #1
  },
  bnvs:c  .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { \use_i:nn #1 } }
  },
  bnvs:cn .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { \use_i:nn #1 } } \use_ii:nn #1
  },
  debug  .code:n = \BNVS_DEBUG_on:,
  reset  .code:n = \reset:n { #1 },
  ignore .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { \BNVS_use_raw:c { c_#1_bool } },
  ignore .default:n = true,
%  ignore .code:n = {}, % comment this line to ignore tests
  noigre .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { !(\BNVS_use_raw:c { c_#1_bool }) },
  noigre .default:n = false,
  noigre .code:n = {}, % comment this line to ignore no tests
}
\int_new:N \l__bnvs_TEST_A_int
\int_new:N \l__bnvs_TEST_B_int
\cs_new:Npn \BNVS_TEST_BEGIN:n #1 {
  \cs_set:Npn \reset:n ##1 {
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \tl_if_empty:nF { ##1 } {
      \__bnvs_gclear:
      \__bnvs_n_gclear:
      \__bnvs_v_gclear:
      \__bnvs_cache_gclear:
    }
    \Beanoves { FIRST = 220+2, LENGTH = 440+5, LAST = 660+6 }
    \BNVS_end:
    \__bnvs_provide_off:
  }
  \cs_set:Npn \reset_X: {
    \reset:n { YES }
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \Beanoves {
      X1  = FIRST,
      X2  = LAST-LENGTH+1,
      A1  = FIRST:,
      A2  = LAST-LENGTH+1:,
      AA1 = FIRST::,
      AA2 = LAST-LENGTH+1::,
      Z1  = :LAST,
      Z2  = :FIRST+LENGTH-1,
      AL11 = FIRST::LENGTH,
      AL12 = FIRST::LAST-FIRST+1,
      AL21 = LAST-LENGTH+1::LENGTH,
      AL22 = LAST-LENGTH+1::LAST-FIRST+1,
      AZ11 = FIRST:LAST,
      AZ12 = FIRST:FIRST+LENGTH-1,
      AZ21 = LAST-LENGTH+1:LAST,
      AZ22 = LAST-LENGTH+1:FIRST+LENGTH-1,
      LZ11 = ::LENGTH:LAST,
      LZ12 = ::LENGTH:FIRST+LENGTH-1,
      LZ21 = ::LAST-FIRST+1:LAST,
      LZ22 = ::LAST-FIRST+1:FIRST+LENGTH-1,
      ZL11 = :LAST::LENGTH,
      ZL12 = :LAST::LAST-FIRST+1,
      ZL21 = :FIRST+LENGTH-1::LENGTH,
      ZL22 = :FIRST+LENGTH-1::LAST-FIRST+1,
    }
    \BNVS_end:
  }
  \tl_if_empty:nF { #1 } { \keys_set_known:nn {bnvs.test} {#1} }
  \bool_if:NTF \l__bnvs_TEST_ignore_bool {
    \tl_clear:N \l__bnvs_TEST_done_tl
    \RenewDocumentEnvironment{bnvs.test}{+b}{
      \BNVS_set:cpn { end_test: } {
        \BNVS_set:cpn { end_test: } { }
        \end{bnvs.test}
      }
    } {
      \__bnvs_end_test:
    }
    \begin{bnvs.test}
  } {
    \cs_set:Npn \banner:n ##1 {
      \__bnvs_call_greset:
      \BNVS_log_a:xn { ▶︎▶︎▶︎▶︎▶︎~TEST~##1~/~line:~\the\inputlineno} {}
    }
    \RenewDocumentEnvironment{beanoves.failure}{}
      {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
         \setlength{\itemindent}{0pt}%
         \setlength{\leftmargin}{0pt}%
         \setlength{\labelwidth}{0pt}%
         \addtolength{\topsep}{-0.5\parskip}%
         \listparindent \parindent
         \setlength{\parsep}{\parskip}}}
      {\end{list}}  
% Utilities
    \cs_set_eq:NN \test_extract:nnnn \BNVS_TEST_extract:nnnn
    \cs_set_eq:NN \test_extract:Nnnn \BNVS_TEST_extract:Nnnn
    \cs_set_eq:NN \test_split:Nnnn \BNVS_TEST_split:Nnnn
	   \cs_set_eq:NN \assert_equal:nnn \BNVS_ASSERT_equal:nnn
    \cs_set_eq:NN \assert_equal:xnn \BNVS_ASSERT_equal:xnn
    \cs_set_eq:NN \assert_equal:xxn \BNVS_ASSERT_equal:xxn
	   \cs_set_eq:NN \assert_size_equal:nnn \BNVS_ASSERT_size_equal:nnn
	   \cs_set_eq:NN \assert_size_not_equal:nnn \BNVS_ASSERT_size_not_equal:nnn
    \cs_set_eq:NN \assert_equal_tl:vnn \BNVS_ASSERT_equal_tl:vnn
    \cs_set_eq:NN \test_fail:n \BNVS_TEST_fail:n
    \cs_set_eq:NN \test_fail:x \BNVS_TEST_fail:x
    \cs_set:Npn \assert_equal_ans:nn {
      \assert_equal_tl:vnn { ans }
    }
    \cs_set:Npn \preflight:n ##1 {
      \banner:n { ##1 }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \preflight:nn ##1 ##2 {
      \banner:n { ##2~/~##1 }
      \tl_if_empty:nF { ##1 } {
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \preflight:nnn ##1 ##2 ##3 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2~/~##3~/ }
      } {
        \banner:n { ##2~/~X=##1->##2~/ }
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \postflight: {
      \assert_equal:xxn {
        \int_use:N \l__bnvs_group_int
      } {
        \int_use:N \l__bnvs_TEST_group_int
      } { Bad~group~nesting }
      \BNVS_end:
    }
    \cs_set:Npn \flight:nT ##1 ##2 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:n { ##1 }
        ##2
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnT ##1 ##2 ##3 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nn { ##1 } { ##2 }
        ##3
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnnT ##1 ##2 ##3 ##4 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nnn { ##1 } { ##2 } { ##3 }
        ##4
        \postflight:
      }
    }
    \cs_set:Npn \Test_x_path_resolve:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_kip_x_path_resolve:TF {
          \BNVS_ASSERT_equal_tl:vnn {id } { ?! } { ##6-id }
          \BNVS_ASSERT_equal_tl:vnn { id } { ?! } { ##6-id }
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \__bnvs_seq_use:cn { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
        \__bnvs_gclear:
      }
    }
    \cs_set:Npn \Test_path_resolve_n:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \__bnvs_gclear_all:
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_kip_n_path_resolve:TF {
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \__bnvs_seq_use:cn { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
% Utilities
    \cs_set:Npn \Test_generic_ncTF:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        \__bnvs_int_set:cv { TEST_A } { group }
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-TRUE }
        } {
          \test_fail:x { ##5-FALSE(\token_to_str:N ##1)}
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__bnvs_group_int } {
          \test_fail:n { ##5~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_ncTF:Nnnnn { c }
    \cs_set:Npn \Test_what_action_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_ncTF:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
%   Usage \Test_generic_X_ncTF:Nnnn \__bnvs_previous_append:ncTF {X=123} {122} {label}
    \cs_set:Npn \Test_generic_X_ncTF:Nnnn ##1 ##2 {
      \Test_generic_ncTF:Nnnnn ##1 { ##2 } {}
    }
    \cs_generate_variant:Nn \Test_generic_X_ncTF:Nnnn { c }
    \cs_set:Npn \Test_what_action_X_ncTF:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \cs_if_exist:cTF { __bnvs_##1_##2:ncTF } {
        \BNVS_use:Nc
        \Test_generic_X_ncTF:Nnnn { ##1_##2:ncTF } { ##3 } { ##4 } { ##5 }
      } {
        \test_fail:x { ##5-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##2 } { ##6 } {
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
          \assert_equal_ans:nn { ##5 } { ##6-TRUE }
        } {
          \test_fail:n { ##6-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_generic_X_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        ##1 { ?!X } { ##3 } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-X-TRUE }
        } {
          \test_fail:n { ##5-X-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_X_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_X_nncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nnNTF } {
        \Test_generic_X_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:nnNTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_X:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnnT { ##2 } { ##5 } { ##2~/~##3 } {
        \group_begin:
        \__bnvs_value_resolve:ncTF { ?!X } { a } {
          \group_end:
          ##1 { ?!X } { ##3 } { ans } {
            \assert_equal_ans:nn { ##4 } { ##5-b }
          } {
            \test_fail:x { ##5-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##5-d(value_resolve:ncTF) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_X:Nnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_X_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_check_value_X:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnnT { ##2 } { ##6 } { ##2~/~##4 } {
        \group_begin:
        \exp_args:Nx
        \__bnvs_value_resolve:ncTF { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { a } {
          \group_end:
          \exp_args:Nx
          ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
            \assert_equal_ans:nn { ##5 } { ##6-b }
          } {
            \test_fail:n { ##6-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##6-d(value_resolve:ncTF-2) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_check_value_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_what_resolve_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:nnnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:nnnnn { ##1 } { append }
    }
    \cs_set:Npn \Test_what_resolve_ncTF:nnnnn ##1 {
      \Test_what_action_ncTF:nnnnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_ncTF:nnnnn ##1 {
      \Test_what_action_ncTF:nnnnnn { ##1 } { append }
    }
% General
    \cs_set:Npn \Test_index_resolve_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { append }
    }
    \cs_set:Npn \Test_index_resolve:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { index } { append }
    }
    \cs_set:Npn \Test_range_resolve:nnn {
      \Test_what_action_X_ncTF:nnnnn { range } { resolve }
    }
    \cs_set:Npn \Test_range_append:nnn {
      \Test_what_action_X_ncTF:nnnnn { range } { append }
    }
% n index
    \cs_set:Npn \Test_n_get:nnnn {
      \Test_generic_ncTF:Nnnnn \__bnvs_n_get:ncTF
    }
    \cs_set:Npn \Test_n_get_X:nnn {
      \Test_generic_X_ncTF:Nnnn \__bnvs_n_get:ncTF
    }
    \cs_set:Npn \Test_n_resolve:nnnn {
      \Test_what_action_ncTF:nnnnnn { n } { resolve }
    }
    \cs_set:Npn \Test_n_append:nnnn {
      \Test_what_action_ncTF:nnnnnn { n } { append }
    }
    \cs_set:Npn \Test_n_resolve_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n } { resolve }
    }
    \cs_set:Npn \Test_n_append_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n } { append }
    }
    \cs_set:Npn \Test_n_index_resolve_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_n_index_append_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n_index } { append }
    }
    \cs_set:Npn \Test_n_index_resolve:nnnn {
      \Test_what_action_ncTF:nnnnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_n_index_append:nnnn {
      \Test_what_action_ncTF:nnnnnn { n_index } { append }
    }
    \cs_set:Npn \Test_n_incr_resolve:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_incr } { resolve }
    }
    \cs_set:Npn \Test_n_incr_append:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_incr } { append }
    }
    \cs_set:Npn \Test_n_post_resolve:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_post } { resolve }
    }
    \cs_set:Npn \Test_n_post_append:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_post } { append }
    }
% v
    \cs_set:Npn \Test_v_incr_resolve:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_incr } { resolve }
    }
    \cs_set:Npn \Test_v_incr_append:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_incr } { append }
    }
    \cs_set:Npn \Test_v_post_resolve:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_post } { resolve }
    }
    \cs_set:Npn \Test_v_post_append:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_post } { append }
    }
% query
    \cs_set:Npn \Test_if_append:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { append }
    }
    \cs_set:Npn \Test_if_resolve:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { resolve }
    }
    \cs_set:Npn \Test_regex:nnnn ##1 {
      \bool_if:NTF \l__bnvs_TEST_ignore_bool {
        \use_none:nnn
      } {
        \tl_if_exist:cTF { c__bnvs_##1_regex } {
          \BNVS_TEST_extract:cnnn { c__bnvs_##1_regex }
        } {
          \test_fail:n { Bad~name:~##1}
          \use_none:nnn
        }
      }
    }
    \cs_set:Npn \Test_query:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \__bnvs_tl_clear:c { TEST_A }
        \__bnvs_query_eval:ncTF { ##2 } { TEST_A } {
          \assert_equal_tl:vnn { TEST_A } { ##3 } {
            Test~\cs{__bnvs_query_eval:nc}:~##4-a
          }
        } {
          \test_fail:n { ##4-CALL }
        }
      }
    }
    \cs_set:Npn \Test_eval:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \BeanovesEval[in=\l__bnvs_ans_tl]{ ##2 }
        \assert_equal_ans:nn { ##3 } { ##4 }
      }
    }
    \BNVS_log_a:nn {▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎} {}
    \BNVS_log_a:xn {TEST~\l__bnvs_TEST_banner_tl\space file:~\BeanovesCurrentTestFile, line:~\the\inputlineno} {}
    \tl_set:Nn \l__bnvs_TEST_done_tl {
      \BNVS_log_a:xn { TEST~\l__bnvs_TEST_banner_tl...~DONE} {}
      \BNVS_log_a:nn {◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀} {}
    }
  }
}
\cs_new:Npn \BeanovesCurrentTestFile {
  \tl_if_empty:VF \CurrentFilePath { \CurrentFilePath / }
  \CurrentFile
}
\cs_set:Npn \BNVS_TEST_extract:nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \tl_if_empty:nT { #3 } {
    \__bnvs_match_once:nnT { #1 } { #2 } {
      \test_fail:n { #4-a }
    }
  } {
    \__bnvs_match_once:nnTF { #1 } { #2 } {
      \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { match } , }
      \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
      \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
        \__bnvs_tl_if_empty:cTF { b } {
          \seq_put_left:Nn \l__bnvs_match_seq { #2 }
        } {
          \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
        }
      }
      \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { split } , }
      \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
    } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_set:Npn \BNVS_TEST_extract:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_extract_once:NnNTF #1 { #2 } \l__bnvs_match_seq {
    \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { match } , }
    \seq_set_from_clist:Nn \l__bnvs_match_seq { #3 }
    \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
      \__bnvs_tl_if_empty:cTF { b } {
        \seq_put_left:Nn \l__bnvs_match_seq { #2 }
      } {
        \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
      }
    }
    \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { match } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn
  \BNVS_TEST_extract:Nnnn { cnnn }
\cs_set:Npn \BNVS_TEST_split:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_split:NnNTF #1 { #2 } \l__bnvs_split_seq {
    \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { split } , }
    \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
    \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { split } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn \msg_error:nnnn { nnnx }
\cs_set:Npn \BNVS_ASSERT_equal:nnn #1 #2 #3 {
  \tl_if_eq:nnF { #1 } { #2 } {
    \msg_error:nnnx { beanoves } { :nn } { FAILED~`#1'!=`#2' } { \BeanovesCurrentTestFile :\the\inputlineno :#3}
    \begin{beanoves.failure}
    \item FAILURE~`#1'!=`#2'~(\BeanovesCurrentTestFile :\the\inputlineno)
    \item #3
    \end{beanoves.failure}
  }
}
\box_new:N \l__bnvs_TEST_A_box
\box_new:N \l__bnvs_TEST_B_box
\cs_set:Npn \BNVS_ASSERT_size_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{beanoves.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{beanoves.failure}
    }
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_ASSERT_size_not_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{beanoves.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{beanoves.failure}
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_TEST_fail:n #1 {
  \msg_error:nnnx { beanoves } { :nn } { TEST~FAILED } { \BeanovesCurrentTestFile :\the\inputlineno :#1~(\int_use:N \g__bnvs_call_int)}
  \begin{beanoves.failure}
  \item FAILURE~unexpected~branch~(\BeanovesCurrentTestFile :\the\inputlineno)
  \item #1
  \end{beanoves.failure}
}
\cs_generate_variant:Nn \BNVS_ASSERT_equal:nnn { x, xx }
\cs_set:Npn \BNVS_ASSERT_equal_tl:vnn {
  \BNVS_tl_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_generate_variant:Nn \BNVS_TEST_fail:n { x }
\cs_new:Npn \BNVS_DEBUG_log_f:c #1 {
  \BNVS_DEBUG_log:x { \token_to_str:c { \BNVS:c { #1 } } }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncn #1 #2 #3 {
  \BNVS_DEBUG_log:x { #1 \token_to_str:c { \BNVS:c { #2 } } #3 }
}
\cs_new:Npn \BNVS_DEBUG_log_tl:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_tl_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_int:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_int_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_int_use:Nv \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nc #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_to_str:n { #1 }
    -> / \tl_to_str:n { #2 } /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { v }
\cs_new:Npn \BNVS_DEBUG_log_tl:nc #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_if_empty:nF { #1 } { #1 -> }
    \BNVS_tl_use:Nc \token_to_str:N  { #2 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #2 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_tl:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_tl_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #1 } /
  }
}

\cs_new:Npn \BNVS_DEBUG_log_arg:nn #1 #2 {
  \BNVS_DEBUG_log:x { \tl_to_str:n { #1 } -> / \tl_to_str:n { #2 } / }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnc #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:ncn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:ncn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_cs:nN #1 #2 {
  \BNVS_DEBUG_log:x { \tl_to_str:n { #1 } == \token_to_str:N #2 }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:N #1 {
  \BNVS_DEBUG_log:x {
    \token_to_str:N #1 => / \seq_count:N #1 / \seq_use:Nn #1 . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nN #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_to_str:n { #1 } => / \seq_count:N #2 / \seq_use:Nn #2 . /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { x }
\cs_new:Npn \BNVS_DEBUG_log_seq:xc #1 #2 {
  \BNVS_DEBUG_log:x {
    #1
    => / \seq_count:c { l__bnvs_#2_seq }
       / \seq_use:cn { l__bnvs_#2_seq } . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:c #1 {
  \BNVS_DEBUG_log:x {
    \token_to_str:c { l__bnvs_#1_seq }
    => / \seq_count:c { l__bnvs_#1_seq }
       / \seq_use:cn { l__bnvs_#1_seq } . /
  }
}
\tl_new:N \BNVS_DEBUG_tl
\cs_new:Npn \BNVS_DEBUG_log_cs_set:cpn #1 {
  \tl_set:Nn \BNVS_DEBUG_tl { #1 }
  \tl_replace_once:Nnn \BNVS_DEBUG_tl { : } { _ }
  \cs_set:cpn { BNVS_DEBUG_log_ \BNVS_DEBUG_tl :nn }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cn #1 #2 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    #2
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnn #1 #2 #3 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nn { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnc #1 #2 #3 #4 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnc { #2 } { #3 } { IN } { #4 }
    \cs_if_exist:cT { l__bnvs_#4_tl } {
      \BNVS_DEBUG_log_tl:c { #4 }
    }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnn #1 #2 #3 #4 #5 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnn { #2 } { #3 } { #4 } { #5 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnnc #1 #2 #3 #4 #5 #6 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnc { #2 } { #3 } { #4 } { #5 } { IN } { #6 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnnnnc #1 #2 #3 #4 #5 #6 #7 #8 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnnc { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { IN } { #8 }
  }
}
%</!final>
% \end{bnvs.gobble}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% The number of variables used has not been optimized,
% nor the \TeX\ groups used.
% Optimization often goes against readability.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_id_last_tl
\tl_set:Nn \l__bnvs_id_last_tl { ?! }
\tl_new:N \l__bnvs_a_tl
\tl_new:N \l__bnvs_b_tl
\tl_new:N \l__bnvs_c_tl
\tl_new:N \l__bnvs_V_tl
\tl_new:N \l__bnvs_A_tl
\tl_new:N \l__bnvs_L_tl
\tl_new:N \l__bnvs_Z_tl
\tl_new:N \l__bnvs_ans_tl
\tl_new:N \l__bnvs_key_tl
\tl_new:N \l__bnvs_key_base_tl
\tl_new:N \l__bnvs_id_tl
\tl_new:N \l__bnvs_n_tl
\tl_new:N \l__bnvs_path_tl
\tl_new:N \l__bnvs_group_tl
\tl_new:N \l__bnvs_scan_tl
\tl_new:N \l__bnvs_query_tl
\tl_new:N \l__bnvs_token_tl
\tl_new:N \l__bnvs_root_tl
\tl_new:N \l__bnvs_n_incr_tl
\tl_new:N \l__bnvs_incr_tl
\tl_new:N \l__bnvs_post_tl
\tl_new:N \l__bnvs_suffix_tl
\int_new:N \g__bnvs_call_int
\int_new:N \l__bnvs_int
\seq_new:N \g__bnvs_def_seq
\seq_new:N \l__bnvs_a_seq
\seq_new:N \l__bnvs_b_seq
\seq_new:N \l__bnvs_ans_seq
\seq_new:N \l__bnvs_match_seq
\seq_new:N \l__bnvs_split_seq
\seq_new:N \l__bnvs_path_seq
\seq_new:N \l__bnvs_path_base_seq
\seq_new:N \l__bnvs_query_seq
\seq_new:N \l__bnvs_token_seq
\bool_new:N \l__bnvs_in_frame_bool
\bool_set_false:N \l__bnvs_in_frame_bool
\bool_new:N \l__bnvs_parse_bool
%    \end{macrocode}
% \end{bnvs.macrocode}
% In order to implement the provide feature, we
% add getters and setters
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\bool_new:N \l__bnvs_provide_bool
\BNVS_new:cpn { provide_on: } {
  \bool_set_true:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n { PROVIDE...ON }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { provide_off: } {
  \bool_set_false:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n { PROVIDE...OFF }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\__bnvs_provide_off:
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_if_provide: }
% \begin{syntax}
% \cs{__bnvs_if_provide:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% Execute \meta{yes code} when in provide mode, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_provide: } { p, T, F, TF } {
  \bool_if:NTF \l__bnvs_provide_bool {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsection{Infinite loop management}
% Unending recursivity is managed here.
% \begin{variable} {\g__bnvs_call_int}
% Some functions calls, as well as some loop bodies, decrement this counter.
% When this counter reaches 0, an error is raised or
% a computation is aborted.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\int_const:Nn \c__bnvs_max_call_int { 2048 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_call_greset:}
% \begin{syntax}
% \cs{__bnvs_call_greset:}
% \end{syntax}
% Reset globally the call stack counter to its maximum value.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set:Npn  \__bnvs_call_greset: {
  \int_gset:Nn \g__bnvs_call_int { \c__bnvs_max_call_int }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
% \begin{function}[TF]{\__bnvs_call:}
% \begin{syntax}
% \cs{__bnvs_call_do:TF} \marg{ yes code } \marg{ no code }
% \end{syntax}
% Decrement the \cs{g__bnvs_call_int} counter globally and
% execute \meta{ yes code } if we have not reached 0,
% \meta{ no code } otherwise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { call: } { T, F, TF } {
  \int_gdecr:N \g__bnvs_call_int
  \int_compare:nNnTF \g__bnvs_call_int > 0 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
%
% \subsection{Overlay specification}
% \subsection{Basic functions}
% \begin{variable} {\g__bnvs_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% The basic keys are, assuming \meta{id}!\meta{key} is a fully qualified overlay set name,
% \begin{description}
% \item [\texttt{\meta{id}!\meta{key}/V}] for the value
% \item [\texttt{\meta{id}!\meta{key}/A}] for the first index
% \item [\texttt{\meta{id}!\meta{key}/L}] for the length when provided
% \item [\texttt{\meta{id}!\meta{key}/Z}] for the last index when provided
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_prop {
      \BNVS_DEBUG_log:n { ##1 -> ##2 }
    }
  }
  \BNVS_DEBUG_log_cache_gprop:n {#1}
  \BNVS_DEBUG_log_v_gprop:n {#1}
  \BNVS_DEBUG_log_n_gprop:n {#1}
}
\NewDocumentCommand\BeanovesLogGProp {O{20}} {
  \BNVS_begin:
  \BNVS_DEBUG_on:
  \BNVS_DEBUG_log_gprop:n {#1}
  \BNVS_end:
}
%</!final>
%<*final>
\NewDocumentCommand\BeanovesLogGProp {O{20}} { \__bnvs_error:n {Only~with~beanoves-debug} }
%</final>
% \end{bnvs.gobble}
% \begin{function}{
%   \__bnvs_gput:nnn,
%   \__bnvs_gput:nnn,
%   \__bnvs_item:nn,
%   \__bnvs_gremove:nn,
%   \__bnvs_gclear:n,
%   \__bnvs_gclear:v,
%   \__bnvs_gclear:,
% }
% \begin{syntax}
% \cs{__bnvs_gput:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{__bnvs_item:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_gremove:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_gclear:n} \marg{key}
% \cs{__bnvs_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% This is a wrapper over \LaTeX3\ eponym functions.
% The key argument is \texttt{\meta{key}/\meta{subkey}}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gput:nnn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { gput:nnn } #1 #2 #3 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
\BNVS_DEBUG_log_f:cnnnnnn { gput:nnn }
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:cpn { gput:nnv } #1 #2 {
  \BNVS_tl_use:nv {
    \__bnvs_gput:nnn { #1 } { #2 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_prop { #2 / #1 }
}
\BNVS_new:cpn { gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_prop { #2 / #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { gremove:nn } { SUBKEY } { #1 } { KEY } { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L } {
    \__bnvs_gremove:nn { ##1 } { #1 }
  }
  \__bnvs_cache_gclear:n { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnn { gclear:nn } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { gclear: } {
  \prop_gclear:N \g__bnvs_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { gclear:nn }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_generate_variant:cn { gclear:n } { V }
\BNVS_new:cpn { gclear:v } {
   \BNVS_tl_use:Nc \__bnvs_gclear:V
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_gput:nnn{|item:nn|gremove:nn}, noigre}
% \__bnvs_gput:nnn { subkey } { key } { value }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \prop_item:Nn \g__bnvs_prop { key / subkey } } 
%   { value }
%   { \test_fail:n { A } }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \__bnvs_item:nn { subkey } { key } } 
%   { value }
%   { \test_fail:n { B } }
% \__bnvs_gremove:nn {subkey} {key}
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \__bnvs_item:nn { subkey } { key } } 
%   { }
%   { \test_fail:n { C } }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_gclear:/n/v, noigre}
% \__bnvs_gput:nnn { A } { key_1 } { value_1 }
% \__bnvs_gput:nnn { A } { key_2 } { value_2 }
% \__bnvs_gput:nnn { A } { key_3 } { value_3 }
% \cs_set:Npn \BNVS_Test:nnTF #1 #2 {
%   \exp_args:Nx
%   \tl_if_eq:nnTF
%     { \prop_item:Nn \g__bnvs_prop { key_#1 / A } } 
%     { #2 }
% }
% \cs_set:Npn \Test_in:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { value_#1 }
%     { }
%     { \test_fail:n { IN_#1/#2 } }
% }
% \cs_set:Npn \Test_out:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { }
%     { }
%     { \test_fail:n { OUT_#1/#2 } }
% }
% \Test_in:nn { 1 } { A }
% \Test_in:nn { 2 } { B }
% \Test_in:nn { 3 } { C }
% \__bnvs_gclear:n { key_1 }
% \Test_out:nn { 1 } { D }
% \Test_in:nn { 2 } { E }
% \Test_in:nn { 3 } { F }
% \__bnvs_tl_set:cn { TEST_A } { key_2 }
% \__bnvs_gclear:v { TEST_A }
% \Test_out:nn { 1 } { G }
% \Test_out:nn { 2 } { H }
% \Test_in:nn { 3 } { I }
% \__bnvs_gclear:
% \Test_out:nn { 1 } { J }
% \Test_out:nn { 2 } { K }
% \Test_out:nn { 3 } { L }
% \cs_undefine:N \BNVS_Test:nnTF
% \cs_undefine:N \Test_in:nn
% \cs_undefine:N \Test_out:nn
% \end{bnvs.test}
%
% \begin{function}[pTF]{
%   \__bnvs_if_in:nn,
%   \__bnvs_if_in:n,
% }
% \begin{syntax}
% \cs{__bnvs_if_in_p:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_if_in:nnTF} \marg{subkey} \marg{key} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_in_p:n} \marg{key}
% \cs{__bnvs_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{key}/\meta{subkey}}, it makes the code more concise and readable.
% The version with no \meta{subkey} is the or combination for keys
% |V|, |A| and |Z|.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:nn } #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \__bnvs_if_in_p:nn V { #1 }
    || \__bnvs_if_in_p:nn A { #1 }
    || \__bnvs_if_in_p:nn Z { #1 }
  } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_in:nTF { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_if_in:nnTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_if_in:nn#1 } { subkey } { key }
% }
% \cs_set:Npn \BNVS_Test:TF {
%   \bool_if:nTF { \__bnvs_if_in_p:nn { subkey } { key } }
% }
% \BNVS_Test:TF       { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { TF } { \test_fail:n { A/2 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/3 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_gput:nnn { subkey } { key } { value }
% \prop_if_in:NnF \g__bnvs_prop { key/subkey } { \test_fail:n { B } }
% \bool_if:nF { \prop_if_in_p:Nn \g__bnvs_prop { key/subkey } } { \test_fail:n { BB } }
% \BNVS_Test:TF       { } { \test_fail:n { B/1 } }

% \BNVS_Test:n { TF } { } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { B/3 } }
% \cs_undefine:N \BNVS_Test:TF
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \__bnvs_gprovide:nnnT,
% }
% \begin{syntax}
% \cs{__bnvs_gprovide:nnnT} \marg{subkey} \marg{key} \marg{value} \marg{true precode}
% \end{syntax}
% Execute \meta{true precode} before providing,
% or \meta{false precode} before not providing.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gprovide:nnnT } #1 #2 #3 #4 {
  \prop_if_in:NnF \g__bnvs_prop { #2 / #1 } {
    #4
    \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnn { gprovide:nnnT } 
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_gprovide:nnnT, noigre}
% \__bnvs_gclear:
% \__bnvs_if_in:nnT { subkey } { key } { \test_fail:n { A } }
% \__bnvs_gprovide:nnnT { subkey } { key } { value } { }
% \__bnvs_if_in:nnF { subkey } { key } { \test_fail:n { B } }
% \__bnvs_gprovide:nnnT { subkey } { key } { value } {
%   \test_fail:n { C }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_get:nnc}
% \begin{syntax}
% \cs{__bnvs_get:nncTF} \marg{subkey} \marg{key} \marg{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined, on resolution only.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { get:nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_prop { #2 / #1 }
  } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnnc { get:nncTF } { ...TRUE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnnc { get:nncTF } { ...FALSE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c=\BNVS:c{get:nncTF}, noigre}
% \__bnvs_gclear:
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_get:nncTF { subkey } { key } { TEST } { \test_fail:n { A/1 } } { }
% \__bnvs_tl_clear:c { TEST }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_get:nnc#1 } { subkey } { key } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/2 } }
% \BNVS_Test:n {  F }                          { }
% \__bnvs_gput:nnn { subkey } { key } { value }
% \cs_new:Npn \TestT:n #1 {
%   \__bnvs_tl_if_eq:cnF { TEST } { value } { \test_fail:n { #1 } }
% }
% \BNVS_Test:n { TF } { \TestT:n { B/1 } } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { \TestT:n { B/3 } }
% \BNVS_Test:n {  F }                      { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { get:nvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_get:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \__bnvs_gput:nnn X { A } { B }
% \BNVS_Test:xxn { \__bnvs_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} || \__bnvs_if_in_p:nn X {A} } TF } { T } { 11 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_get:nncF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_get:nncT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsection{Functions with cache}
% \begin{variable} {\g__bnvs_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges.
% \begin{description}
% \item [\texttt{\meta{id}!\meta{key}/V}] for the cached static value of the value
% \item [\texttt{\meta{id}!\meta{key}/A}] for the cached static value of the first index
% \item [\texttt{\meta{id}!\meta{key}/L}] for the cached static value of the length
% \item [\texttt{\meta{id}!\meta{key}/Z}] for the cached static value of the last index
% \item [\texttt{\meta{id}!\meta{key}/P}] for the cached static value of the previous index
% \item [\texttt{\meta{id}!\meta{key}/N}] for the cached static value of the next index
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_cache_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_cache_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_cache_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_cache_prop {
      \BNVS_DEBUG_log:n { c: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogCProp {O{20}} { \BNVS_DEBUG_log_cache_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \__bnvs_cache_gput:nnn,
%   \__bnvs_cache_gput:nnv,
%   \__bnvs_cache_gput:nvn,
%   \__bnvs_cache_item:nn,
%   \__bnvs_cache_gremove:nn,
%   \__bnvs_cache_gclear:n,
%   \__bnvs_cache_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_cache_gput:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{__bnvs_cache_item:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_cache_gremove:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_cache_gclear:n} \marg{key}
% \cs{__bnvs_cache_gclear:}
% \end{syntax}
% Wrapper over the functions above for \texttt{\meta{key}/\meta{subkey}}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { cache_gput:nnn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { cache_gput:nnn } #1 #2 #3 {
\BNVS_DEBUG_log_f:c { cache_gput:nnn }
\BNVS_DEBUG_log_arg:nn { SUBKEY } { #1 }
\BNVS_DEBUG_log_arg:nn { KEY } { #2 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #3 }
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 } { #3 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \__bnvs_cache_gput:nnn { nV, nnV }
\BNVS_new:cpn { cache_gput:nvn } #1 {
  \BNVS_tl_use:nc {
    \__bnvs_cache_gput:nVn { #1 }
  }
}
\BNVS_new:cpn { cache_gput:nnv } #1 #2 {
  \BNVS_tl_use:nc {
    \__bnvs_cache_gput:nnV { #1 } { #2 }
  }
}
\BNVS_new:cpn { cache_item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:cpn { cache_gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:cpn { cache_gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L, P, N } {
    \prop_gremove:Nn \g__bnvs_cache_prop { #1 / ##1 }
  }
}
\BNVS_new:cpn { cache_gclear: } {
  \prop_gclear:N \g__bnvs_cache_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { cache_gclear: }
\BNVS_DEBUG_log_gprop:n { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[pTF]{
%   \__bnvs_cache_if_in:nn,
% }
% \begin{syntax}
% \cs{__bnvs_cache_if_in_p:n} \marg{subkey} \marg{key}
% \cs{__bnvs_cache_if_in:nTF} \marg{subkey} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{subkey}/\meta{key}}, it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_cache_if_in:nn #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_cache_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_cache_get:nnc
% }
% \begin{syntax}
% \cs{__bnvs_cache_get:nncTF} \marg{subkey} \marg{key} \marg{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { cache_get:nnc } #1 #2 #3 { p, T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_cache_prop { #2 / #1 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=cache_(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \__bnvs_cache_gput:nnn X { A } { B }
% \BNVS_Test:xxn { \__bnvs_cache_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {B} || \__bnvs_cache_if_in_p:nn X {A} } TF } { T } { 11 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_cache_get:nncF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_cache_get:nncT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsubsection{Implicit value counter}
% The implicit value counter is local to the current frame.
% It is defined at the global level because changes made
% at any depth must be made at the frame depth.
% If the frame were a closure, this counter would belong to that closure.
% When used for the first time, it either defaults to the firsrt index or last index.
% \begin{variable} {\g__bnvs_v_prop}
% \meta{key}--\meta{value} property list to store the contents or the named value counters.
% The keys are \meta{id}!\meta{key}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_v_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_v_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_v_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_v_prop {
      \BNVS_DEBUG_log:n { v: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogVProp {O{20}} { \BNVS_DEBUG_log_v_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \__bnvs_v_gput:nn,
%   \__bnvs_v_gput:nV,
%   \__bnvs_v_gput:Vn,
%   \__bnvs_v_item:n,
%   \__bnvs_v_gremove:n,
%   \__bnvs_v_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_v_gput:nn} \marg{key} \marg{value}
% \cs{__bnvs_v_item:n} \marg{key}
% \cs{__bnvs_v_gremove:n} \marg{key}
% \cs{__bnvs_v_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_gput:nn } {
  \prop_gput:Nnn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:cpn { v_gput:nv } #1 {
  \BNVS_tl_use:nv {
    \__bnvs_v_gput:nn { #1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_item:n } #1 {
  \prop_item:Nn \g__bnvs_v_prop { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_gremove:n } {
  \prop_gremove:Nn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { v_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_v_prop { #1 }
\BNVS_DEBUG_log_f:cnn { v_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:cpn { v_gclear: } {
  \prop_gclear:N \g__bnvs_v_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { v_gclear:n }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[pTF]{
%   \__bnvs_v_if_in:n
% }
% \begin{syntax}
% \cs{__bnvs_v_if_in_p:n} \marg{key}
% \cs{__bnvs_v_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{key}} value counter.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_if_in:n } #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_v_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_v_get:nc,
% }
% \begin{syntax}
% \cs{__bnvs_v_get:ncTF} \marg{key} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_get:nc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_v_prop { #1 }
  } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { v_get:ncTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { v_get:ncTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{cn={\BNVS:c{v_gput:nn}}{|get}, noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } { #3 }
% }
% \__bnvs_v_gput:nn { A } { B }
% \BNVS_Test:xxn { \__bnvs_v_item:n {A} } { B } { 1 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_v_get:ncF {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_v_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \cs_undefine:N \BNVS_Test:xxn
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \__bnvs_v_greset:nn,
%   \__bnvs_v_greset:vn,
%   \__bnvs_greset_all:nn
%   \__bnvs_greset_all:vn
% }
% \begin{syntax}
% \cs{__bnvs_v_greset:nnTF} \marg{key} \marg{initial value} \marg{true code} \marg{false code}
% \cs{__bnvs_greset_all:nnTF} \marg{key} \marg{initial value} \marg{true code} \marg{false code}
% \end{syntax}
% The key must include the frame id.
% Reset the value counter to the given \meta{initial value}.
% The |_all| version also cleans the cached values.
% If the \meta{key} is known, \meta{true code} is executed,
% otherwise \meta{false code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_greset:nn } #1 #2 { T, F, TF } {
  \__bnvs_v_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { v_greset:nnTF } { }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_v_gremove:n { #1 }
    \tl_if_empty:nF { #2 } {
      \__bnvs_v_gput:nn { #1 } { #2 }
    }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_greset:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_v_greset:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { greset_all:nn } #1 #2 { T, F, TF } {
  \__bnvs_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { greset_all:nnTF } { KEY } { #1 } { VALUE } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_begin:
    \clist_map_inline:nn { V, A, Z, L } {
      \__bnvs_get:nncT { ##1 } { #1 } { a } {
        \__bnvs_quark_if_nil:cT { a } {
          \__bnvs_cache_get:nncTF { ##1 } { #1 } { a } {
            \__bnvs_gput:nnv { ##1 } { #1 } { a }
          } {
            \__bnvs_gput:nnn { ##1 } { #1 } { 1 }
          }
        }
      }
    }
    \BNVS_end:
    \__bnvs_cache_gclear:n { #1 }
    \__bnvs_v_greset:nnT { #1 } { #2 } {}
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { greset_all:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_greset_all:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\__bnvs_gclear_all:n, \__bnvs_gclear_all:}
% \begin{syntax}
% \cs{__bnvs_gclear_all:n} \marg{key}
% \cs{__bnvs_gclear_all:}
% \end{syntax}
% Convenient shortcuts to clear all the storage, for the given key in the first case.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gclear_all: } {
  \__bnvs_gclear:
  \__bnvs_cache_gclear:
  \__bnvs_n_gclear:
  \__bnvs_v_gclear:
}
\BNVS_new:cpn { gclear_all:n } #1 {
  \__bnvs_gclear:n { #1 }
  \__bnvs_cache_gclear:n { #1 }
  \__bnvs_n_gremove:n { #1 }
  \__bnvs_v_gremove:n { #1 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Implicit index counter}
% The implicit index counter is also local to the current frame.
% It is defined at the global level because changes made
% at any depth must be made at the frame depth.
% When used for the first time, it defaults to 1.
% \begin{variable} {\g__bnvs_n_prop}
% \meta{key}--\meta{value} property list to store the contents of the named index counters.
% The keys are \meta{id}!\meta{key}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_n_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_n_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_n_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_n_prop {
      \BNVS_DEBUG_log:n { n: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogNProp {O{20}} { \BNVS_DEBUG_log_n_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \__bnvs_n_gput:nn,
%   \__bnvs_n_gput:nv,
%   \__bnvs_n_gput:vn,
%   \__bnvs_n_gprovide:nn,
%   \__bnvs_n_item:n,
%   \__bnvs_n_gremove:n,
%   \__bnvs_n_gremove:v,
%   \__bnvs_n_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_n_gput:nn} \marg{key} \marg{value}
% \cs{__bnvs_n_item:n} \marg{key}
% \cs{__bnvs_n_gremove:n} \marg{key}
% \cs{__bnvs_n_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { n_gput:nn } {
  \prop_gput:Nnn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { n_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { n_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \__bnvs_n_gput:nn { nV }
\BNVS_new:cpn { n_gput:nv } #1 {
  \BNVS_tl_use:nc {
    \__bnvs_n_gput:nV { #1 }
  }
}
\BNVS_new:cpn { n_gprovide:nn } #1 #2 {
  \prop_if_in:NnF \g__bnvs_n_prop { #1 } {
    \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { n_gprovide:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:cpn { n_gremove:n } {
  \prop_gremove:Nn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { n_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_n_prop { #1 }
\BNVS_DEBUG_log_f:cnn { n_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_generate_variant:cn { n_gremove:n } { V }
\BNVS_new:cpn { n_gremove:v } {
  \BNVS_tl_use:nc {
    \__bnvs_n_gremove:V
  }
}
\BNVS_new:cpn { n_gclear: } {
  \prop_gclear:N \g__bnvs_n_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { n_gclear: }
\BNVS_DEBUG_log_gprop:n { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_n_gremove:n { V }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[pTF]{\__bnvs_n_if_in:n}
% \begin{syntax}
% \cs{__bnvs_n_if_in_p:nn} \marg{key}
% \cs{__bnvs_n_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{key}} value counter.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_n_if_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_n_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_n_get:nc}
% \begin{syntax}
% \cs{__bnvs_n_get:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_n_get:nc #1 #2 { T, F, TF } {
  \__bnvs_prop_get:NncTF \g__bnvs_n_prop { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { n_get:ncTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { n_get:ncTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=n_(gput|gremove|gclear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } {#3}
% }
% \__bnvs_n_gput:nn { A } { B }
% \BNVS_Test:xxn { \__bnvs_n_item:n {A} } { B } { 1 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_n_get:ncF {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_n_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsubsection{Regular expressions}
%
% \begin{variable}{\c__bnvs_name_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_name_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=name_regex, noigre}
% \Test_regex:nnnn { name } {A} {A} {1}
% \Test_regex:nnnn { name } {_A1} {_A1} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_id_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_id_regex {
  (?: \ur{c__bnvs_name_regex} | [?] )? !
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=id_regex, noigre}
% \Test_regex:nnnn { id } {!} {!} {1}
% \Test_regex:nnnn { id } {_A1!} {_A1!} {2}
% \Test_regex:nnnn { id } {?!} {?!} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_path_regex}
% A sequence of \texttt{.\meta{positive integer}} items representing a path.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_path_regex {
  (?: \. \ur{c__bnvs_name_regex} | \. [-+]? \d+ )*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=path_regex, noigre}
% \Test_regex:nnnn { path } {} {} {1}
% \Test_regex:nnnn { path } {.1} {.1} {2}
% \Test_regex:nnnn { path } {.1.2} {.1.2} {3}
% \Test_regex:nnnn { path } {.1.-2} {.1.-2} {4}
% \Test_regex:nnnn { path } {.-1} {.-1} {5}
% \Test_regex:nnnn { path } {.-1.2} {.-1.2} {6}
% \Test_regex:nnnn { path } {.-1.-2} {.-1.-2} {7}
% \Test_regex:nnnn { path } {.1.n} {.1.n} {2'}
% \Test_regex:nnnn { path } {.1.2.n} {.1.2.n} {3'}
% \Test_regex:nnnn { path } {.1.-2.n} {.1.-2.n} {4'}
% \Test_regex:nnnn { path } {.-1.n} {.-1.n} {5'}
% \Test_regex:nnnn { path } {.-1.2.n} {.-1.2.n} {6'}
% \Test_regex:nnnn { path } {.-1.-2.n} {.-1.-2.n} {7'}
% \Test_regex:nnnn { path } {.n.1} {.n.1} {2''}
% \Test_regex:nnnn { path } {.1.n.2} {.1.n.2} {3''}
% \Test_regex:nnnn { path } {.1.n.-2} {.1.n.-2} {4''}
% \Test_regex:nnnn { path } {.n.-1} {.n.-1} {5''}
% \Test_regex:nnnn { path } {.-1.n.2} {.-1.n.2} {6''}
% \Test_regex:nnnn { path } {.-1.n.-2} {.-1.n.-2} {7''}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_A_key_Z_regex}
% A key is the name of an overlay set possibly followed by a dotted path.
% Matches the whole string.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_key_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item[1:] The range name including the slide \meta{id} and question mark if any
% \item[2:] slide \meta{id} including the question mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[3:] the path, if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_regex} ) \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}{:N=\c__bnvs_A_key_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_key_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1, {},{}} {2}
% \BNVS_Test:nnn {A.1} {A, {}, .1} {3}
% \BNVS_Test:nnn {_A1.1} {_A1, {}, .1} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1, {}, .1.2} {5}
% \BNVS_Test:nnn {?!A} {?!A, ?!, {}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!, {}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A, ?!, .1} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1, ?!, .1} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1, ?!, .1.2} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A, {}, .1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1, {}, .1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1, {}, .1.2.n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A, ?!, .1.n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1, ?!, .1.n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1, ?!, .1.2.n} {5'-?!}
% \end{bnvs.test}
%
% \begin{variable}{\c__bnvs_TEST_A_key_n_Z_regex}
% A key is the name of an overlay set possibly followed by a dotted path.
% Matches the whole string.
% Catch the ending \texttt{.n}.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_TEST_A_key_n_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{itemize}
% \item[1:] The full match
% \item[2:] The overlay set name including the slide \meta{id} and question mark if any, the dotted path but excluding the trailing \texttt{.n}
% \item[3:] slide \meta{id} including the question mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? )
  \ur{c__bnvs_name_regex}
  (?: \. \ur{c__bnvs_name_regex} | \. [-+]? \d+ )*? )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[4:] the last \texttt{.n} component if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \. n )? \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{itemize}
% \begin{bnvs.test}{banner=A_key_n_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_TEST_A_key_n_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1,{},{}} {2}
% \BNVS_Test:nnn {A.1} {A.1,{},{}} {3}
% \BNVS_Test:nnn {_A1.1} {_A1.1,{},{}} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1.1.2,{},{}} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2,{},{.n}} {6}
% \BNVS_Test:nnn {?!A} {?!A, ?!,{}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!,{}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A.1, ?!,{}} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1.1, ?!,{}} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1.1.2, ?!,{}} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A.1, {}, .n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1.1, {}, .n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2, {}, .n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A.1, ?!, .n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1.1, ?!, .n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1.1.2, ?!, .n} {5'-?!}
% \BNVS_Test:nnn {?!_A1.1.n.2.n} {?!_A1.1.n.2, ?!, .n} {5''-?!}
% \end{bnvs.test}
%
% \begin{variable}{\c__bnvs_colons_regex}
% For ranges defined by a colon syntax.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_colons_regex { :(:+)? }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=colons_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn {
%   \BNVS_TEST_split:Nnnn \c__bnvs_colons_regex
% }
% \BNVS_Test:nnn { A:C } {{A},{},{C}} {1}
% \BNVS_Test:nnn { A::C } {{A},{:},{C}} {2}
% \BNVS_Test:nnn { A:::C } {{A},{::},{C}} {3}
% \BNVS_Test:nnn { :B::C } {{},{},{B},{:},{C}} {4}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 9 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{bnvs.macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \+\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
%   \item 1: \meta{key} of a slide range
%   \item 2: \meta{id} of a slide range including the exclamation mark 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 3: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{}} { 1|2|3-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ++ABC } {} {{ABC},{},{}} {a'}
% \BNVS_Test:nnnn { ++ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b'}
% \BNVS_Test:nnnn { ++?!ABC } {} {{?!ABC},{?!},{}} {c'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~X~ } {++?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e'}
% \end{bnvs.test}
%   \item 4: \meta{key} of a slide range
%   \item 5: \meta{id} of a slide range including the exclamation mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 6: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:}, noigre, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{}} { 4|5|6-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2~X~ } {?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e}
% \BNVS_Test:nnnn { ABC.3.N.n~~ } {} {{ABC},{},{.3.N.n}} {f}
% \end{bnvs.test}
% We continue with other expressions
%   \item 7: the \meta{++n} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      (?: \.(\+)\+n
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\c__bnvs_split_regex/.++n, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{+},{},{} } { 7-#4~(.++n) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC.++n } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2.++n~~ } {}  {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC.++n } {}  {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~X~ } { ?!ABC.1.2.++n~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 8: the poor man integer expression after `|+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      |  \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner={\token_to_str:N\c__bnvs_split_regex/+=}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { `+='~#4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{} } { 8-#4~(+=) } 
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl { #3, {}, #4 }
% }
% \BNVS_Test:nnnnn { ABC += 421 } {} {{ABC}, {}, {}} {421} {1}
% \BNVS_Test:nnnnn { ABC += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {2}
% \BNVS_Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {3}
% \BNVS_Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {4}
% \BNVS_Test:nnnnn { ?!ABC += 421 } {} {{?!ABC}, {?!}, {}} {421} {5}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {6}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1~X } {?!ABC += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {7}
% \BNVS_Test:nnnnn { ?!ABC += (P.1+1)~~^^A(
% ) } {?!ABC += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {8}
% \end{bnvs.test}
%   \item 9: the post increment
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      | (\+)\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:...++}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{+}} { 9-#4~(...++) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC++ } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2++~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC++ } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2++~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2++~X~ } {?!ABC.1.2++~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
% \end{myList}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    )?
  ) \s*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\c__bnvs_split_regex/split, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%     { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},/2 } { split-#3 }
% }
% \BNVS_Test:nnn { ++A }     {{A},{},{}} { 1-a }
% \BNVS_Test:nnn { ++?!A }   {{?!A},{?!},{}} { 1-b }
% \BNVS_Test:nnn { ++A.3 }   {{A},{},{.3}} { 1-c }
% \BNVS_Test:nnn { ++?!A.3 } {{?!A},{?!},{.3}} { 1-d }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,{},{},{},#2,/2 } { split-#3 }
% }
% \BNVS_Test:nnn { A.++n }   {{A},{},{},{+},{},{}} { 2-a' }
% \BNVS_Test:nnn { ?!A.++n } {{?!A},{?!},{},{+},{},{}} { 2-b' }
% \BNVS_Test:nnn { A.3.++n } {{A},{},{.3},{+},{},{}} { 2-c' }
% \BNVS_Test:nnn {?!A.3.++n} {{?!A},{?!},{.3},{+},{},{}} { 2-d' }
% \BNVS_Test:nnn { A }   {{A},{},{},{},{},{}} { 2-a }
% \BNVS_Test:nnn { A.n } {{A},{},{.n},{},{},{}} { 2-b }
% \BNVS_Test:nnn { ?!A } {{?!A},{?!},{},{},{},{}} { 2-c }
% \BNVS_Test:nnn { ?!A.n } {{?!A},{?!},{.n},{},{},{}} { 2-d }
% \BNVS_Test:nnn { A.3 } {{A},{},{.3},{},{},{}} { 2-e }
% \BNVS_Test:nnn { A.3.n } {{A},{},{.3.n},{},{},{}} { 2-f }
% \BNVS_Test:nnn { A.N.3.n } {{A},{},{.N.3.n},{},{},{}} { 2-f' }
% \BNVS_Test:nnn { ?!A.3 } {{?!A},{?!},{.3},{},{},{}} { 2-g }
% \BNVS_Test:nnn { ?!A.3.n } {{?!A},{?!},{.3.n},{},{},{}} { 2-h }
% \BNVS_Test:nnn { A++ }   {{A},{},{},{},{},{+}} { 3-a }
% \BNVS_Test:nnn { A.n++ }   {{A},{},{.n},{},{},{+}} { 3-b }
% \BNVS_Test:nnn { ?!A++ } {{?!A},{?!},{},{},{},{+}} { 3-c }
% \BNVS_Test:nnn { ?!A.n++ } {{?!A},{?!},{.n},{},{},{+}} { 3-d }
% \BNVS_Test:nnn { A.3++ } {{A},{},{.3},{},{},{+}} { 3-e }
% \BNVS_Test:nnn { A.3.n++ } {{A},{},{.3.n},{},{},{+}} { 3-f }
% \BNVS_Test:nnn { ?!A.3++ } {{?!A},{?!},{.3},{},{},{+}} { 3-g }
% \BNVS_Test:nnn { ?!A.3.n++ } {{?!A},{?!},{.3.n},{},{},{+}} { 3-h }
% \BNVS_Test:nnn { A.length } {{A},{},{.length},{},{},{}} { 4-a }
% \BNVS_Test:nnn { A.3.length } {{A},{},{.3.length},{},{},{}} { 4-b }
% \BNVS_Test:nnn { ?!A.length } {{?!A},{?!},{.length},{},{},{}} { 4-c }
% \BNVS_Test:nnn { ?!A.3.length } {{?!A},{?!},{.3.length},{},{},{}} { 4-d }
% \BNVS_Test:nnn { A.last } {{A},{},{.last},{},{},{}} { 5-a }
% \BNVS_Test:nnn { ?!A.last } {{?!A},{?!},{.last},{},{},{}} { 5-b }
% \BNVS_Test:nnn { A.3.last } {{A},{},{.3.last},{},{},{}} { 5-c }
% \BNVS_Test:nnn { ?!A.3.last } {{?!A},{?!},{.3.last},{},{},{}} { 5-d }
% \BNVS_Test:nnn { A.previous } {{A},{},{.previous},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.previous } {{?!A},{?!},{.previous},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.previous } {{A},{},{.3.previous},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.previous } {{?!A},{?!},{.3.previous},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.next } {{A},{},{.next},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.next } {{?!A},{?!},{.next},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.next } {{A},{},{.3.next},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.next } {{?!A},{?!},{.3.next},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.range } {{A},{},{.range},{},{},{}} { 7-a }
% \BNVS_Test:nnn { ?!A.range } {{?!A},{?!},{.range},{},{},{}} { 7-b }
% \BNVS_Test:nnn { A.3.range } {{A},{},{.3.range},{},{},{}} { 7-c }
% \BNVS_Test:nnn { ?!A.3.range } {{?!A},{?!},{.3.range},{},{},{}} { 7-d }
% \end{bnvs.test}
% \end{variable}
%
% \subsubsection{\pkg{beamer.cls} interface}
% Work in progress.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\RequirePackage{keyval}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l__bnvs_id_last_tl { #1 ! }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_KEY} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/before}{
  \__bnvs_n_gclear:
  \__bnvs_v_gclear:
  \bool_set_true:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_BEFORE} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/after}{
  \bool_set_false:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_AFTER} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Defining named slide ranges}
%
% \begin{function}[TF]{\__bnvs_range_set:cccn}
%   \begin{syntax}
%     \cs{__bnvs_range_set:cccnTF} \meta{core first}  \meta{core end} \meta{core length} \marg{tl} \marg{yes code} \marg{no code}
%   \end{syntax}
% Parse \meta{tl} as a range according to \cs{c__bnvs_colons_regex} and set the variables accordingly.
% \meta{tl} is expected to only contain colons and integers.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { split_pop_left:c } #1 { T, F, TF } {
  \__bnvs_seq_pop_left:ccTF { split } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { split_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { split_pop_left:cTF } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVV }
\BNVS_new_conditional:cpnn { range_set:cccn } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { range_set:cccnTF } {
  \BNVS_DEBUG_log_tl:c { #1 }
  \BNVS_DEBUG_log_tl:c { #2 }
  \BNVS_DEBUG_log_tl:c { #3 }
  \BNVS_DEBUG_log_arg:nn { IN } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_range_set_cccnTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_tl_clear:c { a }
  \__bnvs_tl_clear:c { b }
  \__bnvs_tl_clear:c { c }
  \__bnvs_regex_split:cnTF { colons } { #4 } {
    \__bnvs_seq_pop_left:ccT { split } { a } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% |a| may contain the \meta{start}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_seq_pop_left:ccT { split } { b } {
        \__bnvs_tl_if_empty:cTF { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a one colon range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \__bnvs_split_pop_left:cTF { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% |b| may contain the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \__bnvs_seq_pop_left:ccT { split } { c } {
              \__bnvs_tl_if_empty:cTF { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% A |::| was expected:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                \__bnvs_error:n { Invalid~range~expression(1):~#4 }
              } {
                \int_compare:nNnT { \__bnvs_tl_count:c { c } } > { 1 } {
                  \__bnvs_error:n { Invalid~range~expression(2):~#4 }
                }
                \__bnvs_split_pop_left:cTF { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l__bnvs_c_tl} may contain the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                  \__bnvs_seq_if_empty:cF { split } {
                    \__bnvs_error:n { Invalid~range~expression(3):~#4 }
                  }
                } {
                  \__bnvs_error:n { Internal~error }
                }
              }
            } 
          } {
          }
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a two colon range component.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \int_compare:nNnT { \__bnvs_tl_count:c { b } } > { 1 } {
            \__bnvs_error:n { Invalid~range~expression(4):~#4 }
          }
          \__bnvs_seq_pop_left:ccT { split } { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% |c| contains the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \__bnvs_split_pop_left:cTF { b } {
              \__bnvs_tl_if_empty:cTF { b } {
                \__bnvs_seq_pop_left:cc { split } { b }
%    \end{macrocode}
% \end{bnvs.macrocode}
% |b| may contain the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                \__bnvs_seq_if_empty:cF { split } {
                  \__bnvs_error:n { Invalid~range~expression(5):~#4 }
                }
              } {
                \__bnvs_error:n { Invalid~range~expression(6):~#4 }
              }
            } {
              \__bnvs_tl_clear:c { b }
            }
          }
        }
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Providing both the \meta{start}, \meta{length} and \meta{end} of a range
% is not allowed, even if they happen to be consistent.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \BNVS_next: { }
    \__bnvs_tl_if_empty:cT { a } {
      \__bnvs_tl_if_empty:cT { b } {
        \__bnvs_tl_if_empty:cT { c } {
          \cs_set:Npn \BNVS_next: {
            \__bnvs_error:n { Invalid~range~expression(7):~#3 }
          }
        }
      }
    }
    \BNVS_next:
    \cs_set:Npn \BNVS:nnn ##1 ##2 ##3 {
      \BNVS_end:
      \__bnvs_tl_set:cn { #1 } { ##1 }
      \__bnvs_tl_set:cn { #2 } { ##2 }
      \__bnvs_tl_set:cn { #3 } { ##3 }
    }
    \BNVS_exp_args:Nvvv \BNVS:nnn { a } { b } { c }
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_set_cccnTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_range_set:cccnTF, noigre}
% \__bnvs_range_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_clear:c { a }
%   \__bnvs_tl_clear:c { b }
%   \__bnvs_tl_clear:c { c }
%   \BNVS_use:c { range_set:cccn#1 } { a } { b } { c } { #2 }
% }
% \BNVS_Test:nn { TF } { } { \test_fail:n { A } } { }
% \BNVS_Test:nn { T  } { } { \test_fail:n { A } }
% \BNVS_Test:nn {  F } { }                          { }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \__bnvs_tl_if_eq:cnTF { a } { #1 } {
%     \__bnvs_tl_if_eq:cnTF { b } { #2 } {
%       \__bnvs_tl_if_eq:cnF { c } { #3 } {
%         \test_fail:n { #4/c }
%       }
%     } {
%       \test_fail:n { #4/b }
%     }
%   } {
%     \test_fail:n { #4/a }
%   }
% }
% \BNVS_Test:nnnn { } { } { } { X }
% \__bnvs_range_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \BNVS_Test:nn { TF } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } } { \test_fail:n { B/a } }
% \BNVS_Test:nn { T  } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } }
% \BNVS_Test:nn {  F } { 1:2 }     { \test_fail:n { #4/a } }
% \BNVS_Test:nn { TF } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } } { \test_fail:n { C/a } }
% \BNVS_Test:nn { T  } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn {  F } { 1::3 }     { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn { TF } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } } { \test_fail:n { D/a } }
% \BNVS_Test:nn { T  } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } }
% \BNVS_Test:nn {  F } { :2::3 }     { \test_fail:n { #4/a } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \BNVS_Test:nnnn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \__bnvs_range:nnnn,
%   \__bnvs_range:nvvv,
% }
%   \begin{syntax}
%     \cs{__bnvs_range:nnnn} \marg{key} \marg{start} \marg{end} \marg{length}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { range:nnnn } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { range:nnnn } { KEY } { #1 }
\BNVS_DEBUG_log_range_nnnn:nn { } { ... }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_provide:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { ...PROVIDE... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_if_in:nnTF A { #1 } {
      \use_none:nnn
    } {
      \__bnvs_if_in:nnTF Z { #1 } {
        \use_none:nnn
      } {
        \__bnvs_if_in:nnTF L { #1 } {
          \use_none:nnn
        } {
          \__bnvs_do_range:nnnn { #1 }
        }
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { .../DO~RANGE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_do_range:nnnn { #1 }
  }
}
\BNVS_new:cpn { range:nvvv } #1 #2 #3 #4 {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:nv {
        \BNVS_use:c { range:nnnn } { #1 }
      } { #2 }
    } { #3 }
  } { #4 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \__bnvs_parse_record:n,
%   \__bnvs_parse_record:v,
%   \__bnvs_parse_record:nn,
%   \__bnvs_parse_record:xn,
%   \__bnvs_parse_record:vn,
%   \__bnvs_n_parse_record:n,
%   \__bnvs_n_parse_record:v,
%   \__bnvs_n_parse_record:nn,
%   \__bnvs_n_parse_record:xn,
%   \__bnvs_n_parse_record:vn
% }
%   \begin{syntax}
%     \cs{__bnvs_parse_record:n} \marg{full name}
%     \cs{__bnvs_parse_record:nn} \marg{full name} \marg{value}
%     \cs{__bnvs_n_parse_record:n} \marg{full name}
%     \cs{__bnvs_n_parse_record:nn} \marg{full name} \marg{value}
%   \end{syntax}
% Auxiliary function for \cs{__bnvs_parse:n} and \cs{__bnvs_parse:nn} below.
% If \meta{value} does not correspond to a range,
% the \texttt{V} key is used.
% The \texttt{_n} variant concerns the index counter.
% This is a bottleneck.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_record:n }  #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { parse_record_n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_record_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_provide:TF {
    \__bnvs_gprovide:nnnT V { #1 } { 1 } {
      \__bnvs_gclear:n { #1 }
    }
  } {
    \__bnvs_gclear:n { #1 }
    \__bnvs_gput:nnn V { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_n:nn { ... } { ...END }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_parse_record:n { V }
\BNVS_new:cpn { parse_record:v } {
  \BNVS_tl_use:nc {
    \__bnvs_parse_record:V
  }
}
\BNVS_new:cpn { parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn { parse_record:nn }
  { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_record_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_range_set:cccnTF { a } { b } { c } { #2 } {
    \__bnvs_range:nvvv { #1 } { a } { b } { c }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...RANGE... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \__bnvs_if_provide:TF {
      \__bnvs_gprovide:nnnT V { #1 } { #2 } {
        \__bnvs_gclear_all:n { #1 }
      }
    } {
      \__bnvs_gclear_all:n { #1 }
      \__bnvs_gput:nnn V { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \__bnvs_parse_record:nn { x, V }
\BNVS_new:cpn { parse_record:vn } {
  \BNVS_tl_use:nc {
    \__bnvs_parse_record:Vn
  }
}
\BNVS_new:cpn { n_parse_record:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { n_parse_record:n } { KEY } { #1 }
\BNVS_DEBUG_log_n_parse_record_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \bool_if:NTF \l__bnvs_n_provide_bool {
    \__bnvs_n_gprovide:nn
  } {
    \__bnvs_n_gput:nn
  }
  { #1 } { 1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_n:nn { ... } { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_n_parse_record:n { V }
\BNVS_new:cpn { n_parse_record:v } {
  \BNVS_tl_use:nc {
    \__bnvs_n_parse_record:V
  }
}
\BNVS_new:cpn { n_parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn
  { n_parse_record:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_n_parse_record_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_range_set:cccnTF { a } { b } { c } { #2 } {
    \__bnvs_error:n { Unexpected~range:~#2 }
  } {
    \__bnvs_if_provide:TF {
      \__bnvs_n_gprovide:nn { #1 } { #2 }
    } {
      \__bnvs_n_gput:nn { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_nn:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \__bnvs_n_parse_record:nn { x, V }
\BNVS_new:cpn { n_parse_record:vn } {
  \BNVS_tl_use:Nc \__bnvs_n_parse_record:Vn
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.test}{:N=\__bnvs_n_parse_record:nn, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \banner:n { #1 }
%   \assert_equal:xxn {\__bnvs_n_item:n {X} } {#1} {a}
% }
% \__bnvs_provide_on:
% \__bnvs_n_parse_record:nn {X} {A}
% \BNVS_DEBUG_log:n { 111 }
% {
%   \BNVS_set:cpn { error:n } #1 {
%     \cs_set:Npn \test_fail:n ##1 { }
%   }
%   \BNVS_DEBUG_log:n { 111 }
%   \__bnvs_n_parse_record:nn {X} {A::C}
% }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \__bnvs_name_id_n_get:n,
%   \__bnvs_name_id_n_get:v,
% }
% \begin{syntax}
% \cs{__bnvs_name_id_n_set:nTF} \marg{key} \marg{ yes code} \marg{ no code}
% \end{syntax}
% If the \meta{key} is a key, put the name it defines into the |key| |tl| variable,
% the frame id in the |id| |tl| variable, then
% execute \meta{yes code}.
% The |n| |tl| variable is empty except when \meta{key} ends with \texttt{.n}.
% Otherwise execute \meta{no code}.
% If \meta{key} does not contain a frame id,
% then |key| is prepended with
% then |id_last| and |id| is set to this value as well.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { name_id_n_end_export: } {
  \cs_set:Npn \BNVS:nnn ##1 ##2 ##3 {
    \BNVS_end:
    \__bnvs_tl_set:cn { key } { ##1 }
    \__bnvs_tl_set:cn { id } { ##2 }
    \__bnvs_tl_set:cn { n } { ##3 }
  }
  \__bnvs_tl_if_empty:cTF { id } {
    \BNVS_exp_args:Nvvv
    \BNVS:nnn { key } { id_last } { n }
    \__bnvs_tl_put_left:cv { key } { id_last }
  } {
    \BNVS_exp_args:Nvvv
    \BNVS:nnn { key } { id } { n }
    \__bnvs_tl_set:cv { id_last } { id }
  }
}
\BNVS_new_conditional:cpnn { name_id_n_get:n } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { name_id_n_get:n } { 
  \BNVS_DEBUG_log_arg:nn { IN } { #1 }
  \BNVS_DEBUG_tl:c { key }
  \BNVS_DEBUG_tl:c { id }
  \BNVS_DEBUG_tl:c { n }
  \BNVS_DEBUG_tl:c { id_last }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_match_once:NnTF \c__bnvs_TEST_A_key_n_Z_regex { #1 } {
    \__bnvs_match_pop_left:cTF { key } {
      \__bnvs_match_pop_left:cTF { key } {
        \__bnvs_match_pop_left:cTF { id } {
          \__bnvs_match_pop_left:cTF { n } {
            \__bnvs_name_id_n_end_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_name_id_n_get_n:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_end:
            \__bnvs_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/n }
            \prg_return_false:
          }
        } {
          \BNVS_end:
          \__bnvs_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/id }
          \prg_return_false:
        }
      } {
        \BNVS_end:
        \__bnvs_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/name }
        \prg_return_false:
      }      
    } {
      \BNVS_end:
      \__bnvs_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/n }
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_name_id_n_get_n:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { name_id_n_get:v } #1 { T, F, TF } {
  \BNVS_tl_use:nv { \BNVS_use:c { name_id_n_get:nTF } } { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\__bnvs_name_id_n_get:nTF, noigre, noigre}
% \__bnvs_match_once:NnTF \c__bnvs_TEST_A_key_n_Z_regex { ?!X } { } { }
% \__bnvs_name_id_n_get:nTF { ?!X } { } { }
% \cs_set:Npn \BNVS_Test:nnnnnn #1 #2 #3 #4 #5 #6 {
%   \banner:n { #6 }
%   \tl_if_empty:nTF { #2 } {
%     \__bnvs_name_id_n_get:nT { #1 } {
%       \test_fail:n { FAIL }
%     }
%   } {
%     \__bnvs_name_id_n_get:nTF { #1 } {
%       \assert_equal_tl:vnn { key } { #2 } { #6-name }
%       \assert_equal_tl:vnn { id } { #3 } { #6-id }
%       \assert_equal_tl:vnn { n } { #4 } { #6-n }
%       \assert_equal_tl:vnn { id_last } { #5 } { #6-last }
%     } {
%       \test_fail:n { FAIL(bis) }
%     }
%   }
% }
% \BNVS_Test:nnnnnn { X    } { ?!X  } { ?! }  { } { ?! } { 1 }
% \BNVS_Test:nnnnnn { X.1  } { ?!X.1 } { ?! } { } { ?! } { 2 }
% \BNVS_Test:nnnnnn { F!X  } { F!X } { F!  } { } { F! } { 3 }
% \BNVS_Test:nnnnnn { X    } { F!X } { F!  } { } { F! } { 4 }
% \BNVS_Test:nnnnnn { X!X  } { X!X } { X!  } { } { X! } { 5 }
% \BNVS_Test:nnnnnn { Y!X.1 } { Y!X.1 } { Y! } { } { Y! } { 6 }
% \BNVS_Test:nnnnnn { Y!X.n } { Y!X } { Y! } { .n } { Y! } { 7 }
% \BNVS_Test:nnnnnn { Y!X.1.n } { Y!X.1 } { Y! } { .n } { Y! } { 8 }
% \BNVS_Test:nnnnnn { ?!!X.1 } { } { } { } { } { 9 }
% \cs_undefine:N \BNVS_Test:nnnnnn
% \end{bnvs.test}
%
% \begin{function}{\__bnvs_parse:n, \__bnvs_parse:nn}
%   \begin{syntax}
%     \cs{__bnvs_parse:n} \marg{key}
%     \cs{__bnvs_parse:nn} \marg{key} \marg{definition}
%   \end{syntax}
% Auxiliary functions called within a group by |\keyval_parse:nnn|.
% \meta{key} is the overlay reference key, 
% including eventually a dotted path and a frame identifier,
% \meta{definition} is the corresponding definition.
% \begin{variable}{\l__bnvs_match_seq}
% Local storage for the match result.
% \end{variable}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { parse:n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \peek_remove_spaces:n {
    \peek_catcode:NTF \c_group_begin_token {
      \__bnvs_tl_if_empty:cTF { root } {
        \__bnvs_error:n { Unexpected~list~at~top~level. }
      }
      \BNVS_begin:
      \__bnvs_int_incr:c { }
      \__bnvs_tl_set:cx { root } { \__bnvs_int_use:c { } . }
      \cs_set:Npn \bnvs:nw ####1 ####2 \s_stop {
        \regex_match:nnT { \S* } { ####2 } {
          \__bnvs_error:n { Unexpected~####2 }
        }
        \keyval_parse:nnn {
          \__bnvs_parse:n
        } {
          \__bnvs_parse:nn
        } { ####1 }
        \BNVS_end:
      }
      \bnvs:nw
    } {
      \__bnvs_tl_if_empty:cTF { root } {
        \__bnvs_name_id_n_get:nTF { #1 } {
          \__bnvs_tl_if_empty:cTF { n } {
            \__bnvs_parse_record:v
          } {
            \__bnvs_n_parse_record:v
          }
          { key }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...COMPLETE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        } {
          \__bnvs_error:n { Unexpected~key:~#1 }
        }
      } {
        \__bnvs_int_incr:c { }
        \__bnvs_tl_if_empty:cTF { n } {
          \__bnvs_parse_record:xn
        } {
          \__bnvs_n_parse_record:xn
        } {
          \__bnvs_tl_use:c { root } . \__bnvs_int_use:c { }
        } { #1 }
      }
      \use_none_delimit_by_s_stop:w
    }
  }
  #1 \s_stop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_parse:n, noigre}
% \__bnvs_provide_off:
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn V { ?!#1 } } { #2 } { #1 }
% }
% \__bnvs_parse_record:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \__bnvs_gclear:n { ?!X }
% \__bnvs_parse:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \__bnvs_gput:nnn V { ?!Y } { 2 }
% \BNVS_Test:nn { Y } { 2 }
% \__bnvs_parse:n { ?!Y }
% \BNVS_Test:nn { Y } { 1 }
% \__bnvs_gput:nnn V { ?!Z } { 2 }
% \BNVS_Test:nn { Z } { 2 }
% \__bnvs_provide_on:
% \__bnvs_parse:n { ?!Z }
% \BNVS_Test:nn { Z } { 2 }
% \end{bnvs.test}
%
%    \begin{macrocode}
\BNVS_new:cpn { do_range:nnnn } #1 #2 #3 #4 {
    \__bnvs_gclear_all:n { #1 }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_range:nnnn, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn A {#1} } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } {#8~A }
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn Z {#1} } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } {#8~Z }
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn L {#1} } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } {#8~L }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \__bnvs_provide_off:
%   \__bnvs_range:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \__bnvs_provide_on:
%   \__bnvs_range:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \__bnvs_range:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \__bnvs_range:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \__bnvs_range:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=range:nvvv, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \assert_equal:xxn { \__bnvs_item:nn A { #1 } } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } { #8/A }
%   \assert_equal:xxn { \__bnvs_item:nn Z { #1 } } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } { #8/Z }
%   \assert_equal:xxn { \__bnvs_item:nn L { #1 } } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } { #8/L }
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \__bnvs_tl_set:cn { TEST_A } { #2 }
%   \__bnvs_tl_set:cn { TEST_B } { #3 }
%   \__bnvs_tl_set:cn { TEST_C } { #4 }
%   \__bnvs_range:nvvv  { #1 } { TEST_A } { TEST_B } { TEST_C }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \__bnvs_provide_off:
%   \BNVS_Test:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \__bnvs_provide_on:
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \BNVS_Test:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \BNVS_Test:nnnnnnn
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { do_range:nnnn } {
  \BNVS_DEBUG_log_arg:nn { KEY } { #1 }
  \BNVS_DEBUG_log_arg:nn { FIRST } { #2 }
  \BNVS_DEBUG_log_arg:nn { LAST } { #3 }
  \BNVS_DEBUG_log_arg:nn { LENGTH } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_do_range_nnnn:nn {  } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #4 } {
    \tl_if_empty:nTF { #2 } {
      \tl_if_empty:nTF { #3 } {
        \__bnvs_error:n { Not~a~range:~:~#1 }
      } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn V { #1 } { \q_nil }
      }
    } {
      \__bnvs_gput:nnn A { #1 } { #2 }
      \__bnvs_gput:nnn V { #1 } { \q_nil }
      \tl_if_empty:nF { #3 } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn L { #1 } { \q_nil }
      }
    }
  } {
    \tl_if_empty:nTF { #2 } {
      \__bnvs_gput:nnn L { #1 } { #4 }
      \tl_if_empty:nF { #3 } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn A { #1 } { \q_nil }
        \__bnvs_gput:nnn V { #1 } { \q_nil }
      }
    } {
      \__bnvs_gput:nnn A { #1 } { #2 }
      \__bnvs_gput:nnn L { #1 } { #4 }
      \__bnvs_gput:nnn Z { #1 } { \q_nil }
      \__bnvs_gput:nnn V { #1 } { \q_nil }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_do_range_nnnn:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_new:Npn \BNVS_exp_args:NNcv #1 #2 #3 #4 {
  \BNVS_tl_use:nc { \exp_args:NNnV #1 #2 { #3 } }
    { #4 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_exp_args:NNcv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \cs_set:Npn \BNVS_Test:cnn  #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { #2 } {
%     \test_fail:n { #3 }
%   }
% }
% \BNVS_exp_args:NNcv \relax \BNVS_Test:cnn { A } { TEST_A } { A }
% \cs_undefine:N \BNVS_Test:cnn
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_set:cv #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end: \__bnvs_tl_set:cn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn { parse:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_tl_set:cn { a } { #1 }
  \__bnvs_tl_put_left:cv { a } { root }
  \__bnvs_name_id_n_get:vTF { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \regex_match:nnTF { \S } { #2 } {
      \peek_remove_spaces:n {
        \peek_catcode:NTF \c_group_begin_token {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The value is a comma separated list, go recursive.
% But before we warn about an unexpected \texttt{.n} suffix, if any.
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/list}, noigre}
%   \__bnvs_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_get:nncF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%     }
%   }
%   \__bnvs_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_get:nncT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%     }
%   }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \__bnvs_tl_if_empty:cF { n } {
\__bnvs_warning:n { Ignoring~unexpected~suffix~.n:~#1 }
          }
          \BNVS_begin:
          \__bnvs_tl_set:cv { root } { key }
          \int_set:Nn \l__bnvs_int { 0 }
          \cs_set:Npn \BNVS:nn ##1 ##2 \s_stop {
            \regex_match:nnT { \S } { ##2 } {
              \__bnvs_error:n { Unexpected~value~#2 }
            }
            \keyval_parse:nnn {
              \__bnvs_parse:n
            } {
              \__bnvs_parse:nn
            } { ##1 }
            \BNVS_end:
          }
          \BNVS:nn
        } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/KEY=VALUE}, noigre, noigre}
% \__bnvs_parse:nn { X } { FIRST: }
% \__bnvs_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \__bnvs_parse:nn { X } { FIRST::LENGTH }
% \__bnvs_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \BNVS_DEBUG_log_gprop:n { 100 }
% \__bnvs_get:nncTF L { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LENGTH } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/L }
% }
% \__bnvs_parse:nn { X } { FIRST:LAST }
% \__bnvs_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \__bnvs_get:nncTF Z { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LAST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/Z }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \__bnvs_tl_if_empty:cTF { n } {
            \__bnvs_parse_record:vn
          } {
            \__bnvs_n_parse_record:vn
          }
          { key } { #2 }
          \use_none_delimit_by_s_stop:w
        }
      }
      #2 \s_stop
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Empty value given: remove the reference.
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/empty~value}, noigre}
%   \__bnvs_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_get:nncF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%    }
%  }
%   \__bnvs_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_get:nncT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%    }
%  }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/1... }
\BNVS_DEBUG_log_tl:c { key }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_tl_if_empty:cTF { n } {
        \__bnvs_gclear:v
      } {
        \__bnvs_n_gremove:v
      }
      { key }
    }
  } {
    \__bnvs_error:n { Invalid~key:~#2 }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/2... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_end_tl_set:cv { id_last } { id_last }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\__bnvs_parse_prepare:N, noigre}
% \__bnvs_tl_set:cn { a } {A[B]C}
% \__bnvs_parse_prepare:N \l__bnvs_a_tl
% \assert_equal:xxn { \tl_to_str:V \l__bnvs_a_tl } { \tl_to_str:n { A {{B}} C } } {1}
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_prepare:N } #1 {
  \tl_set:Nx #1 #1
  \bool_set_false:N \l__bnvs_parse_bool
  \bool_do_until:Nn \l__bnvs_parse_bool {
    \tl_if_in:NnTF #1 {%---[
    ]} {
      \regex_replace_all:nnNF { \[ ([^\]%---)
      ]*%---[(
      ) \] } { { { \1 } } } #1 {
        \bool_set_true:N \l__bnvs_parse_bool
      }
    } {
      \bool_set_true:N \l__bnvs_parse_bool
    }
  }
  \tl_if_in:NnTF #1 {%---[
  ]} {
    \__bnvs_error:n { Unbalanced~%---[
    ]}
  } {
    \tl_if_in:NnT #1 { [%---]
    } {
      \__bnvs_error:n { Unbalanced~[ %---]
      }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{
%   bnvs:cn={parse:nn}{/+\token_to_str:N\__bnvs_item:n}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \__bnvs_provide_off:
%   \banner:n { #5 }
%   \__bnvs_parse:nn {X} {#1}
%   \assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a}
%   \assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#3} {#5-c}
%   \assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#4} {#5-b}
%   \__bnvs_provide_on:
%   \clist_map_inline:nn {D, D:E, D::F, :E::F} {
%     \__bnvs_parse:nn {X} { ##1 }
%     \assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a(##1)}
%     \assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#3} {#5-c(##1)}
%     \assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#4} {#5-b(##1)}
%  }
% }
% \BNVS_Test:nnnnn {A:   } {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B  } {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C } {A} { \exp_not:N \q_nil } {C} {3}
% \BNVS_Test:nnnnn {:B::C} { \exp_not:N \q_nil } {B} {C} {4}
% \end{bnvs.test}
% \begin{bnvs.test}{
%   bnvs:cn={parse:nn}{+\cs{__bnvs_item:n}}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_parse:nn {X.1.2} {#1}
%   \assert_equal:xxn {\__bnvs_item:nn A {?!X.1.2} } {#2} {#5-A}
%   \assert_equal:xxn {\__bnvs_item:nn Z {?!X.1.2} } {#3} {#5-Z}
%   \assert_equal:xxn {\__bnvs_item:nn L {?!X.1.2} } {#4} {#5-L}
% }
% \BNVS_Test:nnnnn {A:} {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B} {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C} {A} { \exp_not:N \q_nil } {C} {3}
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={parse:n}{/:nn}, noigre}
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_if_in:nnTF A {?!X.#5} {
%     \assert_equal:xxn {\__bnvs_item:nn A {?!X.#5} } {#1} {#4-a}
%     \assert_equal:xxn {\__bnvs_item:nn Z {?!X.#5} } {#2} {#4-b}
%     \assert_equal:xxn {\__bnvs_item:nn L {?!X.#5} } {#3} {#4-c}
%   } {
%     \__bnvs_if_in:nnTF V {?!X.#5} {
%       \assert_equal:xxn {\__bnvs_item:nn V {?!X.#5} } {#1} {#4-v}
%     } {
%       \test_fail:n {#4-F}
%     }
%   }
% }
% \__bnvs_parse:nn {X.3} {::C:B}
% \__bnvs_parse:nn {X.3} {{A:,A:B,A::C,:B::C,::C:B, D}}
% \BNVS_Test:nnnnn {A} {} {} {4-1} {3.1}
% \BNVS_Test:nnnnn {A} {B} { \exp_not:N \q_nil } {4-2} {3.2}
% \BNVS_Test:nnnnn {A} { \exp_not:N \q_nil } {C} {4-3} {3.3}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-4} {3.4}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-5} {3.5}
% \BNVS_Test:nnnnn {D} {} {} {4-6} {3.6}
% \cs_undefine:N \BNVS_Test:nnnnn
% \end{bnvs.test}
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key--value list}
%   \end{syntax}
%   The keys are the slide overlay references.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{key--value} items are parsed by \cs{__bnvs_parse:nn}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_put_right:cv #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_v_gput:nc #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_v_gput:nn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { \token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_arg:nn { IN } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_gput_right:Nn \g__bnvs_def_seq { #2 }
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, clear everything.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_gclear:
    }
    \BNVS_begin:
    \__bnvs_tl_clear:c { root }
    \int_zero:N \l__bnvs_int
    \__bnvs_tl_set:cn { a } { #2 }
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, use the global definitions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \seq_if_empty:NF \g__bnvs_def_seq {
        \__bnvs_tl_put_left:cx { a } {
          \seq_use:Nn \g__bnvs_def_seq , ,
        }
      }
    }
    \__bnvs_parse_prepare:N \l__bnvs_a_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ...\token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \IfBooleanTF {#1} {
      \__bnvs_provide_on:
    } {
      \__bnvs_provide_off:
    }
    \BNVS_tl_use:nv {
      \keyval_parse:nnn { \__bnvs_parse:n } { \__bnvs_parse:nn }
    } { a }
    \BNVS_end_tl_set:cv { id_last } { id_last }
    \ignorespaces
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\beamer@frame, \beamer@masterdecode}
% \begin{syntax}
% \cs{beamer@frame} \marg{overlay specification}
% \cs{beamer@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} reads it.
% \begin{variable}{\l__bnvs_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% Save the original macro \cs{beamer@masterdecode} and then override it
% to properly preprocess the argument.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set_eq:NN \__bnvs_beamer@frame \beamer@frame
\cs_set:Npn \beamer@frame < #1 > {
  \BNVS_begin:
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_eval:nc { ans }
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_beamer@frame <
  } { ans } >
}
\cs_set_eq:NN \__bnvs_beamer@masterdecode \beamer@masterdecode
\cs_set:Npn \beamer@masterdecode #1 {
  \BNVS_begin:
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_eval:nc { ans }
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_beamer@masterdecode
  } { ans }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_scan:nNc}
% \begin{syntax}
% \cs{__bnvs_scan:nNc} \marg{named overlay expression} \meta{eval} \meta{tl core}
% \end{syntax}
% Scan the \meta{named overlay expression} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from the \meta{eval} function, which is \cs{__bnvs_eval:nN}.
% A group is created to use local variables:
% \begin{variable}{\l__bnvs_ans_tl}
% The token list that will be appended to \meta{tl variable} on return.
% \end{variable}
% \begin{variable}{\l__bnvs_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l__bnvs_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l__bnvs_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l__bnvs_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
% Next are helpers.
% \begin{function}{
%   \__bnvs_scan_question:T
% }
% \begin{syntax}
% \cs{__bnvs_scan_question:T} \marg{code}
% \end{syntax}
% At top level state, scan the tokens of the
% \meta{named overlay expression} looking for a `|?|' character.
% If a `|?(...)|' is found, then the \meta{code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { scan_question:T } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_question:T } { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccT { token } { token } {
    \__bnvs_tl_if_eq:cnTF { token } { ? } {
      \__bnvs_scan_require_open:
      #1
    } {
      \__bnvs_tl_put_right:cv { ans } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}    }
    }
    \__bnvs_scan_question:T { #1 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \__bnvs_scan_require_open:
% }
% \begin{syntax}
% \cs{require_open:}
% \end{syntax}
% We just found a `|?|',
% we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
% \end{function}
%    \begin{macrocode}
\BNVS_new:cpn { scan_require_open: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_require_open: } { }
%</!final>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \tl_if_eq:NnTF \l__bnvs_token_tl { ( %)
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Set the parenthesis depth to 1 (on first passage).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_int_set:cn { } { 1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Record the forthcomming content in
% the \cs{l__bnvs_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_tl_clear:c { query }
        \__bnvs_scan_require_close:
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Ignore this token and loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_scan_require_open:
      }
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% End reached but no opening parenthesis found, raise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \__bnvs_fatal:x {Missing~'('%---)
      ~after~a~? }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \__bnvs_scan_require_close:
% }
% \begin{syntax}
% \cs{require_close:}
% \end{syntax}
% We found a `|?(|', we record the forthcomming content in the |query| variable,
% up to the next balancing `|)|`.
% \end{function}
%    \begin{macrocode}
\BNVS_new:cpn { scan_require_close: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_require_close: } { }
%</!final>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \__bnvs_tl_if_eq:cnTF { token } { ( %---)
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to |query|,
% then scan again for a^^A---(
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_int_incr:c { }
      \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_scan_require_close:
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is not a `|(|'.^^A---)
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_tl_if_eq:cnTF { token } { %(---
        )
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a balancing ^^A(---
% `|)|', we decrement and test the depth.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_int_decr:c {}
        \int_compare:nNnTF { \__bnvs_int_use:c {} } = 0 {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to |ans|
% and look for the next |?|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to |query| because it is not yet the
% end of sequence marker.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_scan_require_close:
        }
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to |query|
% and look for a balancing^^A(---
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_scan_require_close:
      }
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Above ends the code for Not a  `|(|'. ^^A---)
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and terminate.
% As recovery we feed |query| with the missing ^^A(---
% `|)|'.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \__bnvs_error:x { Missing~%(---
      `)' }
    \__bnvs_tl_put_right:cx { query } {
      \prg_replicate:nn { \l__bnvs_int } {%(---
      )}
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c={scan:nNc}, noigre}
% \cs_set:Npn \BNVS_TEST_eval:nc #1 #2 {
%   \__bnvs_tl_put_right:cn { #2 } { !(#1) }
% }
% \__bnvs_tl_clear:c { a }
% \__bnvs_scan:nNc {1+1} \BNVS_TEST_eval:nc { a }
% \__bnvs_scan:nNc {?(A)} \BNVS_TEST_eval:nc { a }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \banner:n { Test:~scan/#3/#1/}
%   \__bnvs_tl_clear:c { a }
%   \__bnvs_scan:nNc { #1 } \BNVS_TEST_eval:nc { a }
%   \assert_equal_tl:vnn { a } { #2 } { #3 }
% }
% \BNVS_Test:nnn {} {} {1}
% \BNVS_Test:nnn {1+1} {1+1} {2}
% \BNVS_Test:nnn {1?(+)1} {1!(+)1} {3}
% \BNVS_Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \cs_undefine:N \BNVS_TEST_eval:nc
% \cs_undefine:N \BNVS_Test:nnn
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { scan:nNc } #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { scan:nNc } {
  \BNVS_DEBUG_log_arg:nn { WHAT } { #1 }
  \BNVS_DEBUG_log_cs:nN { CMD } #2
  \BNVS_DEBUG_log_arg:nc { IN } { #3 }
}
\BNVS_DEBUG_log_scan_nNc:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_set:cpn { fatal:x } ##1 {
    \msg_fatal:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \BNVS_set:cpn { error:x } ##1 {
    \msg_error:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \__bnvs_tl_set:cn { scan } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_seq_clear:c { token }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Explode the \meta{named overlay expression} into a list of individual tokens:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:nnN { } { #1 } \l__bnvs_token_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Run the top level loop to scan for a `|?|' character:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_scan_question:T {
    \BNVS_tl_use:Nv #2 { query } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
\BNVS_DEBUG_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #3 }
  } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_scan_nNc:nn { ... } { ...DONE }
\BNVS_DEBUG_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Resolution}
%
% Given a name, a frame id and an integer path,
% we resolve any intermediate standalone reference.
% For example, with |A=B| and |B=C|, |A| is resolved in |C|.
% But with |A=B+1| and |B=C|, |A| is not resolved in |C+1|.
% With |A=B:D| and |B=C|, |A| is not resolved in |C:D| as well.
%
% \begin{function}[TF]{
%   \__bnvs_kip:ccc
% }
% \begin{syntax}
% \cs{__bnvs_kip:cccTF} \marg{key} \marg{id} \marg{path} \marg{yes code} \marg{no code}
% \end{syntax}
% Auxiliary function. On input,
% the \meta{key} tl variable contains a set name whereas
% the \meta{id} tl variable contains a frame id.
% If \meta{key} tl variable contents is a recorded key, on return,
% \meta{key} tl variable contains the resolved name,
% \meta{id} tl variable contains the used frame id,
% \meta{path} seq variable is prepended with new dotted path components,
% \meta{yes code} is executed, otherwise \meta{no code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVx }
\quark_new:N \q__bnvs
\BNVS_new:cpn { end_kip_export_seq:nnnccc } #1 #2 #3 #4 #5 #6 {
  \BNVS_end:
  \tl_if_empty:nTF { #2 } {
    \__bnvs_tl_set:cn { #4 } { #1 }
    \__bnvs_tl_put_left:cv { #4 } { #5 }
  } {
    \__bnvs_tl_set:cn { #4 } { #1 }
    \__bnvs_tl_set:cn { #5 } { #2 }
  }
  \__bnvs_seq_set_split:cnn { #6 } { \q__bnvs } { #3 }
  \__bnvs_seq_remove_all:cn { #6 } { }
}
\BNVS_new:cpn { end_kip_export:ccc } {
  \exp_args:Nnnx \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_end_kip_export_seq:nnnccc { key }
  } { id } {
    \__bnvs_seq_use:cn { path } { \q__bnvs }
  }
}
\BNVS_new_conditional:cpnn { match_pop_kip: } { T, F, TF } {
  \__bnvs_match_pop_left:cTF { key } {
    \__bnvs_match_pop_left:cTF { key } {
      \__bnvs_match_pop_left:cTF { id } {
        \__bnvs_match_pop_left:cTF { path } {
          \__bnvs_seq_set_split:cnv { path } { . } { path }
          \__bnvs_seq_remove_all:cn { path } { }
          \prg_return_true:
        } {
          \prg_return_false:
        }
      } {
        \prg_return_false:
      }
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { kip:ccc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { kip:ccc } {
  \BNVS_DEBUG_log_tl:c  { #1 }
  \BNVS_DEBUG_log_tl:c  { #2 }
  \BNVS_DEBUG_log_seq:c { #3 }
}
\BNVS_DEBUG_log_kip_ccc:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_match_once:NvTF \c__bnvs_A_key_Z_regex { #1 }  {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a correct key, update the path sequence accordingly.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \__bnvs_match_pop_kip:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn { } {...ID...}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_end_kip_export:ccc { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...TRUE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...UNREACHABLE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...FALSE/NOT~A~KEY}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_kip_n_path_resolve:,
%   \__bnvs_kip_x_path_resolve:,
% }
% \begin{syntax}
% \cs{__bnvs_kip_n_path_resolve:TF} \marg{yes code} \marg{no code}
% \cs{__bnvs_kip_x_path_resolve:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% \marg{yes code} will be executed once resolution has occurred,
% \marg{no code} otherwise.
% The |key| and |id| variables as well as the |path| sequence
% are meant to contain proper information on input and on output as well.
% On input, |\l__bnvs_key_tl| contains a slide range name, 
% |\l__bnvs_id_tl| contains a frame id and
% |\l__bnvs_path_seq| contains the components of an integer path, possibly empty.
% On return, the variable |\l__bnvs_key_tl| contains the resolved range name,
% |\l__bnvs_id_tl| contains the frame id used and
% |\l__bnvs_path_seq| contains the sequence of integer path components that could not be resolved.
%
% To resolve one level of a named one slide specification like
% \meta{qualified name}.\meta{i_1}...\meta{i_n},
% we replace the shortest \meta{qualified name}.\meta{i_1}...\meta{i_k}
% where 0$≤$k$≤$n by its definition \meta{qualified name'}.\meta{j_1}...\meta{j_p}
% if any. The \cs{__bnvs_resolve_?:NNNTF} function uses this one level resolution
% as many times as possible, but no more than a predefined limit to catch
% circular reference that would lead to an infinite loop.
%
% \begin{enumerate}
% \item If |\l__bnvs_key_tl| content is the name of an unlimited range,
% and the first item of this range is exactly another name range with
% eventually a heading frame identifier or a trailing integer path,
% then |\l__bnvs_key_tl| is replaced by this name, the |\l__bnvs_id_tl|
% and |\l__bnvs_id_tl| are updates accordingly and
% the \meta{path seq var} is prepended with the integer path.
% \item If \meta{path seq var} is not empty,
% append to the right of |\l__bnvs_key_tl| after a separating dot,
% all its left elements but the last one and loop.
% Otherwise return.
%
% In the |_n| variant, the resolution is driven only when there is a non empty
% dotted path.
%
% In the |_x| variant, the resolution is driven one step further:
% if \meta{path seq var} is empty, \meta{name tl var} can contain anything,
% including an integer for example.
% \end{enumerate}
% \end{function}
% \begin{function}{
%   \__bnvs_kip_x_path_resolve:TFF
% }
% \begin{syntax}
% \cs{__bnvs_kip_x_path_resolve:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{bnvs.test}{bnvs:c={kip_n_path_resolve:TF}, noigre}
% \Test_path_resolve_n:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_path_resolve_n:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_path_resolve_n:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \Test_path_resolve_n:nnnnnn { X=Y,Y } { X } { } { X } { } { 1B }
% \Test_path_resolve_n:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \Test_path_resolve_n:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_path_resolve_n:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_path_resolve_n:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_path_resolve_n:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_path_resolve_n:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \Test_path_resolve_n:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_path_resolve_n:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B }
% \Test_path_resolve_n:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C }
% \Test_path_resolve_n:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D }
% \Test_path_resolve_n:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H }
% \Test_path_resolve_n:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2 }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_path_resolve_n:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L }
% \Test_path_resolve_n:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A }
% \Test_path_resolve_n:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A' }
% \end{bnvs.test}
%
% \begin{bnvs.test}{bnvs:c={kip_x_path_resolve:TF}, noigre}
% \Test_x_path_resolve:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y=12 } { X } { 1 } { 12 } { } { 1C' }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y=123 } { X } { 1.2 } { 123 } { } { 2C }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2 = 1234 } { X } { 1.2 } { 1234 } { } { 3C }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3=12 } { X } { 1.2.3 } { 12 } { } { 5C }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 6C }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2.3.4=Z, Z = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7A }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2.3=Z, Z.4 = 123 } { X } { 1.2.3.4 } { 123 } { } { 7B }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2=Z, Z.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 7C }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1=Z, Z.2.3.4 = 234} { X } { 1.2.3.4 } { 234 } { } { 7D }
% \Test_x_path_resolve:nnnnnn { X=Y, Y=Z,Z.1.2.3.4 = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7D }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7E }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2.3=Z, Z.4=4 } { X } { 1.2.3.4 } { 4 } { } { 7F }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7G }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y=Z, Z.2.3.4 = 234 } { X } { 1.2.3.4 } { 234 } { } { 7H }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7I1 }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { 123 } { } { 7I2 }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3=Z, Z.4 = 4, } { X } { 1.2.3.4 } { 4 } { } { 7J }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7K }
% \Test_x_path_resolve:nnnnnn { X.1.2.3=Y, X.1.2=Z, Y.4=4 } { X } { 1.2.3.4 } { 4 } { } { 8A }
% \Test_x_path_resolve:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Z } { } { 9A }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_x_path_resolve:TFF } #1 #2 {
  \__bnvs_kip_x_path_resolve:TF {
    \__bnvs_seq_if_empty:cTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_a_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_kip_export: } {
  \exp_args:Nnnx
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_end_kip_export_seq:nnnccc { key }
  } { id } {
    \__bnvs_seq_use:cn { path } { \q__bnvs }
  } { key } { id } { path }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { seq_merge:cc } #1 #2 {
  \__bnvs_seq_if_empty:cF { #2 } {
    \__bnvs_seq_set_split:cnx { #1 } { \q__bnvs } {
      \__bnvs_seq_use:cn { #1 } { \q__bnvs }
      \exp_not:n { \q__bnvs }
      \__bnvs_seq_use:cn { #2 } { \q__bnvs } 
    }
    \__bnvs_seq_remove_all:cn { #1 } { }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_x_path_resolve:nFF } #1 #2 #3 {
  \__bnvs_get:nvcTF #1 { a } { b } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_kip:cccTF { b } { id } { path } {
      \__bnvs_tl_set_eq:cc { key } { b }
      \__bnvs_seq_merge:cc { path } { b }
      \__bnvs_seq_clear:c { b }
      \__bnvs_seq_set_eq:cc { a } { path }
      \__bnvs_kip_x_path_resolve_loop_or_end_return:
    } {
      \__bnvs_seq_if_empty:cTF { b } {
        \__bnvs_tl_set_eq:cc { key } { b }
        \__bnvs_seq_clear:c { path }
        \__bnvs_seq_clear:c { a }
        \__bnvs_kip_x_path_resolve_loop_or_end_return:
      } {
        #2
      }
    }
  } {
    #3
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_x_path_resolve_VAL_loop_or_end_return:F } #1 {
  \__bnvs_kip_x_path_resolve:nFF V { #1 } {
    \__bnvs_kip_x_path_resolve:nFF A { #1 } {
      \__bnvs_kip_x_path_resolve:nFF L { #1 } { #1 }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_x_path_resolve_end_return_true: } {
  \__bnvs_seq_pop_left:ccTF { path } { a } {
    \__bnvs_seq_if_empty:cTF { path } {
      \__bnvs_tl_clear:c { b }
      \__bnvs_index_can:vTF { key } {
        \__bnvs_index_append:vvcTF { key } { a } { b } {
          \__bnvs_tl_set:cv { key } { b }
        } {
          \__bnvs_tl_set:cv { key } { a }
        }
      } {
        \__bnvs_tl_set:cv { key } { a }
      }
    } {
      \__bnvs_error:x { Path~too~long~.\BNVS_tl_use:c { a }
        .\__bnvs_seq_use:cn { path } . }
    }
  } {
    \__bnvs_value_resolve:vcT { key } { key } {}
  }
  \__bnvs_end_kip_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { kip_x_path_resolve: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { kip_x_path_resolve:TF } {
  \BNVS_DEBUG_log_tl:c { key }
  \BNVS_DEBUG_log_tl:c { id }
  \BNVS_DEBUG_log_seq:c { path }
}
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_seq_set_eq:cc { a } { path }
  \__bnvs_seq_clear:c { b }
  \__bnvs_kip_x_path_resolve_loop_or_end_return:
}
\BNVS_new:cpn { kip_x_path_resolve_loop_or_end_return: } {
  \__bnvs_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... }  { ...LOOP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_tl_set_eq:cc { a } { key }
    \__bnvs_seq_if_empty:cTF { a } {
      \__bnvs_kip_x_path_resolve_VAL_loop_or_end_return:F {
        \__bnvs_kip_x_path_resolve_end_return_true:
      }
    } {
      \__bnvs_tl_put_right:cx { a } { . \__bnvs_seq_use:cn { a } . }
      \__bnvs_kip_x_path_resolve_VAL_loop_or_end_return:F {
        \__bnvs_seq_pop_right:ccT { a } { c } {
          \__bnvs_seq_put_left:cv { b } { c }
        }
        \__bnvs_kip_x_path_resolve_loop_or_end_return:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_n_path_resolve_or_end_return:nF } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get:nvcTF { #1 } { a } { b } {
    \__bnvs_kip:cccTF { b } { id } { path } {
      \__bnvs_tl_set_eq:cc { key } { b }
      \__bnvs_seq_merge:cc { path } { b }
      \__bnvs_seq_set_eq:cc { a } { path }
      \__bnvs_seq_clear:c { b }
      \__bnvs_kip_n_path_resolve_loop_or_end_return:
    } {
      \__bnvs_seq_pop_right:ccTF { a } { c } {
        \__bnvs_seq_put_left:cv { b } { c }
        \__bnvs_kip_n_path_resolve_loop_or_end_return:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...Unknown~key... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_kip_n_path_resolve_end_return_true:
      }
    }
  } {
    #2
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_n_path_resolve_VAL_loop_or_end_return: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...VAL... }
\BNVS_DEBUG_log_tl:c { b }
\BNVS_DEBUG_log_seq:c { b }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_kip_n_path_resolve_or_end_return:nF V {
    \__bnvs_kip_n_path_resolve_or_end_return:nF A {
      \__bnvs_kip_n_path_resolve_or_end_return:nF L {
        \__bnvs_seq_pop_right:ccTF { a } { c } {
          \__bnvs_seq_put_left:cv { b } { c }
          \__bnvs_kip_n_path_resolve_loop_or_end_return:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...Unknown~key... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_kip_n_path_resolve_end_return_true:
        }
      }
    }
  }
}
\BNVS_new:cpn { kip_n_path_resolve_end_return_false: } {
  \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_false:
}
\BNVS_new:cpn { kip_n_path_resolve_end_return_true: } {
  \__bnvs_end_kip_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
% \end{bnvs.macrocode}

% \begin{function}{
%   \__bnvs_kip_n_path_resolve_loop_or_end_return:
% }
% Loop to resolve the path.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_n_path_resolve_loop_or_end_return: } {
  \__bnvs_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...LOOP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_tl_set_eq:cc { a } { key }
    \__bnvs_seq_if_empty:cTF { a } {
      \__bnvs_seq_if_empty:cTF { b } {
        \__bnvs_kip_n_path_resolve_end_return_true:
      } {
        \__bnvs_kip_n_path_resolve_VAL_loop_or_end_return:
      }
    } {
      \__bnvs_tl_put_right:cx { a } { . \__bnvs_seq_use:cn { a } . }
      \__bnvs_kip_n_path_resolve_VAL_loop_or_end_return:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   __bnvs_kip_n_path_resolve:
% }
% This is the entry point to resolve the path.
% Local variables:
% \begin{itemize}
% \item \cs{...key_tl}, \cs{...id_tl}, \cs{...path_seq}
% contain the resolution.
% \item |...a_tl| contains the name with a partial index path currently resolved.
% \item \cs{...a_seq} contains the dotted path components to be resolved.
% It equals \cs{...path_seq} at the beginning 
% \item \cs{...b_seq} is used as well.
% Initially empty.
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { kip_n_path_resolve: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { kip_n_path_resolve:TF } {
  \BNVS_DEBUG_tl:c { key }
  \BNVS_DEBUG_tl:c { id   }
  \BNVS_DEBUG_log_seq:c { path }
}
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_seq_set_eq:cc { a } { path }
  \__bnvs_seq_clear:c { b }
  \__bnvs_kip_n_path_resolve_loop_or_end_return:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Evaluation bricks}
% We start by helpers.
% \begin{function}{
%  \__bnvs_round_ans:n,
%  \__bnvs_round:c,
%  \__bnvs_round_ans:
%}
% \begin{syntax}
% \cs{__bnvs_round:c} \meta{tl core name}
% \cs{__bnvs_round_ans:}
% \cs{__bnvs_round_ans:n} \marg{expression}
% \end{syntax}
% The first function replaces the variable content
% with its rounded floating point evaluation.
% The second function replaces |ans| tl variable content
% with its rounded floating point evaluation.
% The last function appends to the |ans| tl variable
% the rounded floating point evaluation of the argument.
% \end{function}
% \begin{bnvs.test}{bnvs:c={round_ans:n}, noigre}
% \banner:n {1}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_round_ans:n {11+(1)-111}
% \assert_equal_tl:vnn { ans } { -99 } { 1 }
% \__bnvs_round_ans:n { }
% \assert_equal_tl:vnn { ans } { -990 } { 2 }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=round:c, noigre}
% \banner:n {1}
% \__bnvs_tl_set:cn { a } {11+(1)-111}
% \__bnvs_round:c { a }
% \assert_equal:xxn { \l__bnvs_a_tl } { -99 } { 1 }
% \__bnvs_tl_clear:c { a }
% \__bnvs_round:c { a }
% \assert_equal_tl:vnn { a } { 0 } { 2 }
% \__bnvs_tl_set:cn { ans } {11+(1)-111}
% \__bnvs_round_ans:
% \assert_equal_tl:vnn { ans } { -99 } { 3 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round_ans:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { round_ans:n } { }
\BNVS_DEBUG_log_arg:nn { IN } { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #1 } {
    \__bnvs_tl_put_right:cn { ans } { 0 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { EMPTY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \__bnvs_tl_put_right:cx { ans } { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_tl:nc { OUT } { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:N } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { round:N } { }
\BNVS_DEBUG_log:x { \token_to_str:N #1 -> / \tl_to_str:V #1 / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF #1 {
    \tl_set:Nn #1 { 0 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n { EMPTY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \tl_set:Nx #1 { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { OUT -> / \tl_to_str:V #1 / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:c } {
  \BNVS_tl_use:Nc \__bnvs_round:N
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_end_return_false:
%   \BNVS_end_return_false:x
% }
% \begin{syntax}
% \cs{__bnvs_end_return_false:}
% \cs{__bnvs_end_return_false:x} \marg{message}
% \end{syntax}
% End a group and calls \cs{prg_return_false:}.
% The message is for debugging only.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false: {
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false:x #1 {
  \__bnvs_error:x { #1 }
  \BNVS_end_return_false:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_value_resolve:nc,
%   \__bnvs_value_resolve:vc,
%   \__bnvs_value_append:nc,
%   \__bnvs_value_append:xc,
%   \__bnvs_value_append:vc
% }
% \begin{syntax}
% \cs{__bnvs_value_resolve:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{__bnvs_value_append:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the content of the \meta{key} value counter
% into the \meta{tl variable} or
% append this value to the right of the variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% Inside the \meta{no code} branch,
% the content of the \meta{tl variable} is undefined.
% Implementation detail: we return the first in the cache for subkey V
% and in the general prop for subkey V.
% Once we have found a value, we feed the previous items
% such that the next search stops at the first item.
% The cache contains an integer which is the computed value from the general prop.
% A group is created while appending but not while resolving.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { value_resolve_return:nnnT } #1 #2 #3 #4 {
  \__bnvs_tl_if_empty:cTF { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_resolve_ncTF:nn { ... } { ...FALSE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } {
    \__bnvs_cache_gput:nnv V { #2 } { #3 }
    #4
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_resolve_ncTF:nn { ... } { ...TRUE/#1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_nil:c } #1 { T, F, TF } {
  \BNVS_tl_use:Nc \quark_if_nil:NTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_no_value:c } #1 { T, F, TF } {
  \BNVS_tl_use:Nc \quark_if_no_value:NTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { value_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { value_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_value_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF V { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_get:nncTF V { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We can retrieve the value from either the first or last index.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_gput:nnn V { #1 } { \q_no_value }
        \__bnvs_first_resolve:ncTF { #1 } { #2 } {
          \__bnvs_value_resolve_return:nnnT A { #1 } { #2 } {
            \__bnvs_gput:nnn V { #1 } { \q_nil }
          }
        } {
          \__bnvs_last_resolve:ncTF { #1 } { #2 } {
            \__bnvs_value_resolve_return:nnnT Z { #1 } { #2 } {
              \__bnvs_gput:nnn V { #1 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_resolve_ncTF:nn { ... } { ...FALSE/##1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn V { #1 } { \q_nil }
            \prg_return_false:
          }
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \__bnvs_fatal:n {Circular~definition:~#1}
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Possible recursive call.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_value_resolve_return:nnnT V { #1 } { #2 } {
              \__bnvs_gput:nnn V { #1 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_resolve_ncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn V { #1 } { \q_nil }
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BeanovesLogGProp
\BNVS_DEBUG_log_f:ncn { ... } { value_resolve:ncTF } { ...FALSE/RESOLVE }
\BNVS_DEBUG_log_arg:nnnc { UNKNOWN~KEY } { #1 } { IN } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { value_resolve:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_value_resolve:ncTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_put_right:vc } #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #2 }
  } { #1 }
}
\BNVS_new_conditional:cpnn { value_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { value_append:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_value_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_value_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_value_append_ncTF:nn { ... } { ...TRUE(FAILED) }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { value_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c=value_append:ncTF, noigre}
% \Test_what_append_X_ncTF:nnnn { value } { 222 } { 222 } { 1 }
% \reset:n { YES }
% \BNVS_DEBUG_log_gprop:n { }
% \BNVS_DEBUG_tl:c { ans }
% \__bnvs_if_resolve:ncF { FIRST } { ans } {
%   \assert_equal_ans{ ans }
% \Test_what_append_X_:nn { 222 } { NO~WAY }
% }
% \__bnvs_tl_clear:c ncTF:nnnn { value } { FIRST } { 222 } { 2 }
% \cs_new:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_value_resolve:ncTF { X } { ans } {
%     \assert_equal_tl:vnn { ans } { #1 } { #2/A }
%     \__bnvs_cache_get:nncTF V { X } { ans } {
%       \assert_equal_tl:vnn { ans } { #1 } { #2/B }
%     } {
%       \test_fail:n { #2/C }
%     } 
%   } {
%     \test_fail:n { #2/D }
%   }
% }
% \__bnvs_gput:nnn V { X } { 421 }
% \BNVS_Test:nn { 421 } { 1 }
% \__bnvs_gclear_all:n { X }
% \__bnvs_gput:nnn A { X } { 422 }
% \__bnvs_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 422 } { 2 }
% \__bnvs_gclear_all:n { X }
% \__bnvs_gput:nnn Z { X } { 423 }
% \__bnvs_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 423 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \__bnvs_first_resolve:nc,
%   \__bnvs_first_resolve:xc,
%   \__bnvs_first_resolve:vc,
%   \__bnvs_first_append:nc,
%   \__bnvs_first_append:xc,
%   \__bnvs_first_append:vc
% }
% \begin{syntax}
% \cs{__bnvs_first_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_first_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the first index of the \meta{key} slide range
% into the \meta{tl variable} or
% append the first index of the \meta{key} slide range
% to the \meta{tl variable}.
% If no resolution occurs the content of the
% \meta{tl variable} is undefined in the first case
% and unmodified in the second.
% Cache the result.
% Execute \meta{yes code} when there is a \meta{first}, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { first_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { first_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_first_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF A { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_first_resolve:ncTF/C, noigre}
% \__bnvs_cache_gput:nnn A { X } { 421 }
% \__bnvs_first_resolve:ncTF { X } { ans } {
%   \assert_equal_ans:nn { 421 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_get:nncTF A { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn A { #1 } { \q_no_value }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The first index must be computed separately from the length and the last index.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_last_resolve:ncTF { #1 } { #2 } {
          \__bnvs_tl_put_right:cn { #2 } { - }
          \__bnvs_length_append:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { + 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_tl_if_empty:cTF { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
              \__bnvs_gput:nnn A { #1 } { \q_nil }
              \prg_return_false:
            } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_first_resolve:ncTF/q_nil-ZL, noigre}
% \__bnvs_gput:nnn A { X } { \q_nil }
% \__bnvs_gput:nnn Z { X } { 666 }
% \__bnvs_gput:nnn L { X } { 445 }
% \__bnvs_first_resolve:ncTF { X } { ans } {
%   \assert_equal_ans:nn { 222 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
              \__bnvs_gput:nnn A { #1 } { \q_nil }
              \__bnvs_cache_gput:nnv A { #1 } { #2 }
              \prg_return_true:
            }
          } {
            \__bnvs_error:n {
Unavailable~length~for~#1~(\token_to_str:N\__bnvs_first_resolve:ncTF/2) }
            \__bnvs_gput:nnn A { #1 } { \q_nil }
            \prg_return_false:
          }
        } {
          \__bnvs_error:n {
Unavailable~last~for~#1~(\token_to_str:N\__bnvs_first_resolve:ncTF/1) }
          \__bnvs_gput:nnn A { #1 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { a } {
          \__bnvs_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv A { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BeanovesLogGProp
\BNVS_DEBUG_log_first_resolve_ncTF:nn { ... } { ...FALSE/C^^J Unknown~KEY = / #1 / A / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { first_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { first_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { first_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_first_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_first_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_first_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\__bnvs_first_append:ncTF, noigre}
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1 }
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1' }
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4' }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5 }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5' }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6 }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6' }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \__bnvs_last_resolve:nc,
%   \__bnvs_last_append:nc
% }
% \begin{syntax}
% \cs{__bnvs_last_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_last_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the last index of the fully qualified \meta{key} range
% into or to the right of the right of the \meta{tl variable}, when possible.
% Execute \meta{yes code} when a last index was given,
% \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { last_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { last_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_last_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF Z { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }  {
    \__bnvs_get:nncTF Z { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn Z { #1 } { \q_no_value }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The last index must be computed separately from the start and the length.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...A+L... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_first_resolve:ncTF { #1 } { #2 } {          
          \__bnvs_tl_put_right:cn { #2 } { + }
          \__bnvs_length_append:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { - 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_cache_gput:nnv Z { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn Z { #1 } { \q_nil }
            \prg_return_true:
          } {
            \__bnvs_error:x {
 Unavailable~length~for~#1~(\token_to_str:N \__bnvs_last_resolve:ncTF/1) }
            \__bnvs_gput:nnn Z { #1 } { \q_nil }
            \prg_return_false:
          }
        } {
          \__bnvs_error:x {
Unavailable~first~for~#1~(\token_to_str:N \__bnvs_last_resolve:ncTF/1) }
          \__bnvs_gput:nnn Z { #1 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \__bnvs_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv Z { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...TRUE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { last_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_last_append:nc #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { last_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_last_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_last_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_last_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { last_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=last, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 1 }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 2 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 3 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 4 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 5 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 6 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 11 }
% \end{bnvs.test}
% \begin{function}[TF]{\__bnvs_length_resolve:nc, \__bnvs_length_append:nc}
% \begin{syntax}
% \cs{__bnvs_length_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_length_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the length of the \meta{key} slide range into \meta{tl variable},
% or append the length of the \meta{key} slide range to \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{length}, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.test}{bnvs:c=append_length:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { length } { ::445 } { 445 } { 1 }
% \Test_what_append_X_ncTF:nnnn { length } { ::445 } { 445 } { 2 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH } { 445 } { 3 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH } { 445 } { 4 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST::LENGTH } { 445 } { 5 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST::LENGTH } { 445 } { 6 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH:LAST } { 445 } { 7 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH:LAST } { 445 } { 8 }
% \Test_what_append_X_ncTF:nnnn { length } { :LAST::LENGTH } { 445 } { 9 }
% \Test_what_append_X_ncTF:nnnn { length } { :LAST::LENGTH } { 445 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=if_resolve:ncTF, noigre}
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { A }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=if_append:ncTF, noigre}
% \Test_if_append:nnnn { 222:666 } { X.last } { 666 } { A }
% \Test_if_append:nnnn { 222:666 } { X.1 } { 222 } { B }
% \Test_if_append:nnnn { 222:666 } { X.last - X.1 } { 444 } { C }
% \Test_if_append:nnnn { 222:666 } { X.last - (X.1) } { 444 } { D }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 0 } { A2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 0 } { B2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 0 } { C2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 0 } { D2i }
% \reset:n { Y }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 666 } { A2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 222 } { B2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 444 } { C2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 444 } { D2 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST:LAST } { 445 } { 11 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST:LAST } { 445 } { 12 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { length_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { length_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_length_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF L { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_get:nncTF L { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn L { #1 } { \q_no_value }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The length must be computed separately from the start and the last index.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_last_resolve:ncTF { #1 } { #2 } {
          \__bnvs_tl_put_right:cn { #2 } { - }
          \__bnvs_first_append:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { + 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_gput:nnn L { #1 } { \q_nil }
            \__bnvs_cache_gput:nnv L { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \__bnvs_error:n {
Unavailable~first~for~#1~(\__bnvs_length_resolve:ncTF/2) }
            \return_false:
          }
        } {
          \__bnvs_error:n {
Unavailable~last~for~#1~(\__bnvs_length_resolve:ncTF/1) }
          \return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \__bnvs_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv L { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { length_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { length_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { length_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_length_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_length_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_append_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_length_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { length_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_range_resolve:nc,
%   \__bnvs_range_append:nc,
% }
% \begin{syntax}
% \cs{__bnvs_range_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_range_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the range of the \meta{key} slide range into the \meta{tl variable}
% or append this range to the \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{range}, \meta{no code} otherwise, in that latter case
% the content the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { range_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { range_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_range_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_first_resolve:ncTF { #1 } { a } {
    \BNVS_tl_use:Nv \int_compare:nNnT { a } < 0 {
      \__bnvs_tl_set:cn { a } { 0 }
    }
    \__bnvs_last_resolve:ncTF { #1 } { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from above and below.
% \begin{bnvs.test}{bnvs:cn={range_append:ncTF}{A-Z}, noigre}
% \Test_range_append:nnn { 222:666 } { 222-666 } { 3 }
% \Test_range_append:nnn { 222::445 } { 222-666 } { 4 }
% \Test_range_append:nnn { ::445:666 } { 222-666 } { 5 }
% \Test_range_append:nnn { :666::445 } { 222-666 } { 6 }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST:LAST } { 222-666 } { 3 }
% ^^A\Test_range_append:nnn { FIRST::LENGTH } { 222-666 } { 4 }
% \Test_range_append:nnn { ::LENGTH:LAST } { 222-666 } { 5 }
% \Test_range_append:nnn { :LAST::LENGTH } { 222-666 } { 6 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_right:cn { a } { - }
      \__bnvs_tl_put_right:cv { a } { b }
      \BNVS_end_tl_put_right:cv { #2 } { a }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_ncTF:nn { ... } { ...TRUE/A-Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from below.
% \begin{bnvs.test}{:N=\__bnvs_range_append:ncTF/A-, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { 222 } { 222- } { 1 }
% \Test_range_append:nnn { 222: } { 222- } { 1' }
% \Test_range_append:nnn { 222:: } { 222- } { 1'' }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST } { 222- } { 1 }
% \Test_range_append:nnn { FIRST: } { 222- } { 1' }
% \Test_range_append:nnn { FIRST:: } { 222- } { 1'' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_end_tl_put_right:cv { #2 } { a }
      \__bnvs_tl_put_right:cn { #2 } { - }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_ncTF:nn { ... } { ...TRUE/A- }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_last_resolve:ncTF { #1 } { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from above.
% \begin{bnvs.test}{:N=\__bnvs_range_append:ncTF/-Z, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { :666 } { -666 } { 1 }
% \reset:n { Y }
% \Test_range_append:nnn { :LAST } { -666 } { 1' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_left:cn { b } { - }
      \BNVS_end_tl_put_right:cv { #2 } { b }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_ncTF:nn { ... } { ...TRUE/-Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_value_resolve:ncTF { #1 } { b } {
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unlimited range.
% \begin{bnvs.test}{:Nn=\__bnvs_range_append:ncTF{/:-}, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { 222 } { 222- } { 1 }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST } { 222- } { 1' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_end_tl_put_right:cv { #2 } { b }
        \__bnvs_tl_put_right:cn { #2 } { - }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_ncTF:nn { ... } { ...TRUE/V }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_end:
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { range_append } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { range_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { range_resolve_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_range_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { #2 }
  \__bnvs_range_append:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } 
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { range_resolve } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_previous_resolve:nc,
%   \__bnvs_previous_append:nc
% }
% \begin{syntax}
% \cs{__bnvs_previous_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to the variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\__bnvs_previous_append:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { previous } { 222: } { 221 } { 2 }
% \Test_what_append_X_ncTF:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5' }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6 }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6' }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_previous_append:ncTF, noigre}
% \reset:n { Y }
% \Beanoves { X = :LAST::LENGTH }
% \Test_what_append_X_ncTF:nnnn { last } { } { 666 } { A }
% \Test_what_append_X_ncTF:nnnn { length } { } { 445 } { B }
% \Test_what_append_X_ncTF:nnnn { first } { } { 222 } { C }
% \Test_what_append_X_ncTF:nnnn { previous } {  } { 221 } { 7 }
% \Test_what_append_X_ncTF:nnnn { previous } { :LAST+1::LENGTH } { 222 } { 7' }
% \Beanoves {X=:LAST}
% \__bnvs_tl_clear:c { a }
% \__bnvs_previous_append:ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \__bnvs_tl_clear:c { a }
% \__bnvs_previous_append:ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { previous_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { previous_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF P { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_first_resolve:ncTF { #1 } { #2 } {
      \__bnvs_tl_put_right:cn { #2 } { -1 }
      \__bnvs_round:c { #2 }
      \__bnvs_cache_gput:nnv P { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { previous_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { previous_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { previous_append_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_previous_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_previous_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { previous_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_next_resolve:nc,
%   \__bnvs_next_append:nc,
% }
% \begin{syntax}
% \cs{__bnvs_next_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_next_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to this variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\__bnvs_next_append:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 1 }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 2 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 3 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 4 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 5 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 6 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 7 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 8 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 9 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { next_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { next_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_next_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_cache_get:nncTF N { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_last_resolve:ncTF { #1 } { #2 } {
      \__bnvs_tl_put_right:cn { #2 } { +1 }
      \__bnvs_round:c { #2 }
      \__bnvs_cache_gput:nnv N { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { next_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { next_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { next_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_next_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_next_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { next_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_v_resolve:nc,
%   \__bnvs_v_append:nc
% }
% \begin{syntax}
% \cs{__bnvs_v_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_v_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the value of the \meta{key} overlay set
% into the \meta{tl variable} or
% append this value to the right of this variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only. 
% \end{function}
% \begin{bnvs.test}{:N=\__bnvs_v_resolve:ncTF, noigre}
% \reset:n { Y }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { v_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_v_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_v_get:ncTF { #1 } { #2 } {
    \__bnvs_quark_if_no_value:cTF { #2 } {
      \__bnvs_fatal:n {Circular~definition:~#1}
      \prg_return_false:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/ALREADY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_v_gput:nn { #1 } { \q_no_value }
    \__bnvs_value_resolve:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_v_resolve:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_resolve_ncTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_DEBUG_log_gprop:n { 100 }
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_v_append:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { v } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_v_gput:nv { #1 } { #2 }
      \prg_return_true:
    } {
      \__bnvs_first_resolve:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_v_gput:nv { #1 } { #2 }
        \prg_return_true:
      } {
        \__bnvs_last_resolve:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_v_gput:nv { #1 } { #2 }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...FALSE/Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_v_gremove:n { #1 }
          \prg_return_false:
        }
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { v_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { v_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_v_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_v_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\__bnvs_value_append:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_value_append:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{bnvs.test}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { v_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_index_can:n,
%   \__bnvs_index_can:v,
%   \__bnvs_index_resolve:nnc,
%   \__bnvs_index_resolve:vvc,
%   \__bnvs_index_append:nnc,
%   \__bnvs_index_append:vvc
% }
% \begin{syntax}
% \cs{__bnvs_index_can:nTF} \marg{key} \marg{yes code} \marg{no code}
% \cs{__bnvs_index_resolve:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_index_append:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index associated to the \meta{key} and \meta{integer} slide range
% into the \meta{tl variable} or
% append this index to the right of this variable.
% When \meta{integer} is 1, this is the first index,
% when \meta{integer} is 2, this is the second index, and so on.
% When \meta{integer} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% The computation may fail when too many recursion calls are made.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \__bnvs_if_in_p:nn V { #1 }
    || \__bnvs_if_in_p:nn A { #1 }
    || \__bnvs_if_in_p:nn Z { #1 }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { index_can:nTF } { KEY } { #1 }
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...TRUE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...FALSE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_index_can:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { index_resolve:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_index_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \exp_args:Nx \__bnvs_value_resolve:ncTF { #1.#2 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
  } {
    \__bnvs_first_resolve:ncTF { #1 } { #3 } {
      \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			\__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/FIRST }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited overlay set.
% \begin{bnvs.test}{bnvs:c=index_resolve:nncTF, noigre}
% \Test_index_resolve:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_index_resolve:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_index_resolve:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_index_resolve:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_resolve:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_resolve:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    } {
      \__bnvs_last_resolve:ncTF { #1 } { #3 } {
        \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			  \__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/LAST }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_value_resolve:ncTF { #1 } { #3 } {
          \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			    \__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_false:
        }
      }
  }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_resolve:nvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_index_resolve:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_resolve:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_index_resolve:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { index_append:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_index_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_index_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
%    \end{macrocode}
% \begin{bnvs.test}{:N=\__bnvs_index_append:nncTF, noigre}
% \Test_index_append:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_index_append:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_index_append:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_index_append:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
%    \begin{macrocode}
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_append:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_index_append:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Index counter}
% \begin{function}[TF]{\__bnvs_n_resolve:nc,\__bnvs_n_append:nc, \__bnvs_n_append:Vc}
% \begin{syntax}
% \cs{__bnvs_n_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluate the n counter associated to the \marg{key} overlay set
% into \meta{tl variable}.
% Initialize this counter to 1 on the first use.
% \meta{no code} is never executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { n_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_n_get:ncF { #1 } { #2 } {
    \__bnvs_tl_set:cn { #2 } { 1 }
    \__bnvs_n_gput:nn { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { n_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { n_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\__bnvs_n_append:ncTF, noigre}
% \Test_n_append_X:nnn { 1 } { 1 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 123 }
% \Test_n_append_X:nnn { } { 123 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_append:nnnn { } { ?!#1 } { 1 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%  \__bnvs_n_index_resolve:nc,
%  \__bnvs_n_index_append:nc,
%  \__bnvs_n_index_resolve:nnc,
%  \__bnvs_n_index_append:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_n_index_resolve:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_index_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_index_resolve:nncTF} \marg{key} \marg{base key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_index_append:nncTF} \marg{key} \marg{base key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index for the value of the n counter associated to the
% \marg{key} overlay set into the \meta{tl variable} or
% append this value the right of this variable.
% Initialize this counter to 1 on the first use.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\__bnvs_n_index_resolve:ncTF, noigre}
% \reset:n { YES }
% \Test_n_index_resolve_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_n_index_resolve_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { 445 }
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { -443 }
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\__bnvs_n_index_append:ncTF, noigre}
% \reset:n { YES }
% \Test_n_index_append_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_n_index_append_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_append:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { 445 }
%   \Test_n_index_append:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_append:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { -443 }
%   \Test_n_index_append:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_index_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { n_index_resolve:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_index_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_n_resolve:ncTF { #1 } { #2 } {
    \__bnvs_index_resolve:nvcTF { #1 } { #2 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_index_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_index_resolve:nncTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_n_index_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_n_resolve:ncTF { #1 } { #3 } {
    \__bnvs_tl_put_left:cn { #3 } { #2. }
    \__bnvs_if_resolve:vcTF { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_index_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { n_index_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_index_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_index_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_ncTF:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_ncTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_index_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_index_append:nncTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_n_index_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_index_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_nncTF:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_nncTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { n_index_append } { T, F, TF }
\BNVS_new_conditional_vvc:cn { n_index_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\__bnvs_n_index_append:ncTF, noigre}
% \reset:n { YES }
% \Test_n_index_append_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_n_append_X:nnn { } { 445 } { 2 }
% \Test_n_index_append_X:nnn { } { 666 } { 1 }
% \end{bnvs.test}
%
% \subsubsection{Value counter}
% \begin{function} [TF] {
%   \__bnvs_v_incr_resolve:nnc,
%   \__bnvs_v_incr_append:nnc,
%   \__bnvs_v_incr_append:VnN,
%   \__bnvs_v_incr_append:VVN
% }
% \begin{syntax}
% \cs{__bnvs_v_incr_append:nnTF}  \marg{key} \marg{offset} \marg{yes code} \marg{no code}
% \cs{__bnvs_v_incr_resolve:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_v_incr_append:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Increment the value counter position accordingly.
% When requested, put the result in the \meta{tl variable}.
% In the second version, the result will lay within the declared range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_incr_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { v_incr_resolve_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #2 } { #3 } {
    \BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
      \__bnvs_v_resolve:ncTF { #1 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_incr_resolve:nncTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_v_incr_resolve:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_incr_resolve:nncTF{/:2}, noigre}
% \reset:n { Y }
% \__bnvs_v_incr_resolve:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    } {
      \__bnvs_tl_put_right:cn { #3 } { + }
      \__bnvs_v_append:ncTF { #1 } { #3 } {
        \__bnvs_round:c { #3 }
        \__bnvs_v_gput:nv { #1 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_incr_resolve:nncTF{/:3}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_v_incr_resolve:nncTF { ?!X } { 444 } { ans } {
%   \assert_equal_ans:nn { 666 } { 3 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { v_incr_resolve } { T, F, TF }
\BNVS_new_conditional:cpnn { v_incr_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { v_incr_append_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_incr_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_v_incr_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_incr_append:nncTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_v_incr_append:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_append_nncTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_incr_append:nncTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_v_incr_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } { 2 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { v_incr_append } { T, F, TF }
\BNVS_new_conditional_vvc:cn { v_incr_append } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_post_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { v_post_resolve:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_post_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_v_resolve:ncTF { #1 } { #3 } {
    \BNVS_begin:
    \__bnvs_if_resolve:ncTF { #2 } { a } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { a } = 0 {
        \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nncTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_v_post_resolve:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_tl_put_right:cn { a } { + }
        \__bnvs_tl_put_right:cv { a } { #3 }
        \__bnvs_round:c { a }
        \BNVS_end_v_gput:nc { #1 } { a }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_v_post_resolve:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 2222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \end{bnvs.test}
%    \begin{macrocode}
      \BNVS_end:
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \__bnvs_v_post_resolve:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
      \prg_return_false:
  }
}
\BNVS_new_conditional_vvc:cn { v_post_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_post_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { v_post_append:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_post_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_v_post_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_append_nncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_append:nncTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_v_post_append:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
%   \__bnvs_tl_set:cn { ans } { 2 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_v_post_append:nncTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_v_post_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 2 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { 2' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  }
}
\BNVS_new_conditional_vnc:cn { v_post_append } { T, F, TF }
\BNVS_new_conditional_vvc:cn { v_post_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:cn={v_post_append:nncTF}{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 9 }
% \__bnvs_v_post_append:nncTF { ?!X } { 8000 } { ans } {
%   \assert_equal_ans:nn { 9222 } { A }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { A' }
%   } {
%     \test_fail:n { NO_WAY-A' }
%   }
% } {
%   \test_fail:n { NO_WAY-A }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 9 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_v_post_append:vncTF { a } { 8000 }  { ans } {
%   \assert_equal_ans:nn { 9222 } { B }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { B' }
%   } {
%     \test_fail:n { NO_WAY-B' }
%   }
% } {
%   \test_fail:n { NO_WAY-B }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_v_post_append:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C' }
%   } {
%     \test_fail:n { NO_WAY-C' }
%   }
% } {
%   \test_fail:n { NO_WAY-C }
% }
% \end{bnvs.test}
% \begin{function} [TF] {
%   \__bnvs_n_incr_resolve:nnnc,
%   \__bnvs_n_incr_resolve:vvnc,
%   \__bnvs_n_incr_resolve:nnc,
%   \__bnvs_n_incr_resolve:vvc,
%   \__bnvs_n_incr_append:nnnc,
%   \__bnvs_n_incr_append:nnc,
%   \__bnvs_n_incr_append:vnc,
%   \__bnvs_n_incr_append:vvc,
%   \__bnvs_n_post_resolve:nnc,
%   \__bnvs_n_post_append:nnc
%   }
% \begin{syntax}
% \cs{__bnvs_n_incr_resolve:nncTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_incr_resolve:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_incr_append:nnncTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_n_incr_append:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Increment the implicit n counter accordingly.
% When requested, put the resulting index in the variable with \meta{tl core name}.
% \end{function}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnc}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves{ X = 123 }
% \__bnvs_n_resolve:ncTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 1 } { A }
% } {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_n_index_resolve:ncTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 123 } { B }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Beanoves{ X = 123 }
% \__bnvs_n_incr_resolve:nncTF { ?!X } { 123 } { ans } {
%   \assert_equal_ans:nn { 246 } { C }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Test_n_incr_append:nnnnn { 123 } {} { 123 } { 246 } { 1 }
% \Test_n_get:nnnn {} {} { 124 } { 2 }
% \Test_n_incr_append:nnnnn { 123 } {} { 500+40+3 } { 666 } { 3 }
% \reset:n { YES }
% \Test_n_incr_append:nnnnn { FIRST } {} { LENGTH-1 } { 666 } { 4 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_incr_resolve:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnnnc { n_incr_resolve:nnncTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #3 } { #4 } {
			\BNVS_tl_use:Nv \int_compare:nNnTF { #4 } = 0 {
      \__bnvs_n_resolve:ncTF { #1 } { #4 } {
        \__bnvs_index_resolve:nvcTF { #1 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_incr_resolve:nnncTF { ?!X } { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_n_incr_resolve:nnncT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \__bnvs_tl_put_right:cn { #4 } { + }
      \__bnvs_n_append:ncTF { #1 } { #4 } {
        \__bnvs_round:c { #4 }
        \__bnvs_n_gput:nv { #1 } { #4 }
        \__bnvs_index_resolve:nvcTF { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnncTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_incr_resolve:nnncTF { ?!X } { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnncTF}{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_n_incr_resolve:nnncT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bvs:cn={n_incr_resolve:nnncTF}{/:5}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnncTF}{/:6}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_incr_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_incr_resolve_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #2 } { #3 } {
			\BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
      \__bnvs_n_resolve:ncTF { #1 } { #3 } {
        \__bnvs_index_resolve:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_incr_resolve:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_n_incr_resolve:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \__bnvs_tl_put_right:cn { #3 } { + }
      \__bnvs_n_append:ncTF { #1 } { #3 } {
        \__bnvs_round:c { #3 }
        \__bnvs_n_gput:nv { #1 } { #3 }
        \__bnvs_index_resolve:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nncTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_incr_resolve:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_incr_resolve:nncTF{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_n_incr_resolve:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_incr_resolve:nncTF{/:5}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_incr_resolve:nncTF{/:6}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { n_incr_resolve } { T, F, TF }
\BNVS_new_conditional_vvc:cn { n_incr_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_incr_append:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnnnc { n_incr_append:nnncTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_incr_resolve:nnncTF { #1 } { #2 } { #3 } { #4 }{
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nnncT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nnncT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { n_incr_append } { T, F, TF }
\BNVS_new_conditional_vvvc:cn { n_incr_append } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_incr_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_incr_append:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_incr_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_incr_append:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { n_incr_append } { T, F, TF }
\BNVS_new_conditional_vvc:cn { n_incr_append } { T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nncTF}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_n_incr_append:vncTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_n_incr_append:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function} [TF] {
%   \__bnvs_v_post_resolve:nnc,
%   \__bnvs_v_post_resolve:vvc,
%   \__bnvs_v_post_append:nnc,
%   \__bnvs_v_post_append:vnN,
%   \__bnvs_v_post_append:vvN
% }
% \begin{syntax}
% \cs{__bnvs_v_post_resolve:nncTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_v_post_append:nncTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Resolve the value of the free counter for the given \meta{key} into
% the \meta{tl variable} then increment this free counter position
% accordingly.
% The append version, appends the value to the right of the \meta{tl variable}.
% The content of the \meta{tl variable} is undefined
% while in the \marg{no code} branch and on resolution only.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_post_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_post_resolve_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_n_resolve:ncTF { #1 } { #3 } {
    \BNVS_begin:
    \__bnvs_if_resolve:ncTF { #2 } { #3 } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
        \BNVS_end:
        \__bnvs_index_resolve:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_append:nncTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_post_resolve:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
%   \__bnvs_n_index_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
        \__bnvs_tl_put_right:cn { #3 } { + }
        \__bnvs_n_append:ncTF { #1 } { #3 } {
          \__bnvs_round:c { #3 }
          \__bnvs_n_gput:nv { #1 } { #3 }
          \BNVS_end:
          \__bnvs_index_resolve:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_append:nncTF{/:2}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_n_post_resolve:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 222 } {2-A}
%   \__bnvs_n_index_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_append:nncTF{/:22'}, noigre}
% \reset:n{ YES }
% \__bnvs_n_post_resolve:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
            \prg_return_false:
          }
        } {
          \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_resolve:nncTF{/:3}, noigre}
% \reset:n{ YES }
% \__bnvs_n_post_resolve:nncT { ?! } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      }
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_resolve:nncTF{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_n_post_resolve:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nncTF:nn { ... } { ...FALSE/D }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_resolve:nncTF{/:5}, noigre}
% \reset:n{ YES }
% \__bnvs_n_post_resolve:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/5-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { n_post_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { n_post_append_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_post_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_n_post_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_append:nncTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_post_append:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
%   \__bnvs_n_index_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_n_post_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {2-A}
%   \__bnvs_n_index_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\__bnvs_n_post_append:nncTF{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_n_post_append:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \reset:n{ YES }
% \__bnvs_n_post_append:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { n_post_append } { T, F, TF }
\BNVS_new_conditional_vvc:cn { n_post_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\__bnvs_v_post_append:nncTF{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_v_post_append:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { A-1 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { A-2 }
%   } {
%     \test_fail:n { NO_WAY-A-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-A-4 }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_v_post_append:vncTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 2222 } { B-1 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { B-2 }
%   } {
%     \test_fail:n { NO_WAY-B-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-B-4 }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_v_post_append:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C-1 }
%   \__bnvs_v_resolve:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C-2 }
%   } {
%     \test_fail:n { NO_WAY-C-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-C-4 }
% }
% \end{bnvs.test}
%
% \subsubsection{Evaluation}
%
% \begin{function}{\__bnvs_round_ans:}
% \begin{syntax}
% \cs{__bnvs_rslv_round:}
% \end{syntax}
% Helper function to round the |\l__bnvs_ans_tl| variable.
% For ranges only, this will be set to |\prg_do_nothing|
% because we do not want to interpret the |-| sign as a minus operator.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { round_ans: } {
  \__bnvs_round:c { ans }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsubsection{ Functions for the resolution }
% They manily start with |\__bnvs_if_resolve_|
%
% \begin{function}{\__bnvs_if_resolve_end_return_false:n}
% \begin{syntax}
% \cs{__bnvs_if_resolve_end_return_false:n} \marg{message}
% \end{syntax}
% Close one \TeX\ group, display a message and return false.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \__bnvs_path_resolve_n:TFF,
% }
% \begin{syntax}
% \cs{__bnvs_path_resolve_n:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_resolve_n:TFF } #1 #2 {
  \__bnvs_kip_n_path_resolve:TF {
    \__bnvs_seq_if_empty:cTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function} {
%   \__bnvs_path_resolve_n:T
% }
% \begin{syntax}
% \cs{__bnvs_path_resolve_n:T} \marg{yes code}
% \end{syntax}
% Resolve the path and execute \meta{yes code} on success.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...#1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_resolve_n:T } #1 {
  \__bnvs_path_resolve_n:TFF {
    #1
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Unknown~dotted~path
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { resolve_x:T } #1 {
  \__bnvs_kip_x_path_resolve:TFF {
    #1
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \__bnvs_if_resolve_end_return_false:n { Unknown~dotted~path }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_path_suffix:n,
% }
% \begin{syntax}
% \cs{__bnvs_path_suffix:nTF} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% If the last item of |\l__bnvs_path_seq| is \meta{suffix},
% then execute \meta{yes code} otherwise execute \meta{no code}.
% The suffix is |n| in the second case.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { path_pop_right_n:c } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c=path_pop_right_n:cTF, noigre}
% \__bnvs_seq_clear:c { path }
% \__bnvs_path_pop_right_n:cTF { a } {
%   \test_fail:n { NO~WAY/1 }
% } {
% }
% \__bnvs_seq_set_split:cnn { path } { . } { 1.2.3 }
% \__bnvs_seq_set_split:cnn { path } { . } { n }
%   \__bnvs_path_pop_right_n:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/2 }
% }
% \__bnvs_seq_set_split:cnn { path } { . } { 1.2.3.n }
% \__bnvs_path_pop_right_n:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
  \__bnvs_seq_pop_right:ccTF { path } { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \__bnvs_if_resolve_pop_kip:TTF,
%   \__bnvs_if_resolve_pop_complete_white:T,
%   \__bnvs_if_resolve_pop_complete_black:T,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_pop_kip:TTF} \marg{blank code} \marg{black code} \marg{end code}
% \cs{__bnvs_if_resolve_pop_complete_white:T} \marg{blank code}
% \cs{__bnvs_if_resolve_pop_complete_black:T} \marg{black code}
% \end{syntax}
% For |\__bnvs_if_resolve_pop_kip:TTF|.
% If the |split| sequence is empty, execute \meta{end code}.
% Otherwise pops the 3 heading items of the
% |split| sequence into the three |tl| variables |key|, |id|, |path|.
% If |key| is blank then execute \meta{blank code}, otherwise execute
% \meta{black code}.
%
% For |\__bnvs_if_resolve_pop_complete_white:T|: pops the three heading items of
% the |split| sequence into the three variables
% |n_incr|, |incr|, |post|.
% Then execute \meta{blank code}.
%
% For |\__bnvs_if_resolve_pop_complete_black:T|: pops the six heading items of
% the |split| sequence then execute \meta{blank code}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_kip_complete: } {
  \__bnvs_tl_if_blank:vT { id } {
    \__bnvs_tl_put_left:cv { key } { id_last }
    \__bnvs_tl_set:cv { id } { id_last }
  }
  \__bnvs_tl_if_blank:vTF { path } {
    \__bnvs_seq_clear:c { path }
  } {
    \__bnvs_seq_set_split:cnv { path } { . } { path }
    \__bnvs_seq_remove_all:cn { path } { }
  }
  \__bnvs_tl_set_eq:cc { key_base } { key }
  \__bnvs_seq_set_eq:cc { path_base } { path }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...COMPLETE... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_kip:TTF } #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...POP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_split_pop_left:cTF { key } {
    \__bnvs_split_pop_left:cTF { id } {
      \__bnvs_split_pop_left:cTF { path } {
        \__bnvs_tl_if_blank:vTF { key } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The first 3 capture groups are empty,
% and the 3 next ones are expected to contain the expected information.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          #1
        } {
          \__bnvs_if_resolve_pop_kip_complete:
          #2
        }
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/2 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/1 }
    }
  } { #3 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \__bnvs_if_resolve_pop_complete:nNT
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_pop_kip:FFTF} \marg{empty key code} \marg{no id code} \marg{true code} \marg{no capture code}
% \cs{__bnvs_if_resolve_pop_complete:nNT} \marg{tl} \meta{tl var} \marg{true code}
% \end{syntax}
% \meta{tl} and \meta{tl var} are the arguments of the \cs{__bnvs_if_resolve:nc} conditionals.
% conditional variants.
%
% \cs{__bnvs_if_resolve_pop_kip:FFTF} locally
% sets the |key|, |id| and |path| |tl| variables
% to the 3 heading items of the split sequence,
% which correspond to the 3 eponym capture groups.
% If no capture group is available, \meta{no capture code} is executed.
% If the capture group for the key is empty, then \meta{empty key code} is executed.
% If there is no capture group for the id, then \meta{no id code} is executed.
% Otherwise \meta{true code} is executed.
%
% \cs{__bnvs_rslv_pop_end:T} locally
% sets the three |tl| variables |n_incr|, |incr| and |post|
% to the three heading items of the split sequence,
% which correspond to the last 3 eponym capture groups.
% \end{function}
% \begin{bnvs.test}{bnvs:c=if_resolve_pop_kip:TTF, noigre}
% \cs_set:Npn \BNVS_DEBUG_log_if_resolve_ncTF:nn #1 #2 {}
% \cs_set:Npn \__bnvs_end_unreachable_return_false:n #1 {
%   \__bnvs_tl_set:cn { ans } { #1 }
% }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 #4 #5 #6 {
%   \__bnvs_tl_clear:c { ans  }
%   \__bnvs_tl_clear:c { key  }
%   \__bnvs_tl_clear:c { id   }
%   \__bnvs_tl_clear:c { path }
%   \__bnvs_seq_set_split:cnn { split } { . } { #1 }
%   \__bnvs_seq_pop_left:cc { split } { a }
%   \__bnvs_if_resolve_pop_kip:TTF {
%     \__bnvs_tl_set:cn { ans } { FIRST  }
%   } {
%     \__bnvs_tl_set:cn { ans } { SECOND }
%   } {
%     \__bnvs_tl_set:cn { ans } { THIRD  }
%   }
%   \assert_equal_ans:nn { #2 } { #6/ans }
%   \assert_equal_tl:vnn { key  } { #3 } { #6/key  }
%   \assert_equal_tl:vnn { id   } { #4 } { #6/id   }
%   \assert_equal_tl:vnn { path } { #5 } { #6/path }
% }
% \BNVS_Test:nnn { .  .2.3 } { FIRST  } {   } { 2 } { 3 } { 1 }
% \BNVS_Test:nnn { . 1.2.3 } { SECOND } { 1 } { 2 } { 3 } { 2 }
% \BNVS_Test:nnn {         } { THIRD  } {   } {  } {  } { 3 }
% \BNVS_Test:nnn { . 1     } { if_resolve_pop_kip:TTF/1 } { 1 } { } { } { 4 }
% \BNVS_Test:nnn { . 1.2   } { if_resolve_pop_kip:TTF/2 } { 1 } { 2 } { } { 5 }
% \cs_undefine:N \BNVS_Test:nnn
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_complete_white:T } #1 {
  \__bnvs_split_pop_left:cTF { n_incr } {
    \__bnvs_split_pop_left:cTF { incr } {
      \__bnvs_split_pop_left:cTF { post } {
        #1
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/3 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/2 }
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_complete_black:T } #1 {
  \__bnvs_split_pop_left:cTF { a } {
    \__bnvs_split_pop_left:cTF { a } {
      \__bnvs_split_pop_left:cTF { a } {
        \__bnvs_split_pop_left:cTF { a } {
          \__bnvs_split_pop_left:cTF { a } {
            \__bnvs_split_pop_left:cTF { a } {
              #1
            } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/6 }
            }
          } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/5 }
          }
        } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/4 }
        }
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/3 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/2 }
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/1 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve:nc,
%   \__bnvs_if_resolve:vc,
%   \__bnvs_if_append:nc,
%   \__bnvs_if_append:vc,
%   \__bnvs_if_append:xc
% }
% \begin{syntax}
% \cs{__bnvs_if_append:ncTF} \marg{expression} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluates the \meta{expression},
% replacing all the named overlay specifications by their static
% counterpart then put the rounded result in \meta{tl variable} when resolving or to
% the right of the \meta{tl variable} when appending.
% Executed within a group.
% Heavily used by \cs{__bnvs_query_eval:nc}, where \meta{integer expression}
% was initially enclosed inside `|?(...)|'.
% Local variables: 
% \begin{variable}{\l__bnvs_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l__bnvs_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l__bnvs_split_int }
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_int_new:c { split }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{variable}{\l__bnvs_key_tl}
%    Storage for |split| sequence items that represent names.
% \end{variable}
% \begin{variable}{\l__bnvs_path_tl}
%    Storage for |split| sequence items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% Open a main \TeX\ group to define local functions and variables,
% sometimes another grouping level is used.
% The main \TeX\ group is closed in the various \cs{...end_return...} functions.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { kip_x_path_resolve_or_end_return_false:nT } #1 #2 {
  \__bnvs_kip_x_path_resolve:TFF {
    #2
  } {
    \BNVS_end_return_false:x { Too~many~dotted~components:~#1 }
  } {
    \BNVS_end_return_false:x { Unknown~dotted~path:~#1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \__bnvs_if_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...TRUE }
%</!final>
    \prg_return_true:
  } {
    \BNVS_end:
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...FALSE }
%</!final>
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_unreachable_return_false:n } #1 {
  \__bnvs_error:x { UNREACHABLE/#1 }
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_call:TF {
    \BNVS_begin:
    \BNVS_set:cpn { if_resolve_warning:n } ##1 {
      \__bnvs_warning:n { #1:~##1 }
      \BNVS_set:cpn { if_resolve_warning:n } {
        \use_none:n
      }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
% \end{bnvs.macrocode}
% This \TeX\ group will be closed just before returning.
% Implementation:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_regex_split:cnTF { split } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...SPLIT... }
\BNVS_DEBUG_log_seq:c { split }
%</!final>
% \end{bnvs.gobble}
% \end{bnvs.macrocode}
% The leftmost item is not a special item: we start feeding |\l__bnvs_ans_tl| with it.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_set:cpn { if_resolve_end_return_true: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Normal and unique end of the loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_round_ans:
        \BNVS_tl_use:nv {
          \BNVS_end:
          \__bnvs_tl_set:cn { #2 }
        } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
      \BNVS_set:cpn { if_resolve_round_ans: } { \__bnvs_round_ans: }
      \__bnvs_tl_clear:c { ans }
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_tl_clear:c { ans }
      \__bnvs_round_ans:n { #1 }
      \BNVS_end_tl_set:cv { #2 } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ...TRUE/DIRECT }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:     
    }
  } {
    \__bnvs_error:n { TOO_MANY_NESTED_CALLS/Resolution }
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_append:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_append:ncTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_resolve:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_resolve:ncTF { #1 } { #2 } {
    \prg_return_true:     
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Next functions are helpers for the \cs{__bnvs_if_resolve:nc} conditional variants.
% When present, their two first arguments \meta{tl} and \meta{tl var}
% are exactly the ones given to the variants.
%
% \begin{function}{
%   \__bnvs_if_resolve_loop_or_end_return:
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_loop_or_end_return:}
% \end{syntax}
% May call itself at the end.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...LOOP... }
\BNVS_DEBUG_log_seq:c { split }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_split_pop_left:cTF { a } {
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_if_resolve_pop_kip:TTF {
      \__bnvs_if_resolve_pop_kip:TTF {
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/3 }
      } {
        \__bnvs_if_resolve_pop_complete_white:T {
          \__bnvs_tl_if_blank:vTF { n_incr } {
            \__bnvs_tl_if_blank:vTF { incr } {
              \__bnvs_tl_if_blank:vTF { post } {
                \__bnvs_if_resolve_value_loop_or_end_return_true:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Only the dotted path, branch according to the last component.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                  \__bnvs_seq_pop_right:ccTF { path } { a } {
                    \BNVS_tl_use:Nv \str_case:nnF { a } {
{ n         } { \BNVS_use:c { if_resolve_loop_or_end_return[.n]: } }
{ length    } { \BNVS_use:c { if_resolve_loop_or_end_return[.length]: } }
{ last      } { \BNVS_use:c { if_resolve_loop_or_end_return[.last]:  } }
{ range     } { \BNVS_use:c { if_resolve_loop_or_end_return[.range]: } }
{ previous  } { \BNVS_use:c { if_resolve_loop_or_end_return[.previous]: } }
{ next      } { \BNVS_use:c { if_resolve_loop_or_end_return[.next]:  } }
{ reset     } { \BNVS_use:c { if_resolve_loop_or_end_return[.reset]: } }
{ reset_all } { \BNVS_use:c { if_resolve_loop_or_end_return[.reset_all]: } }
                    } {
\BNVS_use:c { if_resolve_loop_or_end_return[...<integer>]: }
                    }
                  } {
\BNVS_use:c { if_resolve_loop_or_end_return[...]: }
                  }
                }
              } {
\BNVS_use:c { if_resolve_loop_or_end_return[...++]: }
              }
            } {
              \__bnvs_path_suffix:nTF { n } {
\BNVS_use:c { if_resolve_loop_or_end_return[...n+=...]: }
              } {
\BNVS_use:c { if_resolve_loop_or_end_return[...+=...]: }
              }
            }
          } {
\BNVS_use:c { if_resolve_loop_or_end_return[...++n]: }
          }
        }
      } {
% split sequence empty
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/2 }
      }
    } {
      \__bnvs_if_resolve_pop_complete_black:T {
        \__bnvs_path_suffix:nTF { n } {
\BNVS_use:c { if_resolve_loop_or_end_return[++...n]: }
        } {
\BNVS_use:c { if_resolve_loop_or_end_return[++...]: }
        }
      }
    } {
      \__bnvs_if_resolve_end_return_true:
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { if_resolve_value_loop_or_end_return_true:F } #1 {
  \__bnvs_tl_set:cx { a } {
    \BNVS_tl_use:c { key } \BNVS_tl_use:c { path }
  }
  \__bnvs_v_resolve:vcTF { a } { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(v) }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_if_resolve_loop_or_end_return:
  } {
    \__bnvs_value_resolve:vcTF { a } { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(V) }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_tl_put_right:cv { ans } { a }
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      #1
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_return_error:n } #1 {
      \__bnvs_error:n { #1 }
      \BNVS_end:
      \prg_return_false:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item Case \texttt{...n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_if_resolve:nnnn { FIRST+1 } { X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { LENGTH-1 } { X.n } { 444 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.n } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:c { path }
\BNVS_DEBUG_log_seq:c { path }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_base_resolve_n:
    \__bnvs_n_index_append:vvcTF { key } { key_base } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...n }
\BNVS_DEBUG_log_tl:c { b }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_end_return_error:n {
        Undefined~dotted~path
      }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { path_suffix:n } #1 { T, F, TF } {
  \__bnvs_seq_get_right:ccTF { path } { a } {
    \__bnvs_tl_if_eq:cnTF { a } { #1 } {
      \__bnvs_seq_pop_right:ccT { path } { a } { }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.length]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...length}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...length }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/length}, noigre}
% \Test_if_resolve:nnnn { 222::445 } { X.length } { 445 } { 1 }
% \Test_if_resolve:nnnn { 222:666 } { X.length } { 445 } { 2 }
% \Test_if_resolve:nnnn { ::445:666 } { X.length } { 445 } { 3 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length } { 445 } { 4 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length } { 445 } { 5 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length } { 445 } { 6 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222::445 } { X.length+X.length } { 890 } { 1' }
% \Test_if_resolve:nnnn { 222:666 } { X.length+X.length } { 890 } { 2' }
% \Test_if_resolve:nnnn { ::445:666 } { X.length+X.length } { 890 } { 3' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length+X.length } { 890 } { 4' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length+X.length } { 890 } { 5' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length+X.length } { 890 } { 6' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_length_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../length }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~length }
    } 
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.last]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...last}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...last }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.last}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.last } { 666 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.last } { 666 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last } { 666 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last } { 666 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last } { 666 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last } { 666 } { 8 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :666 } { X.last / 2 } { 333 } { 1' }
% \Test_if_resolve:nnnn { 222::445 } { X.last / 2 } { 333 } { 2' }
% \Test_if_resolve:nnnn { 222:666 } { X.last / 2 } { 333 } { 3' }
% \Test_if_resolve:nnnn { ::445:666 } { X.last / 2 } { 333 } { 4' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last / 2 } { 333 } { 5' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last / 2 } { 333 } { 6' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last / 2 } { 333 } { 7' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last / 2 } { 333 } { 8' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_last_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../last }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \BNVS_end_return_false:x { NO~last }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.range]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...range}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...range }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.range}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_if_resolve:nnnn { 222: } { X.range } { 222- } { 1' }
% \Test_if_resolve:nnnn { 222:: } { X.range } { 222- } { 1'' }
% \Test_if_resolve:nnnn { :666 } { X.range } { -666 } { 2 }
% \Test_if_resolve:nnnn { 222::445 } { X.range } { 222-666 } { 3 }
% \Test_if_resolve:nnnn { 222:666 } { X.range } { 222-666 } { 4 }
% \Test_if_resolve:nnnn { ::445:666 } { X.range } { 222-666 } { 5 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_if_resolve:nnnn { FIRST: } { X.range } { 222- } { 6' }
% \Test_if_resolve:nnnn { FIRST:: } { X.range } { 222- } { 6'' }
% \Test_if_resolve:nnnn { :LAST } { X.range } { -666 } { 7 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.range } { 222-666 } { 8 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.range } { 222-666 } { 9 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.range } { 222-666 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_range_append:vcTF { key } { ans } {
      \BNVS_set:cpn { if_resolve_round_ans: } { \prg_do_nothing: }
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../range }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~range }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.previous]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...previous}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...previous }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.previous}, noigre}
% \Test_if_resolve:nnnn { 222: } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::' } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.previous } { 221 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.previous } { 221 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5 }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5' }
% \Test_if_resolve:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.previous } { 221 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.previous } { 221 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_previous_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../previous }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~previous }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.next]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...next}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...next }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.next}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.next } { 667 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.next } { 667 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.next } { 667 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { X.next } { 667 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.next } { 667 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.next } { 667 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.next } { 667 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_next_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../next }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~next }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.reset]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...reset}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...reset }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.reset}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-3 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_v_greset:vnT { key } { } { }
    \__bnvs_value_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../reset }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.reset_all]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...reset\_all}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...reset_all }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/.reset_all}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-3 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { c-1 }
% \Test_if_resolve:nnnn { } { LAST+=333 } { 999 } { c-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { c-3 }
% \Test_if_resolve:nnnn { } { X } { 666 } { c-4 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_greset_all:vnT { key } { } { }
    \__bnvs_value_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../reset }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...<integer>]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...<integer> }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/Counter/.<integer>}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.1 } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X.1 } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X.1 } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X.1 } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X.1 } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X.1 } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.1 } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X.1 } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X.1 } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.1 } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.1 } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X.1 } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.1 } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X.1 } { 666 } { 1-d' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_index_append:vvcTF { key } { a } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../<integer> }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~integer }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/Counter/...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X } { 666 } { 1-d' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_value_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../... }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~value }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...++]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...++ }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_suffix:nTF { reset } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...reset++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...reset++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_path_resolve_n:T {
      \__bnvs_v_greset:vnT { key } { } { }
      \__bnvs_v_post_append:vncTF { key } { 1 }  { ans } {
        \__bnvs_if_resolve_loop_or_end_return:
      } {
        \__bnvs_if_resolve_end_return_false:n { NO~post }
      }
    }
  } {
    \__bnvs_path_suffix:nTF { reset_all } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...reset_all++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...reset_all++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_path_resolve_n:T {
        \__bnvs_greset_all:vnT { key } { } { }
        \__bnvs_v_post_append:vncTF { key } { 1 }  { ans } {
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { NO~post }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_path_resolve_n:T {
        \__bnvs_v_post_append:vncTF { key } { 1 }  { ans } {
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { NO~post }
        }
      }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...n+=...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{....n+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...n+=... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...n+=...}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.n += 444 } { 666 } { B }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { C }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { D }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { E }
% \Test_if_resolve:nnnn { } { X.n += (LENGTH - 1) } { 666 } { F }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { G }
% \Test_if_resolve:nnnn { } { X.n += (-(LENGTH-1)) } { 222 } { H }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { I }
% \Test_if_resolve:nnnn { } { X.n += LENGTH - 1 } { 666 } { J }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { K }
% \Test_if_resolve:nnnn { } { X.n += -444~4 } { 2224 } { L }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_base_resolve_n:
    \__bnvs_n_incr_append:vvvcTF { key } { key_base }  { incr }  { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...n+=... }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n {
        NO~n~incrementation
      }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...+=...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{A+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...+=... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...+=...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_if_resolve:nnnn { } { FIRST } { 222 } { B }
% \Test_if_resolve:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 8 }
% \Test_if_resolve:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 10 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 12 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 16 }
% \Test_if_resolve:nnnn { } { X } { 667 } { 13 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_v_incr_append:vvcTF { key }  { incr }  { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...+=... }
%</!final>
% \end{bnvs.gobble}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n {
        NO~incremented~value
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { base_resolve_n: } {
  \__bnvs_seq_if_empty:cF { path_base } {
    \__bnvs_seq_pop_right:cc { path_base } { a }
    \__bnvs_seq_if_empty:cF { path_base } {
      \__bnvs_tl_put_right:cx { key_base } {
        . \__bnvs_seq_use:cn { path_base } { . }
      }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...BASE~n... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { base_resolve: } {
  \__bnvs_seq_if_empty:cF { path_base } {
    \__bnvs_tl_put_right:cx { key_base } {
      . \__bnvs_seq_use:cn { path_base } { . }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...BASE... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[...++n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...++n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/...++n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.++n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.++n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { X.3.N.++n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_base_resolve:
    \__bnvs_n_incr_append:vvncTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...++n }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~...++n }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[++...n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{++...n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~++...n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:ncTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={if_append:ncTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_append:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_append:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_append:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_append:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_resolve_n:T {
    \__bnvs_base_resolve_n:
    \__bnvs_n_incr_append:vvncTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...n }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~++...n }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[++...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{++...}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log:n { ▃▃▃▃▃~CASE~++... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_path_suffix:nTF { reset } {
    \__bnvs_path_resolve_n:T {
      \__bnvs_v_incr_append:vncTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...reset }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_v_greset:vnT { key } { } { }
        \__bnvs_if_resolve_loop_or_end_return:
      } {
        \__bnvs_v_greset:vnT { key } { } { }
        \__bnvs_if_resolve_end_return_false:n { No~increment }
      }
    }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
  } {
    \__bnvs_path_suffix:nTF { reset_all } {
      \__bnvs_path_resolve_n:T {
        \__bnvs_v_incr_append:vncTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...reset_all }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_greset_all:vnT { key } { } { }
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_greset_all:vnT { key } { } { }
          \__bnvs_if_resolve_end_return_false:n { No~increment }
        }
      }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset_all}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
    } {
      \__bnvs_path_resolve_n:T {
        \__bnvs_v_incr_append:vncTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { No~increment }
        }
      }
    }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c={if_resolve_loop_or_end_return[++...]:}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N } { 112 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N } { 112 } { 4-b }
% \Test_if_resolve:nnnn { } { B } { 112 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
%
% \begin{function}[TF]{
%   \__bnvs_query_eval:nc
% }
% \begin{syntax}
% \cs{__bnvs_query_eval:ncTF} \marg{overlay query} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of |\l__bnvs_ans_tl|.
% Ranges are supported with the colon syntax.
% This is executed within a local \TeX\ group managed by the caller.
% Below are local variables and constants.
% \begin{variable}{\l__bnvs_V_tl}
% Storage for a single value out of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_TEST_A_tl}
% Storage for the first component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_Z_tl}
% Storage for the last component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_L_tl}
% Storage for the length component of a range.
% \end{variable}
% \begin{variable}{\c__bnvs_A_cln_Z_regex}
% Used to parse slide range overlay specifications.
% A, A:Z, A::L on one side, :Z, :Z::L and ::L:Z on the other sides.
% Next are the capture groups.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item 2: V
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( [^:]+? )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 3, 4, 5: A : Z? or A :: L?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( [^:]+? ) \s* : (?: ( \s* [^:]*? ) | : ( \s* [^:]*? ) )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 6, 7: ::(L:Z)?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | :: \s* (?: ( [^:]+? ) \s* : \s* ( [^:]+? ) )?
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 8, 9: :(Z::L)?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | : \s* (?: ( [^:]+? ) \s* :: \s* ( [^:]*? ) )?
  )
  \s* \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}{:N=\c__bnvs_A_cln_Z_regex, noigre}
% \Test_regex:nnnn { A_cln_Z } {V    } {{},{V},{ },{ },{ },{ },{ },{ },{ }} {1}
% \Test_regex:nnnn { A_cln_Z } {A:Z  } {{},{ },{A},{Z},{ },{ },{ },{ },{ }} {2}
% \Test_regex:nnnn { A_cln_Z } {A:   } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3}
% \Test_regex:nnnn { A_cln_Z } {A::L } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4}
% \Test_regex:nnnn { A_cln_Z } {A::  } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5}
% \Test_regex:nnnn { A_cln_Z } {::L:Z} {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6}
% \Test_regex:nnnn { A_cln_Z } {::   } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7}
% \Test_regex:nnnn { A_cln_Z } {:Z::L} {{},{ },{ },{ },{ },{ },{ },{Z},{L}} {8}
% \Test_regex:nnnn { A_cln_Z } {:Z:: } {{},{ },{ },{ },{ },{ },{ },{Z},{ }} {9}
% \Test_regex:nnnn { A_cln_Z } {:    } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10}
% \end{bnvs.test}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { query_eval_end_return_true: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \group_end:
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { query_eval_end_return_false: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { query_eval_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { query_eval_error_end_return_false:n } #1 {
  \__bnvs_error:x { #1 }
  \__bnvs_query_eval_end_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { query_eval_unreachable: } {
  \__bnvs_query_eval_error_end_return_false:n { UNREACHABLE }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_blank:cTF } #1 {
  \BNVS_tl_use:Nc \tl_if_blank:VTF { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_pop_left:c } #1 { T, F, TF } {
  \BNVS_tl_use:nc {
    \BNVS_seq_use:Nc \seq_pop_left:NNTF { match }
  } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { match_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { match_pop_left:cTF } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:cpn { match_pop_left:cT } #1 #2 {
  \BNVS_use:c { match_pop_left:cTF }
    { #1 } { #2 } { \__bnvs_query_eval_unreachable: }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:c={match_pop_left:cTF}, noigre}
% \__bnvs_seq_clear:c { match }
% \__bnvs_seq_put_right:cn { match } { SUCCESS }
% \__bnvs_match_pop_left:cTF { A } {
%   \__bnvs_tl_if_eq:cnF { A } { SUCCESS } {
%     \test_fail:n { A/1 }
%   }
% } {
%   \test_fail:n { A/2 }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \__bnvs_query_eval_match_branch:
% }
% \begin{syntax}
% \cs{__bnvs_query_eval_match_branch:TF} \marg{true code} \marg{false code}
% \end{syntax}
% Puts the proper items of |\l__bnvs_match_seq| in
% |\l__bnvs_V_tl|, |\l__bnvs_TEST_A_tl|, |\l__bnvs_Z_tl|, |\l__bnvs_L_tl|
% then branches accordingly on one of the returning 
% |\__bnvs_query_eval_return[|\meta{description}|]:| functions.
% All these functions properly set the |...ans_tl| variable and they end with either
% |\prg_return_true:| or |\prg_return_false:|.
% This is not inlined for readability.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { query_eval_match_branch: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...MATCH... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_match_pop_left:cT V {
    \__bnvs_match_pop_left:cT V {
      \__bnvs_if_blank:cTF V {
        \__bnvs_match_pop_left:cT A {
          \__bnvs_match_pop_left:cT Z {
            \__bnvs_match_pop_left:cT L {
              \__bnvs_if_blank:cTF A {
                \__bnvs_match_pop_left:cT L {
                  \__bnvs_match_pop_left:cT Z {
                    \__bnvs_if_blank:cTF Z {
                      \__bnvs_if_blank:cTF L {
                        \__bnvs_match_pop_left:cT Z {
                          \__bnvs_match_pop_left:cT L {
                            \__bnvs_if_blank:cTF L {
                              \__bnvs_if_blank:cTF Z {
                                \BNVS_use:c { query_eval_return[:]: }
                              } {
                                \BNVS_use:c { query_eval_return[:Z]: }
                              }
                            } {
                              \__bnvs_if_blank:cTF Z {
\__bnvs_query_eval_error_end_return_false:n { Missing~first~or~last }
                              } {
                                \BNVS_use:c { query_eval_return[:Z::L]: }
                              }
                            }
                          }
                        }
                      } {
\__bnvs_query_eval_error_end_return_false:n { Missing~first~or~last }
                      }
                    } {
                      \__bnvs_if_blank:cTF L {
                        \__bnvs_query_eval_unreachable:
                      } {
                        \BNVS_use:c { query_eval_return[:Z::L]: }
                      }
                    }
                  }
                }
              } {
                \__bnvs_if_blank:cTF Z {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { query_eval_return[A:]: }
                  } {
                    \BNVS_use:c { query_eval_return[A::L]: }
                  }
                } {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { query_eval_return[A:Z]: }
                  } {
                    \__bnvs_query_eval_error_end_return_false:n {
                      Only~two~of~first,~last~or~length
                    }
                  }
                }
              }
            }
          }
        }
      } {
        \BNVS_use:c { query_eval_return[V]: }
      }
    }
  }
}
\BNVS_new:cpn { query_eval_return[V]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} Single value
% \begin{bnvs.test}{bnvs:c={query_eval_return[V]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { V } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[V]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { V } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...[V]...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...[V]...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new:cpn { query_eval_return[A:Z]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:\meta{last}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A:Z]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[A:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \__bnvs_if_append:vcTF { Z } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...[A:Z]...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new:cpn { query_eval_return[A::L]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}::\meta{length}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A::L]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[A::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { A } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { A }
      \__bnvs_tl_put_right:cn { ans } { -1 }
      \__bnvs_round_ans:
      \__bnvs_tl_put_left:cn { ans } { - }
      \__bnvs_tl_put_left:cv { ans } { A }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { query_eval_return[A:]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:} and \texttt{\meta{first}::} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A:]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[A:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222- } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { query_eval_return[:Z::L]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{:Z::L} or \texttt{::L:Z} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:Z::L]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[:Z::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { Z } { Z } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_left:cn  { ans } { 1-}
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \__bnvs_round_ans:
      \__bnvs_tl_put_right:cn { ans } { - }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { query_eval_return[:]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:]:}, noigre}
% \reset:n { Y }
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { - } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \prg_return_true:
}
\BNVS_new:cpn { query_eval_return[:Z]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{::\meta{last}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:Z]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { query_eval_return[:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { -666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \__bnvs_if_append:vcTF { Z } { ans } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { query_eval:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { query_eval:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_query_eval_ncTF:nn { } { ... }
\BNVS_set:cpn { error:n } ##1 {
  \__bnvs_error:n { #1 / ##1 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_call_greset:
  \__bnvs_match_once:NnTF \c__bnvs_A_cln_Z_regex { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...MATCH... }
\BNVS_DEBUG_log_seq:c { match }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_begin:
    \__bnvs_query_eval_match_branch:TF {
      \BNVS_end_tl_set:cv { #2 } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Error
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \__bnvs_error:n { Syntax~error:~#1 }
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c={query_eval:ncTF}, noigre}
% \Test_query:nnnn { 100 } { 1 } { 1 } { 1 }
% \Test_query:nnnn { } { 1+1 } { 2 } { 2 }
% \Test_query:nnnn { } { X.1 } { 100 } { 3a }
% \Test_query:nnnn { } { X.11 } { 110 } { 3b }
% \Test_query:nnnn { } { X.1+X.11 } { 210 } { 3c }
% \Test_query:nnnn { } { X.111 } { 210 } { 4a }
% \Test_query:nnnn { } { X.1:X.111 } { 100-210 } { 4b }
% \Test_query:nnnn { } { X.1::111 } { 100-210 } { 5 }
% \Test_query:nnnn { 4 } { X.1 } { 4 } { 6 }
% \Test_query:nnnn { } { X.0 } { 3 } { 7 }
% \Test_query:nnnn { } { X.-1 } { 2 } { 8 }
% \Test_query:nnnn { } { X.-2 } { 1 } { 9 }
% \Test_query:nnnn { } { X.-3 } { 0 } { 10 }
% \end{bnvs.test}
%
% \begin{function}{
%   \__bnvs_eval:nc
% }
% \begin{syntax}
% \cs{__bnvs_eval:nN} \marg{overlay query list} \meta{tl variable}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated list of \meta{overlay query}'s,
% replacing all the named overlay specifications and integer expressions
% by their static counterparts by calling \cs{__bnvs_query_eval:nc},
% then append the result to the right of the \meta{tl variable}.
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l__bnvs_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l__bnvs_ans_seq}
% Storage of the evaluated result.
% \end{variable}
% \begin{variable}{\c__bnvs_comma_regex}
% Used to parse slide range overlay specifications.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { eval:nc } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { eval:nc } { IN } { #1 } { #2 }
\BNVS_DEBUG_log_eval_nc:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables declaration
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_clear:c { query }
  \__bnvs_seq_clear:c { ans }
%    \end{macrocode}
% \end{bnvs.macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{first}::\meta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:NnN \c__bnvs_comma_regex { #1 } \l__bnvs_query_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Then each component is evaluated and the result is stored in \cs{l__bnvs_ans_seq}
% that we have clear before use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_map_inline:cn { query } {
    \__bnvs_tl_clear:c { ans }
    \__bnvs_query_eval:ncTF { ##1 } { ans } {
      \__bnvs_seq_put_right:cv { ans } { ans }
    } {
      \seq_map_break:n {
        \__bnvs_error:n { Circular/Undefined~dependency~in~#1}
      }
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to the tl variable.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \exp_args:NNnx
  \BNVS_end:
  \__bnvs_tl_put_right:cn { #2 } { \__bnvs_seq_use:cn { ans } , }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c={eval:nc}, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BNVS_DEBUG_log_tl:c { ans }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_eval:nc {X.1} { ans }
% \assert_equal_ans:nn { 222 } { 1 }
% \end{bnvs.test}
%
% \begin{function}{\BeanovesEval}
%   \begin{syntax}
%     \cs{BeanovesEval} \oarg{tl variable} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{__bnvs_eval:nN}
% within a group. \cs{...ans_tl} is used locally to store the result.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesEval { O{} m } {
  \BNVS_begin:
  \keys_define:nn { BeanovesEval } {
    in:N .tl_set:N = \l__bnvs_BeanovesEval_tl,
    in:N .initial:n = { },
    see .bool_set:N = \l__bnvs_BeanovesEval_bool,
    see .default:n = true,
    see .initial:n = false,
  }
  \keys_set:nn { BeanovesEval } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_eval:nc { #2 } { ans }
  \__bnvs_tl_if_empty:cTF { BeanovesEval } {
    \bool_if:nTF { \l__bnvs_BeanovesEval_bool } {
      \BNVS_tl_use:Nv \BNVS_end: { ans }
    } {
      \BNVS_end:
    }
  } {
    \bool_if:nTF { \l__bnvs_BeanovesEval_bool } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
        \BNVS_end:
        \tl_set:Nn ##1 { ##2 }
        ##2
      }
      \BNVS_tl_use:nv {
        \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_BeanovesEval_tl
      } { ans }
    } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
        \BNVS_end:
        \tl_set:Nn ##1 { ##2 }
      }
      \BNVS_tl_use:nv {
        \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_BeanovesEval_tl
      } { ans }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BeanovesEval, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BeanovesEval[in:N=\l__bnvs_TEST_A_tl]{X.2}
% \assert_equal_tl:vnn { TEST_A } { 223 } { 1 }
% \end{bnvs.test}
%
% \subsubsection{Reseting counters}
% \begin{function}{\BeanovesReset, \BeanovesReset*}
%   \begin{syntax}
%     \cs{beanovesReset} \oarg{first value} \marg{key}
%     \cs{beanovesReset}* \oarg{first value} \marg{key}
%   \end{syntax}
% Forwards to \cs{__bnvs_v_greset:nnF} or \cs{__bnvs_greset_all:nnF} when starred.
% \end{function}
% \begin{bnvs.test}{:N=\BeanovesReset, noigre}
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { value }{ FIRST } { 222 } { 1 }
% \Test_v_incr_append:nnnnn { } { ?!X } { 123 } { 345 } { 1 }
% \BeanovesReset{X}
% \Test_what_append_X_ncTF:nnnn { value }{ } { 222 } { 1 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesReset { s O{} m } {
  \__bnvs_name_id_n_get:nTF { #3 } {
    \BNVS_tl_use:nv {
      \IfBooleanTF { #1 } {
        \__bnvs_greset_all:nnF
      } {
        \__bnvs_v_greset:nnF
      }
    } { key } { #2 } {
%      \__bnvs_warning:n { Unknown~name:~#3 }
    }
  } {
    \__bnvs_warning:n { Bad~name:~#3 }
  }
  \ignorespaces
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_off:
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\makeatother
\ExplSyntaxOff
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.gobble}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{bnvs.gobble}
%
% \begin{bnvs.test}{banner=misc, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \banner:n { #1 => #2}
%   \__bnvs_if_resolve:ncTF { #1 } { ans } {
%     \assert_equal_ans:nn { #2 } { A }
%   } {
%     \test_fail:n { B }
%   }
% }
% \Beanoves {
%   Air      = 1 : Gannet.last,
%   Chameleo = Air.2::1,
%   Gannet   = Chameleo.next::1,
%   Water    = Air.next : Picasso.last,
%   Octopus  = Water.2::1,
%   Starfish = Octopus.next::1,
%   StickyStarfish = Starfish.1::1,
%   Picasso = Starfish.next::1,
%   PicassoTrans = 1 : Picasso.previous,
%   Summary  = Water.next::1,
% }
% \BNVS_Test:nn { Chameleo.previous } {1}
% \BNVS_Test:nn { Gannet.previous } {2}
% \BNVS_Test:nn { Water.previous } {3}
% \BNVS_Test:nn { Octopus.previous } {4}
% \BNVS_Test:nn { Starfish.previous } {5}
% \BNVS_Test:nn { PicassoTrans.range } {1-6}
% \BNVS_Test:nn { Air.range } {1-3}
% \BNVS_Test:nn { Chameleo.1 } {2}
% \BNVS_Test:nn { Gannet.1 } {3}
% \BNVS_Test:nn { Water.range } {4-7}
% \BNVS_Test:nn { Octopus.1 } {5}
% \BNVS_Test:nn { Starfish.1 } {6}
% \BNVS_Test:nn { Picasso.range } {7-7}
% \BNVS_Test:nn { Summary.range } {8-8}
% \BNVS_Test:nn { Picasso.1 } {7}
% \BNVS_Test:nn { Air.last } {3}
% \BNVS_Test:nn { StickyStarfish.range } {6-6}
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
%
% \end{implementation}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
%<*internal>
\iffalse
%</internal>
%<*test-lua>
local Command = {}
Command.__index = Command

function Command:clear()
  self.all__ = {}
  self.by_name__ = {}
  self.output__ = {}
end

Command:clear()

function Command:output(message)
  if message == true then
    self.output__ = {}
  elseif message then
    self.output__[#self.output__+1] = message
  end
  return self.output__
end

function Command:already(name, signature) --> Command?
  if signature then
    name = name..":"..signature
  end
  return self.by_name__[name]
end

function Command:base_signature(name) --> String, String?
  local pattern = "^([a-zA-Z_@]*):([NncVvoxefpwDTF]*)"
  local base, signature = name:match(pattern)
  if base then
    return base, signature
  end
  return name
end

function Command:make(name, signature) --> Command?
  -- self:output("name: "..name..", signature: "..(signature or "")..", "..(name:find("bnvs") and "OK" or "KO"))
  if not name:find("bnvs") then
    return nil
  end
  if name:find("q__") then
    return nil
  end
  if name:find("DEBUG") then
    return nil
  end
  if name:len()<7 then
    return nil
  end
  if signature then
    name = name..":"..signature
  end
  local o = self.by_name__[name]
  if o then
    return o
  end
  local base, signature = self:base_signature(name)
  o = {
    name = name,
    base = base,
    signature = signature,
  }
  setmetatable(o, self)
  table.insert(self.all__, o)
  self.by_name__[name] = o
  if name:match("^c__") then
    o.is_constant = true
  elseif name:match("^[lg]__") then
    o.is_variable = true
  else
    o.is_function = true
  end
  return o
end

function iter (a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function Command:sorted()
  table.sort(self.all__, function(l, r) return l.name < r.name end)
  return iter, self.all__, 0
end

function Command:sorted_functions()
  local t = {}
  for _,cmd in self:sorted() do
    if cmd.is_function then
      t[#t+1] = cmd
    end
  end
  return iter, t, 0
end

function Command:parse_all(s)
  local n = 0
  local pattern = "%f[\\]"..--
[[\([a-zA-Z_@:]+)]]
  for name in string.gmatch (s, pattern) do
    if not self:already(name) and self:make(name) then
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs commands parsed")
end

function Command:parse_set_eq(s)
  local n = 0
  local pattern = "\\cs_set_eq:NN%s*"..
"\\([a-zA-Z_@:]+)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command copy")
end

function Command:parse_action(s, action)
  local n = 0
  local pattern = "\\cs_"..action..":Np?n%s+"..
"\\([a-zA-Z_@:]*)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." command definition "..action)
end

function Command:parse_BNVS_action(s, action)
  local n = 0
  local pattern = "\\BNVS_"..action..":cpn%s*{"..
"%s*([a-zA-Z_@:]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_"..name
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command definition "..action)
end

function Command:parse_BNVS_new_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_"..signature..":ncn?%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, name in string.gmatch (s, pattern) do
    name = "__bnvs_"..module.."_"..name
    local cmd = self:make(name..":"..signature)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new definition "..signature)
end

function Command:parse_BNVS_new_tl_signed(s, signature)
  local n = 0
  local pattern = "\\BNVS_new_tl_"..signature..":c?%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_tl_"..name..":"..signature
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new tl definition "..signature)
end

function Command:complete_variant(variant, signature) --> String
  if #variant < #signature then
    local ans = {}
    for i=1,#signature do
      ans[#ans+1] = signature:sub(i, i)
    end
    for i=1,#variant do
      ans[i] = variant:sub(i, i)
    end
    return table.concat(ans)
  end
  return variant
end

function Command:parse_generate_variant(s)
  local n = 0
  local pattern = "\\cs_generate_variant:Nn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_BNVS_generate_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_variant:cn%s*"..
"{%s*"..
"([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    core = "__bnvs_"..core
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_new_conditional(s)
  local n = 0
  local pattern = "\\prg_new_conditional:Npnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"[^{"..--}
"]*{([pTF,%s]-)}"
  for core, conditionals in string.gmatch (s, pattern) do
    local from = self:already(core)
    if from then
      from.is_conditional_core = true
    end
    local base, signature = self:base_signature(core)
    for c in conditionals:gmatch("([pTF]+)") do
      local name = c == "p" and (signature and base.."_p:"..signature or core.."_p") or core..c
      local generated = self:make(name)
      if generated then
        generated.is_defined = true
        generated.conditional_core = core
        n = n+1
      end
    end
  end
  self:output("-> "..n.." bnvs conditionals created")
end

function Command:parse_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\prg_generate_conditional_variant:Nnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_conditional_variant:cnn%s*"..
"{%s*([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    base = "__bnvs_"..base
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." "..signature.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional_nc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_([a-z]*):ncn?%s*{%s*"..
"([a-z]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for signature, module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs ncn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_cc:ncnn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":cc"..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":ncn*%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_tl(s, signature, is_tl)
  is_tl = is_tl == nil and false or is_tl
  local n = 0
  local pattern = "BNVS_new_conditional_tl_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  local prefix = is_tl and "__bnvs_tl_" or "__bnvs_"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = prefix..base..":"..signature..c
  self:output("-> "..name)
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cpnn(s)
  local n = 0
  local pattern = "BNVS_new_conditional:cpnn%s*{%s*"..
"([a-zA-Z_@]*):([a-zA-Z_@]*)%s*}[^{"..--}
"]*{%s*"..
"([pTF,%s]*)%s*}"
  local pattern_pTF = "([pTF]+)"
  for base, signature, pTFs in string.gmatch(s, pattern) do
    for pTF in string.gmatch(pTFs, pattern_pTF) do
      local name = "__bnvs_"..base
      if pTF == "p" then
        name = name.."_p:"..signature
      else
        name = name..":"..signature..pTF
      end
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = pTF == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = pTF == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs raw conditional variants generated")
end

function Command:check_unused_variants()
  self:output("-> check for unused variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused variants...DONE")
end

function Command:check_unused_conditional_variants(skip)
  if skip then
    return
  end
  self:output("-> check for unused conditional variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused_conditional then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused conditional variants...DONE")
end

function Command:check_undefined()
  self:output("-> check for undefined...")
  for _,cmd in self:sorted_functions() do
    if not cmd.is_defined and not cmd.is_conditional_core then
      if cmd.name:len() > 7 then
        self:output("!!!! "..cmd.name)
      end
    end
  end
  self:output("-> check for undefined...DONE")
end

function Command:check_variants(s) --> [String]
  self:clear()
  self:parse_all(s)
  self:parse_set_eq(s)
  self:parse_action(s,"new")
  self:parse_action(s,"set")
  self:parse_BNVS_action(s,"new")
  self:parse_BNVS_action(s,"set")
  self:parse_generate_variant(s)
  self:parse_BNVS_generate_variant(s)
  self:parse_new_conditional(s)
  self:parse_BNVS_new_signed(s, "c")
  self:parse_BNVS_new_signed(s, "cc")
  self:parse_BNVS_new_signed(s, "cn")
  self:parse_BNVS_new_signed(s, "cv")
  self:parse_BNVS_new_signed(s, "cnn")
  self:parse_BNVS_new_signed(s, "cnv")
  self:parse_BNVS_new_signed(s, "cnx")
  self:parse_BNVS_new_tl_signed(s, "c")
  self:parse_BNVS_new_tl_signed(s, "cn")
  self:parse_BNVS_new_tl_signed(s, "cv")
  self:parse_BNVS_new_conditional_cpnn(s)
  self:parse_BNVS_new_conditional_signed(s, "c")
  self:parse_BNVS_new_conditional_signed(s, "nc")
  self:parse_BNVS_new_conditional_signed(s, "cc")
  self:parse_BNVS_new_conditional_signed(s, "cn")
  self:parse_BNVS_new_conditional_signed(s, "cnn")
  self:parse_BNVS_new_conditional_signed(s, "cnv")
  self:parse_BNVS_new_conditional_signed(s, "cnx")
  self:parse_BNVS_new_conditional_tl(s, "cn", true)
  self:parse_BNVS_new_conditional_tl(s, "cv", true)
  self:parse_BNVS_new_conditional_tl(s, "vnc", false)
  self:parse_BNVS_new_conditional_tl(s, "vvc", false)
  self:parse_BNVS_new_conditional(s, "Nn")
  self:parse_BNVS_new_conditional(s, "Nv")
  self:parse_BNVS_new_conditional(s, "nn")
  self:parse_BNVS_new_conditional(s, "c")
  self:parse_BNVS_new_conditional(s, "cc")
  self:parse_BNVS_new_conditional(s, "cv")
  self:parse_BNVS_new_conditional(s, "vc")
  self:parse_BNVS_new_conditional(s, "vnc")
  self:parse_BNVS_new_conditional(s, "vvc")
  self:parse_BNVS_new_conditional(s, "vvnc")
  self:parse_BNVS_new_conditional(s, "vvvc")
  self:parse_generate_conditional_variant(s)
  self:parse_BNVS_generate_conditional_variant(s)
  self:check_unused_variants()
  self:check_unused_conditional_variants(true)
  self:check_undefined()
  return self:output()
end
local function check_variants (path) --> string?
  local file = io.open(path, "r")
  if file == nil then
    return nil
  end
  local s = file:read("a")
  file:close()
  local ra1 = Command:check_variants([[
\BNVS_set:cpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
\cs_generate_variant:Nn \__bnvs_v_gput:nn { nV }
\bnvs_TEST_A:n
\bnvs_TEST_B:nn
\cs_set:Npn \bnvs_TEST_B:nn {}
\cs_new:Npn \bnvs_C:nn {}
\BNVS_new_conditional:cpnn { get:nnc } #1 #2 #3 { p, T, F, TF } {}
\_generate_conditional_variant:Nnn
  \__bnvs_get:nnc {nV} { p, T, F, TF }
]])
  local ra2 = Command:check_variants(s)
  for _,v in ipairs(ra2) do
    ra1[#ra1+1] = v
  end
  return ra2
end
return {
  __INFO__ = "beanoves dedicated table for DEBUGGING",
  check_variants  = check_variants,
  Command__ = Command,
}
%</test-lua>
%<*internal>
\fi
%</internal>
