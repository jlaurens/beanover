% \iffalse meta-comment
% !TEX program  = LuaLaTeX
%
%% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2022 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of multiple time lines in |beamer| documents.
Time lines are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay ranges

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf and
                                beanoves.sty.

\endpostamble
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% ! TeX proot = ...
\ProvideDocumentCommand\directlua{m}{\wlog{Run with LuaLaTeX}}
\directlua {
  local cmd = 'pdftex "\jobname.dtx"'
  local f = assert(io.popen(cmd, 'r')) 
  local s = assert(f:read('*a')) 
  f:close() 
}
\documentclass{l3doc}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\tcbuselibrary{minted}
\RequirePackage{beanoves}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specification with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{beanoves.sty}
\date{\fileversion \qquad \filedate}
\begin{document}
\maketitle
\changes{v1.0}{2009/10/06}{First public release}
\begin{abstract}
This package allows the management of multiple slide lists in |beamer| documents.
Slide lists are very handy both during edition and to manage complex and variable \pkg{beamer} overlay specifications.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanoves}
\begin{document}
\Beanoves {
      A = 1:2,
      B = A.next:3,
      C = B.next,
    }
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.1)-?(B.last)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2::B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.3)-> {From slide 3}\\
\visible<?(B.3::B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare named slide ranges.
On line 5, we declare a slide range named `A', starting at slide 1 and with length 2.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1,
on line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.3)} stands for 3.
%
On line 6, we declare a second slide range named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last slide number is 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide number after slide range `B' is 6
which is also the start of the third slide range
due to line 7.
\section{Named slide lists}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn.
The main slide list is a range on integers covering all the slide numbers, from one to the total amount of slides.
In general, a slide list is a range of positive integers identified by a unique name.
The main practical interest is that such lists may be defined relative to one another, we can even have lists of slide ranges.
Finally, we can use these lists to organize \pkg{beamer} overlay specifications logically.
%
\subsection{Defining named slide lists}
In order to define named slide lists, we can either use the |\Beanoves| command below before a \pkg{beamer} frame environment, or use the |beanoves| option of this environment.
The value of the |beanoves| option is similar to the argument of the |\Beanoves| commands, but the latter takes precedence on the former.
This behaviour may be useful to input the very same source code into different frames and have different combinations of slides.
%
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{
    \phantom{xx}\meta{name_1}=\meta{spec_1},
    \phantom{xx}\meta{name_2}=\meta{spec_2},
    \phantom{xx}...,
    \phantom{xx}\meta{name_n}=\meta{spec_n},
    \}
  \end{syntax}
\end{function}
\begin{function}{\Beanoves}
  \begin{syntax}
    \cs{Beanoves}\{
    \phantom{xx}\meta{name_1}=\meta{spec_1},
    \phantom{xx}\meta{name_2}=\meta{spec_2},
    \phantom{xx}...,
    \phantom{xx}\meta{name_n}=\meta{spec_n},
    \}
  \end{syntax}
\end{function}
The keys \meta{name_i} are the slide lists names, they are case sensitive and must contain no spaces nor `|/|' character.
In order to avoid name conflicts with floating point functions, it is suggested to let them contain an uppercase letter ot an underscore.
When the same key is used multiple times, only the last one is taken into account.
Possible values for \meta{spec_i} are the \emph{slide range specifiers} \meta{first},
\meta{first}:\meta{length}, \meta{first}::\meta{last}, :\meta{length}::\meta{last}
where \meta{first}, \meta{length} and \meta{last} are algebraic expression involving any integer valued named overlay specifications defined below.

Also possible values are \emph{slide list specifiers} which are comma separated list of \emph{slide range specifiers} and \emph{slide list specifier} between square brackets.
The definition
\\[0.2ex]
\hphantom{xx}\meta{name}|=[|\meta{spec_1}|,|\meta{spec_2}|,...,|\meta{spec_n}|]|,
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\meta{name}|.1=|\meta{spec_1}|,|
\\\hphantom{xx}\meta{name}|.2=|\meta{spec_2}|,|
\\\hphantom{xx}|...,|
\\\hphantom{xx}\meta{name}|.|\textit{n}|=|\meta{spec_n}.
\\[0.2ex]
The rules above can apply individually to each
\\[0.2ex]
\hphantom{xx}\meta{name}|.|\rlap{\textit{i}}\phantom{|i|}|=|\meta{spec_i}.
\\[0.2ex]
Moreover we can go deeper: the definition
\\[0.2ex]
\hphantom{xx}\meta{name}|=[[|\meta{spec_{1.1}}|,| \meta{spec_{1.2}}|],[[|\meta{spec_{2.1}}|,| \meta{spec_{2.2}}|]]|
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\meta{name}|.1.1=|\meta{spec_{1.1}}|,|
\\\hphantom{xx}\meta{name}|.1.2=|\meta{spec_{1.2}}|,|
\\\hphantom{xx}\meta{name}|.2.1=|\meta{spec_{2.1}}|,|
\\\hphantom{xx}\meta{name}|.2.2=|\meta{spec_{2.2}}
\\[0.2ex]
and so on.
%
\section{Named overlay specifications}
%
\subsection{Named slide ranges}
When \emph{slide range specifications} are used, the named overlay specifications are detailled in the tables below together with
their replacement meaning value as \pkg{beamer} standard overlay specification.
%
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\multicolumn{2}{c}{\ttfamily \meta{name} == [\(i\), \(i+1\), \(i+2\),...]}
\\\hline
\bfseries \textrm{syntax} & \bfseries \textrm{meaning} 
\\\hline
\meta{name}.1 & \(i\)\\
\meta{name}.2 & \(i+1\) \\
\meta{name}.\meta{integer} & \(i+ \meta{integer} - 1\) \\
\hline
\end{tabular}
\end{center}
In the frame example below, we use the \cs{BeanovesEval} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:6,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval(A.1) ==3,
\BeanovesEval(A.2) ==4,
\BeanovesEval(A.-1)==1,
\end{frame}
\end{tcblisting}
%
When the slide range has been given a length or an end,
like in the frame example below, we also have
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|l|l}
\hline
\multicolumn{4}{c|}{\ttfamily \meta{name} == [\(i\), \(i+1\),..., \(j\)]}
\\\hline
\bfseries \textrm{syntax} & \bfseries \textrm{meaning} & \bfseries \textrm{example} & \bfseries \textrm{output}
\\\hline
\meta{name}.length & \(j-i+1\) & A.length & 6\\
\meta{name}.last & \(j\) & A.last & 8\\
\meta{name}.next & \(j+1\) & A.next & 9\\
\meta{name}.range & \(i\) ''-'' \(j\) & A.range & 3-8\\
\hline
\end{tabular}
\end{center}
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:6,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval(A.length) == 6,
\BeanovesEval(A.1)      == 3,
\BeanovesEval(A.2)      == 4,
\BeanovesEval(A.-1)     == 1,
\end{frame}
\end{tcblisting}
%
Using these specification on unfinite named slide ranges is unsupported.
%
Finally each named slide range has a dedicated counter \texttt{\meta{name}.n}
which is some kind of variable that can be used and incremented\footnote{This is actually an experimental feature.}.
\begin{description}
\item[\ttfamily\meta{name}.n]: use the position of the counter 
\item[\ttfamily\meta{name}.n+=\meta{integer}]: advance the counter by \meta{integer} and use the new position
\item[\ttfamily++\meta{name}.n]: advance the counter by 1 and use the new position
\end{description}
Notice that ``|.n|'' can generally be omitted.
%
\subsection{Named slide lists}
After the definition
\\[0.2ex]
\hphantom{xx}\meta{name}|=[|\meta{spec_1}|,|\meta{spec_2}|,...,|\meta{spec_n}|]|
\\[0.2ex]
the rules of the previous section apply recursively to each individual
declaration
\\[0.2ex]\hphantom{xx}\meta{name}|.|\rlap{\textit{i}}\hphantom{|i|}|=|\meta{spec_i}.
%
\section{\texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\meta{queries})}'. Each one is then evaluated and replaced by its static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s of next table.
Sometimes, using \texttt{\meta{name}.range} is not allowed as it would lead to
an algeabraic difference instead of a range.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{query} & \bfseries \textrm{static value} & \bfseries \textrm{limitation}
\\\hline
|:| & -\\
|::| & -\\
\meta{first expr} & \meta{first}\\
\meta{first expr}|:| & \meta{first} - & \textrm{no }\meta{name}.range \\
\meta{first expr}|::| & \meta{first} - & \textrm{no }\meta{name}.range \\
\meta{first expr}|:|\meta{length expr} & \meta{first} - \meta{last} & \textrm{no }\meta{name}.range \\
\meta{first expr}|::|\meta{end expr} & \meta{first} - \meta{last}  & \textrm{no }\meta{name}.range \\
\hline
\end{tabular}
\end{center}
Here \meta{first expr}, \meta{length expr} and \meta{end expr}
both denote algebraic expressions possibly involving named overlay specifications and counters.
As integers, they respectively evaluate to \meta{first}, \meta{length} and \meta{last}.

For example both \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been properly defined with a length.

Notice that nesting \texttt{?(...)} expressions is not supported.


\end{documentation}
\DocInput{beanoves.dtx}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=beanoves>
%    \end{macrocode}
%
% \subsection{Package declarations}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
  {beanoves}
  {2022/10/28}
  {1.0}
  {Named overlay specifications for beamer}
\cs_new:Npn \@@_DEBUG_on: {
  \cs_set:Npn \@@_DEBUG:n ##1 {
    \msg_term:nnn { beanoves } { :n } { ##1 }
  }
}
\cs_new:Npn \@@_DEBUG_off: {
  \cs_set_eq:NN \@@_DEBUG:n \use_none:n
}
\@@_DEBUG_off:
\cs_generate_variant:Nn \@@_DEBUG:n { x, V }
\int_zero_new:N \l_@@_group_int
\cs_set:Npn \@@_group_begin: {
  \group_begin:
  \int_incr:N \l_@@_group_int
\@@_DEBUG:x {GROUP~DOWN:~\int_use:N \l_@@_group_int}
}
\cs_set:Npn \@@_group_end: {
  \group_end:
\@@_DEBUG:x {GROUP~UP:~\int_use:N \l_@@_group_int}
}
%    \end{macrocode}
%
% \begin{implementation}
% \ExplSyntaxOn
% \NewDocumentEnvironment{test}{}
%   {\color{red}\bfseries\ExplSyntaxOn\__beanoves_gclear:\int_gset:Nn \g__beanoves_append_int { 128 } }
%   {\__beanoves_gclear:\ExplSyntaxOff\ignorespacesafterend}
% \ExplSyntaxOff
%
% \NewDocumentEnvironment{myFailure}{}
%   {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{0pt}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
% \ExplSyntaxOn
% \cs_set:Npn \myDebug #1 {
%   \begin{list}{\llap{\emoji{no-entry}\quad}}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}
%   \clist_map_inline:nn { #1 } {
%     \item \exp_args:Nx \use:n { ##1 }
%   }
%   \end{list}
% }
% \cs_set:Npn \__beanoves_test_extract:nnnn #1 #2 #3 #4 {
%   \regex_extract_once:nnNTF { #1 } { #2 } \l_match_seq {
%     \tl_set:Nx \l_a_tl { \seq_use:Nn \l_match_seq , }
%     \seq_set_from_clist:Nn \l_split_seq { #3 }
%     \tl_set:Nx \l_b_tl { \seq_use:Nn \l_split_seq , }
%     \exp_args:Nxx \tl_if_eq:nnF { \l_a_tl } { \l_b_tl } {
%       \begin{myFailure}
%       \item FAILURE~`\l_a_tl'!=`\l_b_tl'
%       \item #4~(#2)
%       \end{myFailure}
%     }
%   } {
%     \begin{myFailure}{}
%     \item FAILURE~NO~MATCH
%     \item #4~(#2)
%     \end{myFailure}
%   }
% }
% \cs_set:Npn \__beanoves_test_extract:Nnnn #1 #2 #3 #4 {
%   \regex_extract_once:NnNTF #1 { #2 } \l_match_seq {
%     \tl_set:Nx \l_a_tl { \seq_use:Nn \l_match_seq , }
%     \seq_set_from_clist:Nn \l_split_seq { #3 }
%     \tl_set:Nx \l_b_tl { \seq_use:Nn \l_split_seq , }
%     \exp_args:Nxx \tl_if_eq:nnF { \l_a_tl } { \l_b_tl } {
%       \begin{myFailure}
%       \item FAILURE~`\l_a_tl'!=`\l_b_tl'
%       \item #4~(#2)
%       \end{myFailure}
%     }
%   } {
%     \begin{myFailure}
%     \item FAILURE~NO~MATCH
%     \item #4~(#2)
%     \end{myFailure}
%   }
% }
% \cs_set:Npn \__beanoves_test_split:Nnnn #1 #2 #3 #4 {
%   \regex_split:NnN #1 { #2 } \l_match_seq
%   \tl_set:Nx \l_a_tl { \seq_use:Nn \l_match_seq , }
%   \seq_set_from_clist:Nn \l_split_seq { #3 }
%   \tl_set:Nx \l_b_tl { \seq_use:Nn \l_split_seq , }
%   \exp_args:Nxx \tl_if_eq:nnF { \l_a_tl } { \l_b_tl } {
%     \begin{myFailure}
%     \item FAILURE~`\l_a_tl'!=`\l_b_tl'
%     \item Test~split~#4~(#2)
%     \end{myFailure}
%   }
% }
% \cs_set:Npn \__beanoves_assert_equal:nnn #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { #2 } {
%     \msg_error:nnn { beanoves } { :n } { FAILED~`#1'!=`#2' }
%     \begin{myFailure}
%     \item FAILURE~`#1'!=`#2'
%     \item #3
%     \end{myFailure}
%   }
% }
% \cs_generate_variant:Nn \__beanoves_assert_equal:nnn { xxn }
% \ExplSyntaxOff
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% In that case, variables need not follow exactly the \LaTeX3\ naming convention:
% we do not specialize with the module name.
% On execution, next initialization instructions declare the variables as side effect.
%    \begin{macrocode}
\int_zero_new:N  \l_@@_split_int
\int_zero_new:N  \l_@@_depth_int
\int_zero_new:N  \g_@@_append_int
\bool_new:N \l_@@_no_counter_bool
\bool_new:N \l_@@_no_range_bool
\bool_new:N \l_@@_continue_bool
%    \end{macrocode}
%
% \subsection{Overlay specification}
% \subsubsection{In slide range definitions}
% \begin{variable} {\g_@@_prop}
% \meta{key}--\meta{value} property list to store the named slide lists.
% The basic keys are, assuming \meta{name} is a slide list identifier,
% \begin{description}
% \item [\texttt{\meta{name}/A}] for the first index
% \item [\texttt{\meta{name}/L}] for the length when provided
% \item [\texttt{\meta{name}/Z}] for the last index when provided
% \item [\texttt{\meta{name}/C}] for the counter value, when used
% \item [\texttt{\meta{name}/C0}] for initial value of the counter (when reset)
% \end{description}
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges. They are characterized by a `|//|'.
% \begin{description}
% \item [\texttt{\meta{name}//A}] for the cached static value of the first index
% \item [\texttt{\meta{name}//Z}] for the cached static value of the last index
% \item [\texttt{\meta{name}//L}] for the cached static value of the length
% \item [\texttt{\meta{name}//N}] for the cached static value of the next index
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
%    \begin{macrocode}
\prop_new:N \g_@@_prop
%    \end{macrocode}
% \end{variable}
% \begin{function}{\@@_gput:nn,\@@_gput:nV,\@@_gprovide:nn,\@@_gprovide:nV,\@@_item:n,\@@_get:nN,\@@_gremove:n,\@@_gclear:n,\@@_gclear_cache:n,\@@_gclear:}
% \begin{syntax}
% \cs{@@_gput:nn} \marg{key} \marg{value}
% \cs{@@_gprovide:nn} \marg{key} \marg{value}
% \cs{@@_item:n} \marg{key}
% \cs{@@_get:n} \marg{key} \meta{tl variable}
% \cs{@@_gremove:n} \marg{key}
% \cs{@@_gclear:n} \marg{key}
% \cs{@@_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions,
% except \cs{@@_gprovide:nn} which meaning is straightforward.
%    \begin{macrocode}
\cs_new:Npn \@@_gput:nn {
  \prop_gput:Nnn \g_@@_prop
}
\cs_new:Npn \@@_gprovide:nn #1 #2 {
  \prop_if_in:NnF \g_@@_prop { #1 } {
    \prop_gput:Nnn \g_@@_prop { #1 } { #2 }
  }
}
\cs_new:Npn \@@_item:n {
  \prop_item:Nn \g_@@_prop
}
\cs_new:Npn \@@_get:nN {
  \prop_get:NnN \g_@@_prop
}
\cs_new:Npn \@@_gremove:n {
  \prop_gremove:Nn \g_@@_prop
}
\cs_new:Npn \@@_gclear:n #1 {
  \clist_map_inline:nn { A, L, Z, C, C0, /, /A, /L, /Z, /N } {
    \@@_gremove:n { #1 / ##1 }
  }
}
\cs_new:Npn \@@_gclear_cache:n #1 {
  \clist_map_inline:nn { /A, /L, /Z, /N } {
    \@@_gremove:n { #1 / ##1 }
  }
}
\cs_new:Npn \@@_gclear: {
  \prop_gclear:N \g_@@_prop
}
\cs_generate_variant:Nn \@@_gput:nn { nV }
\cs_generate_variant:Nn \@@_gprovide:nn { nV }
%    \end{macrocode}
% \end{function}
% \begin{function}[pTF]{\@@_if_in:n,\@@_if_in:V}
% \begin{syntax}
% \cs{@@_if_in_p:n} \marg{key}
% \cs{@@_if_in:nTF} \marg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to test for the existence of some key, it makes the code more concise and readable.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g_@@_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn \@@_if_in:n {V} { p, T, F, TF }
%    \end{macrocode}
% \end{function}
% \begin{function}[TF]{\@@_get:nN}
% \begin{syntax}
% \cs{@@_get:nNTF} \marg{key} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{true code} when the item is found, \meta{false code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_get:nN #1 #2 { T, F, TF } {
  \prop_get:NnNTF \g_@@_prop { #1 } #2 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{test}
% \cs_set:Npn \Test:xxn #1 #2 #3 {
%   \__beanoves_assert_equal:xxn { #1 } { #2 } {Test~\cs{__beanoves_g(put|remove|clear|...):nn}~#3}
% }
% \__beanoves_gput:nn { A } { B }
% \Test:xxn { \__beanoves_item:n {A} } { B } { 1 }
% \Test:xxn { \__beanoves_if_in:nTF {A} TF } { T } { 3 }
% \Test:xxn { \__beanoves_if_in:nTF {B} TF } { F } { 4 }
% \Test:xxn { \__beanoves_if_in:nT {A} T } { T } { 5 }
% \Test:xxn { \__beanoves_if_in:nT {B} T } { } { 6 }
% \Test:xxn { \__beanoves_if_in:nF {A} F } { } { 7 }
% \Test:xxn { \__beanoves_if_in:nF {B} F } { F } { 8 }
% \Test:xxn { \bool_if:nTF { \__beanoves_if_in_p:n {A} } TF } { T } { 9 }
% \Test:xxn { \bool_if:nTF { \__beanoves_if_in_p:n {B} } TF } { F } { 10 }
% \Test:xxn { \bool_if:nTF { \__beanoves_if_in_p:n {B} || \__beanoves_if_in_p:n {A} } TF } { T } { 11 }
% \tl_clear:N \l_b_tl
% \__beanoves_get:nNTF {A} \l_b_tl {
%   \tl_set:Nn \l_b_tl { SUCCESS }
% } {
%   \tl_set:Nn \l_b_tl { FAILURE }
% }
% \Test:xxn { \l_b_tl } { SUCCESS } { 13 }
% \__beanoves_get:nNTF {B} \l_b_tl {
%   \tl_set:Nn \l_b_tl { FAILURE }
% } {
%   \tl_set:Nn \l_b_tl { SUCCESS }
% }
% \Test:xxn { \l_b_tl } { SUCCESS } { 13 }
% \end{test}
% Utility message.
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
%    \end{macrocode}
%
% \subsubsection{Regular expressions}
%
% \begin{variable}{\c@@_name_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
%    \begin{macrocode}
\regex_const:Nn \c@@_name_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_name_regex {A} {A} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_name_regex {_A1} {_A1} {Test~2}
% \end{test}
% \end{variable}
% \begin{variable}{\c@@_path_regex}
% A sequence of \texttt{.\meta{positive integer}} items representing a path.
%    \begin{macrocode}
\regex_const:Nn \c@@_path_regex {
  (?: \. \d+ )*
}
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_path_regex {} {} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_path_regex {.1} {.1} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_path_regex {.1.2} {.1.2} {Test~3}
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_key_regex, \c@@_A_key_Z_regex}
% A key is the name of a slide range possibly followed by positive integer attributes
% using a dot syntax.
% The `|A_key_Z|' variant matches the whole string.
%    \begin{macrocode}
\regex_const:Nn \c@@_key_regex {
  \ur{c@@_name_regex} \ur{c@@_path_regex}
}
\regex_const:Nn \c@@_A_key_Z_regex { 
  \A \ur{c@@_key_regex} \Z
}
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {A} {A} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {_A1} {_A1} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {A.1} {A.1} {Test~3}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {_A1.1} {_A1.1} {Test~4}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {_A1.1.2} {_A1.1.2} {Test~5}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex {(_A1.1.2)} {_A1.1.2} {Test~6}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_key_Z_regex {A} {A} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_key_Z_regex {_A1} {_A1} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_key_Z_regex {A.1} {A.1} {Test~3}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_key_Z_regex {_A1.1} {_A1.1} {Test~4}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_key_Z_regex {_A1.1.2} {_A1.1.2} {Test~5}
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_dotted_regex}
% A specifier is the name of a slide range possibly followed by attributes
% using a dot syntax.
% This is a poor man version to save computations,
% a dedicated parser would help in error management.
%    \begin{macrocode}
\regex_const:Nn \c@@_dotted_regex {
  \A \ur{c@@_name_regex} (?: \. [^.]+ )* \Z
}
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {A} {A} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {_A1} {_A1} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {A.1} {A.1} {Test~3}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {_A1.-1} {_A1.-1} {Test~4}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {_A1.-1.2} {_A1.-1.2} {Test~5}
% \__beanoves_test_extract:Nnnn \c__beanoves_dotted_regex {_A1.range} {_A1.range} {Test~6}
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_colons_regex}
% For ranges defined by a colon syntax.
%    \begin{macrocode}
\regex_const:Nn \c@@_colons_regex { :(:+)? }
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_split:Nnnn \c__beanoves_colons_regex
%   { A:C } {{A},{},{C}} {Test~1}
% \__beanoves_test_split:Nnnn \c__beanoves_colons_regex
%   { A::C } {{A},{:},{C}} {Test~2}
% \__beanoves_test_split:Nnnn \c__beanoves_colons_regex
%   { A:::C } {{A},{::},{C}} {Test~3}
% \__beanoves_test_split:Nnnn \c__beanoves_colons_regex
%   { :B::C } {{},{},{B},{:},{C}} {Test~4}
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_int_regex}
% A decimal integer with an eventual leading sign next to the first digit.
%    \begin{macrocode}
\regex_const:Nn \c@@_int_regex {
  (?:[-+])? \d+
}
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_int_regex
%   {421} {421} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_int_regex
%   {+421} {+421} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_int_regex
%   {-421} {-421} {Test~3}
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_list_regex}
% A comma separated list between square brackets.
%    \begin{macrocode}
\regex_const:Nn \c@@_list_regex {
  \A \[ \s*
%    \end{macrocode}
% Capture groups:
% \begin{myList}
% \item 2: the content between the brackets, outer spaces trimmed out
%    \begin{macrocode}
    ( [^\] %[---
    ]*? )
  \s* \] \Z
}
%    \end{macrocode}
% \end{myList}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_list_regex
%   {[]} {[],{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_list_regex
%   {[x]} {[x], x} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_list_regex
%   {[~x~]} {[~x~],{x}} {Test~3}
% \__beanoves_test_extract:Nnnn \c__beanoves_list_regex
%   {[~x[~]} {[~x[~],{x[}} {Test~4}
% 
% \end{test}
% \end{variable}
%
% \begin{variable}{\c@@_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 10 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
%    \begin{macrocode}
\regex_const:Nn \c@@_split_regex {
  \s* ( ? :
%    \end{macrocode}
% We start with `|++|' instrussions
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
%   \begin{myList}
%   \item 1: \meta{name} of a slide range
%    \begin{macrocode}
    \+\+ ( \ur{c@@_name_regex} )
%    \end{macrocode}
%   \item 2: optionally followed by an integer path
%    \begin{macrocode}
    ( \ur{c@@_path_regex} ) (?: \. n )?
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ++ABC.n } {{++ABC.n},{ABC},{},{},{},{},{},{},{},{},{},{}} {Test~2a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ++ABC.1.2.n~~ } {{++ABC.1.2.n~~},{ABC},{.1.2},{},{},{},{},{},{},{},{},{}} {Test~2b}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ++ABC } {{++ABC},{ABC},{},{},{},{},{},{},{},{},{},{}} {Test~2c}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ++ABC.1.2~~ } {{++ABC.1.2~~},{ABC},{.1.2},{},{},{},{},{},{},{},{},{}} {Test~2d}
% \end{test}
% We continue with other expressions
%   \item 3: \meta{name} of a slide range
%    \begin{macrocode}
  | ( \ur{c@@_name_regex} )
%    \end{macrocode}
%   \item 4: optionally followed by an integer path
%    \begin{macrocode}
    ( \ur{c@@_path_regex} )
%    \end{macrocode}
% Next comes another branching
%    \begin{macrocode}
    (?:
%    \end{macrocode}
%   \item 5: the \meta{length} attribute
%    \begin{macrocode}
       \. l(e)ngth
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.length } {{A.length},{},{},{A},{},{e},{},{},{},{},{},{}} {Test~5a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.length } {{A.1.2.length},{},{},{A},{.1.2},{e},{},{},{},{},{},{}} {Test~5b}
% \end{test}
%   \item 6: the \meta{last} attribute
%    \begin{macrocode}
    |  \. l(a)st
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.last } {{A.last},{},{},{A},{},{},{a},{},{},{},{},{}} {Test~6a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.last } {{A.1.2.last},{},{},{A},{.1.2},{},{a},{},{},{},{},{}} {Test~6b}
% \end{test}
%   \item 7: the \meta{next} attribute
%    \begin{macrocode}
    |  \. ne(x)t
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.next } {{A.next},{},{},{A},{},{},{},{x},{},{},{},{}} {Test~7a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.next } {{A.1.2.next},{},{},{A},{.1.2},{},{},{x},{},{},{},{}} {Test~7b}
% \end{test}
%   \item 8: the \meta{range} attribute
%    \begin{macrocode}
    |  \. (r)ange
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.range } {{A.range},{},{},{A},{},{},{},{},{r},{},{},{}} {Test~8a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.range } {{A.1.2.range},{},{},{A},{.1.2},{},{},{},{r},{},{},{}} {Test~8b}
% \end{test}
%   \item 9: the \meta{n} attribute
%    \begin{macrocode}
    |  \. (n)
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.n } {{A.n},{},{},{A},{},{},{},{},{},{n},{},{}} {Test~9a}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.n } {{A.1.2.n},{},{},{A},{.1.2},{},{},{},{},{n},{},{}} {Test~9b}
% \end{test}
%   \item 10: the poor man integer expression after `|+=|'.
%   When it contains no parenthesis, it is an algebraic expression involving
%   integers and \meta{key}'s.
%   Otherwise it starts with a parenthesis and ends with the first parenthesis
%   followed by a white space or the end of the text.
%   This tricky definition allows quite any algebraic expression involving parenthesis.
%   The problems may arise when dealing with nested expressions.
%    \begin{macrocode}
        (?: \s* \+= \s*
          ( (?: \ur{c@@_int_regex} | \ur{c@@_key_regex} )
            (?: [+\-*/] (?: \d+ | \ur{c@@_key_regex}) )*
          | \( .*? \) (?: \Z | \s+ )
          )
        )?
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ABC.n += 421 } {{ABC.n += 421},{},{},{ABC},{},{},{},{},{},{n},{421},{}} {Test~`+='~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_key_regex
%   { P.1 } {P.1} {Test~`+='~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ABC.n += 1+P.1 } {{ABC.n += 1+P.1},{},{},{ABC},{},{},{},{},{},{n},{1+P.1},{}} {Test~`+='~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ABC.n += 1+P.1X } {{ABC.n += 1+P.1},{},{},ABC,{},{},{},{},{},{n},{1+P.1},{}} {Test~`+='~3}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { ABC.n += (P.1+1)~~^^A(
% ) } {{ABC.n += (P.1+1)~},{},{},ABC,{},{},{},{},{},{n},{(P.1+1)~},{}} {Test~`+='~4}
% \end{test}
%    \begin{macrocode}
    | \. ( - \ur{c@@_int_regex} )
%    \end{macrocode}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.-1 } {A.-1,{},{},{A},{},{},{},{},{},{},{},{-1}} {Test~`.-'~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_split_regex
%   { A.1.2.-1 } {A.1.2.-1,{},{},{A},{.1.2},{},{},{},{},{},{},{-1}} {Test~`.-'~1}
% \end{test}
%    \begin{macrocode}
    )?
%    \end{macrocode}
% \end{myList}
%    \begin{macrocode}
  ) \s*
}
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{\pkg{beamer.cls} interface}
%    \begin{macrocode}
\RequirePackage{keyval}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l@@_id_tl { #1 }
  \@@_DEBUG_on:
  \@@_DEBUG:x {**********~THIS_IS_KEY}
  \@@_DEBUG_off:
}
\AddToHook{env/beamer@frameslide/before}{
  \@@_DEBUG_on:
  \@@_DEBUG:x {**********~THIS_IS_BEFORE}
  \@@_DEBUG_off:
}
\AddToHook{cmd/frame/before}{
  \tl_clear:N \l@@_id_tl
  \@@_DEBUG_on:
  \@@_DEBUG:x {**********~THIS_IS_FRAME}
  \@@_DEBUG_off:
}
%    \end{macrocode}
% \subsubsection{Defining named slide ranges}
%
% \begin{function}{\@@_parse:Nnn}
%   \begin{syntax}
%     \cs{@@_parse:nn} \meta{command} \marg{key} \marg{definition}
%   \end{syntax}
% Auxiliary function called within a group.
% \meta{key} is the slide key, 
% including eventually a dotted integer path,
% \meta{definition} is the corresponding definition.
% \meta{command} is \cs{@@_range:nVVV} at runtime.
% \begin{variable}{\l_match_seq}
% Local storage for the match result.
% \end{variable}
% \end{function}
%
% \begin{function}{\@@_range:nnnn, \@@_range:nVVV,\@@_range_alt:nnnn, \@@_range_alt:nVVV}
%   \begin{syntax}
%     \cs{@@_range:nnnn}  \marg{key} \marg{first} \marg{length} \marg{last}
%     \cs{@@_range_alt:nnnn}  \marg{key} \marg{first} \marg{length} \marg{last}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% The alt variant does not override an already existing value.
%    \begin{macrocode}
\cs_new:Npn \@@_range:Nnnnn #1 #2 #3 #4 #5 {
  \tl_if_empty:nTF { #3 } {
    \tl_if_empty:nTF { #4 } {
      \tl_if_empty:nTF { #5 } {
        \msg_error:nnn { beanoves } { :n } { Not~a~range:~:~#2 }
      } {
        #1 { #2/Z } { #5 }
      }
    } {
      #1 { #2/L } { #4 }
      \tl_if_empty:nF { #5 } {
        #1 { #2/Z } { #5 }
        #1 { #2/A } { #2.last - (#2.length) + 1 }
      }
    }
  } {
    #1 { #2/A } { #3 }
    \tl_if_empty:nTF { #4 } {
      \tl_if_empty:nF { #5 } {
        #1 { #2/Z } { #5 }
        #1 { #2/L } { #2.last - (#2.1) + 1 }
      }
    } {
      #1 { #2/L } { #4 }
      #1 { #2/Z } { #2.1 + #2.length - 1 }
    }
  }
}
\cs_new:Npn \@@_range:nnnn #1 {
  \@@_gclear:n { #1 }
  \@@_range:Nnnnn \@@_gput:nn { #1 }
}
\cs_generate_variant:Nn \@@_range:nnnn { nVVV }
\cs_new:Npn \@@_range_alt:nnnn #1 {
  \@@_gclear_cache:n { #1 }
  \@@_range:Nnnnn \@@_gprovide:nn { #1 }
}
\cs_generate_variant:Nn \@@_range_alt:nnnn { nVVV }
%    \end{macrocode}%
% \begin{test}
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {#1/A} } { #2 } {Test~\cs{__beanoves_range:nnnn}~#5~A }
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {#1/L} } { #3 } {Test~\cs{__beanoves_range:nnnn}~#5~L }
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {#1/Z} } { #4 } {Test~\cs{__beanoves_range:nnnn}~#5~Z }
% }
% \__beanoves_range:nnnn {X} {FIRST} {} {}
% \Test { X } {FIRST} {} {} {TestB~\cs{__beanoves_range:nnnn}~X}
% \__beanoves_range:nnnn {X} {} {LENGTH} {}
% \Test { X } {} {LENGTH} {} {TestC~\cs{__beanoves_range:nnnn}~X.1}
% \__beanoves_range:nnnn {X} {} {} {LAST}
% \Test { X } {} {} {LAST} {TestC~\cs{__beanoves_range:nnnn}~X.1}
% \__beanoves_range:nnnn {X.1} {FIRST} {} {}
% \Test { X.1 } {FIRST} {} {} {TestB~\cs{__beanoves_range:nnnn}~X.1}
% \__beanoves_range:nnnn {X.1} {} {LENGTH} {}
% \Test { X.1 } {} {LENGTH} {} {TestC~\cs{__beanoves_range:nnnn}~X.1}
% \__beanoves_range:nnnn {X.1} {} {} {LAST}
% \Test { X.1 } {} {} {LAST} {TestC~\cs{__beanoves_range:nnnn}~X.1}
% \__beanoves_range:nnnn {X} {FIRST} {LENGTH} {}
% \Test { X } {FIRST} {LENGTH} {X.1+X.length-1} {Test~\cs{__beanoves_range:nnnn}~a}
% \__beanoves_range:nnnn {X} {FIRST} {} {LAST}
% \Test { X } {FIRST} {X.last-(X.1)+1} {LAST} {Test~\cs{__beanoves_range:nnnn}~b}
% \__beanoves_range:nnnn {X} {} {LENGTH} {LAST}
% \Test { X } {X.last-(X.length)+1} {LENGTH} {LAST} {Test~\cs{__beanoves_range:nnnn}~c}
% \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%   \cs_set:Npn \Test ##1 ##2 ##3 ##4 ##5 { }
% }
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__beanoves_assert_equal:xxn { MISSING~ERROR } {  } {Test~\cs{__beanoves_range:nnnn}~#5~Z }
% }
% \__beanoves_range:nnnn {X} {} {} {}
% \Test { X } {} {} {} {TestA~\cs{__beanoves_range:nnnn}~X}
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__beanoves_assert_equal:xxn { MISSING~ERROR } {  } {Test~\cs{__beanoves_range:nnnn}~#5~Z }
% }
% \__beanoves_range:nnnn {X.1} {} {} {}
% \Test { X.1 } {} {} {} {TestA~\cs{__beanoves_range:nnnn}~X.1}
% \end{test}
% \end{function}
% \begin{function}{\@@_parse:Nn}
%   \begin{syntax}
%     \cs{@@_parse:nn} \meta{command} \marg{key}
%   \end{syntax}
% Define a hidden range, for which slides are never shown.
% This is useful to conditionally show or hide a sequence of slides.
%    \begin{macrocode}
\cs_new:Npn \@@_parse:Nn #1 #2 {
  \@@_gput:nn { #1/ } { }
}
%    \end{macrocode}
% \end{function}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_empty:nTF { xTF }
\cs_new:Npn \@@_do_parse:Nnn #1 #2 #3 {
%    \end{macrocode}
% The first argument has signature |nVVV|.
% This is not a list.
%    \begin{macrocode}
  \tl_clear:N \l_a_tl
  \tl_clear:N \l_b_tl
  \tl_clear:N \l_c_tl
  \regex_split:NnN \c@@_colons_regex { #3 } \l_split_seq
  \seq_pop_left:NNT \l_split_seq \l_a_tl {
%    \end{macrocode}
% \cs{l_a_tl} may contain the \meta{start}.
%    \begin{macrocode}
    \seq_pop_left:NNT \l_split_seq \l_b_tl {
      \tl_if_empty:NTF \l_b_tl {
%    \end{macrocode}
% This is a one colon range.
%    \begin{macrocode}
        \seq_pop_left:NN \l_split_seq \l_b_tl
%    \end{macrocode}
% \cs{l_b_tl} may contain the \meta{length}.
%    \begin{macrocode}
        \seq_pop_left:NNT \l_split_seq \l_c_tl {
          \tl_if_empty:NTF \l_c_tl {
%    \end{macrocode}
% A |::| was expected:
%    \begin{macrocode}
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(1):~#3 }
          } {
            \int_compare:nNnT { \tl_count:N \l_c_tl } > { 1 } {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(2):~#3 }
            }
            \seq_pop_left:NN \l_split_seq \l_c_tl
%    \end{macrocode}
% \cs{l_c_tl} may contain the \meta{end}.
%    \begin{macrocode}
            \seq_if_empty:NF \l_split_seq {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(3):~#3 }
            }
          }
        }
      } {
%    \end{macrocode}
% This is a two colon range.
%    \begin{macrocode}
        \int_compare:nNnT { \tl_count:N \l_b_tl } > { 1 } {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(4):~#3 }
        }
        \seq_pop_left:NN \l_split_seq \l_c_tl
%    \end{macrocode}
% \cs{l_c_tl} contains the \meta{end}.
%    \begin{macrocode}
        \seq_pop_left:NNTF \l_split_seq \l_b_tl {
          \tl_if_empty:NTF \l_b_tl {
            \seq_pop_left:NN \l_split_seq \l_b_tl
%    \end{macrocode}
% \cs{l_b_tl} may contain the \meta{length}.
%    \begin{macrocode}
            \seq_if_empty:NF \l_split_seq {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(5):~#3 }
            }
          } {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(6):~#3 }
          }
        } {
          \tl_clear:N \l_b_tl
        }
      }
    }
  }
%    \end{macrocode}
% Providing both the \meta{start}, \meta{length} and \meta{end} of a range
% is not allowed, even if they happen to be consistent.
%    \begin{macrocode}
  \bool_if:nF {
    \tl_if_empty_p:N \l_a_tl
    || \tl_if_empty_p:N \l_b_tl
    || \tl_if_empty_p:N \l_c_tl
  } {
\msg_error:nnn { beanoves } { :n } { Invalid~range~expression(7):~#3 }
  }
  #1 { #2 } \l_a_tl \l_b_tl \l_c_tl
}
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~do_parse/#4/#1/}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/A} } {#1} {Test~\cs{__beanoves_do_parse:Nnn}~#4-a}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/L} } {#2} {Test~\cs{__beanoves_do_parse:Nnn}~#4-b}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/Z} } {#3} {Test~\cs{__beanoves_do_parse:Nnn}~#4-c}
% }
% \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {A}
% \Test:nnnn {A} {} {} {1}
% \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {A:B}
% \Test:nnnn {A} {B} {X.1+X.length-1} {2}
% \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {A::C}
% \Test:nnnn {A} {X.last-(X.1)+1} {C} {3}
% \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {:B::C}
% \Test:nnnn {X.last-(X.length)+1} {B} {C} {4}
% \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {::C:B}
% \Test:nnnn {X.last-(X.length)+1} {B} {C} {5}
% {
%   \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%     \cs_set:Npn \Test:nnnn ##1 ##2 ##3 ##4 { }
%   }
%   \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {A::C:B}
% }
% {
%   \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%     \cs_set:Npn \Test:nnnn ##1 ##2 ##3 ##4 { }
%   }
%   \__beanoves_do_parse:Nnn \__beanoves_range:nVVV {X} {A:B::C}
% }
% \end{test}
%    \begin{macrocode}
\cs_new:Npn \@@_parse:Nnn #1 #2 #3 {
  \@@_group_begin:
  \regex_match:NnTF \c@@_A_key_Z_regex { #2 } {
%    \end{macrocode}
% We got a valid key.
%    \begin{macrocode}
    \regex_extract_once:NnNTF \c@@_list_regex { #3 } \l_match_seq {
%    \end{macrocode}
% This is a comma separated list, extract each item and go recursive.
%    \begin{macrocode}
      \exp_args:NNx
      \seq_set_from_clist:Nn \l_match_seq {
        \seq_item:Nn \l_match_seq { 2 }
      }
      \seq_map_indexed_inline:Nn \l_match_seq {
        \@@_do_parse:Nnn #1 { #2.##1 } { ##2 }
      }
    } {
      \@@_do_parse:Nnn #1 { #2 } { #3 }
    }
  } {
    \msg_error:nnn { beanoves } { :n } { Invalid~key:~#1 }
  }
  \@@_group_end:
}
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~item/#4/#1/}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/A} } {#1} {Test~\cs{__beanoves_parse:Nnn}~#4-a}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/L} } {#2} {Test~\cs{__beanoves_parse:Nnn}~#4-b}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X/Z} } {#3} {Test~\cs{__beanoves_parse:Nnn}~#4-c}
% }
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X} {A}
% \Test:nnnn {A} {} {} {1}
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X} {A:B}
% \Test:nnnn {A} {B} {X.1+X.length-1} {2}
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X} {A::C}
% \Test:nnnn {A} {X.last-(X.1)+1} {C} {3}
% \end{test}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~item/#4/#1/}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.1.2/A} } {#1} {Test~\cs{__beanoves_parse:Nnn}~#4-a}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.1.2/L} } {#2} {Test~\cs{__beanoves_parse:Nnn}~#4-b}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.1.2/Z} } {#3} {Test~\cs{__beanoves_parse:Nnn}~#4-c}
% }
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X.1.2} {A}
% \Test:nnnn {A} {} {} {1}
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X.1.2} {A:B}
% \Test:nnnn {A} {B} {X.1.2.1+X.1.2.length-1} {2}
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X.1.2} {A::C}
% \Test:nnnn {A} {X.1.2.last-(X.1.2.1)+1} {C} {3}
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 #5 {
% \__beanoves_DEBUG:n {**********~Test:~item/#4/#1/}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.#5/A} } {#1} {Test~\cs{__beanoves_parse:Nnn}~#4-a}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.#5/L} } {#2} {Test~\cs{__beanoves_parse:Nnn}~#4-b}
%   \__beanoves_assert_equal:xxn {\__beanoves_item:n {X.#5/Z} } {#3} {Test~\cs{__beanoves_parse:Nnn}~#4-c}
% }
% \__beanoves_parse:Nnn \__beanoves_range:nVVV {X.3} {[A,A:B,A::C,:B::C,::C:B]}
% \Test:nnnnn {A} {} {} {4-1} {3.1}
% \Test:nnnnn {A} {B} {X.3.2.1+X.3.2.length-1} {4-2} {3.2}
% \Test:nnnnn {A} {X.3.3.last-(X.3.3.1)+1} {C} {4-3} {3.3}
% \Test:nnnnn {X.3.4.last-(X.3.4.length)+1} {B} {C} {4-4} {3.4}
% \Test:nnnnn {X.3.5.last-(X.3.5.length)+1} {B} {C} {4-5} {3.5}
% \end{test}
%
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key--value list}
%   \end{syntax}
%   The keys are the slide range specifiers.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{key--value} items are parsed by \cs{@@_parse:Nnn}.
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
  \tl_if_eq:NnT \@currenvir { document } {
    \@@_gclear:
  }
  \IfBooleanTF {#1} {
    \keyval_parse:nnn {
      \@@_parse:Nn \@@_range_alt:nVVV
    } {
      \@@_parse:Nnn \@@_range_alt:nVVV
    }
  } {
    \keyval_parse:nnn {
      \@@_parse:Nn \@@_range:nVVV
    } {
      \@@_parse:Nnn \@@_range:nVVV
    }
  }
  { #2 }
  \ignorespaces
}
%    \end{macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{function}
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\beamer@frame, \beamer@masterdecode}
% \begin{syntax}
% \cs{beamer@frame} \marg{overlay specification}
% \cs{beamer@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} uses it.
% \begin{variable}{\l_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% Save the original macro \cs{beamer@masterdecode} and then override it
% to properly preprocess the argument.
%    \begin{macrocode}
\cs_set_eq:NN \@@_beamer@frame \beamer@frame
\cs_set:Npn \beamer@frame < #1 > {
  \@@_group_begin:
  \tl_clear:N \l_ans_tl
  \@@_scan:nNN { #1 } \@@_eval:nN \l_ans_tl
  \exp_args:NNNV
  \@@_group_end:
  \@@_beamer@frame < \l_ans_tl >
}
\cs_set_eq:NN \@@_beamer@masterdecode \beamer@masterdecode
\cs_set:Npn \beamer@masterdecode #1 {
  \@@_group_begin:
  \tl_clear:N \l_ans_tl
  \@@_scan:nNN { #1 } \@@_eval:nN \l_ans_tl
  \exp_args:NNV
  \@@_group_end:
  \@@_beamer@masterdecode \l_ans_tl
}
%    \end{macrocode}
% \begin{function}{\@@_scan:nNN}
% \begin{syntax}
% \cs{@@_scan:nNN} \marg{named overlay expression} \meta{eval} \meta{tl variable}
% \end{syntax}
% Scan the \meta{named overlay expression} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from the \meta{eval} function, which is \cs{@@_eval:nN}.
% A group is created to use local variables:
% \begin{description}
%   \item[\cs{l_ans_tl}:] is the token list that will be appended to \meta{tl variable} on return.
% \end{description}
% \begin{variable}{\l_@@_depth_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{g_@@_append_int}
% Decremented each time \cs{@@_append:nN} is called.
% To avoid catch circular definitions.
% \end{variable}
% \begin{variable}{\l_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l_ask_bool}
% Whether a loop may continue.
% Controls the continuation of the main loop that scans
%     the tokens of the \meta{named overlay expression} looking for a question mark.
% \end{variable}
% \begin{variable}{\l_query_bool}
% Whether a loop may continue. 
% Controls the continuation of the secondary loop that scans
%     the tokens of the \meta{named overlay expression} looking for an opening
%     parenthesis follow the question mark.
%     It then controls the loop looking for the balanced closing parenthesis.
% \end{variable}
% \begin{variable}{\l_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_scan:nNN #1 #2 #3 {
  \@@_group_begin:
  \tl_clear:N \l_ans_tl
  \int_zero:N \l_@@_depth_int
  \seq_clear:N \l_token_seq
%    \end{macrocode}
% Explode the \meta{named overlay expression} into a list of tokens:
%    \begin{macrocode}
  \regex_split:nnN {} { #1 } \l_token_seq
%    \end{macrocode}
% Run the top level loop to scan for a `|?|':
%    \begin{macrocode}
  \bool_set_true:N  \l_ask_bool
  \bool_while_do:Nn \l_ask_bool {
    \seq_pop_left:NN \l_token_seq \l_token_tl
    \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% We reached the end of the sequence (and the token list),
% we end the loop here.
%    \begin{macrocode}
      \bool_set_false:N \l_ask_bool
    } {
%    \end{macrocode}
% \cs{l_token_tl} contains a `normal' token.
%    \begin{macrocode}
      \tl_if_eq:NnTF \l_token_tl { ? } {
%    \end{macrocode}
% We found a `|?|', we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
%    \begin{macrocode}
        \bool_set_true:N \l_query_bool
        \bool_while_do:Nn \l_query_bool {
%    \end{macrocode}
% Get next token.
%    \begin{macrocode}
          \seq_pop_left:NN \l_token_seq \l_token_tl
          \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% No opening parenthesis found, raise.
%    \begin{macrocode}
            \msg_fatal:nnx { beanoves } { :n } {Missing~'('%---)
              ~after~a~?:~#1}
          } {
            \tl_if_eq:NnT \l_token_tl { ( %)
            } {
%    \end{macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Increment the parenthesis depth to 1 (on first passage).
%    \begin{macrocode}
              \int_incr:N \l_@@_depth_int
%    \end{macrocode}
% Record the forthcomming content in the \cs{l_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
%    \begin{macrocode}
              \tl_clear:N \l_query_tl
              \bool_while_do:Nn \l_query_bool {
%    \end{macrocode}
% Get next token.
%    \begin{macrocode}
                \seq_pop_left:NN \l_token_seq \l_token_tl
                \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and end both bool while loops.
% As recovery we feed \cs{l_query_tl} with the missing ^^A(---
% `|)|'.
% |\l_@@_depth_int| is 0 whenever |\l_query_bool| is false.
%    \begin{macrocode}
                  \msg_error:nnx { beanoves } { :n } {Missing~%(---
                    `)':~#1 }
                  \int_do_while:nNnn \l_@@_depth_int > 1 {
                    \int_decr:N \l_@@_depth_int
                    \tl_put_right:Nn \l_query_tl {%(---
                    )}
                  }
                  \int_zero:N \l_@@_depth_int
                  \bool_set_false:N \l_query_bool
                  \bool_set_false:N \l_ask_bool
                } {
                  \tl_if_eq:NnTF \l_token_tl { ( %---)
                  } {
%    \end{macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to \cs{l_query_tl}.
%    \begin{macrocode}
                    \int_incr:N \l_@@_depth_int
                    \tl_put_right:NV \l_query_tl \l_token_tl
                  } {
%    \end{macrocode}
% This is not a `|(|'.^^A---)
%    \begin{macrocode}
                    \tl_if_eq:NnTF \l_token_tl { %(
                      )
                    } {
%    \end{macrocode}
% We found a  ^^A(---
% `|)|', decrement the depth.
%    \begin{macrocode}
                      \int_decr:N \l_@@_depth_int
                      \int_compare:nNnTF \l_@@_depth_int = 0 {
%    \end{macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to \cs{l_ans_tl}
% and stop the inner loop.
%    \begin{macrocode}
  \exp_args:NV #2 \l_query_tl \l_ans_tl
  \bool_set_false:N \l_query_bool
                      } {
%    \end{macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to \cs{l_query_tl} because it is not the
% end of sequence marker.
%    \begin{macrocode}
                        \tl_put_right:NV \l_query_tl \l_token_tl
                      }
%    \end{macrocode}
% Above ends the code for a positive depth.
%    \begin{macrocode}
                    } {
%    \end{macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to \cs{l_query_tl}.
%    \begin{macrocode}
                      \tl_put_right:NV \l_query_tl \l_token_tl
                    }
                  }
                }
%    \end{macrocode}
% Above ends the code for Not a  `|(|'^^A---)
%    \begin{macrocode}
              }
            }
%    \end{macrocode}
% Above ends the code for: Found the `|(|' after the `|?|' ^^A---)
%    \begin{macrocode}
          }
%    \end{macrocode}
% Above ends the code for not a no value quark.
%    \begin{macrocode}
        }
%    \end{macrocode}
% Above ends the code for the bool while loop to find the `|(|' after the `|?|'.^^A---)
%
% If we reached the end of the token list, then end both the current loop and its containing loop.
%    \begin{macrocode}
        \quark_if_no_value:NT \l_token_tl {
          \bool_set_false:N \l_query_bool
          \bool_set_false:N \l_ask_bool
        }
      } {
%    \end{macrocode}
% This is not a `|?|', append the token to right of \cs{l_ans_tl} and continue.
%    \begin{macrocode}
        \tl_put_right:NV \l_ans_tl \l_token_tl
      }
%    \end{macrocode}
% Above ends the code for the bool while loop to find a `|(|' after the `|?|' ^^A---)
%    \begin{macrocode}
    }
  }
%    \end{macrocode}
% Above ends the outer bool while loop to find `|?|' characters.
% We can append our result to \meta{tl variable}
%    \begin{macrocode}
  \exp_args:NNNV
  \@@_group_end:
  \tl_put_right:Nn #3 \l_ans_tl
}
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \eval:nN #1 #2 {
%   \tl_put_right:Nn #2 { !(#1) }
% }
% \tl_clear:N \l_a_tl
% \__beanoves_scan:nNN {1+1} \eval:nN \l_a_tl
% \__beanoves_scan:nNN {?(A)} \eval:nN \l_a_tl
% \cs_set:Npn \Test:nnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~scan/#3/#1/}
%   \tl_clear:N \l_a_tl
%   \__beanoves_scan:nNN { #1 } \eval:nN \l_a_tl
%   \exp_args:NV
%   \__beanoves_assert_equal:nnn \l_a_tl { #2 } {
%     Test~\cs{__beanoves_scan:nNN}~#3
%   }
% }
% \Test:nnn {} {} {1}
% \Test:nnn {1+1} {1+1} {2}
% \Test:nnn {1?(+)1} {1!(+)1} {3}
% \Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \end{test}
%
% \subsubsection{Evaluation bricks}
%
% \begin{function}{ \@@_fp_round:nN, \@@_fp_round:N }
% \begin{syntax}
% \cs{@@_fp_round:nN} \marg{expression} \meta{tl variable}
% \cs{@@_fp_round:N} \meta{tl variable}
% \end{syntax}
% Shortcut for |\fp_eval:n{round(|\texttt{\meta{expression}}|)}| appended to \meta{tl variable}.
% The second variant replaces the variable content
% with its rounded floating point evaluation.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_fp_round:nN #1 #2 {
  \@@_DEBUG:x { ROUND:\tl_to_str:n{#1}/\string#2=\tl_to_str:V #2}
  \tl_if_empty:nTF { #1 } {
    \@@_DEBUG:x { ROUND1:~EMPTY }
  } {
    \@@_DEBUG:x { ROUND1:~\tl_to_str:n{#1} }
    \tl_put_right:Nx #2 {
      \fp_eval:n { round(#1) }
    }
  }
}
\cs_generate_variant:Nn \@@_fp_round:nN { VN, xN }
\cs_new:Npn \@@_fp_round:N #1 {
  \@@_DEBUG:x { ROUND:\string#1=\tl_to_str:V #1}
  \tl_if_empty:VTF #1 {
    \@@_DEBUG:x { ROUND2:~EMPTY }
  } {
    \@@_DEBUG:x { ROUND2:~\exp_args:Nx\tl_to_str:n{#1} }
    \tl_set:Nx #1 {
      \fp_eval:n { round(#1) }
    }
  }
}
%    \end{macrocode}
%
% \begin{function}[TF]{ \@@_raw_first:nN, \@@_raw_first:xN, \@@_raw_first:VN }
% \begin{syntax}
% \cs{@@_raw_first:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the first index of the \meta{name} slide range
% to the \meta{tl variable}.
% Cache the result.
% Execute \meta{true code} when there is a \meta{first}, \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \@@_return_true:nnN #1 #2 #3 {
  \tl_if_empty:NTF \l_ans_tl {
    \@@_group_end:
\@@_DEBUG:n { RETURN_FALSE/key=#1/type=#2/EMPTY }
    \@@_gremove:n { #1//#2 }
    \prg_return_false:
  } {
    \@@_fp_round:N \l_ans_tl
    \@@_gput:nV { #1//#2 } \l_ans_tl
    \exp_args:NNNV
    \@@_group_end:
    \tl_put_right:Nn #3 \l_ans_tl
\@@_DEBUG:x { RETURN_TRUE/key=#1/type=#2/ans=\l_ans_tl/ }
    \prg_return_true:
  }
}
\cs_set:Npn \@@_return_false:nn #1 #2 {
\@@_DEBUG:n { RETURN_FALSE/key=#1/type=#2/ }
  \@@_group_end:
  \@@_gremove:n { #1//#2 }
  \prg_return_false:
}
\prg_new_conditional:Npnn \@@_raw_first:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x { RAW_FIRST/
    key=\tl_to_str:n{#1}/\string #2=/\tl_to_str:V #2/}
  \@@_if_in:nTF { #1//A } {
\@@_DEBUG:n { RAW_FIRST/#1/CACHED }
    \tl_put_right:Nx #2 { \@@_item:n { #1//A } }
    \prg_return_true:
  } {
\@@_DEBUG:n { RAW_FIRST/key=#1/NOT_CACHED }
    \@@_group_begin:
    \tl_clear:N \l_ans_tl
    \@@_get:nNTF { #1/A } \l_a_tl {
\@@_DEBUG:x { RAW_FIRST/key=#1/A=\l_a_tl }
      \@@_if_append:VNTF \l_a_tl \l_ans_tl {
        \@@_return_true:nnN { #1 } A #2
      } {
        \@@_return_false:nn { #1 } A
      }
    } {
\@@_DEBUG:n { RAW_FIRST/key=#1/A/F }
      \@@_get:nNTF { #1/L } \l_a_tl {
\@@_DEBUG:n { RAW_FIRST/key=#1/L=\l_a_tl }
        \@@_get:nNTF { #1/Z } \l_b_tl {
\@@_DEBUG:n { RAW_FIRST/key=#1/Z=\l_b_tl }
          \@@_if_append:xNTF {
            \l_b_tl - ( \l_a_tl ) + 1
          } \l_ans_tl {
            \@@_return_true:nnN { #1 } A #2
          } {
            \@@_return_false:nn { #1 } A
          }
        } {
\@@_DEBUG:n { RAW_FIRST/key=#1/Z/F/ }
          \@@_return_false:nn { #1 } A
        } 
      } {
\@@_DEBUG:n { RAW_FIRST/key=#1/L/F/ }
        \@@_return_false:nn { #1 } A
      } 
    }
  }
}
\prg_generate_conditional_variant:Nnn
    \@@_raw_first:nN { VN, xN } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \__beanoves_DEBUG:n { WHAT }
% \int_gset:Nn \g__beanoves_append_int { 128 }
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:x { **********~Test~\cs{__beanoves_raw_first:nNT }/#4/#1/ }
%   \Beanoves { #1 }
%   \tl_clear:N \l_ans_tl
% \__beanoves_DEBUG:n { 3 }
%   \cs_set:Npn \TEST {FAILURE}
%   \__beanoves_raw_first:nNT { #2 } \l_ans_tl {
%     \cs_set:Npn \TEST {SUCCESS}
% }
% \__beanoves_DEBUG:n { 4 }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #3 }
%     { Test~\cs{__beanoves_raw_first:nNT }~#4-a }
%   \__beanoves_assert_equal:xxn { \TEST } { SUCCESS }
%     { Test~\cs{__beanoves_raw_first:nNT }~#4-b }
% \__beanoves_DEBUG:n { 5 }
% }
% \__beanoves_DEBUG:n { WHAT~BEFORE~PROBLEM }
% \Test:nnnn { X = 123 } { X } { 123 } { 1 }
% \__beanoves_DEBUG:n { WHAT }
% \Test:nnnn { X = 123 } { X } { 123 } { 2 }
% \group_begin:
% \__beanoves_DEBUG:x { **********~Test~\cs{__beanoves_raw_first:nNT }/:LENGTH::LAST/ }
% \Beanoves { X = :LENGTH::LAST }
%   \tl_clear:N \l_ans_tl
% \__beanoves_DEBUG:x { 1111111111111111111 }
% \__beanoves_raw_length:nNT { X } \l_ans_tl {}
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_first:nN }~LENGTH }
%   \tl_clear:N \l_ans_tl
% \__beanoves_raw_last:nNT { X } \l_ans_tl {}
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_first:nN }~LENGTH }
% \group_end:
% \Test:nnnn { A = 11, X = :LENGTH::LAST } { X } { 1 } { 3 }
% \Test:nnnn { A = 11, X = ::LAST:LENGTH } { X } { 1  } { 4 }
% \Test:nnnn { AAA = 11, X = AAA.5 } { X } { 15 } { 5 }
% \Test:nnnn { X.123 = 456 } { X.123 } { 456 } { 6 }
% \Test:nnnn { X = FIRST:LENGTH, FIRST=2, LENGTH=3 } { X } { 2 } { 7 }
% \end{test}
% \begin{function}[TF]{ \@@_if_first:nN }
% \begin{syntax}
% \cs{@@_if_first:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the first index of the \meta{name} slide range
% to the \meta{tl variable}.
% If no first index was explicitely given,
% use the counter when available and 1 hen not.
% Cache the result.
% Execute \meta{true code} when there is a \meta{first}, \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_first:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x { IF_FIRST/\tl_to_str:n{#1}/\string #2=\tl_to_str:V #2}
  \@@_raw_first:nNTF { #1 } #2 {
    \prg_return_true:
  } {
    \@@_get:nNTF { #1/C } \l_a_tl {
\@@_DEBUG:n { IF_FIRST/#1/C/T/\l_a_tl }
      \bool_set_true:N \l_no_counter_bool
      \@@_if_append:xNTF \l_a_tl \l_ans_tl {
        \@@_return_true:nnN { #1 } A #2
      } {
        \@@_return_false:nn { #1 } A
      }
    } {
      \regex_match:NnTF \c@@_A_key_Z_regex { #1 } {
        \@@_gput:nn { #1/A } { 1 }
        \tl_set:Nn #2 { 1 }
\@@_DEBUG:x{IF_FIRST_MATCH:
  key=\tl_to_str:n{#1}/\string #2=\tl_to_str:V #2 /}
        \@@_return_true:nnN { #1 } A #2
      } {
\@@_DEBUG:x{IF_FIRST_NO_MATCH:
  key=\tl_to_str:n{#1}/\string #2=\tl_to_str:V #2 /}
        \@@_return_false:nn { #1 } A
      }
    }  
  }
}
%    \end{macrocode}
%
% \begin{function}{\@@_first:nN, \@@_first:VN}
% \begin{syntax}
% \cs{@@_first:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the start of the \meta{name} slide range
% to the \meta{tl variable}.
% Cache the result.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_first:nN #1 #2 {
  \@@_if_first:nNF { #1 } #2 {
    \msg_error:nnn { beanoves } { :n } { Range~with~no~first:~#1 }
  }
}
\cs_generate_variant:Nn \@@_first:nN { VN }
%    \end{macrocode}
% \begin{test}
% \__beanoves_DEBUG:n { WHAT }
% \int_gset:Nn \g__beanoves_append_int { 128 }
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:x { **********~Test~\cs{__beanoves_first:nN }/#4/#1/ }
% \__beanoves_DEBUG:n { 1 }
%   \Beanoves { #1 }
% \__beanoves_DEBUG:n { 2 }
%   \tl_clear:N \l_ans_tl
% \__beanoves_DEBUG:n { 3 }
%   \__beanoves_first:nN { #2 } \l_ans_tl
% \__beanoves_DEBUG:n { 4 }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #3 }
%     { Test~\cs{__beanoves_first:nN }~#4 }
% \__beanoves_DEBUG:n { 5 }
% }
% \__beanoves_DEBUG:n { WHAT~BEFORE~PROBLEM }
% \Test:nnnn { X = 123 } { X } { 123 } { 1 }
% \__beanoves_DEBUG:n { WHAT }
% \Test:nnnn { X = 123 } { X } { 123 } { 2 }
% \__beanoves_DEBUG:x { **********~Test~\cs{__beanoves_first:nN }/:LENGTH::LAST }
% \group_begin:
% \Beanoves { X = :LENGTH::LAST }
%   \tl_clear:N \l_ans_tl
% \__beanoves_raw_length:nNT { X } \l_ans_tl {}
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_first:nN }~LENGTH }
%   \tl_clear:N \l_ans_tl
% \__beanoves_raw_last:nNT { X } \l_ans_tl {}
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_first:nN }~LENGTH }
% \group_end:
% \Test:nnnn { A = 11, X = :LENGTH::LAST } { X } { 1 } { 3 }
% \Test:nnnn { A = 11, X = ::LAST:LENGTH } { X } { 1  } { 4 }
% \Test:nnnn { A = 11, X = A.5 } { X } { 15 } { 5 }
% \Test:nnnn { X.123 = 456 } { X.123 } { 456 } { 6 }
% \Test:nnnn { X = FIRST:LENGTH, FIRST=2, LENGTH=3 } { X } { 2 } { 7 }
% \end{test}
% \begin{function}[TF]{\@@_raw_length:nN}
% \begin{syntax}
% \cs{@@_raw_length:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the length of the \meta{name} slide range to \meta{tl variable}
% Execute \meta{true code} when there is a \meta{length}, \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_raw_length:nN #1 #2 { T, F, TF } {
\@@_DEBUG:n { RAW_LENGTH/#1 }
  \@@_if_in:nTF { #1//L } {
    \tl_put_right:Nx #2 { \@@_item:n { #1//L } }
\@@_DEBUG:x { RAW_LENGTH/CACHED/#1/\@@_item:n { #1//L } }
    \prg_return_true:
  } {
\@@_DEBUG:x { RAW_LENGTH/NOT_CACHED/key=#1/ }
    \@@_gput:nn { #1//L } { 0 }
    \@@_group_begin:
    \tl_clear:N \l_ans_tl
    \@@_if_in:nTF { #1/L } {
      \@@_if_append:xNTF {
        \@@_item:n { #1/L }
      } \l_ans_tl {
        \@@_return_true:nnN { #1 } L #2
      } {
        \@@_return_false:nn { #1 } L
      }
    } {
      \@@_get:nNTF { #1/A } \l_a_tl {
        \@@_get:nNTF { #1/Z } \l_b_tl {
          \@@_if_append:xNTF {
            \l_b_tl - (\l_a_tl) + 1
          } \l_ans_tl {
            \@@_return_true:nnN { #1 } L #2
          } {
            \@@_return_false:nn { #1 } L
          }
        } {
          \@@_return_false:nn { #1 } L
        }
      } {
        \@@_return_false:nn { #1 } L
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_raw_length:nN { VN } { T, F, TF }
%    \end{macrocode}
% \begin{function}{\@@_length:nN, \@@_length:VN}
% \begin{syntax}
% \cs{@@_length:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the length of the \meta{name} slide range to \meta{tl variable}
% \end{function}
% \begin{test}
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__beanoves_DEBUG:x { **********~Test~\cs{__beanoves_length:nN }~/#3/#1/ }
%   \Beanoves { X = #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_length:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_length:nN }~#3-a }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_length:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_length:nN }~#3-b }
% }
% \Test:nnn { 1:2 } { 2 } { 1 }
% \Test:nnn { :2::3 } { 2 } { 2 }
% \Test:nnn { ::3:2 } { 2 } { 3 }
% \Test:nnn { FIRST:LENGTH,FIRST=1,LENGTH=2,LAST=3 } { 2 } { 4 }
% \Test:nnn { :LENGTH::LAST,FIRST=1,LENGTH=2,LAST=3 } { 2 } { 5 }
% \Test:nnn { ::LAST:LENGTH,FIRST=1,LENGTH=2,LAST=3 } { 2 } { 6 }
% \end{test}
%    \begin{macrocode}
\cs_new:Npn \@@_length:nN #1 #2 {
  \@@_raw_length:nNF { #1 } #2 {
    \msg_error:nnn { beanoves } { :n } { Range~with~no~length:~#1 }
  }
}
\cs_generate_variant:Nn \@@_length:nN { VN }
%    \end{macrocode}
%
% \begin{function}[TF]{\@@_raw_last:nN}
% \begin{syntax}
% \cs{@@_raw_last:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Put the last index of the \meta{name} range to
% the right of the \meta{tl variable}, when possible.
% Execute \meta{true code} when a last index was given,
% \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_raw_last:nN #1 #2 { T, F, TF } {
\@@_DEBUG:n { RAW_LAST/#1 }
  \@@_if_in:nTF { #1//Z } {
    \tl_put_right:Nx #2 { \@@_item:n { #1//Z } }
    \prg_return_true:
  }  {
    \@@_gput:nn { #1//Z } { 0 }
    \@@_group_begin:
    \tl_clear:N \l_ans_tl
    \@@_if_in:nTF { #1/Z } {
\@@_DEBUG:x { NORMAL_RAW_LAST:~\@@_item:n { #1/Z } }
      \@@_if_append:xNTF {
        \@@_item:n { #1/Z }
      } \l_ans_tl {
        \@@_return_true:nnN { #1 } Z #2
      } {
        \@@_return_false:nn { #1 } Z
      }
    } {
      \@@_get:nNTF { #1/A } \l_a_tl {
        \@@_get:nNTF { #1/L } \l_b_tl {
          \@@_if_append:xNTF {
            \l_a_tl + (\l_b_tl) - 1
          } \l_ans_tl {
            \@@_return_true:nnN { #1 } Z #2
          } {
            \@@_return_false:nn { #1 } Z
          }
        } {
          \@@_return_false:nn { #1 } Z
        }
      } {
        \@@_return_false:nn { #1 } Z
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_raw_last:nN { VN } { T, F, TF }
%    \end{macrocode}
% \begin{function}{\@@_last:nN, \@@_last:VN}
% \begin{syntax}
% \cs{@@_last:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the last index of the \meta{name} slide range to \meta{tl variable}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_last:nN #1 #2 {
  \@@_raw_last:nNF { #1 } #2 {
    \msg_error:nnn { beanoves } { :n } { Range~with~no~last:~#1 }
  }
}
\cs_generate_variant:Nn \@@_last:nN { VN }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__beanoves_DEBUG:n { **********~Test~\cs{__beanoves_last:nN }~/#3/#1/ }
%   \Beanoves { X = #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_last:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_last:nN }~#3-a }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_raw_last:nNTF { X } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   } {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_last:nN }~#3-b }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_last:nN }~#3-c }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_raw_last:nNTF { Y } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   } {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_last:nN }~#3-d }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_last:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_last:nN }~#3-aa }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_raw_last:nNTF { X } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   } {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_last:nN }~#3-bb }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_last:nN }~#3-cc }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_raw_last:nNTF { Y } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   } {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_last:nN }~#3-dd }
% }
% \Test:nnn { ::4 } { 4 } { 1 }
% \Test:nnn { 2::4 } { 4 } { 2 }
% \Test:nnn { :2::4 } { 4 } { 3 }
% \Test:nnn { ::4:2 } { 4 } { 4 }
% \Test:nnn { 2:3 } { 4 } { 5 }
% \Test:nnn { ::LAST, FIRST=2, LENGTH=3, LAST=4 } { 4 } { 6 }
% \Test:nnn { ::LAST } { 4 } { 7 }
% \Test:nnn { FIRST::LAST } { 4 } { 8 }
% \Test:nnn { FIRST::LAST } { 4 } { 9 }
% \Test:nnn { FIRST:LENGTH } { 4 } { 10 }
% \Test:nnn { FIRST:LENGTH } { 4 } { 11 }
% \end{test}
%
% \begin{function}[TF]{\@@_if_next:nN}
% \begin{syntax}
% \cs{@@_if_next:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% Execute \meta{true code} when there is a \meta{next} index, \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_next:nN #1 #2 { T, F, TF } {
  \@@_if_in:nTF { #1//N } {
    \tl_put_right:Nx #2 { \@@_item:n { #1//N } }
    \prg_return_true:
  } {
    \@@_group_begin:
    \cs_set:Npn \@@_return_true: {
      \tl_if_empty:NTF \l_ans_tl {
        \@@_group_end:
        \prg_return_false:
      } {
        \@@_fp_round:N \l_ans_tl
        \@@_gput:nV { #1//N } \l_ans_tl
        \exp_args:NNNV
        \@@_group_end:
        \tl_put_right:Nn #2 \l_ans_tl
        \prg_return_true:
      }
    }
    \cs_set:Npn \@@_return_false: {
      \@@_group_end:
      \prg_return_false:
    }
    \tl_clear:N \l_a_tl
    \@@_raw_last:nNTF { #1 } \l_a_tl {
      \@@_if_append:xNTF {
        \l_a_tl + 1
      } \l_ans_tl {
        \@@_return_true:
      } {
        \@@_return_false:
      }
    } {
      \@@_return_false:
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_next:nN { VN } { T, F, TF }
%    \end{macrocode}
% \begin{function}{\@@_next:nN, \@@_next:VN}
% \begin{syntax}
% \cs{@@_next:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_next:nN #1 #2 {
  \@@_if_next:nNF { #1 } #2 {
    \msg_error:nnn { beanoves } { :n } { Range~with~no~next:~#1 }
  }
}
\cs_generate_variant:Nn \@@_next:nN { VN }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__beanoves_DEBUG:n { **********/#3/#1/ }
%   \Beanoves { X = #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_next:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_next:nN }~#3-a }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_next:nNTF { X } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   } {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_next:nN }~#3-b }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_next:nN }~#3-c }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_next:nNTF { Y } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   } {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_next:nN }~#3-d }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_next:nN { X } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_next:nN }~#3-a }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_next:nNTF { X } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   } {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_next:nN }~#3-b }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_next:nN }~#3-c }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_next:nNTF { Y } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { FAILURE }
%   } {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_next:nN }~#3-d }
% }
% \Test:nnn { ::4 } { 5 } { 1 }
% \Test:nnn { 2::4 } { 5 } { 2 }
% \Test:nnn { :2::4 } { 5 } { 3 }
% \Test:nnn { ::4:2 } { 5 } { 4 }
% \Test:nnn { 2:3 } { 5 } { 5 }
% \Test:nnn { ::C, A=2, B=3, C=4 } { 5 } { 6 }
% \Test:nnn { ::C } { 5 } { 7 }
% \Test:nnn { A::C } { 5 } { 8 }
% \Test:nnn { A::C } { 5 } { 9 }
% \Test:nnn { A:B } { 5 } { 10 }
% \Test:nnn { A:B } { 5 } { 11 }
% \end{test}
% \begin{function}[TF]{\@@_if_free_counter:Nn, \@@_if_free_counter:NV}
% \begin{syntax}
% \cs{@@_if_free_counter:NnTF} \meta{tl variable} \marg{name} \marg{true code} \marg{false code}
% \end{syntax}
% Set the \meta{tl variable} to the value of
% the counter associated to the \marg{name} slide range.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_free_counter:Nn #1 #2 { T, F, TF } {
\@@_DEBUG:x { IF_FREE: \string #1/
    key=\tl_to_str:n{#2}/value=\@@_item:n {#2/C}/ }
  \@@_group_begin:
  \tl_clear:N \l_ans_tl
  \@@_get:nNF { #2/C } \l_ans_tl {
    \@@_raw_first:nNF { #2 } \l_ans_tl {
      \@@_raw_last:nNF { #2 } \l_ans_tl { }
    }
  }
\@@_DEBUG:x { IF_FREE_2:\string \l_ans_tl=\tl_to_str:V \l_ans_tl/}
  \tl_if_empty:NTF \l_ans_tl {
    \@@_group_end:
    \regex_match:NnTF \c@@_A_key_Z_regex { #2 } {
      \@@_gput:nn { #2/C } { 1 }
      \tl_set:Nn #1 { 1 }
\@@_DEBUG:x { IF_FREE_MATCH_TRUE:\string #1=\tl_to_str:V #1 /
  key=\tl_to_str:n{#2} }
      \prg_return_true:
    } {
\@@_DEBUG:x { IF_FREE_NO_MATCH_FALSE: \string #1=\tl_to_str:V #1/
  key=\tl_to_str:n{#2} }
      \prg_return_false:
    }
  } {
    \@@_gput:nV { #2/C } \l_ans_tl
    \exp_args:NNNV
    \@@_group_end:
    \tl_set:Nn #1 \l_ans_tl
\@@_DEBUG:x { IF_FREE_TRUE(2): \string #1=\tl_to_str:V #1 /
  key=\tl_to_str:n{#2} }
    \prg_return_true:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_free_counter:Nn { NV } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__beanoves_DEBUG:n { **********/#3/#1/ }
%   \Beanoves { X = #1 }
%   \tl_clear:N \l_ans_tl
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_free_counter:NnT \l_ans_tl { X } {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_if_free_counter:NnTF }~#3-a }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_if_free_counter:NnTF }~#3-a }
%   \__beanoves_gclear:
% }
% \Test:nnn { 1 } { 1 } { 1 }
% \Test:nnn { 123 } { 123 } { 2 }
% \Test:nnn { ::123 } { 123 } { 3 }
% \Test:nnn { A+B+C } { 3 } { 4 }
% \Test:nnn { ::A+B } { 2 } { 5 }
% \end{test}
% \begin{function}[TF]{\@@_if_counter:nN, \@@_if_counter:VN}
% \begin{syntax}
% \cs{@@_if_counter:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the value of the counter associated to the \marg{name} slide range
% to the right of \meta{tl variable}.
% The value always lays in between the range, whenever possible.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_counter:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x { IF_COUNTER:key=
    \tl_to_str:n{#1}/\string #2=\tl_to_str:V #2 }
  \@@_group_begin:
  \@@_if_free_counter:NnTF \l_ans_tl { #1 } {
%    \end{macrocode}
% If there is a \meta{first}, use it to bound the result from below.
%    \begin{macrocode}
    \tl_clear:N \l_a_tl
    \@@_raw_first:nNT { #1 } \l_a_tl {
      \fp_compare:nNnT { \l_ans_tl } < { \l_a_tl } {
        \tl_set:NV \l_ans_tl \l_a_tl
      }
    }
%    \end{macrocode}
% If there is a \meta{last}, use it to bound the result from above.
%    \begin{macrocode}
    \tl_clear:N \l_a_tl
    \@@_raw_last:nNT { #1 } \l_a_tl {
      \fp_compare:nNnT { \l_ans_tl } > { \l_a_tl } {
        \tl_set:NV \l_ans_tl \l_a_tl
      }
    }
    \exp_args:NNx
    \@@_group_end:
    \@@_fp_round:nN \l_ans_tl #2
\@@_DEBUG:x {IF_COUNTER_TRUE:key=\tl_to_str:n{#1}/
  \string #2=\tl_to_str:V #2 }
    \prg_return_true:
  } {
\@@_DEBUG:x {IF_COUNTER_FALSE:key=\tl_to_str:n{#1}/
  \string #2=\tl_to_str:V #2 }
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_counter:nN { VN } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \__beanoves_append:xN #1 #2 { \tl_set:Nx #2 { #1 } }
% \cs_set:Npn \Test:nnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~range/#3/#1/}
%   \__beanoves_parse:Nnn \__beanoves_range:nVVV { X } { #1 }
%   \tl_clear:N \l_ans_tl
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_counter:nNT { X } \l_ans_tl {
%     \tl_set:Nn \l_a_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_if_counter:nNTF }~#3-a }
%   \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_if_counter:nNTF }~#3-b }
%   \__beanoves_gclear:
% }
% \Test:nnn { 1 } { 1 } { 1 }
% \Test:nnn { 123 } { 123 } { 2 }
% \Test:nnn { ::123 } { 123 } { 3 }
% \end{test}
% \begin{function}[TF]{\@@_if_index:nnN, \@@_if_index:VVN, \@@_if_index:nnnN}
% \begin{syntax}
% \cs{@@_if_index:nnNTF} \marg{name} \marg{integer path} \meta{tl variable} \marg{true code} \marg{false code}
% \cs{@@_if_index:nnnNTF} \marg{name} \marg{integer path} \marg{integer shift} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the index associated to the \marg{name} and \marg{integer path} slide range
% to the right of \meta{tl variable}.
% When \meta{integer shift} is 1, this is the first index,
% when \meta{integer shift} is 2, this is the second index, and so on.
% When \meta{integer shift} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \meta{true code} is executed, otherwise
% \meta{false code} is executed.
% The computation may fail when too many recursion calls are made.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_index:nnN #1 #2 #3 { T, F, TF } {
\@@_DEBUG:x { IF_INDEX:key=#1/index=#2/\string#3/ }
  \@@_group_begin:
  \tl_set:Nn \l_name_tl { #1 }
  \regex_split:nnNTF { \. } { #2 } \l_split_seq {
    \seq_pop_left:NN \l_split_seq \l_a_tl
    \seq_pop_right:NN \l_split_seq \l_a_tl
    \seq_map_inline:Nn \l_split_seq {
      \tl_set_eq:NN \l_b_tl \l_name_tl
      \tl_put_right:Nn \l_b_tl { . ##1 }
      \exp_args:Nx     
      \@@_get:nN { \l_b_tl / A } \l_c_tl
      \quark_if_no_value:NTF \l_c_tl {
        \tl_set_eq:NN \l_name_tl \l_b_tl
      } {
        \tl_set_eq:NN \l_name_tl \l_c_tl      
      }
\@@_DEBUG:x { IF_INDEX_SPLIT:##1/
  \string\l_name_tl=\tl_to_str:N \l_name_tl}
    }
    \tl_clear:N \l_b_tl
    \@@_raw_first:xNTF { \l_name_tl.\l_a_tl } \l_b_tl {
      \tl_set_eq:NN \l_ans_tl \l_b_tl
    } {
      \tl_clear:N \l_b_tl
      \@@_raw_first:VNTF \l_name_tl \l_b_tl {
        \tl_set_eq:NN \l_ans_tl \l_b_tl
      } {
        \tl_set_eq:NN \l_ans_tl \l_name_tl
      }
      \tl_put_right:Nx \l_ans_tl { + (\l_a_tl) - 1}
    }
\@@_DEBUG:x { IF_INDEX_TRUE:key=#1/index=#2/
  \string\l_ans_tl=\tl_to_str:N \l_ans_tl }
    \exp_args:NNx
    \@@_group_end:
    \@@_fp_round:nN \l_ans_tl #3
    \prg_return_true:
  } {
\@@_DEBUG:x { IF_INDEX_FALSE:key=#1/index=#2/ }
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_index:nnN { VVN } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \__beanoves_append:xN #1 #2 { \tl_set:Nx #2 { #1 } }
% \cs_set:Npn \Test:nnn #1 #2 #3 #4 #5 {
% \__beanoves_DEBUG:n {**********~Test:~index/#1/#5/}
%   \Beanoves { #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_index:nnNT { #2 } { #3 } \l_ans_tl {}
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #4 }
%     { Test~\cs{__beanoves_index:nnN }~#5 }
%   \__beanoves_gclear:
% }
% \Test:nnn { A = 1 } { A } { .1 } { 1 } { 1 }
% \Test:nnn { A = 1 } { A } { .2 } { 2 } { 2 }
% \Test:nnn { A = 1, B.2 = A } { B } { .2.3 } { 3 } { 3 }
% \Test:nnn { A = 2, B.2 = A } { B } { .2.4 } { 5 } { 4 }
% \Test:nnn { A = 2, B.2.3 = A } { B } { .2.3.4 } { 5 } { 5 }
% \Test:nnn { A = 2, B.2.3 = A, A.4 = 25 } { B } { .2.3.4 } { 25 } { 6 }
% \Test:nnn { B = 4 } { B } { .1 } { 4 } { 7 }
% \Test:nnn { B = 4 } { B } { .0 } { 3 } { 7 }
% \Test:nnn { B = 4 } { B } { .-1 } { 2 } { 8 }
% \Test:nnn { B = 4 } { B } { .-2 } { 1 } { 9 }
% \Test:nnn { B = 4 } { B } { .-3 } { 0 } { 10 }
% \end{test}
% \begin{function}[TF]{\@@_if_index:nnnN, \@@_if_index:VVVN}
% \begin{syntax}
% \cs{@@_if_index:nnnNTF} \marg{name} \marg{integer path} \marg{integer index} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the value of the counter associated to the \marg{name} slide range
% to the right of \meta{tl variable}.
% The value always lays in between the range, whenever possible.
% If the computation is possible, \meta{true code} is executed, otherwise
% \meta{false code} is executed.
% The computation may fail when too many recursion calls are made.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_index_original:nnnN #1 #2 #3 #4 { T, F, TF } {
\@@_DEBUG:x { IF_INDEX:key=#1/path=#2/index=#3/\string#4/ }
  \@@_group_begin:
  \tl_set:Nn \l_a_tl { #1 }
  \regex_split:nnNTF { \. } { #2 } \l_split_seq {
    \cs_set:Npn \:n ##1 {
      \tl_set_eq:NN \l_b_tl \l_a_tl
      \tl_put_right:Nn \l_b_tl { . ##1 }
      \exp_args:Nx
      \@@_get:nNTF { \l_b_tl / A } \l_c_tl {
        \exp_args:NNx
        \regex_match:NnTF \c@@_A_key_Z_regex \l_c_tl {
          \tl_set_eq:NN \l_a_tl \l_c_tl
        } {
          \cs_set:Npn \:n ####1 {
            \tl_set_eq:NN \l_b_tl \l_a_tl
            \tl_put_right:Nn \l_b_tl { . ####1 }
            \tl_set_eq:NN \l_a_tl \l_b_tl
\@@_DEBUG:x { IF_INDEX_SPLIT(2):##1/
  \string\l_a_tl=\tl_to_str:N \l_a_tl}
          }
        }
      } {
        \tl_set_eq:NN \l_a_tl \l_b_tl
      }
\@@_DEBUG:x { IF_INDEX_SPLIT:##1/
  \string\l_a_tl=\tl_to_str:N \l_a_tl}
    }
    \seq_map_function:NN \l_split_seq \:n
    \tl_clear:N \l_b_tl
    \@@_raw_first:VNTF \l_a_tl \l_b_tl {
      \tl_set_eq:NN \l_ans_tl \l_b_tl
    } {
      \tl_set_eq:NN \l_ans_tl \l_a_tl
    }
    \tl_put_right:Nx \l_ans_tl { + (#3) - 1}
\@@_DEBUG:x { IF_INDEX_TRUE:key=#1/path=#2/index=#3/
  \string\l_ans_tl=\tl_to_str:N \l_ans_tl }
    \exp_args:NNx
    \@@_group_end:
    \@@_fp_round:nN \l_ans_tl #4
    \prg_return_true:
  } {
    \tl_if_empty:nTF { #2 } {
      \tl_clear:N \l_b_tl
      \@@_raw_first:VNTF \l_a_tl \l_b_tl {
        \tl_set_eq:NN \l_ans_tl \l_b_tl
      } {
        \tl_set_eq:NN \l_ans_tl \l_a_tl
      }
      \tl_put_right:Nx \l_ans_tl { + (#3) - 1}
\@@_DEBUG:x { IF_INDEX_TRUE:key=#1/path=#2/index=#3/
    \string\l_ans_tl=\tl_to_str:N \l_ans_tl }
      \exp_args:NNx
      \@@_group_end:
      \@@_fp_round:nN \l_ans_tl #4
      \prg_return_true:
    } {
\@@_DEBUG:x { IF_INDEX_FALSE:key=#1/path=#2/index=#3/ }
      \prg_return_false:
    }
  }
}
\prg_new_conditional:Npnn \@@_if_index:nnnN #1 #2 #3 #4 { T, F, TF } {
\@@_DEBUG:x { IF_INDEX:key=#1/path=#2/index=#3/\string#4/ }
  \@@_group_begin:
  \tl_set:Nn \l_a_tl { #1 }
  \seq_set_split:Nnn \l_split_seq { . } { #2 }
  \seq_remove_all:Nn \l_split_seq {}
\@@_DEBUG:x {SPLIT_SEQ:/\seq_use:Nn \l_split_seq / /}
  \cs_set:Npn \:n ##1 {
    \tl_set_eq:NN \l_b_tl \l_a_tl
    \tl_put_right:Nn \l_b_tl { . ##1 }
    \exp_args:Nx
    \@@_get:nNTF { \l_b_tl / A } \l_c_tl {
      \exp_args:NNx
      \regex_match:NnTF \c@@_A_key_Z_regex \l_c_tl {
        \tl_set_eq:NN \l_a_tl \l_c_tl
      } {
        \tl_set_eq:NN \l_a_tl \l_b_tl
      }
    } {
      \tl_set_eq:NN \l_a_tl \l_b_tl
    }
\@@_DEBUG:x { IF_INDEX_SPLIT:##1/
  \string\l_a_tl=\tl_to_str:N \l_a_tl}
  }
  \seq_map_function:NN \l_split_seq \:n
  \tl_clear:N \l_b_tl
  \@@_raw_first:VNTF \l_a_tl \l_b_tl {
    \tl_set_eq:NN \l_ans_tl \l_b_tl
    \tl_put_right:Nx \l_ans_tl { + (#3) - 1}
\@@_DEBUG:x { IF_INDEX_TRUE:key=#1/path=#2/index=#3/
  \string\l_ans_tl=\tl_to_str:N \l_ans_tl }
    \exp_args:NNx
    \@@_group_end:
    \@@_fp_round:nN \l_ans_tl #4
    \prg_return_true:
  } {
\@@_DEBUG:x { IF_INDEX_FALSE:key=#1/path=#2/index=#3/ }
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_index:nnnN { VVVN } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \__beanoves_append:xN #1 #2 { \tl_set:Nx #2 { #1 } }
% \cs_set:Npn \Test:nnnnnn #1 #2 #3 #4 #5 #6 {
% \__beanoves_DEBUG:x {**********~Test:~\string\if_index:nnnN/#1/#6/}
%   \Beanoves { #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_index:nnnNT { #2 } { #3 } { #4 } \l_ans_tl {}
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #5 }
%     { Test~\string\__beanoves_if_index:nnnN~#6 }
%   \__beanoves_gclear:
% }
% \Test:nnnnnn { A = 1 }   { A } { } {  1 } {  1 } { 1-a }
% \Test:nnnnnn { A = 1 }   { A } { } {  2 } {  2 } { 1-b }
% \Test:nnnnnn { A = 1 }   { A } { } {  0 } {  0 } { 1-c }
% \Test:nnnnnn { A = 1 }   { A } { } { -1 } { -1 } { 1-d }
% \Test:nnnnnn { A.1 = 1 } { A } { .1 } { 1 } { 1 } { 2-a }
% \Test:nnnnnn { A.1 = 1 } { A } { .1 } { 2 } { 2 } { 2-b }
% \Test:nnnnnn { A.1 = 1 } { A } { .1 } { 0 } { 0 } { 2-c }
% \Test:nnnnnn { A.1 = 1 } { A } { .1 } { -1 } { -1 } { 2-d }
% \Test:nnnnnn { A.1.2 = 1 } { A } { .1.2 } { 1 } { 1 } { 3-a }
% \Test:nnnnnn { A.1.2 = 1 } { A } { .1.2 } { 2 } { 2 } { 3-b }
% \Test:nnnnnn { A.1.2 = 1 } { A } { .1.2 } { 0 } { 0 } { 3-c }
% \Test:nnnnnn { A.1.2 = 1 } { A } { .1.2 } { -1 } { -1 } { 3-d }
% \Test:nnnnnn { A.1.2 = B, B.3.4 = 11 } { A } { .1.2.3.4 } { 1 } { 11 } { 4-a }
% \Test:nnnnnn { A.1.2 = B, B.3.4 = 11 } { A } { .1.2.3.4 } { 2 } { 12 } { 4-b }
% \Test:nnnnnn { A.1.2 = B, B.3.4 = 11 } { A } { .1.2.3.4 } { 0 } { 10 } { 4-c }
% \Test:nnnnnn { A.1.2 = B, B.3.4 = 11 } { A } { .1.2.3.4 } { -1 } { 9 } { 4-d }
% \end{test}

% \begin{function} [TF] {\@@_if_incr:nn, \@@_if_incr:nnN, \@@_if_incr:VnN, \@@_if_incr:VVN}
% \begin{syntax}
% \cs{@@_if_incr:nnTF}  \marg{name} \marg{offset} \marg{true code} \marg{false code}
% \cs{@@_if_incr:nnNTF} \marg{name} \marg{offset} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% \end{function}
% Increment the free counter position accordingly.
% When requested, put the result in the \meta{tl variable}.
% The result will lay within the declared range.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_incr:nn #1 #2 { T, F, TF } {
\@@_DEBUG:x { IF_INCR:\tl_to_str:n{#1}/\tl_to_str:n{#2} }
  \@@_group_begin:
  \tl_clear:N \l_a_tl
  \@@_if_free_counter:NnTF \l_a_tl { #1 } {
    \tl_clear:N \l_b_tl
    \@@_if_append:xNTF { \l_a_tl + (#2) } \l_b_tl {
      \@@_fp_round:N \l_b_tl
      \@@_gput:nV { #1/C } \l_b_tl
      \@@_group_end:
\@@_DEBUG:x { IF_INCR_TRUE:#1/#2 }
      \prg_return_true:
    } {
      \@@_group_end:
\@@_DEBUG:x { IF_INCR_FALSE(1):#1/#2 }
      \prg_return_false:
    }
  } {
    \@@_group_end:
\@@_DEBUG:x { IF_INCR_FALSE(2):#1/#2 }
    \prg_return_false:
  }
}
\prg_new_conditional:Npnn \@@_if_incr:nnN #1 #2 #3 { T, F, TF } {
  \@@_if_incr:nnTF { #1 } { #2 } {
    \@@_if_counter:nNTF { #1 } #3 {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_incr:nnN { VnN, VVN } { T, F, TF }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~free_counter/#3/#1/}
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_free_counter:NnT \l_ans_tl { X } {}
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #1 }
%     { Test~\cs{__beanoves_if_incr:nNTF }~#3-a }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_if_counter:nNT { X } \l_ans_tl {}
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #2 }
%     { Test~\cs{__beanoves_if_incr:nNTF }~#3-b }
%   \__beanoves_gclear:
% }
% \Beanoves { X = 123 }
% \Test:nnn { 123 } { 123 } { 1 }
% \Beanoves { X = 123 }
% \tl_clear:N \l_a_tl
% \__beanoves_if_incr:nnT { X } { -100 } {
%   \tl_set:Nn \l_a_tl { SUCCESS }
% }
% \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_if_incr:nNTF } }
% \Test:nnn { 23 } { 123 } { 2 }
% \Beanoves { X = ::123 }
% \Test:nnn { 123 } { 123 } { 3 }
% \Beanoves { X = ::123 }
% \__beanoves_if_incr:nnT { X } { 100 } {
%   \tl_set:Nn \l_a_tl { SUCCESS }
% }
% \__beanoves_assert_equal:xxn { \l_a_tl } { SUCCESS }
%     { Test~\cs{__beanoves_if_incr:nNTF } }
% \Test:nnn { 223 } { 123 } { 4 }
% \end{test}
%
% \begin{function}[TF]{\@@_if_range:nN}
% \begin{syntax}
% \cs{@@_if_range:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the range of the \meta{name} slide range to the \meta{tl variable}.
% Execute \meta{true code} when there is a \meta{range}, \meta{false code} otherwise.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_range:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x{ RANGE:key=#1/\string#2/}
  \bool_if:NTF \l_@@_no_range_bool {
    \prg_return_false:
  } {
    \@@_if_in:nTF { #1/ } {
      \tl_put_right:Nn { 0-0 }
    } {
      \@@_group_begin:
      \tl_clear:N \l_a_tl
      \tl_clear:N \l_b_tl
      \tl_clear:N \l_ans_tl
      \@@_raw_first:nNTF { #1 } \l_a_tl {
        \@@_raw_last:nNTF { #1 } \l_b_tl {
          \exp_args:NNNx
          \@@_group_end:
          \tl_put_right:Nn #2 { \l_a_tl - \l_b_tl }
\@@_DEBUG:x{ RANGE_TRUE_A_Z:key=#1/\string#2=#2/}
          \prg_return_true:
        } {
          \exp_args:NNNx
          \@@_group_end:
          \tl_put_right:Nn #2 { \l_a_tl - }
\@@_DEBUG:x{ RANGE_TRUE_A:key=#1/\string#2=#2/}
          \prg_return_true:
        }
      } {
        \@@_raw_last:nNTF { #1 } \l_b_tl {
\@@_DEBUG:x{ RANGE_TRUE_Z:key=#1/\string#2=#2/}
          \exp_args:NNNx
          \@@_group_end:
          \tl_put_right:Nn #2 { - \l_b_tl }
          \prg_return_true:
        } {
\@@_DEBUG:x{ RANGE_FALSE:key=#1/}
          \@@_group_end:
          \prg_return_false:
        }
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_range:nN { VN } { T, F, TF }
%    \end{macrocode}
% \begin{function}{\@@_range:nN, \@@_range:VN}
% \begin{syntax}
% \cs{@@_range:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the range of the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_range:nN #1 #2 {
  \@@_if_range:nNF { #1 } #2 {
    \msg_error:nnn { beanoves } { :n } { No~range~available:~#1 }
  }
}
\cs_generate_variant:Nn \@@_range:nN { VN }
%    \end{macrocode}
% \begin{test}
% \bool_set_false:N \l_beanoves_no_range_bool
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~range/#4/#1/}
%   \Beanoves { #1 }
%   \tl_clear:N \l_ans_tl
%   \__beanoves_range:nN { #2 } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #3 }
%     { Test~\cs{__beanoves_range:nN }~#4 }
% }
% \Beanoves { S=1,L=11,E=111,X = S.1 }
% \tl_clear:N \l_ans_tl
% \__beanoves_first:nN { S } \l_ans_tl
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_range:nN }~0-a }
% \tl_clear:N \l_ans_tl
% \__beanoves_first:nN { X } \l_ans_tl
% \__beanoves_assert_equal:xxn { \l_ans_tl } { 1 }
%   { Test~\cs{__beanoves_range:nN }~0-b }
% \Test:nnnn { S=1,L=11,E=111,X = S.1 } { X } { 1- } { 1 }
% \Test:nnnn { S=1,L=11,E=111,X = ::E.1 } { X } { -111 } { 2 }
% \Test:nnnn { S=1,L=11,E=111,X = S.1::E.1 } { X } { 1-111 } { 1 }
% \Test:nnnn { S=1,L=11,E=111,X = S.1:L.1 } { X } { 1-11 } { 3 }
% \Test:nnnn { S=1,L=11,E=111,X = :L.1::E.1 } { X } { 101-111 } { 1 }
% \end{test}
%
% \subsubsection{Evaluation}
%
% \begin{function}{\@@_resolve:nnN, \@@_resolve:VVN, \@@_resolve:nnNN, \@@_resolve:VVNN}
% \begin{syntax}
% \cs{@@_resolve:nnN} \marg{name} \marg{path} \meta{tl variable}
% \cs{@@_resolve:nnNN} \marg{name} \marg{path} \meta{tl name variable} \meta{tl last variable}
% \end{syntax}
% Resolve the \meta{name} and \meta{path} into a key that is put into the \meta{tl name variable}.
% \meta{name_0}.\meta{i_1}.\meta{i_2}...\meta{i_n} is turned into
% \meta{name_1}.\meta{i_2}...\meta{i_n}
% where \meta{name_0}.\meta{i_1} is \meta{name_1},
% then \meta{name_2}.\meta{i_3}...\meta{i_n}
% where \meta{name_1}.\meta{i_2} is \meta{name_2}...
% In the second version, the last path component is first removed from
% \marg{path} and stored in \meta{tl last variable}.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_resolve:nnN #1 #2 #3 {
  \@@_group_begin:
  \tl_set:Nn \l_a_tl { #1 }
  \regex_split:nnNT { \. } { #2 } \l_split_seq {
    \seq_pop_left:NN \l_split_seq \l_b_tl
    \cs_set:Npn \:n ##1 {
      \tl_set_eq:NN \l_b_tl \l_a_tl
      \tl_put_right:Nn \l_b_tl { . ##1 }
      \exp_args:Nx
      \@@_get:nNTF { \l_b_tl / A } \l_c_tl {
        \exp_args:NNx
        \regex_match:NnTF \c@@_A_key_Z_regex \l_c_tl {
          \tl_set_eq:NN \l_a_tl \l_c_tl
        } {
          \cs_set:Npn \:n ####1 {
            \tl_set_eq:NN \l_b_tl \l_a_tl
            \tl_put_right:Nn \l_b_tl { . ####1 }
            \tl_set_eq:NN \l_a_tl \l_b_tl
          }
        }
      } {
        \tl_set_eq:NN \l_a_tl \l_b_tl
      }
    }
    \seq_map_function:NN \l_split_seq \:n
  }
  \exp_args:NNNV
  \@@_group_end:
  \tl_set:Nn #3 \l_a_tl
}
\cs_generate_variant:Nn \@@_resolve:nnN { VVN }
\cs_new:Npn \@@_tl_put_right_braced:Nn #1 #2 {
  \tl_put_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_put_right_braced:Nn { NV }
\cs_new:Npn \@@_resolve:nnNN #1 #2 #3 #4 {
  \@@_group_begin:
  \regex_extract_once:nnNT { (\.\d+)*? (\.\d+) \Z} { #2 } \l_match_seq {
    \exp_args:Nnx
    \@@_resolve:nnN { #1 } { \seq_item:Nn \l_match_seq 2 } \l_name_tl
    \tl_set:Nn \l_a_tl {
      \tl_set:Nn #3
    }
    \exp_args:NNV
    \@@_tl_put_right_braced:Nn \l_a_tl \l_name_tl
    \tl_put_right:Nn \l_a_tl {
      \tl_set:Nn #4
    }
    \exp_args:NNx
    \@@_tl_put_right_braced:Nn  \l_a_tl {
      \seq_item:Nn \l_match_seq 3
    }
  }
  \exp_last_unbraced:NV
  \@@_group_end:
  \l_a_tl
}
\cs_generate_variant:Nn \@@_resolve:nnNN { VVNN }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \__beanoves_append:xN #1 #2 {
%   \tl_set:Nx #2 { #1 }
% }
% \cs_set:Npn \Test:nnn #1 #2 #3 #4 #5 {
% \__beanoves_DEBUG:n {**********~Test:~resolve/#5/#1/}
%   \tl_clear:N \l_ans_tl
%   \Beanoves { #1 }
%   \__beanoves_resolve:nnN { #2 } { #3 } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #4 }
%     { Test~\cs{__beanoves_resolve:nnN }~#5 }
%   \__beanoves_gclear:
% }
% \Test:nnn {} { X } { .1.2 } { X.1.2 } { 1 }
% \__beanoves_parse:Nnn \__beanoves_range:nVVV { X.1 } { Y }
% \__beanoves_get:nN { X.1 / A } \l_ans_tl
% \__beanoves_assert_equal:xxn { \l_ans_tl } { Y }
%   { Test~\cs{__beanoves_resolve:nnN }~A }
% \Test:nnn { X.1 = Y } { X } { .1.2 } { Y.2 } { 2 }
% \Test:nnn { X.1 = Y, Y.2 = Z } { X } { .1.2 } { Z } { 3 }
% \Test:nnn { X.1.2 = Z } { X } { .1.2 } { Z } { 3 }
% \end{test}
%
% \begin{test}
% \cs_set:Npn \__beanoves_append:xN #1 #2 {
%   \tl_set:Nx #2 { #1 }
% }
% \cs_set:Npn \Test:nnn #1 #2 #3 #4 #5 {
% \__beanoves_DEBUG:n {**********~Test:~resolve/#5/#1/}
%   \tl_clear:N \l_ans_tl
%   \Beanoves { #1 }
%   \__beanoves_resolve:nnN { #2 } { #3 } \l_ans_tl
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #4 }
%     { Test~\cs{__beanoves_resolve:nnN }~#5 }
%   \__beanoves_gclear:
% }
% \Test:nnn {} { X } { .1.2 } { X.1.2 } { 1 }
% \__beanoves_parse:Nnn \__beanoves_range:nVVV { X.1 } { Y }
% \__beanoves_get:nN { X.1 / A } \l_ans_tl
% \__beanoves_assert_equal:xxn { \l_ans_tl } { Y }
%   { Test~\cs{__beanoves_resolve:nnN }~A }
% \Test:nnn { X.1 = Y } { X } { .1.2 } { Y.2 } { 2 }
% \Test:nnn { X.1 = Y, Y.2 = Z } { X } { .1.2 } { Z } { 3 }
% \Test:nnn { X.1.2 = Z } { X } { .1.2 } { Z } { 3 }
% \end{test}
%
% \begin{function}[TF]{\@@_if_append:nN,\@@_if_append:VN,\@@_if_append:xN}
% \begin{syntax}
% \cs{@@_if_append:nNTF} \marg{integer expression} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Evaluates the \meta{integer expression},
% replacing all the named specifications by their static
% counterpart then put the result to
% the right of the \meta{tl variable}.
% Executed within a group.
% Heavily used by \cs{@@_eval_query:nN}, where \meta{integer expression}
% was initially enclosed in `|?(...)|'.
% Local variables: 
% \begin{variable}{\l_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l_@@_split_int}
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{variable}{\l_name_tl}
%    Storage for \cs{l_split_seq} items that represent names.
% \end{variable}
% \begin{variable}{\l_path_tl}
%    Storage for \cs{l_split_seq} items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_append:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x { IF_APPEND:\tl_to_str:n { #1 } / \string #2}
  \int_gdecr:N \g_@@_append_int
  \int_compare:nNnTF \g_@@_append_int > 0 {
\@@_DEBUG:x { IF_APPEND...}
    \@@_group_begin:
%    \end{macrocode}
% Local variables:
%    \begin{macrocode}
    \int_zero:N  \l_@@_split_int
    \seq_clear:N \l_split_seq
    \tl_clear:N  \l_name_tl
    \tl_clear:N  \l_path_tl
    \tl_clear:N  \l_group_tl
    \tl_clear:N  \l_ans_tl
    \tl_clear:N  \l_a_tl
%    \end{macrocode}
% Implementation:
%    \begin{macrocode}  
    \regex_split:NnN \c@@_split_regex { #1 } \l_split_seq
\@@_DEBUG:x { IF_APPEND_SPLIT_SEQ: / \seq_use:Nn \l_split_seq / / }
    \int_set:Nn \l_@@_split_int { 1 }
    \tl_set:Nx \l_ans_tl {
      \seq_item:Nn \l_split_seq { \l_@@_split_int }
    }
%    \end{macrocode}
% \begin{function}{\switch:nTF}
% \begin{syntax}
% \cs{switch:nTF} \marg{capture group number} \marg{black code} \marg{white code}
% \end{syntax}
% Helper function to locally set the |\l_group_tl| variable
% to the captured group \meta{capture group number}
% and branch.
% \end{function}
%    \begin{macrocode}
    \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
      \tl_set:Nx ##2 {
        \seq_item:Nn \l_split_seq { \l_@@_split_int + ##1 }
      }
\@@_DEBUG:x { IF_APPEND_SWITCH/##1/\string##2/\tl_to_str:N##2/}
      \tl_if_empty:NTF ##2 { %SWITCH~APPEND~WHITE/##1/\\
        ##4 } { %SWITCH~APPEND~BLACK/##1/\\
        ##3
      }
    }
%    \end{macrocode}
% \cs{prg_return_true:} and \cs{prg_return_false:} are wrapped locally
% to close the group and return the proper value.
%    \begin{macrocode}
    \cs_set:Npn \@@_return_true: {
      \@@_fp_round:
      \exp_args:NNNV
      \@@_group_end:
      \tl_put_right:Nn #2 \l_ans_tl
\@@_DEBUG:x { IF_APPEND_TRUE:\tl_to_str:n { #1 } /
  \string #2=\tl_to_str:V #2 }
      \prg_return_true:
    }
    \cs_set:Npn \@@_fp_round: {
      \@@_fp_round:N \l_ans_tl
    }
    \cs_set:Npn \next: {
      \@@_return_true:
    }
    \cs_set:Npn \@@_return_false: {
      \@@_group_end:
\@@_DEBUG:x { IF_APPEND_FALSE:\tl_to_str:n { #1 } /
  \string #2=\tl_to_str:V #2 }
      \prg_return_false:
    }
    \cs_set:Npn \break: {
      \bool_set_false:N \l@@_continue_bool
      \cs_set:Npn \next: {
        \@@_return_false:
      }
    }
%    \end{macrocode}
% Main loop.
%    \begin{macrocode}
    \bool_set_true:N \l@@_continue_bool
    \bool_while_do:Nn \l@@_continue_bool {
      \int_compare:nNnTF {
        \l_@@_split_int } < { \seq_count:N \l_split_seq
      } {
        \switch:nNTF 1 \l_name_tl {
%    \end{macrocode}
% \begin{myList}
% \item Case \texttt{++\meta{name}\meta{integer path}.n}.
%    \begin{macrocode}
          \switch:nNTF 2 \l_path_tl {
            \@@_resolve:VVN \l_name_tl \l_path_tl \l_name_tl
          } { }
          \@@_if_incr:VnNF \l_name_tl 1 \l_ans_tl {
            \break:
          }
        } {
          \switch:nNTF 3 \l_name_tl {
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \__beanoves_eval:xN #1 #2 {
%   \tl_set:Nx #2 { #1 }
% }
% \cs_set:Npn \Test:nnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#4/#1/}
%   \tl_clear:N \l_ans_tl
%   \Beanoves { #1 }
%   \__beanoves_if_append:nNT { #2 } \l_ans_tl {}
%   \__beanoves_assert_equal:xxn { \l_ans_tl } { #3 }
%     { Test~\cs{__beanoves_resolve:nnN }~#4 }
% }
% \Test:nnn {X=123} { X.n } { 123 } { 1 }
% \Test:nnn {} { ++X.n } { 124 } { 2 }
% \Test:nnn {} { X.n } { 124 } { 3 }
% \end{test}
% \item Cases \texttt{\meta{name}\meta{integer path}...}.
%    \begin{macrocode}
            \tl_set:Nn \l_b_tl {
              \switch:nNTF 4 \l_path_tl {
                \@@_resolve:VVN \l_name_tl \l_path_tl \l_name_tl
              } { }
            }
            \switch:nNTF 5 \l_a_tl {
%    \end{macrocode}
% \item Case \texttt{...length}.
%    \begin{macrocode}
              \l_b_tl
              \@@_raw_length:VNF \l_name_tl \l_ans_tl {
                \break:
              }
            } {
              \switch:nNTF 6 \l_a_tl {
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { A=#1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { A.length } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #2 } {
%     Test~\cs{__beanoves_if_append:nN}/#3-length
%   }
% }
% \Test:nnnn { 11:4 } { 4 } { 1 }
% \Test:nnnn { 11::12 } { 2 } { 2 }
% \Test:nnnn { :2::12 } { 2 } { 3 }
% \Test:nnnn { S:L, S=11,L=2,E=12 } { 2 } { 4 }
% \Test:nnnn { S::E, S =11,L=2,E=12 } { 2 } { 5 }
% \Test:nnnn { :L::E, S=11,L=2,E=12 } { 2 } { 6 }
% \end{test}
% \item Case \texttt{...last}.
%    \begin{macrocode}
                \l_b_tl
                \@@_raw_last:VNF \l_name_tl \l_ans_tl {
                  \break:
                }
              } {
                \switch:nNTF 7 \l_a_tl {
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { A=#1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { A.last } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #2 } {
%     Test~\cs{__beanoves_if_append:nN}/#3-last
%   }
% }
% \Test:nnnn { 11:4 } { 14 } { 1 }
% \Test:nnnn { 11::12 } { 12 } { 2 }
% \Test:nnnn { :2::12 } { 12 } { 3 }
% \Test:nnnn { S:L, S=11,L=2,E=12 } { 12 } { 4 }
% \Test:nnnn { S::E, S=11,L=2,E=12 } { 12 } { 5 }
% \Test:nnnn { :L::E, S=11,L=2,E=12 } { 12 } { 6 }
% \end{test}
% \item Case \texttt{...next}.
%    \begin{macrocode}
                  \l_b_tl
                  \@@_if_next:VNF \l_name_tl \l_ans_tl {
                    \break:
                  }
                } {
                  \switch:nNTF 8 \l_a_tl {
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { A=#1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { A.next } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #2 } {
%     Test~\cs{__beanoves_if_append:nN}/#3-next
%   }
% }
% \Test:nnnn { 11:4 } { 15 } { 1 }
% \Test:nnnn { 11::12 } { 13 } { 2 }
% \Test:nnnn { :2::12 } { 13 } { 3 }
% \Test:nnnn { S:L, S=11,L=2,E=12 } { 13 } { 4 }
% \Test:nnnn { S::E, S=11,L=2,E=12 } { 13 } { 5 }
% \Test:nnnn { :L::E, S=11,L=2,E=12 } { 13 } { 6 }
% \end{test}
% \item Case \texttt{...range}.
%    \begin{macrocode}
                    \l_b_tl
                    \@@_if_range:VNTF \l_name_tl \l_ans_tl {
                      \cs_set_eq:NN \@@_fp_round: \relax
                    } {
                      \break:
                    }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { A=#1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { A.range } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #2 } {
%     Test~\cs{__beanoves_if_append:nN}/#3-range
%   }
% }
% \Test:nnnn { 11:4 } { 11-14 } { 1 }
% \Test:nnnn { 11::12 } { 11-12 } { 2 }
% \Test:nnnn { :2::12 } { 11-12 } { 3 }
% \Test:nnnn { S:L, S=11,L=2,E=12 } { 11-12 } { 4 }
% \Test:nnnn { S::E, S=11,L=2,E=12 } { 11-12 } { 5 }
% \Test:nnnn { :L::E, S=11,L=2,E=12 } { 11-12 } { 6 }
% \end{test}
%    \begin{macrocode}
                  } {
                    \switch:nNTF 9 \l_a_tl {
%    \end{macrocode}
% \item Case \texttt{...n}.
%    \begin{macrocode}
                      \l_b_tl
                      \switch:nNTF { 10 } \l_a_tl {
%    \end{macrocode}
% \item Case \texttt{...+=\meta{integer}}.
%    \begin{macrocode}
\@@_if_incr:VVNF \l_name_tl \l_a_tl \l_ans_tl {
  \break:
}
                      } {
\@@_DEBUG:x {++++++++++~NAME=\l_name_tl}
                        \@@_if_counter:VNF \l_name_tl \l_ans_tl {
                          \break:
                        }
                      }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { #1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { #2 } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #3 } {
%     Test~\cs{__beanoves_if_append:nN}/#4
%   }
% }
% \Test:nnnn { A=1 } { A.n } { 1 } { 1 }
% \Test:nnnn { A.1=101 } { A.1.n } { 1 } { 2 }
% \Test:nnnn { A=11 } { A.n+=100 } { 111 } { 3 }
% \Beanoves { A=11 }
% \tl_clear:N \l_a_tl
% \__beanoves_if_append:nNT { A.n+=100 } \l_a_tl {}
% \tl_clear:N \l_a_tl
% \__beanoves_if_append:nNT { A.n+=-100 } \l_a_tl {}
% \__beanoves_assert_equal:xxn \l_a_tl { 11 } {
%   Test~\cs{__beanoves_if_append:nN}/4/+=
% }
% \end{test}
%    \begin{macrocode}
                    } {
%    \end{macrocode}
% \item Case \texttt{...\meta{integer path}}.
%    \begin{macrocode}
                      \switch:nNTF { 11 } \l_a_tl {
\switch:nNTF 4 \l_path_tl { } {
  \tl_clear:N \l_path_tl
}
\@@_if_index:VVVNF \l_name_tl \l_path_tl \l_a_tl \l_ans_tl {
  \break:
}
                      } {
                        \switch:nNTF 4 \l_path_tl {
\@@_if_index:VVNF \l_name_tl \l_path_tl \l_ans_tl {
  \break:
}
                        } {
\exp_args:Nx
\@@_if_counter:nNF { \l_name_tl } \l_ans_tl {
  \break:
}
                        }
                      }
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
%   \__beanoves_DEBUG:n {**********~Test:~if_append/#3/#1/}
%   \Beanoves { #1 }
%   \tl_clear:N \l_a_tl
%   \__beanoves_if_append:nNT { #2 } \l_a_tl {}
%   \__beanoves_assert_equal:xxn \l_a_tl { #3 } {
%     Test~\cs{__beanoves_if_append:nN}/#4
%   }
%   \__beanoves_gclear:
% }
% \Test:nnnn { A=1 } { A.10 } { 10 } { 1 }
% \Test:nnnn { B=101 } { B.10 } { 110 } { 2 }
% \Test:nnnn { C.1=101 } { C.1 } { 101 } { 3 }
% \Test:nnnn { D.1=101 } { D.1.10 } { 110 } { 4 }
% \Test:nnnn { E.1.2=101 } { E.1.2 } { 101 } { 5 }
% \Test:nnnn { F.1.2=101 } { F.1.2.3 } { 103 } { 6 }
% \Test:nnnn { G.1=GG, GG.2=102 } { G.1.2 } { 102 } { 7 }
% \Test:nnnn { H.1=HH, HH.2=102 } { H.1.2.3 } { 104 } { 8 }
% \__beanoves_DEBUG_on:
% \Test:nnnn { I=10 } { I.-10 } { -1 } { 9 }
% \Test:nnnn { I=10 } { I.0 } { 9 } { 9-a }
% \Test:nnnn { I=10 } { I.-0 } { 9 } { 9-b }
% \Test:nnnn { J.1=10 } { J.1.0 } { 9 } { 10 }
% \Test:nnnn { J.1=10 } { J.1.-0 } { 9 } { 10-a }
% \Test:nnnn { J.1=10 } { J.1.-10 } { -1 } { 10-b }
% \Test:nnnn { K.1=KK, KK.2 = 10 } { K.1.2.0 } { 9 } { 11 }
% \Test:nnnn { K.1=KK, KK.2 = 10 } { K.1.2.-0 } { 9 } { 11-a }
% \Test:nnnn { K.1=KK, KK.2 = 10 } { K.1.2.-10 } { -1 } { 11-b }
% \end{test}
%    \begin{macrocode}
                    }
                  }
                }
              }
            }
          } {
%    \end{macrocode}
% No name.
%    \begin{macrocode}
          }
        }
        \int_add:Nn \l_@@_split_int { 12 }
        \tl_put_right:Nx \l_ans_tl {
          \seq_item:Nn \l_split_seq { \l_@@_split_int }
        }
      } {
        \bool_set_false:N \l@@_continue_bool
      }
    }
    \next:
  } {
    \msg_error:nnx
      { beanoves } { :n } { Too~many~calls:~\tl_to_str:n { #1 } }
    \@@_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \@@_if_append:nN { VN, xN } { T, F, TF }
%    \end{macrocode}
% \end{myList}
%
% \begin{function}[TF]{\@@_if_eval_query:nN}
% \begin{syntax}
% \cs{@@_if_eval_query:nNTF} \marg{overlay query} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of the \meta{seq variable}.
% Ranges are supported with the colon syntax.
% This is executed within a local group.
% Below are local variables and constants.
% \begin{variable}{\l_a_tl}
% Storage for the first index of a range.
% \end{variable}
% \begin{variable}{\l_b_tl}
% Storage for the last index of a range, or its length.
% \end{variable}
% \begin{variable}{\c@@_A_cln_Z_regex}
% Used to parse slide range overlay specifications.
% Next are the capture groups.
% \end{variable}
%    \begin{macrocode}
\regex_const:Nn \c@@_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \begin{myList}
% \item 2: \meta{first}
%    \begin{macrocode}
      ( [^:]* ) \s* :
%    \end{macrocode}
% \item 3: second optional colon
%    \begin{macrocode}
      (:)? \s*
%    \end{macrocode}
% \item 4: \meta{length}
%    \begin{macrocode}
      ( [^:]* )
%    \end{macrocode}
% \item 5: standalone \meta{first}
%    \begin{macrocode}
    | ( [^:]+ )
  ) \s* \Z
}
%    \end{macrocode}
% \end{myList}
% \begin{test}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {A:B} {A:B,{A},{},{B},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
% {A} {A,{},{},{},A} {Test~2}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {A:B} {A:B,{A},{},{B},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {A::B} {A::B,{A},{:},{B},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {A:} {A:,{A},{},{},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {A::} {A::,{A},{:},{},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {::B} {::B,{},:,B,{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {::} {::,{},:,{},{}} {Test~1}
% \__beanoves_test_extract:Nnnn \c__beanoves_A_cln_Z_regex
%   {:} {:,{},{},{},{}} {Test~1}
% \end{test}
% \end{function}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_eval_query:nN #1 #2 { T, F, TF } {
\@@_DEBUG:x { EVAL_QUERY:#1/
    \tl_to_str:n{#1}/\string#2=\tl_to_str:N #2}
  \int_gset:Nn \g_@@_append_int { 128 }
  \regex_extract_once:NnNTF \c@@_A_cln_Z_regex {
    #1
  } \l_match_seq {
\@@_DEBUG:x { EVAL_QUERY:#1/
  \string\l_match_seq/\seq_use:Nn \l_match_seq //}
    \bool_set_false:N \l_@@_no_counter_bool
    \bool_set_false:N \l_@@_no_range_bool
%    \end{macrocode}
%
% \begin{function}{\switch:nNTF}
% \begin{syntax}
% \cs{switch:nNTF} \marg{capture group number} \meta{tl variable} \marg{black code} \marg{white code}
% \end{syntax}
% Helper function to locally set the \meta{tl variable}
% to the captured group \meta{capture group number}
% and branch depending on the emptyness of this variable.
% \end{function}
%    \begin{macrocode}
    \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
\@@_DEBUG:x { EQ_SWITCH:##1/ }
      \tl_set:Nx ##2 {
        \seq_item:Nn \l_match_seq { ##1 }
      }
\@@_DEBUG:x { \string ##2/ \tl_to_str:N ##2/}
      \tl_if_empty:NTF ##2 { ##4 } { ##3 }
    }
    \switch:nNTF 5 \l_a_tl {
%    \end{macrocode}
% \emoji{left-speech-bubble} Single expression
%    \begin{macrocode}
      \bool_set_false:N \l_@@_no_range_bool
      \@@_if_append:VNTF \l_a_tl #2 {
        \prg_return_true:
      } {
        \prg_return_false:
      }
    } {
      \switch:nNTF 2 \l_a_tl {
        \switch:nNTF 4 \l_b_tl {
          \switch:nNTF 3 \l_c_tl {
%    \end{macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}::\meta{last}} range
%    \begin{macrocode}
            \@@_if_append:VNTF \l_a_tl #2 {
              \tl_put_right:Nn #2 { - }
              \@@_if_append:VNTF \l_b_tl #2 {
                \prg_return_true:
              } {
                \prg_return_false:
              }
            } {
              \prg_return_false:
            }
          } {
%    \end{macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:\meta{length}} range
%    \begin{macrocode}
            \@@_if_append:VNTF \l_a_tl #2 {
              \tl_put_right:Nx #2 { - }        
              \tl_put_right:Nx \l_a_tl { + ( \l_b_tl ) - 1}  
              \@@_if_append:VNTF \l_a_tl #2 {
                \prg_return_true:
              } {
                \prg_return_false:
              }
            } {
              \prg_return_false:
            }
          }
        } {
%    \end{macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:} and \texttt{\meta{first}::} range
%    \begin{macrocode}
          \@@_if_append:VNTF \l_a_tl #2 {
            \tl_put_right:Nn #2 { - }
            \prg_return_true:
          } {
            \prg_return_false:
          }
        }
      } {
        \switch:nNTF 4 \l_b_tl {
          \switch:nNTF 3 \l_c_tl {
%    \end{macrocode}
% \emoji{left-speech-bubble} \texttt{::\meta{last}} range
%    \begin{macrocode}
            \tl_put_right:Nn #2 { - }
            \@@_if_append:VNTF \l_a_tl #2 {
              \prg_return_true:
            } {
              \prg_return_false:
            }
          } {
\msg_error:nnx { beanoves } { :n } { Syntax~error(Missing~first):~#1 }
          }
        } {
%    \end{macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
%    \begin{macrocode}
          \seq_put_right:Nn #2 { - }
        } 
      }
    }
  } {
%    \end{macrocode}
% Error
%    \begin{macrocode}
    \msg_error:nnn { beanoves } { :n } { Syntax~error:~#1 }
  }
}
%    \end{macrocode}
% \begin{test}
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
%   \__beanoves_DEBUG:n { **********/#4/#1/ }
%   \Beanoves { #1 }
%   \tl_clear:N \l_tmpa_tl
%   \tl_set:Nn \l_tmpb_tl { FAILURE }
%   \__beanoves_if_eval_query:nNT { #2 } \l_tmpa_tl {
%     \tl_set:Nn \l_tmpb_tl { SUCCESS }
%   }
%   \__beanoves_assert_equal:xxn { \l_tmpa_tl } { #3 } {
%     Test~\cs{__beanoves_eval_query:nN}:~#4-a
%   }
%   \__beanoves_assert_equal:xxn { \l_tmpb_tl } { SUCCESS } {
%     Test~\cs{__beanoves_eval_query:nN}:~#4-b
%   }
% }
% \Test:nnnn { A=100 } { 1 } { 1 } { 1 }
% \Test:nnnn { A=100 } { 1+1 } { 2 } { 2 }
% \Test:nnnn { A=100 } { A.1+A.11 } { 210 } { 3 }
% \Test:nnnn { A=100 } { A.1::A.111 } { 100-210 } { 4 }
% \Test:nnnn { A=100 } { A.1:111 } { 100-210 } { 5 }
% \Test:nnnn { A=4 } { A.1 } { 4 } { 6 }
% \Test:nnnn { A=4 } { A.0 } { 3 } { 7 }
% \Test:nnnn { A=4 } { A.-1 } { 2 } { 8 }
% \Test:nnnn { A=4 } { A.-2 } { 1 } { 9 }
% \Test:nnnn { A=4 } { A.-3 } { 0 } { 10 }
% \end{test}
%
% \begin{function}{\@@_eval:nN}
% \begin{syntax}
% \cs{@@_eval:nN} \marg{overlay query list} \meta{tl variable}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated list of \meta{overlay query}'s,
% replacing all the named overlay specifications and integer expressions
% by their static counterparts by calling \cs{@@_eval_query:nN},
% then append the result to the right of the \meta{tl variable}.
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l_ans_seq}
% Storage of the evaluated result.
% \end{variable}
% \begin{variable}{\c@@_comma_regex}
% Used to parse slide range overlay specifications.
%    \begin{macrocode}
\regex_const:Nn \c@@_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_eval:nN #1 #2 {
\@@_DEBUG:x {EVAL:\tl_to_str:n{#1}/\string#2=\tl_to_str:V #2}
  \@@_group_begin:
%    \end{macrocode}
% Local variables declaration
%    \begin{macrocode}
  \seq_clear:N \l_ans_seq
%    \end{macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{first}::\meta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
%    \begin{macrocode}
  \regex_split:NnN \c@@_comma_regex { #1 } \l_query_seq
%    \end{macrocode}
% Then each component is evaluated and the result is stored in \cs{l_ans_seq}
% that we have clear before use.
%    \begin{macrocode}
  \seq_map_inline:Nn \l_query_seq {
    \tl_clear:N \l_ans_tl
    \@@_if_eval_query:nNTF { ##1 } \l_ans_tl {
      \seq_put_right:NV \l_ans_seq \l_ans_tl
    } {
      \seq_map_break:n {
        \msg_fatal:nnn { beanoves } { :n } { Circular~dependency~in~#1}
      }
    }
  }
%    \end{macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to \meta{tl variable}.
%    \begin{macrocode}
  \exp_args:NNNx
  \@@_group_end:
  \tl_put_right:Nn #2 { \seq_use:Nn \l_ans_seq , }
}
\cs_generate_variant:Nn \@@_eval:nN { VN, xN }
%    \end{macrocode}
%
% \begin{function}{\BeanovesEval}
%   \begin{syntax}
%     \cs{BeanovesEval} \oarg{tl variable} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{@@_eval:nN}
% within a group. \cs{l_ans_tl} is used locally to store the result.
% \end{function}
%    \begin{macrocode}
\NewExpandableDocumentCommand \BeanovesEval { s o m } {
  \@@_group_begin:
  \tl_clear:N \l_ans_tl
  \IfBooleanTF { #1 } {
    \bool_set_true:N  \l_@@_no_counter_bool
  } {
    \bool_set_false:N \l_@@_no_counter_bool
  }
  \@@_eval:nN { #3 } \l_ans_tl
  \IfValueTF { #2 } {
    \exp_args:NNNV
    \@@_group_end:
    \tl_set:Nn #2 \l_ans_tl
  } {
    \exp_args:NV
    \@@_group_end: \l_ans_tl
  }
}
%    \end{macrocode}
%
%
% \subsubsection{Reseting slide ranges}
% \begin{function}{\BeanovesReset}
%   \begin{syntax}
%     \cs{beanovesReset} \oarg{first value} \marg{Slide list name}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesReset { O{1} m } {
  \@@_reset:nn { #1 } { #2 }
  \ignorespaces
}
%    \end{macrocode}
% Forwards to \cs{@@_reset:nn}.
% \end{function}
%
% \begin{function}{\@@_reset:nn}
% \begin{syntax}
% \cs{@@_reset:nn} \marg{first value} \marg{slide list name}
% \end{syntax}
% Reset the counter to the given \meta{first value}.
% Clean the cached values also.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_reset:nn #1 #2 {
  \bool_if:nTF {
    \@@_if_in_p:n { #2/A } || \@@_if_in_p:n { #2/Z }
  } {
    \@@_gremove:n { #2/C }
    \@@_gremove:n { #2//A }
    \@@_gremove:n { #2//L }
    \@@_gremove:n { #2//Z }
    \@@_gremove:n { #2//N }
    \@@_gput:nn { #2/C0 } { #1 }
  } {
    \msg_warning:nnn { beanoves } { :n } { Unknown~name:~#2 }
  }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\makeatother
\ExplSyntaxOff
%    \end{macrocode}
% \end{implementation}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
