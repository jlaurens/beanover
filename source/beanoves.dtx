% \iffalse meta-comment
% !TEX program  = LuaLaTeX
% !TEX encoding = UTF-8
%
% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2024 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of named overlay specifications in |beamer| documents.
Named overlay specifications are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\generate{
  \nopreamble
  \nopostamble
  \file{\jobname-test.lua}{\from{\jobname.dtx}{test-lua}}
}
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay specifications

Copyright (C) 2024 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf,
                                beanoves.sty and
                                beanoves-debug.sty.

\endpostamble
\generate{
  \file{\jobname-debug.sty}{\from{\jobname.dtx}{package,debug}}
}
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package,gubed,final}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% !TeX proot = ...
\PassOptionsToPackage{enable-debug}{expl3}
\documentclass{l3doc}
\RequirePackage{luacode}
\RequirePackage{beanoves-debug}
\ExplSyntaxOn
\cs_new:Npn \BNVSNote {
  \msg_note:nnn { beanoves } { :n }
}
\ExplSyntaxOff
\ProvideDocumentEnvironment{BNVS.test}{+b}{}{}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\RequirePackage{minted}
\tcbuselibrary{minted}
\setminted{style=autumn}
\RequirePackage{hyperref}
\ExplSyntaxOn
\debug_on:n {} % 
\ExplSyntaxOff
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specifications with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{\jobname-debug.sty}
\date{\fileversion \qquad \filedate}
\NewDocumentEnvironment{BNVS.macrocode}{}{
  \setlength{\topsep}{0.4em plus 0.15 em minus 0.15 em}
  \leavevmode
  \begin{trivlist}
  \setlist[trivlist]{nosep}
  \item\vspace{-\baselineskip}
}{
  \end{trivlist}
}
\def\KWNmeta#1{\meta{\textsl{#1}}}%
\def\KWNmarg#1{\marg{\textsl{#1}}}%
\NewDocumentEnvironment {BNVS.OnlyImplementation} {} {} {}%
\AddToHook{cmd/OnlyDescription/before}{
\RenewDocumentEnvironment {BNVS.OnlyImplementation} { +b } {} {}%
}%
%\OnlyDescription
\begin{document}
\maketitle
\changes{v1.0}{2025/01/01}{First public release}
\begin{abstract}
This package allows the management of multiple named overlay specifications in \pkg{beamer} documents.
Named overlay specifications are very handy both during edition and
to manage complex and variable \pkg{beamer} overlay specifications.
In particular, they allow to replace raw numbers in \pkg{beamer}
|<...>| overlay specifications by logical identifiers.
Demonstration files are \href[pdfnewwindow]{https://github.com/jlaurens/beanoves/tree/main/demo}{available for download}
as part of the
\href[pdfnewwindow]{https://github.com/jlaurens/beanoves/}{development repository}.
This is a solution to this \href[pdfnewwindow]{https://latex.org/forum/viewtopic.php?t=25777}{\texttt{latex.org} forum query}.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Installation}
\subsection{Package manager}
When not already available, \pkg{beanoves} package
may be installed using a TEX distribution’s package manager,
either from the graphical user interface, or with the relevant command (|tlmgr| for \TeX\ Live and
|mpm| for MiK\TeX).
This should install files \pkg{beanoves.sty} and its debug version
\pkg{beanoves-debug.sty} as well as \pkg{beanoves-doc.pdf} documentation.

\subsection{Manual installation}
The \pkg{beanoves} source files are available from the \href[pdfnewwindow]{https://github.com/jlaurens/beanoves}{source repository}.
They can also be fetched from the \href[pdfnewwindow]{https://ctan.org/pkg/beanoves}{CTAN repository}.

\subsection{Usage}
The \pkg{beanoves} package is imported by putting \mintinline{latex}{\RequirePackage{beanoves}}
in the preamble of a \LaTeX\ document that uses the \pkg{beamer} class.
Should the package cause problems, 
its features can be temporarily deactivated with
simple commands \cs{BeanovesOff} and \cs{BeanovesOn}.

\section{Minimal example}
%
The \LaTeX\ document below is a contrived example to show how the |beamer|
overlay specifications have been extended.
More demonstration files are available from the
\href[pdfnewwindow]{https://github.com/jlaurens/beanoves/tree/main/demo}{\pkg{beanoves} source repository}.
\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted language=latex,
}
\documentclass{beamer}
\RequirePackage{beanoves}
\begin{document}
\Beanoves {
  A = 1:4,
  B = A.last::3,
  C = B.next,
}
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
-- \visible<?(A.1)> {Only on slide 1}\\
-- \visible<?(B.range)> {Only on slides 4 to 6}\\
-- \visible<?(C.1)> {Only on slide 7}\\
-- \visible<?(A.2)> {Only on slide 2}\\
-- \visible<?(B.2:B.last)> {Only on slides 5 to 6}\\
-- \visible<?(C.2)> {Only on slide 8}\\
-- \visible<?(A.next)-> {From slide 5}\\
-- \visible<?(B.3:B.last)> {Only on slide 6}\\
-- \visible<?(C.3)> {Only on slide 9}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare \emph{named overlay sets}.
On line 5, we declare an overlay set named `A', which is a range starting at slide 1 and ending at slide 4.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1 because 1 is the first index of the overlay set named A.
On line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.next)} stands for 5.
%
On line 6, we declare a second overlay set named `B',
starting after the 3 slides of `A' namely 4.
Its length is 3 meaning that its last slide number is 6,
thus each \texttt{?(B.last)} is replaced by 6.
The next slide number after slide range `B' is 7
which is also the start of the third slide range
due to line 7.
\section{Named overlay sets}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn
according to overlay specifications. The main overlay set is a range of integers
covering all the slide numbers, from one to the total amount of slides.
In general, an overlay set is a range of positive integers identified by a unique name.
The main practical interest is that such sets may be defined relative to one another, we can even have lists of overlay sets.
Finally, we can use these lists to build and organize \pkg{beamer} overlay
specifications logically.
\subsection{Named overlay reference}
|A.1|, |C.2| are \emph{named overlay references}, as well as |A| and |Y!C.2|.
More precisely, they are string identifiers, each one referencing
a well defined static integer or range to be used in \pkg{beamer} overlay specifications.
They have 3 components:
\begin{enumerate}
\item \texttt{\KWNmeta{frame id}!}, like |X!|, optional
\item \texttt{\KWNmeta{short name}} like |A|, required
\item \texttt{.\meta{\textsl{c}_1}....\meta{\textsl{c}_j}} like |.B.C|, optional (\(j=0\)), globally denoted as \emph{dotted path}.
\end{enumerate}
The \emph{frame ids}, \emph{short names} and \meta{c}'s
are alphanumerical case sensitive identifiers,
with possible underscores but with no space.
Unicode symbols above \texttt{U+00A0} are allowed if the underlying \TeX\ engine
supports it.
Only the \emph{frame id} is allowed to be empty, in which case it may apply to any common frame.
The \emph{short names} must not consist of only lowcase letters.

The mapping from \emph{named overlay references} to sets of integers is defined
at the global \TeX\ level to allow its use in
\mintinline{latex}{\begin{frame}<...>}
and to share the same overlay sets between different frames.
Hence the \emph{frame id} due to the need to possibly target a particular frame.

\subsection{Defining named overlay sets}
In order to define \emph{named overlay sets}, we can either execute the next \cs{Beanoves} command  before a \pkg{beamer} \text{frame} environment, or use the custom |beanoves| option of this environment.
%
\begin{function}{\Beanoves, \Beanoves*}
  \begin{syntax}
    \cs{Beanoves}\{\meta{\textsl{ref}_1}=\meta{\textsl{spec}_1},...,\meta{\textsl{ref}_j}=\meta{\textsl{spec}_j}\}
  \end{syntax}
Each \meta{\textsl{ref}} key is a \emph{named overlay reference} whereas each \meta{\textsl{spec}} is an \emph{overlay set specifier}.
When the same \meta{\textsl{ref}} key is used multiple times, only the last one is taken into account.
Notice that \texttt{\meta{\textsl{ref}}=1} can be shortened to \text{\meta{\textsl{ref}}}.
%
\end{function}
When performed at the document level, the \cs{Beanoves} command starts by cleaning 
what was set by previous calls. When performed inside \LaTeX\ environments,
each new call cumulates with the previous one.
Notice that the argument of this function can contain macros:
they will be exhaustively expanded at resolution time\footnote{Precision is needed about the exact time when the expansion occurs.}.
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{\meta{\textsl{ref}_1}=\meta{\textsl{spec}_1},...,\meta{\textsl{ref}_j}=\meta{\textsl{spec}_j}\}
  \end{syntax}
\end{function}
The \cs{Beanoves} arguments take precedence over both the \cs{Beanoves*} arguments
and the \texttt{beanoves} options. This allows to provide an overlay name
only when not already defined, which is helpfull when the very same frame source
is included multiple times in different contexts.
%
\subsubsection{Value specifiers}
\label{section:ValueSpecifiers}
Hereafter \meta{\textsl{value}} denotes a numerical expression.
\begin{description}
\item[\texttt{\meta{\textsl{ref}}=\meta{\textsl{value}}},]
a \emph{value specifier} for a single number.
When omitted it defaults to \(1\).
\item[\texttt{\meta{\textsl{ref}}=[%]
\meta{index_1}=\meta{value_1},...,\meta{index_j}=\meta{value_j}%[
]},] a \emph{value specifier} partially defined in extension.
\meta{\textsl{index}} denotes an explicit positive integer.
This removes the actual \meta{\textsl{ref}} and executes
\texttt{\meta{\textsl{ref}}.\meta{\textsl{index}_k}=\meta{\textsl{value}_k}} for \(1≤k≤j\).
When \texttt{\meta{\textsl{index}_k}=} is omitted,
\texttt{\meta{\textsl{i}}=\meta{\textsl{value}_k}} is executed
where \meta{i} is the smallest positive integer such that
\texttt{\meta{\textsl{ref}}.\meta{\textsl{i}}} is not already defined.
\end{description}

The numerical expressions are evaluated and then rounded using
\cs{fp_eval:n}. They can contain mathematical functions and
\emph{named overlay references} defined above but should not
contain \emph{named overlay references} to \emph{value specifiers}.

The corresponding ovelay set can be seen as a \emph{value counter}.


\subsubsection{Range specifiers}
Hereafter \KWNmeta{first}, \KWNmeta{last} and
\KWNmeta{length} are \emph{value specifiers}.
\begin{description}[noitemsep]
\item[\meta{\textsl{ref}}=\texttt{\KWNmeta{first}:},]
\item[\meta{\textsl{ref}}=\texttt{\KWNmeta{first}::},]
for the infinite range of signed integers starting at and including \KWNmeta{first}.
\end{description}
\begin{description}[noitemsep]
\item[\meta{\textsl{ref}}=\texttt{\KWNmeta{first}:\KWNmeta{last}},]
\item[\meta{\textsl{ref}}=\texttt{\KWNmeta{first}::\KWNmeta{length}},]
\item[\meta{\textsl{ref}}=\texttt{:\KWNmeta{last}::\KWNmeta{length}},]
\item[\meta{\textsl{ref}}=\texttt{::\KWNmeta{length}:\KWNmeta{last}},]
are variants for the same finite range of signed integers starting at and including \KWNmeta{first}, ending at and including \KWNmeta{last},
provided \(\KWNmeta{first}+\KWNmeta{length}=\KWNmeta{last}+1\).
\texttt{\KWNmeta{first}} can be omitted, in which case it defaults to \(1\).
Additionally \texttt{:\KWNmeta{last}}
and \texttt{::\KWNmeta{length}} are then equivalent.
\end{description}
\begin{description}[noitemsep]
\item[\meta{\textsl{ref}}=\texttt{:\KWNmeta{last}},]
\item[\meta{\textsl{ref}}=\texttt{::\KWNmeta{length}},]
are syntactic sugar when \KWNmeta{first} is \(1\).
\end{description}
\subsubsection{List specifiers}
\begin{BNVS.OnlyImplementation}
\end{BNVS.OnlyImplementation}
\label{section:ListSpecifiers}
%<*!final>
Here is the
\hyperref[implementation/section:ListSpecifiers]{implementation}.
%</!final>
\begin{description}
\item[\texttt{\meta{\textsl{ref}}=\{\meta{\textsl{value}}\}},]
synonym of \texttt{\meta{\textsl{ref}}=\meta{\textsl{value}}}.
%where \texttt{\meta{\textsl{definition}_k}}, \(1≤k≤j\), is one of
%
\item[\texttt{\meta{\textsl{ref}}=\{\meta{\textsl{def}_1},...,\meta{\textsl{def}_j}\}},]
where \texttt{\meta{\textsl{def}_k}}, \(1≤k≤j\), is one of
\begin{itemize}
\item \texttt{\meta{\textsl{index}}=\meta{\textsl{spec}}},
\item \texttt{\meta{\textsl{spec}}} for \texttt{\meta{\textsl{i}}=\meta{\textsl{spec}}},
\meta{\textsl{i}} being the smallest positive integer such that \texttt{\meta{\textsl{ref}}.\meta{\textsl{i}}}
is not already defined.
\end{itemize}
for value or range specifiers.
The first step is to remove previous \meta{\textsl{ref}} related definitions, then execute the various
\texttt{\meta{\textsl{ref}}.\meta{\textsl{index}}=\meta{\textsl{spec}}}
definitions in the order given.
%where \texttt{\meta{\textsl{def}_k}}, \(1≤k≤j\), is one of
%
\item[\texttt{\meta{\textsl{ref}}=\{\{\meta{\textsl{def}_1},...,\meta{\textsl{def}_j}\}\}},]
where \texttt{\meta{\textsl{def}_k}}, \(1≤k≤j\), is one of
\begin{itemize}
\item \texttt{\meta{\textsl{name}}=\meta{\textsl{spec}}},
\item \texttt{\meta{\textsl{name}}} for \texttt{\meta{\textsl{name}}=1},
\end{itemize}
The first step is to remove previous \meta{\textsl{ref}} related definitions, then execute the various
\texttt{\meta{\textsl{ref}}.\meta{\textsl{name}}=\meta{\textsl{spec}}}
definitions in the order given.
\KWNmeta{spec} is any specifier.
\end{description}

\section{Resolution of \texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} normally included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\KWNmeta{queries})}'. Each one is then evaluated and replaced by its resolved static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \KWNmeta{queries} argument is a comma separated list of individual \KWNmeta{query}'s processed from left to right as explained below.
Notice that nesting a \texttt{?(...)} query expression inside another
query expression is not supported.

The named overlay sets defined above are queried for integer numerical values
that will be passed to \pkg{beamer}.
Turning an \emph{overlay query} into the static expression it represents,
as when above \texttt{?(A.1)} was replaced by \texttt{1}, is denoted by \emph{overlay query resolution} or simply \emph{resolution}.
The process starts by replacing any \emph{query reference} by its value as explained below until obtaining numerical expressions that are evaluated and finally rounded to the nearest integer to feed \pkg{beamer} with either ranges or numbers.
When the \emph{query reference} is a previously declared \texttt{\KWNmeta{ref}}, like |X| after |X=1|,
it is simply replaced by the corresponding declared
\texttt{\KWNmeta{value}}, here |1|.
Otherwise, we use \emph{implicit overlay queries} and their \emph{resolution rules} depending
on the definition of the named overlay set.
Hereafter \KWNmeta{i} denotes a signed integer whereas \KWNmeta{value},
\KWNmeta{first}, \KWNmeta{last} and \KWNmeta{length} stand for raw integers
or more general numerical expressions that are evaluated beforehands.
%We assume that \(\KWNmeta{first}≤\KWNmeta{last}\) and \(\KWNmeta{length}≥0\).

\emph{Resolution} occurs only when requested and the result is cached for
performance reason.

\subsection{Range overlay queries}
\label{section:ROQ}
\begin{description}
\item[\texttt{\meta{\textsl{ref}} = \KWNmeta{first}:}] as well as \texttt{\KWNmeta{first}::}
defines a range limited from below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\KWNmeta{ref}   & \KWNmeta{first}-\\
\KWNmeta{ref}.1 & \KWNmeta{first}\\
\KWNmeta{ref}.2 & \(\KWNmeta{first}+1\) \\
\KWNmeta{ref}.\KWNmeta{i} & \(\KWNmeta{first} + \KWNmeta{i} - 1\) \\
\KWNmeta{ref}.previous & \(\KWNmeta{first}-1\)\\
\KWNmeta{ref}.first & \(\KWNmeta{first}\)\\
\hline
\end{tabular}
\end{center}
Notice that \texttt{\KWNmeta{ref}.previous} and \texttt{\KWNmeta{ref}.0} are most of the time synonyms.
\item[\texttt{\KWNmeta{ref} = \KWNmeta{first}:\KWNmeta{last}}]
as well as variants \texttt{\KWNmeta{first}::\KWNmeta{length}},
\texttt{::\KWNmeta{length}:\KWNmeta{last}}
or \texttt{:\KWNmeta{last}::\KWNmeta{length}},
which are equivalent provided \(\KWNmeta{first}+\KWNmeta{length} = \KWNmeta{last}+1\).

For a range limited from both above and below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\KWNmeta{ref} & \KWNmeta{first}-\KWNmeta{last}\\
\KWNmeta{ref}.1 & \(\KWNmeta{first}\)\\
\KWNmeta{ref}.2 & \(\KWNmeta{first}+1\) \\
\KWNmeta{ref}.\meta{i} & \(\KWNmeta{first} + \KWNmeta{\textsl{i}} - 1\) \\
\KWNmeta{ref}.previous & \(\KWNmeta{first}-1\)\\
\KWNmeta{ref}.first & \(\KWNmeta{first}\)\\
\KWNmeta{ref}.last & \(\KWNmeta{last}\)\\
\KWNmeta{ref}.next & \(\KWNmeta{last}+1\)\\
\KWNmeta{ref}.length & \(\KWNmeta{length}\)\\
\hline
\end{tabular}
\end{center}
Notice that the resolution of \texttt{\meta{\textsl{ref}}} is a \pkg{beamer} range and not an algebraic difference,
negative integers do not make sense there while in \pkg{beamer} context.

In the frame example below, we use the \cs{BeanovesResolve} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted language=latex,
}
\Beanoves {
  A = 3:8, % or similarly A = 3::6, A = ::6:8 and A = :8::6
}
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesResolve[show](A)          == 3-8,
\BeanovesResolve[show](A.1)        == 3,
\BeanovesResolve[show](A.-1)       == 1,
\BeanovesResolve[show](A.previous) == 2,
\BeanovesResolve[show](A.first)    == 3,
\BeanovesResolve[show](A.last)     == 8,
\BeanovesResolve[show](A.next)     == 9,
\BeanovesResolve[show](A.length)   == 6,
\end{frame}
\end{tcblisting}
%
\item[\texttt{\meta{\textsl{ref}} = \{...\}}]
for an indexed list of specifications.
The resolution of the overlay query
\texttt{\KWNmeta{ref}} gives the resolution of each item of the list, separated by commas, for the largest consecutive indices starting a \(1\).
%
\item[\texttt{\meta{\textsl{ref}} = \{\{...\}\}}]
for a named list of specifications.
The resolution of the overlay query
\texttt{\KWNmeta{ref}} gives the resolution of each item of the list, in the given order, separated by commas.
Notice that each item may in turn be resolved into a comma separated
list of \pkg{beamer} ranges.
\end{description}
%
\subsection{Value counter queries}
\label{section:counter}
\begin{description}
\item[\texttt{\meta{\textsl{ref}} = \meta{\textsl{value}}}] defines a counter value.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\KWNmeta{ref}   & \(\KWNmeta{value}\)\\
\KWNmeta{ref}.1 & \(\KWNmeta{value}\)\\
\KWNmeta{ref}.2 & \(\KWNmeta{value}+1\) \\
\KWNmeta{ref}.\KWNmeta{i} & \(\KWNmeta{value} + \KWNmeta{i} - 1\) \\
\KWNmeta{ref}.previous & \(\KWNmeta{value}-1\)\\
\KWNmeta{ref}.first & \(\KWNmeta{value}\)\\
\KWNmeta{ref}.last & \(\KWNmeta{value}\)\\
\KWNmeta{ref}.next & \(\KWNmeta{value}+1\)\\
\hline
\end{tabular}
\end{center}
\end{description}
Additionnaly, resolution rules are provided for dedicated \emph{overlay queries}, here \KWNmeta{ref} is considered a standard programming variable:
\begin{description}
\item[\texttt{\KWNmeta{ref}=\KWNmeta{integer expression}},] resolve \KWNmeta{integer expression} into \KWNmeta{integer}, assign it to the \KWNmeta{ref} and use it.
It defines \KWNmeta{ref} globally if not already done.
Here \KWNmeta{integer expression} is the longest character sequence with no space%
\footnote{The parser for algebraic expression is very rudimentary.}.
\item[\texttt{\meta{\textsl{ref}}+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{\textsl{integer}}, advance \meta{\textsl{ref}} by \meta{\textsl{integer}} and use the result.
\item[\texttt{++\meta{\textsl{ref}}},] increment \meta{\textsl{ref}} by \(1\) and use it.
\item[\texttt{\meta{\textsl{ref}}++},] use \meta{\textsl{ref}} and then increment it by \(1\).
\end{description}

This can be used for an indirection.
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted language=latex,
}
\Beanoves {
  A = 1,
  B = { 10 = 100 },
  C = 10,
}
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesResolve[show](A.C)     == \BeanovesResolve[show](A.10) == 10,
\BeanovesResolve[show](B.C)     == \BeanovesResolve[show](B.10) == 100,
\BeanovesResolve[show](A.C+=10) == \BeanovesResolve[show](A.20) == 20,
\BeanovesResolve[show](B.C)     == \BeanovesResolve[show](B.20) == 20,
\end{frame}
\end{tcblisting}

In order to decrement a counter, one can increment with a negative value, no dedicated syntax is provided yet.

For each new frame, these counters are reset to the value
they were initialized with. Sometimes, resetting the counter
manually is necessary, for example when managing \pkg{tikz} overlay material.
%
\begin{function}{\BeanovesReset}
  \begin{syntax}
    \cs{BeanovesReset} \oarg{\textsl{options}} \{\meta{\textsl{ref}_1}[=\meta{\textsl{spec}_1}],..., \meta{\textsl{ref}_j}[=\meta{\textsl{spec}_j}]\}
  \end{syntax}
This command is very similar to \cs{Beanoves},
except that a standalone \texttt{\meta{\textsl{ref}_i}} resets the counter to
its default value and that it is meant to be used inside a
\texttt{frame} environment. When the \texttt{all} option is provided,
some internals that were cached for performance reasons are cleared
as well.
\end{function}
\subsection{Dotted paths}
\label{section:DottedPaths}
Previous overlay queries may fail simply because \meta{\textsl{ref}} is not defined.
If the \emph{dotted path} is empty, an error is raised and the resolution returns \texttt{0}.

If the \emph{dotted path} is not empty, \meta{\textsl{ref}} is
\texttt{\meta{\textsl{name}}.\meta{\textsl{c}_1}....\meta{\textsl{c}_j}}.
The indirection resolution takes place:
the path is split into 
\texttt{.\meta{\textsl{c}_1}.\meta{\textsl{c}_2}...\meta{\textsl{c}_{k}}}
and 
\texttt{.\meta{\textsl{c}_{k+1}}...\meta{\textsl{c}_j}},
where $0≤k≤j$,
\texttt{\meta{\textsl{name}}.\meta{\textsl{c}_1}.\meta{\textsl{c}_2}...\meta{\textsl{c}_k}} is defined,
\texttt{\meta{\textsl{c}_{k+1}}...\meta{\textsl{c}_j}} is defined as a \emph{value counter},
and \(k\) is the largest.
Then \texttt{\meta{\textsl{c}_{k+1}}...\meta{\textsl{c}_j}} is resolved into \meta{\textsl{integer}},
taking into account the \emph{value counter} resolution rules,
and \texttt{\meta{\textsl{name}}.\meta{\textsl{c}_1}.\meta{\textsl{c}_2}...\meta{\textsl{c}_k}.\meta{\textsl{integer}}}
is resolved in turn.

If no such \(k\) exists, the replacement resolution takes place:
the longest reference
\texttt{\meta{\textsl{name}}.\meta{\textsl{c}_1}.\meta{\textsl{c}_2}...\meta{\textsl{c}_k}},
where $0≤k≤j$, is first replaced by its definition \texttt{\meta{\textsl{name'}}.\meta{\textsl{c'}_1}...\meta{\textsl{c'}_l}} if any and then the modified overlay query is resolved with preceding rules as well as this one. For example, with
\mintinline{latex}{\Beanoves{A.B=D, D.C=E}},
|A.B.C| is resolved like |E|.

If this resolution still fails, an error is raised and the resolution
returns \texttt{0}.

Care should be taken to avoid circular dependencies.
%
\subsection{The \texttt{beamer} counters}
While inside a \texttt{frame} environment,
it is possible to save the current value of the \texttt{beamerpauses} counter that controls whether elements should appear on the current slide.
For that, we can execute one of \mintinline[escapeinside=||]{latex}{\Beanoves{|\meta{\textsl{ref}}|=pauses}} or in a query
\mintinline[escapeinside=||]{latex}{?(...(|\meta{\textsl{ref}}|=pauses)...)}.
Then later on, we can use |?(...|\meta{\textsl{ref}}|...)| to refer to this saved value
in the same frame\footnote{See
\href[pdfnewwindow]{https://tex.stackexchange.com/questions/34458/reference-overlay-numbers-with-names}{stackexchange}
for an alternative that needs at least two passes.}.
Next frame source is an example of usage.
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted language=latex,
}
\begin{frame}
\visible<+->{A}\\
\visible<+->{B\Beanoves{afterB=pauses}}\\
\visible<+->{C}\\
\visible<?(afterB)>{other C}\\
\visible<?(afterB.previous)>{other B}\\
\end{frame}
\end{tcblisting}
``A'' first appears on slide 1, ``B'' on slide 2 and ``C'' on slide 3.
On line 2, |afterB| takes the value of the \texttt{beamerpauses}
counter once updated, \emph{id est} 3.
``B'' and ``other B'' as well as ``C'' and ``other C'' appear at the same time.
%
If the |beamerpauses| counter is not suitable,
we can execute instead one of \mintinline[escapeinside=||]{latex}{\Beanoves{|\meta{\textsl{ref}}|=slideinframe}} or in a query
\mintinline[escapeinside=||]{latex}{?(...(|\meta{\textsl{ref}}|=slideinframe)...)}.
It uses the numerical value of
\mintinline{latex}{\insertslideinframe}.

\subsection{Multiple queries}
It is possible to replace the comma separated list |?(|\meta{\textsl{query}_1}|),...,?(|\meta{\textsl{query}_j}|)| with the shorter |?(|\meta{\textsl{query}_1}|,...,|\meta{\textsl{query}_j}|)|.
%
\subsection{Frame id}
Except for very special situations, the \emph{frame ids} can be left unspecified.
When no \emph{frame id} was explicitly provided,
\pkg{beanoves} uses the \emph{last frame id} and if the resolution fails
an empty \emph{frame id}. At the beginning of each frame,
the \emph{last frame id} is set to the \emph{frame id} of the current frame,
which is denoted \emph{current frame id} and is empty by default.
Then it gets updated after each named reference resolution where a
\emph{frame id} is explicitly given.
For example, the first time |A.1| reference is resolved within a given frame,
it is first translated to \texttt{\meta{\textsl{last frame id}}!A.1},
but when used just after \texttt{Y!C.2}, for example, it becomes a shortcut to
\texttt{Y!A.1} because the \emph{last frame id} is then \texttt{Y}.

In order to set the \emph{frame id} of the current frame to \meta{\textsl{frame id}},
use the new \texttt{beanoves id} option of the \pkg{beamer} frame environment. 
\begin{function}{beanoves id}
  \begin{syntax}
    beanoves id=\meta{\textsl{frame id}},
  \end{syntax}
\end{function}
We can use the same \meta{\textsl{frame id}} for different frames to share named overlay sets.
When a query contains an undefined \emph{qualified dotted name} with an explicit \meta{\textsl{frame id}},
the resolution uses instead the \emph{qualified dotted name} with an empty \meta{\textsl{frame id}} instead, if possible.
For example, if |X!A| is not defined, |!A| is used instead.
\textcolor{red}{NOT YET IMPLEMENTED}
%
\subsection{Resolution command}
\begin{function}{\BeanovesResolve}
  \begin{syntax}
    \cs{BeanovesResolve} \oarg{\textsl{setup}} \marg{\textsl{queries}}
  \end{syntax}
This function resolves the \meta{\textsl{queries}},
which are like the argument of |?(...)| instructions:
a comma separated list of single \meta{\textsl{query}}'s.
The optional \meta{\textsl{setup}} is a key--value:
\begin{itemize}
\item[\texttt{show}] the result is left into the input stream
\item[\texttt{in:N=\meta{command}}] the result is stored into \KWNmeta{command}.
\end{itemize}
\end{function}
%
\section{Support}
See the \href[pdfnewwindow]{https://github.com/jlaurens/beanoves}{source repository}.
One can report issues there.

\end{documentation}
\DocInput{beanoves.dtx}
\begin{luacode}
local bnvs = require("./\jobname-test.lua")
tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
local ra = bnvs.check_variants("\jobname.sty")
tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
--[[
if ra then
  for _,v in ipairs(ra) do
    tex.print("\\verb|"..v.."|\\\\")
  end
end
]]
\end{luacode}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \NewDocumentEnvironment {BNVS.gobble} { +b } {} {}
% \begin{implementation}
% \begin{BNVS.gobble}
%<*package>
% \end{BNVS.gobble}
%
%\begin{BNVS.gobble}
%\begin{luacode}
%local bnvs = require("./\jobname-test.lua")
%tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
%local ra = bnvs.check_variants("\jobname-debug.sty")
%tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
%--[[
%if ra then
%  for _,v in ipairs(ra) do
%    tex.print("\\verb|"..v.."|\\\\")
%  end
%end
%]]
%\end{luacode}
%\end{BNVS.gobble}
%
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention, unused).
% \begin{BNVS.macrocode}
%    \begin{macrocode}
%<MY=bnvs>
%    \end{macrocode}
% \end{BNVS.macrocode}
% Reserved namespace:
% identifiers containing the case insensitive string |beanoves| or
% containing the case insensitive string |bnvs| delimited by two non characters.
%
% \subsection{Package declarations}
%
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  {beanoves}
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
%<*!final>
  {beanoves-debug}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  {2024/01/11}
  {1.0}
  {Named overlay specifications for beamer}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{Facility layer: definitions and naming}
% In order to make the code shorter and easier to read during development, we add a layer
% over \LaTeX3. The |c| and |v| argument specifiers take a slightly different meaning when
% used in a function which name contains with |bnvs| or |BNVS|.
% Where \LaTeX3 would transform |l__bnvs_ref_tl| into |\l__bnvs_ref_tl|,
% \pkg{bnvs} will directly transform |ref| into |\l__bnvs_ref_tl|.
% The type of the local variable used depends on the context and may be
% |seq| or |int| for example.
% There are however a pair of exceptions mentionned below.
% For a better reading experience,
% `|ref|' will generally stand for |\l__bnvs_ref_tl|,
% whereas `|path| sequence' will generally stand for |\l__bnvs_path_seq|.
% Other similar shortcuts are used as well. 
%
% Functions with |BNVS| in their names are management functions.
% They belong to a deeper layer and do not contain any logic specific
% to the \pkg{beanoves} package.
% \begin{function}{
%   \BNVS:c,
%   \BNVS_l:cn,
%   \BNVS_g:cn,
% }
% \begin{syntax}
% \cs{BNVS:c} \marg{cs core name}
% \cs{BNVS_l:cn} \marg{local variable core name} \marg{ type }
% \cs{BNVS_g:cn} \marg{global variable core name} \marg{ type }
% \end{syntax}
% These are naming functions.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS:c    #1    { __bnvs_#1     }
\cs_new:Npn \BNVS_l:cn #1 #2 { l__bnvs_#1_#2 }
\cs_new:Npn \BNVS_g:cn #1 #2 { g__bnvs_#1_#2 }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \BNVS_use_raw:c,
%   \BNVS_use_raw:Nc,
%   \BNVS_use_raw:nc,
%   \BNVS_use:c,
%   \BNVS_use:Nc,
%   \BNVS_use:nc,
% }
% \begin{syntax}
% \cs{BNVS_use_raw:c} \marg{cs name}
% \cs{BNVS_use_raw:Nc} \KWNmeta{function} \marg{cs name}
% \cs{BNVS_use_raw:nc} \marg{tokens} \marg{cs name}
% \cs{BNVS_use:c} \marg{cs core}
% \cs{BNVS_use:Nc} \KWNmeta{function} \marg{cs core}
% \cs{BNVS_use:nc} \marg{tokens} \marg{cs core}
% \end{syntax}
% \cs{BNVS_use_raw:c} is a wrapper over \cs{use:c}.
% possibly prepended with some code.
% It needs 3 expansion steps just like \cs{BNVS_use:c}.
% The other are used to expand |\use:c| enough before usage by
% \KWNmeta{function} or \meta{tokens}.
% The first argument of \KWNmeta{function} has type |N|.
% The next token after \meta{tokens} will have type |N| too.
% \meta{cs name} is a full cs name
% whereas \meta{cs core} will be prepended with the appropriate prefix.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:N #1 { #1 }
\cs_new:Npn \BNVS_use_raw:c #1 {
  \exp_last_unbraced:No
  \BNVS_use_raw:N { \cs:w #1 \cs_end: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:c #1 {
  \BNVS_use_raw:c { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\BNVS_use:c, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use:c { TEST:n } { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_tl { XX } { 
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:NN #1 #2 {
  #1 #2
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:nN #1 #2 {
  #1 #2
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:Nc #1 #2 {
  \exp_last_unbraced:NNo
  \BNVS_use_raw:NN #1 { \cs:w #2 \cs_end: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:nc #1 #2 {
  \exp_last_unbraced:Nno
  \BNVS_use_raw:nN { #1 } { \cs:w #2 \cs_end: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { \BNVS:c { #2 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:nc #1 #2 {
  \BNVS_use_raw:nc { #1 } { \BNVS:c { #2 } }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_use_raw_saved:N \BNVS_use_raw:N
\cs_set:Npn \BNVS_use_raw:N #1 {
  \cs_if_exist:NF #1 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #1~(c) }
  }
  #1
}
\cs_set_eq:NN \BNVS_use_raw_saved:NN \BNVS_use_raw:NN
\cs_set:Npn \BNVS_use_raw:NN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #2~(N) }
  }
  \BNVS_use_raw_saved:NN #1 #2
}
\cs_set_eq:NN \BNVS_use_raw_saved:nN \BNVS_use_raw:nN
\cs_set:Npn \BNVS_use_raw:nN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #2~(use_raw:nN) }
  }
  \BNVS_use_raw_saved:nN { #1 } #2
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:N=\BNVS_tl_use:Nc, noigre}
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
% \begin{BNVS.test}{:N=\BNVS_tl_use:Nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x { NO_WAY \token_to_str:N #1 }
%   }
% }
% \BNVS_tl_use:Nc \BNVS_Test:N { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\BNVS_tl_use:nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x {
%       ^^J=>\token_to_str:N #1
%       ^^J=>\tl_to_str:N #1
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:x {
%       ^^J=>\tl_to_str:N \l__bnvs_TEST_tl
%       ^^J=>\tl_to_str:n { #1 }
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_tl_use:nvv #1 #2 {
  \BNVS_tl_use:nv { \BNVS_tl_use:nv { #1 } { #2 } }
}
\cs_new:Npn \BNVS_tl_use:nvvv #1 #2 {
  \BNVS_tl_use:nvv { \BNVS_tl_use:nv { #1 } { #2 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\BNVS_use_raw:c, noigre}
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_Test: { SUCCESS }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A }
% \tl_clear:N \l__bnvs_TEST_tl
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use_raw:c { BNVS_Test: } }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A' }
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_fatal:x #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { FAILURE }
% }
% \cs_undefine:N \BNVS_Test:
% \BNVS_use_raw:c { BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { FAILURE } { B }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\BNVS_use:Nc{/:nc}, noigre}
% \BNVS_new:cpn { TEST: } { SUCCESS }
% \cs_if_exist:cF { \BNVS:c { TEST: } } {
%   \BNVS_fatal:x { Unknown~bnvs~command~TEST:~(ii-N) }
% }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \exp_args:No \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { E / \token_to_str:N #1 / }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \BNVS_set:cpn { TEST: } { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \cs_if_eq:NNF #1 \__bnvs_TEST: {
%     \test_fail:x { TEST / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_log:n #1 { }
\cs_generate_variant:Nn \BNVS_log:n { x }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}{
%   \BNVS_DEBUG_on:n,
%   \BNVS_DEBUG_off:n,
%   \BNVS_DEBUG_push:n,
%   \BNVS_DEBUG_pop:,
% }
% \begin{syntax}
% \cs{BNVS_DEBUG_on:n} \KWNmarg{type}
% \cs{BNVS_DEBUG_off:n} \KWNmarg{type}
% \cs{BNVS_DEBUG_push:n} \KWNmarg{types}
% \cs{BNVS_DEBUG_pop:}
% \end{syntax}
% These functions are only available in debug mode.
% Manage debug messaging for one given \meta{type} or \meta{types}.
% The implementation is not publicly exposed.
% \end{function}
% \begin{BNVS.gobble}
% Defines |\BNVS_DEBUG_|\texttt{\meta{type}}|_log:n|
% and its |:x| variant.
% \cs{BNVS_DEBUG_declare:n} creates the command \cs{BNVS_DEBUG_\meta{type}_log:n}
% for each \meta{type} in \meta{types}.
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_DEBUG:c #1 {
  BNVS_DEBUG~#1~
}
\cs_new:Npn \BNVS_DEBUG_on:n #1 {
  \tl_if_empty:nT { #1 } {
    \typein { Empty~argument~not~allowed }
  }
  \cs_set:cpn { \BNVS_DEBUG:c { #1 } log:n } { \BNVS_log:n }
  \cs_generate_variant:cn { \BNVS_DEBUG:c { #1 } log:n } { x }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_DEBUG_off:n #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
  \tl_if_empty:nT { #1 } {
    \typein { Empty~argument~not~allowed }
  }
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_set:cpn { \BNVS_DEBUG:c { #1 } log:n } { \use_none:n }
}
\seq_new:N \l_BNVS_DEBUG_push_n_seq
\cs_new:Npn \BNVS_DEBUG_push:n #1 {
  \tl_if_empty:nT { #1 } {
    \typein { Empty~argument~not~allowed }
  }
  \tl_map_inline:nn { #1 } {
    \BNVS_DEBUG_on:n { ##1 }
  }
  \seq_put_left:Nn \l_BNVS_DEBUG_push_n_seq {
    \tl_map_inline:nn { #1 } {
      \BNVS_DEBUG_off:n { ##1 }
    }
  }
}
\tl_new:N \l_BNVS_DEBUG_push_n_tl
\cs_new:Npn \BNVS_DEBUG_pop: {
  \seq_pop_left:NNTF \l_BNVS_DEBUG_push_n_seq \l_BNVS_DEBUG_push_n_tl {
    \l_BNVS_DEBUG_push_n_tl
  } {
    \BNVS_error:n { Unbalanced~\BNVS_DEBUG_pop: }
  }
}
\AddToHookNext { env/BNVS.test/begin } {
  \BNVS_DEBUG_push:n {CDBGpfarsRomqi}
  \BNVS_DEBUG_pop:
}
\cs_new:Npn \BNVS_DEBUG_log:nn #1 {
  \cs_if_exist_use:cF { \BNVS_DEBUG:c { #1 } log:n } {
    \BNVS_warning:n { Undeclared~DEBUG~type:~#1}
    \cs_new:cpn { \BNVS_DEBUG:c { #1 } log:n } { \use_none:n }
    \use_none:n
  }
}
\cs_new:Npn \BNVS_DEBUG_on: {
  \BNVS_DEBUG_on:n {C}
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_on:
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_DEBUG_off: {
  \BNVS_DEBUG_off:n {C}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \BNVS_new:cpn,
%   \BNVS_set:cpn,
% }
% \cs{BNVS_new:cpn} is like \cs{cs_new:cpn} except that the name
% argument is tagged for \pkg{beanoves} package.
% Similarly for \cs{BNVS_set:cpn}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new:cpn #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: C -> command sequence
%<*!final>
\BNVS_DEBUG_log:nn C { New=>#1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_new:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine:c #1 {
  \cs_undefine:c { \BNVS:c { #1 } }
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:N=\BNVS_new:cpn, noigre}
% \BNVS_new:cpn { TEST: } { }
% \cs_if_exist:NF \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST: }
% \cs_if_exist:NT \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_set:cpn #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn C { BNVS_set:cpn=>#1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_set:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_set:cpn, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \cs_if_exist:NF \__bnvs_TEST:n {
%   \test_fail:n { NO_WAY/1 }
% }
% \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_TEST:n { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { XX } { 
%   \test_fail:n { NO_WAY/2 }
% }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_generate_variant:Nn \cs_generate_variant:Nn { c }
\cs_new:Npn \BNVS_generate_variant:cn #1 {
  \cs_generate_variant:cn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{logging}
%
% Utility messaging.
%
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
\msg_new:nnn { beanoves } { :nn } { #1~(#2) }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_warning:n {
  \msg_warning:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_warning:x {
  \msg_warning:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_error:n {
  \msg_error:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_error:x {
  \msg_error:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_fatal:n {
  \msg_fatal:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_fatal:x {
  \msg_fatal:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.gobble}
% Next are unexposed functions.
%<*!final>
\cs_new:Npn \BNVS_log_a:nn #1 #2 {
  \msg_term:nnn { beanoves } { :n } { #1~#2 }
}
\cs_generate_variant:Nn \BNVS_log_a:nn { xn }
\int_zero_new:N \l__BNVS_DEBUG_group_int
\cs_set:Npn \BNVS_log:n {
  \BNVS_log_a:xn
  { ▃▃ \prg_replicate:nn { \l__BNVS_DEBUG_group_int } { ▁▃ } \space }
}
%</!final>
% \end{BNVS.gobble}
%
% \subsection{Facility layer: Variables}
% \begin{function}{
%   \BNVS_N_new:c,
%   \BNVS_v_new:c,
% }
% \begin{syntax}
% \cs{BNVS_N_new:n} \KWNmarg{type}
% \end{syntax}
% Creates typed utility functions, see usage below.
% Undefined when no longer used.
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_N_new:c #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_new:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nc } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nc } }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1:c } ##1 {
    l \BNVS:c{ ##1 } \tl_if_empty:nF { ##1 } { _ } #1
  }
  \cs_new:cpn { BNVS_#1_new:c } ##1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { \cs:w BNVS_#1:c \cs_end: { ##1 } } }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \use:c { #1_new:c } { \use:c { BNVS_#1:c } { ##1 } }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
  \cs_new:cpn { BNVS_#1_undefine:c } ##1 {
    \cs_undefine:c { \cs:w BNVS_#1:c \cs_end: { ##1 } }  
  }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:c } ##1 {
    \use:c { \cs:w BNVS_#1:c \cs_end: { ##1 } }
  }
  \cs_new:cpn { BNVS_#1_use:Nc } ##1 ##2 {
    \BNVS_use_raw:Nc
      ##1 { \cs:w BNVS_#1:c \cs_end: { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nc } ##1 ##2 {
    \BNVS_use_raw:nc
      { ##1 } { \cs:w BNVS_#1:c \cs_end: { ##2 } }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_v_new:c #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nv } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:cv } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nv } }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:Nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NV ##1 }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:cv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NnV \BNVS_use:c { ##1 } }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NnV \use:n { ##1 } }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_tl_use:Nv{|:nv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_all:c #1 {
  \cs_undefine:c { BNVS_#1:c }
  \cs_undefine:c { BNVS_#1_new:c }
  \cs_undefine:c { BNVS_#1_use:c }
  \cs_undefine:c { BNVS_#1_use:nc }
  \cs_undefine:c { BNVS_#1_use:Nc }
  \cs_undefine:c { BNVS_#1_use:nv }
  \cs_undefine:c { BNVS_#1_use:Nv }
  \cs_undefine:c { BNVS_#1_use:cv }
}
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_N_new:c { bool }
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_bool:c, noigre}
% \exp_args:Nx \tl_if_eq:nnF { \BNVS_bool:c { TEST } } { l__bnvs_TEST_bool } {
%   \test_fail:x { TEST/\BNVS_bool:c { TEST } }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\BNVS_bool_use:Nc{/:nc}, noigre}
% \bool_set_true:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NF #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \bool_set_false:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NT #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
%    \begin{macrocode}
\BNVS_N_new:c { int }
\BNVS_v_new:c { int }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_int_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \int_add:Nn #1 { 245 }
%   \int_compare:nNnF { #1 } = { 666 } {
%     \test_fail:x { TEST / \int_use:N #1 / }
%   }
% }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:Nc   \BNVS_Test:N   { TEST }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
%    \begin{macrocode}
\BNVS_N_new:c { tl }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_tl_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \assert_equal:nnn { #1 } { \l__bnvs_TEST_tl } { A }
% }
% \BNVS_tl_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
%    \begin{macrocode}
\BNVS_v_new:c { tl }
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \assert_equal_tl:vnn { TEST } { #1 } { A }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_tl_use:Nvv #1 {
  \BNVS_exp_args:Nvv #1
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_N_new:c { str }
\BNVS_v_new:c { str }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_str_use:nc{/:Nc}, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNF #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \str_set:Nn \l__bnvs_TEST_A_str { FAILURE }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNT #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A=B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
%    \begin{macrocode}
\BNVS_N_new:c { seq }
\BNVS_v_new:c { seq }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_seq_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { 421 }
%   \seq_pop_left:NNTF #1 \l__bnvs_TEST_tl {
%     \tl_if_eq:NnF \l__bnvs_TEST_tl { SUCCESS } {
%       \test_fail:n { TEST/1/\tl_to_str:N #1 }
%     }
%   } {
%     \test_fail:n { TEST/2/\token_to_str:N #1 }
%   }
% }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:Nc   \BNVS_Test:N   { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*final>
% \end{BNVS.gobble}
%    \begin{macrocode}
\cs_undefine:N \BNVS_N_new:c
%    \end{macrocode}
% \begin{BNVS.gobble}
%</final>
% \end{BNVS.gobble}
% \begin{function}{
%   \BNVS_use:Ncn,
% }
% \begin{syntax}
% \cs{BNVS_use:Ncn} \KWNmeta{function} \KWNmarg{core name} \KWNmarg{type}
% \end{syntax}
% \end{function}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nc }   #1   { #2 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nc } { #1 } { #2 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nv }   #1   { #2 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nv } { #1 } { #2 }
}
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:x { A / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Ncn   \BNVS_Test:N   { TEST_A } { tl }
% \BNVS_use:ncn { \BNVS_Test:N } { TEST_A } { tl }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\BNVS_use:Nvn{/:nvn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { A / \tl_to_str:n { #1 } }
%   }
% }
% \BNVS_use:Nvn   \BNVS_Test:n   { TEST_A } { tl }
% \BNVS_use:nvn { \BNVS_Test:n } { TEST_A } { tl }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Ncn   #1   { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:ncn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Nvn   #1   { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:nvn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_use:Ncncn{/:ncncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:NN #1 #2 {
%   \tl_if_eq:NNF #1 #2 {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Ncncn   \BNVS_Test:NN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_Test:NN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_use_raw:c { BNVS_Test:NN } } { TEST_A } { tl } { TEST_B } { tl }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\BNVS_use:Nvncn{/:nvncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:nN #1 #2 {
%   \tl_if_eq:NnF #2 { #1 } {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Nvncn   \BNVS_Test:nN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_Test:nN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_use_raw:c { BNVS_Test:nN } } { TEST_A } { tl } { TEST_B } { tl }
% \cs_undefine:N \BNVS_Test:nN
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:Ncncn   #1   { #2 } { #3 } { #4 } { #5 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:ncncn { #1 } { #2 } { #3 } { #4 } { #5 }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_use:ncncncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:NNN #1 #2 #3 {
%   \tl_if_eq:NnF #1 { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:NnF #2 { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:NnF #3 { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_use:Ncncncn   \BNVS_Test:NNN   { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \BNVS_use:ncncncn { \BNVS_Test:NNN } { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \end{BNVS.test}
% \begin{function}{
%   \BNVS_new_c:cn,
% }
% \begin{syntax}
% \cs{BNVS_new_c:nc} \KWNmarg{type} \KWNmarg{core name}
% \end{syntax}
% \end{function}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_c:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:c } {
    \BNVS_use_raw:c { BNVS_#1_use:nc } { \BNVS_use_raw:c { #1_#2:N } }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_c:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_if_exist:NT \tl_BNVS_TEST_A:N {
%   \test_fail:n { NAME~CONFLICT:\token_to_str:N \tl_BNVS_TEST_A:N }
% }
% \cs_set:Npn \tl_BNVS_TEST_A:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:n { NO_WAY/1/\token_to_str:N #1 }
%   }
% }
% \BNVS_new_c:nc { tl } { BNVS_TEST_A }
% \cs_if_exist:NF \__bnvs_tl_BNVS_TEST_A:c {
%   \test_fail:n { NO_WAY/2 }
% }
% \__bnvs_tl_BNVS_TEST_A:c { TEST_A }
% \cs_undefine:N \tl_BNVS_TEST_A:N
% \cs_undefine:N \__bnvs_tl_TEST_A:c
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:cn } ##1 {
    \BNVS_use:ncn { \BNVS_use_raw:c { #1_#2:Nn } } { ##1 } { #1 }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_cn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_cn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \__bnvs_tl_TEST_A:cn
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnn:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnn } ##1 {
    \BNVS_use:Ncn { #3 } { ##1 } { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnn:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnn:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnv:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnv } ##1 ##2 {
    \BNVS_tl_use:nv {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnv:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnv:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnx:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnx } ##1 ##2 {
    \exp_args:Nnx \use:n {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnx:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnx:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_cnn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_if_exist:NT \tl_TEST_A:Nnn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:Nnn }
% }
% \cs_set:Npn \tl_TEST_A:Nnn #1 #2 #3 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y }
%   }
%   \tl_if_eq:nnF { #3 } { Z } {
%     \test_fail:n { Z }
%   }
% }
% \BNVS_new_cnn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cnn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cnn { TEST_A } { Y } { Z }
% \cs_undefine:N \tl_TEST_A:Nnn
% \cs_undefine:N \__bnvs_tl_TEST_A:cnn
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cc } ##1 ##2 {
    \BNVS_use:Ncncn #3 { ##1 } { #1 } { ##2 } { #4 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cc:ncNn { #1 } { #1_#2 }
  } { #1_#2:NN }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cc:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cc }
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \BNVS_N_new:c { bnvs }
% \tl_new:N  \l__bnvs_TEST_A_bnvs
% \tl_set:Nn \l__bnvs_TEST_A_bnvs { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \tl_TEST_A:NN \l__bnvs_TEST_A_tl \l__bnvs_TEST_A_bnvs
% \BNVS_new_cc:ncn { tl } { TEST_A } { bnvs }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_A }
% \BNVS_undefine_all:c { bnvs }
% \cs_undefine:N \l__bnvs_TEST_A_bnvs
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:nc #1 #2 {
  \BNVS_new_cc:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \tl_set:Nn \l__bnvs_TEST_B_tl { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \BNVS_new_cc:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_B }
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cn } ##1 {
    \BNVS_use:Ncn #3 { ##1 } { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cv } ##1 ##2 {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 }
    } { ##2 } { #4 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cv:nc #1 #2 {
  \BNVS_new_cv:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cv:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cv }
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:N=\BNVS_new_cv:ncn, noigre}
% \cs_if_exist:NT \tl_BNVS_TEST:Nn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_BNVS_TEST:Nn }
% }
% \cs_new:Npn \tl_BNVS_TEST:Nn { \tl_set:Nn }
% \tl_clear:N \l__bnvs_TEST_A_tl
% \tl_BNVS_TEST:Nn \l__bnvs_TEST_A_tl { SUCCESSA0 }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESSA0 } {
%   \test_fail:n { 0 }
% }
% \BNVS_new_cv:ncn { tl } { BNVS_TEST } { tl }
% \tl_clear:N \l__bnvs_TEST_A_tl
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESSA0 }
% \__bnvs_tl_BNVS_TEST:cv { TEST_A } { TEST_B }
% \__bnvs_tl_if_eq:cvF { TEST_A } { TEST_B } {
%   \test_fail:n { 0 }
% }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESSA0 } {
%   \test_fail:n { 0 }
% }
% \cs_undefine:N \tl_BNVS_TEST:Nn
% \BNVS_undefine_cv:nc { tl } { TEST }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_l_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_l:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_l_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_l:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\BNVS_l_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/l }
%   }
% }
% \BNVS_l_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_l_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_g:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_g:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_g_use:Ncn{/:ncn}, noigre}
% \tl_gset:Nn \g__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/g }
%   }
% }
% \BNVS_g_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_g_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_exp_args:Nvv #1 #2 #3 {
  \BNVS_use:ncncn { \exp_args:NVV #1 }
    { #2 } { tl } { #3 } { tl }
}
\cs_new:Npn \BNVS_exp_args:Nvvv #1 #2 #3 #4 {
  \BNVS_use:ncncncn { \exp_args:NVVV #1 }
    { #2 } { tl } { #3 } { tl } { #4 } { tl }
}
\cs_new:Npn \BNVS_exp_args:Nvvvv #1 #2 #3 #4 #5 {
  \BNVS_tl_use:nc {
	 \exp_args:NnV \use:n {
	   \BNVS_exp_args:Nvvv #1 { #2 } { #3 } { #4 }
	 }
  } { #5 }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_exp_args:Nvvv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:nnF { #2 } { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:nnF { #3 } { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_exp_args:Nvvv \BNVS_Test:nnn { TEST_A } { TEST_B } { TEST_C }
% \end{BNVS.test}
% \begin{function}{
%   \BNVS_new_conditional:cpnn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional:cpnn} \KWNmarg{core name} \KWNmeta{parameter} \KWNmarg{conditions} \KWNmarg{code}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_new_conditional:Npnn { c }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional:cpnn #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_log:x {New => \token_to_str:c { \BNVS:c { #1 } } [TF?] }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \prg_new_conditional:cpnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\cs_generate_variant:Nn \cs_split_function:N { c }
\cs_new:Npn \BNVS_undefine_conditional:c #1 {
  \BNVS_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \BNVS_undefine:c { #1##1 }
  }
}
\cs_new:Npn \BNVS_prg_undefine_conditional:c #1 {
  \cs_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \cs_undefine:c { #1##1 }
  }
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:N } \l__bnvs_TEST_A_tl }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:N#1 } \l__bnvs_TEST_A_tl }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \end{BNVS.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_generate_conditional_variant:Nnn { c }
\cs_new:Npn \BNVS_generate_conditional_variant:cnn #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn C { Variant => #1[TF] }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \prg_generate_conditional_variant:cnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_generate_conditional_variant:cnn { TEST_A:N } c { p, T, F, TF }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:c } { l__bnvs_TEST_A_tl } }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:c#1 } { l__bnvs_TEST_A_tl } }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \BNVS_undefine_conditional:c { TEST_A:c }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cnn #1 #2 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vn:cNnn { #1 }
  } { #1:nn TF } { #2 }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vn:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { S }
% \BNVS_new_conditional:cpnn { TEST:nn } #1 #2 { T, F, TF } {
%   \tl_if_eq:nnTF { #1 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vn:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { S } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { S } { }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { S }     { \test_fail:n { 3 } }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { F } { \test_fail:n { 4 } } { }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { F } { \test_fail:n { 5 } }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { F }                        { }
% \BNVS_undefine_conditional:c { TEST:nn }
% \BNVS_undefine_conditional:c { TEST:Vn }
% \BNVS_undefine_conditional:c { TEST:vn }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cnn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNnn { #1 }
  } { #1:ncTF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cNnnn #1 #2 #3 #4 #5 {
  \BNVS_new_conditional:cpnn { #1:vvc } ##1 ##2 ##3 { #5 } {
    \BNVS_use:nvn {
      \BNVS_use:Nvn #2 { ##1 } { #3 }
    } { ##2 } { #4 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cnnn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvc:cNnnn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNn { #1 }
  } { #1:ncTF }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESS }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vc#1 } { TEST_A } { TEST_B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 4 } }
% \BNVS_TEST:n {  F }                        { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { TEST:nc }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vc:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \BNVS_new_conditional:cpnn { TEST:n } #1 { TF } {
%   \tl_if_eq:nnTF { #1 } { SUCCESS } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_use:c { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { } { \test_fail:n { 1 } }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { \test_fail:n { 3 } } { }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { \test_fail:n { 4 } }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }                        { }
% \BNVS_undefine_conditional:c { TEST:n  }
% \BNVS_undefine_conditional:c { TEST:nN }
% \BNVS_undefine_conditional:c { TEST:VN }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvc:cNn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vvc:cn, noigre, debug}
% \BNVS_new_conditional:cpnn { TEST:nnc } #1 #2 #3 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { #3 } { #1C#2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vvc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUC }
% \tl_set:Nn \l__bnvs_TEST_B_tl { ESS }
% \tl_set:Nn \l__bnvs_TEST_C_tl { SUCCESS }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vvc#1 } { TEST_A } { TEST_B } { TEST_C }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_C_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 4 } }
% \BNVS_TEST:n {  F }                        { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { TEST:nnc }
% \BNVS_undefine_conditional:c { TEST:vvc }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vvc:cnnnn, noigre, debug}
% \BNVS_new_conditional:cpnn { TEST:nn } #1 #2 { TF } {
%   \tl_if_eq:nnTF { #1C#2 } { SUCCESS } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional:cpnn { TEST:nnc } #1 #2 #3 { T, F, TF } {
%   \BNVS_use:c { #3 } { #1 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \__bnvs_TEST:nncTF { SUC } { ESS } { TEST:nnTF } { } { \test_fail:n { 0 } }
% \BNVS_new_conditional_vvc:cnnn { TEST } { tl } { tl } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUC }
% \tl_set:Nn \l__bnvs_TEST_B_tl { ESS }
% \BNVS_use:c { TEST:vvcTF } { TEST_A } { TEST_B } { TEST:nnTF } { } { \test_fail:n { 1 } }
% \BNVS_use:c { TEST:vvcT  } { TEST_A } { TEST_B } { TEST:nnTF } { }
% \BNVS_use:c { TEST:vvcF  } { TEST_A } { TEST_B } { TEST:nnTF }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_use:c { TEST:vvcTF } { TEST_A } { TEST_B } { TEST:nnTF } { \test_fail:n { 3 } } { }
% \BNVS_use:c { TEST:vvcT  } { TEST_A } { TEST_B } { TEST:nnTF } { \test_fail:n { 4 } }
% \BNVS_use:c { TEST:vvcF  } { TEST_A } { TEST_B } { TEST:nnTF }                        { }
% \BNVS_undefine_conditional:c { TEST:nn  }
% \BNVS_undefine_conditional:c { TEST:nnc }
% \BNVS_undefine_conditional:c { TEST:vvc }
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsubsection{Regex}
% \begin{BNVS.macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_regex_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { c \BNVS:c { #2 } _regex }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_match_if_once:Nn,
%   \__bnvs_match_if_once:Nv,
%   \__bnvs_match_if_once:nn,
%   \__bnvs_if_regex_split:cn,
% }
% \begin{syntax}
% \cs{__bnvs_match_if_once:NnTF} \KWNmeta{regex variable} \marg{\textsl{expression}}
% \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_match_if_once:nnTF} \KWNmarg{regex} \marg{\textsl{expression}}
% \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_regex_split:cncTF} \KWNmarg{regex core} \marg{\textsl{expression}} \KWNmeta{seq core} \KWNmarg{\textsl{yes code}} \KWNmarg{no code}
% \cs{__bnvs_if_regex_split:cnTF} \KWNmarg{regex core} \marg{\textsl{expression}} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item \cs{regex_match_if_once:NnNTF} with the |match| sequence as N argument
% \item \cs{regex_match_if_once:nnNTF} with the |match| sequence as N argument
% \item \cs{regex_split:NnNTF} with the |split| sequence as last N argument
% \end{itemize}
% \end{function}
% \begin{BNVS.macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_extract_once:Ncn } #1 #2 #3 { T, F, TF } {
  \BNVS_use:ncn {
    \regex_extract_once:NnNTF #1 { #3 }
  } { #2 } { seq } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_if_once:Nn } #1 #2 { T, F, TF } {
  \BNVS_use:ncn {
    \regex_extract_once:NnNTF #1 { #2 }
  } { match } { seq } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_extract_once:NcnTF, noigre}
% \BNVS_seq_new:c { A_TEST }
% \__bnvs_if_extract_once:NcnTF \c__bnvs_TEST_comma_regex { A_TEST } { , } {
%   \seq_pop_left:NNTF \l__bnvs_A_TEST_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_match_if_once:NnTF, noigre}
% \__bnvs_match_if_once:NnTF \c__bnvs_TEST_comma_regex { , } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_extract_once:Ncv } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_tl_use:nv {
      \regex_extract_once:NnNTF #1 
    } { #3 }
  } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_if_once:Nv } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_tl_use:nv {
      \regex_extract_once:NnNTF #1 
    } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_extract_once:NcvTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \__bnvs_if_extract_once:NcvTF \c__bnvs_TEST_comma_regex { A_TEST }{ TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_A_TEST_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_match_if_once:NvTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \__bnvs_match_if_once:NvTF \c__bnvs_TEST_comma_regex { TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_if_once:nn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \regex_extract_once:nnNTF { #1 } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_match_if_once:nnTF, noigre}
% \__bnvs_match_if_once:nnTF { A } { A } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { A } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_regex_split:cnc } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_regex_split:cn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { split } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_regex_split:cnTF, noigre}
% \cs_set:Npn \BNVS_Test:nT #1 #2 {
%   \seq_pop_left:NNTF \l__bnvs_split_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { #1 } { #1/1 }
%     #2
%   } {
%     \test_fail:n { #1/2 }
%   }
% }
% \__bnvs_if_regex_split:cnTF { TEST_comma } { A,B,C } {
%   \BNVS_Test:nT { A } { \BNVS_Test:nT { B } { \BNVS_Test:nT { C } { } } }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsubsection{Token lists}
% \begin{function}{
%   \__bnvs_tl_clear:c,
%   \__bnvs_tl_use:c,
%   \__bnvs_tl_set_eq:cc,
%   \__bnvs_tl_set:cn,
%   \__bnvs_tl_set:cv,
%   \__bnvs_tl_set:cx,
%   \__bnvs_tl_put_left:cn,
%   \__bnvs_tl_put_right:cn,
%   \__bnvs_tl_put_right:cx,
%   \__bnvs_tl_put_right:cv,
% }
% \begin{syntax}
% \cs{__bnvs_tl_clear:c} \KWNmarg{core key tl}
% \cs{__bnvs_tl_use:c} \KWNmarg{core}
% \cs{__bnvs_tl_count:c} \KWNmarg{core}
% \cs{__bnvs_tl_set_eq:cc} \KWNmarg{lhs core name} \KWNmarg{rhs core name}
% \cs{__bnvs_tl_set:cn} \KWNmarg{core} \KWNmarg{tl}
% \cs{__bnvs_tl_set:cv} \KWNmarg{core} \KWNmarg{value core name}
% \cs{__bnvs_tl_put_left:cn} \KWNmarg{core} \KWNmarg{tl}
% \cs{__bnvs_tl_put_right:cn} \KWNmarg{core} \KWNmarg{tl}
% \cs{__bnvs_tl_put_right:cv} \KWNmarg{core} \KWNmarg{value core name}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_clear:c {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|
% \item |\tl_use:c {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|
% \item |\tl_set_eq:cc {l__bnvs_|\texttt{\KWNmeta{lhs core}}|_tl}||{l__bnvs_|\texttt{\meta{rhs core}}|_tl}|
% \item |\tl_set:cv {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \item |\tl_set:cx {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|\texttt{\KWNmarg{tl}}
% \item |\tl_put_left:cn {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|\texttt{\KWNmarg{tl}}
% \item |\tl_put_right:cn {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|\texttt{\KWNmarg{tl}}
% \item |\tl_put_right:cv {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \end{itemize}
% \end{function}
% \begin{function}{
%   \BNVS_new_conditional_vnc:cn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional_vnc:cn} \KWNmarg{core} \KWNmarg{conditions}
% \end{syntax}
% \KWNmeta{function} is the test function with signature |...:nncTF|.
% \KWNmeta{core}|:nncTF| is used for testing.
% \end{function}
% \begin{BNVS.macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vnc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vnc:cNn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \BNVS_new_conditional_vnc:cn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional_vnc:cn} \KWNmarg{core} \KWNmarg{conditions}
% \end{syntax}
% Forwards to |\BNVS_new_conditional_vnc:cNn| with |\|\KWNmeta{core}|:nncTF| as function argument. Used for testing.
% \end{function}
% \begin{BNVS.macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvnc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvnc:cNn { #1 }
  } { #1:nnncTF }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_new_conditional_vnc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nnc } #1 #2 #3 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_set:Nn { TEST_#3 } { #1 }
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { TEST_#3 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_use:c { TEST:nncTF } { A } { A } { B } { } { \test_fail:n { 0 } }
% \BNVS_use:c { TEST:nncTF } { A } { B } { B } { \test_fail:n { 1 } } { }
% \BNVS_new_conditional_vnc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_TEST:vncTF { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnc TF } { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 3 } }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vnc#1 } { TEST_A } { SUCCESS } { B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { B/1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { B/2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { B/3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { B/4 } }
% \BNVS_TEST:n {  F }                          { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { BNVS_TEST:nnc }
% \BNVS_undefine_conditional:c { BNVS_TEST:vnc }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvvc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nvv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvvc:cNn { #1 }
  } { #1:nnncTF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_c:c {
  \BNVS_new_c:nc { tl }
}
\BNVS_new_tl_c:c { clear }
\BNVS_new_tl_c:c { use }
\BNVS_new_tl_c:c { count }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\__bnvs_tl_clear:c{|use:c|count:c}, noigre}
% \BNVS_tl_new:c { TEST_NCUC }
% \tl_set:Nn \l__bnvs_TEST_NCUC_tl { SUCCESS }
% \assert_size_equal:nnn { SUCCESS } { \__bnvs_tl_use:c { TEST_NCUC } } { 1 }
% \assert_size_equal:nnn { 7 } { \__bnvs_tl_count:c { TEST_NCUC } } { 2 }
% \__bnvs_tl_clear:c { TEST_NCUC }
% \assert_size_equal:nnn {   } { \__bnvs_tl_use:c   { TEST_NCUC } } { 3 }
% \assert_size_equal:nnn { 0 } { \__bnvs_tl_count:c { TEST_NCUC } } { 4 }
% \BNVS_tl_undefine:c { TEST_NCUC }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { tl_set_eq:cc } #1 #2 {
  \BNVS_use:ncncn { \tl_set_eq:NN } { #1 } { tl } { #2 } { tl }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_tl_set_eq:cc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_tl_clear:c { TEST_B }
% \__bnvs_tl_set_eq:cc { TEST_B } { TEST_A }
% \tl_if_eq:NNF \l__bnvs_TEST_A_tl \l__bnvs_TEST_B_tl { \test_fail:n { 1 } }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_cn:c {
  \BNVS_new_cn:nc { tl }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_cv:c #1 {
  \BNVS_new_cv:ncn { tl } { #1 } { tl }
}
\BNVS_new_tl_cn:c { set }
\BNVS_new_tl_cv:c { set }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { tl_set:cx } {
  \exp_args:Nnx \__bnvs_tl_set:cn
}
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\__bnvs_tl_set:cn{|:cv|:cx}, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } { \test_fail:x { cn/\l__bnvs_TEST_A_tl } }
% \tl_clear:N \l__bnvs_TEST_B_tl
% \__bnvs_tl_set:cx { TEST_B } { \l__bnvs_TEST_A_tl }
% \tl_if_eq:NnF \l__bnvs_TEST_B_tl { SUCCESS } { \test_fail:n { cx } }
% \tl_clear:N \l__bnvs_TEST_C_tl
% \__bnvs_tl_set:cv { TEST_C } { TEST_A }
% \tl_if_eq:NnF \l__bnvs_TEST_C_tl { SUCCESS } { \test_fail:n { cv } }
% \end{BNVS.test}
%    \begin{macrocode}
\BNVS_new_tl_cn:c { put_right }
\BNVS_new_tl_cv:c { put_right }
% \BNVS_generate_variant:cn { tl_put_right:cn } { cx }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { tl_put_right:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_right:cn }
}
\BNVS_new_tl_cn:c { put_left }
\BNVS_new_tl_cv:c { put_left }
% \BNVS_generate_variant:cn { tl_put_left:cn } { cx }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { tl_put_left:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_left:cn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_tl_if_empty:c,
%   \__bnvs_tl_if_blank:v,
%   \__bnvs_tl_if_eq:cn,
% }
% \begin{syntax}
% \cs{__bnvs_tl_if_empty:cTF } \KWNmarg{core} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_tl_if_blank:vTF } \KWNmarg{core} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_tl_if_eq:cnTF } \KWNmarg{core} \KWNmarg{tl} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:cTF {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}| \texttt{\KWNmarg{yes code} \KWNmarg{no code}}
% \item |\tl_if_eq:cnTF {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|\texttt{\KWNmarg{tl} \KWNmarg{yes code} \KWNmarg{no code}}
% \end{itemize}
% \end{function}
% \begin{BNVS.macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_c:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2 } ##1 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_c:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_c:ncNn { #1 } { #1_#2:c }
  } { #1_#2:NTF }
}
\BNVS_new_conditional_c:ncn { tl } { if_empty } { p, T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { tl_if_blank:v } #1 { T, F, TF } {
  \BNVS_tl_use:Nv \tl_if_blank:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_tl_if_empty:c, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_empty:c#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_empty:cTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_tl_if_blank:v, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_blank:v#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_blank:vTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cn } ##1 ##2 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cn:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 } 
    } { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cv:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\__bnvs_tl_if_eq:cn{|:cv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { A } { } { \test_fail:n { 1/A } }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { A } { } 
% \__bnvs_tl_if_eq:cnF  { TEST_A } { A }     { \test_fail:n { 1/B } }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { B } { \test_fail:n { 2/A } } { }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { B } { \test_fail:n { 2/B } }
% \__bnvs_tl_if_eq:cnF  { TEST_A } { B }                          { }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { } { \test_fail:n { 3/A } }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { } 
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }     { \test_fail:n { 3/B } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { \test_fail:n { 4/A } } { }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { \test_fail:n { 4/B } }
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }                          { }
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsubsection{Strings}
% \begin{function}[TF]{
%   \__bnvs_str_if_eq:vn,
% }
% \begin{syntax}
% \cs{__bnvs_str_if_eq:vnTF } \KWNmarg{core} \KWNmarg{tl} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\str_if_eq:ccTF {l__bnvs_|\texttt{\KWNmeta{core}}|_tl}|\texttt{\KWNmarg{yes code} \KWNmarg{no code}}
% \end{itemize}
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vv } ##1 ##2 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvnc:cNn { #1 }
  } { #1:nnTF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vn:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vn:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Nvn #3 { ##1 } { #1 }
    }  { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vv:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vv:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_str_if_eq:vn/:vv, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_str_if_eq:vn#1 } { TEST_A }
% }
% \BNVS_Test:n { TF } { SUCCESS } { } { \test_fail:n { 1/A } }
% \BNVS_Test:n { T  } { SUCCESS } { } 
% \BNVS_Test:n {  F } { SUCCESS }     { \test_fail:n { 1/B } }
% \BNVS_Test:n { TF } { FAILURE } { \test_fail:n { 2/A } } { }
% \BNVS_Test:n { T  } { FAILURE } { \test_fail:n { 2/B } }
% \BNVS_Test:n {  F } { FAILURE }                          { }
% \cs_set:Npn \BNVS_Test:n #1 { \BNVS_use_raw:c { __bnvs_str_if_eq:vv#1 } { TEST_A } }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \BNVS_Test:n { TF } { TEST_B } { } { \test_fail:n { 3/A } }
% \BNVS_Test:n {  T } { TEST_B } { }
% \BNVS_Test:n { F  } { TEST_B }     { \test_fail:n { 3/B } }
% \str_set:Nn \l__bnvs_TEST_B_str { FAILURE }
% \BNVS_Test:n { TF } { TEST_B } { \test_fail:n { 4/A } } { }
% \BNVS_Test:n { T  } { TEST_B } { \test_fail:n { 4/B } }
% \BNVS_Test:n {  F } { TEST_B }                          { }
% \cs_undefine:c { Test:n }
% \end{BNVS.test}
%    \begin{macrocode}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsubsection{Sequences}
% \begin{function}{
%   \__bnvs_seq_count:c,
%   \__bnvs_seq_clear:c,
%   \__bnvs_seq_set_eq:cc,
%   \__bnvs_seq_gset_eq:cc,
%   \__bnvs_seq_use:cn,
%   \__bnvs_seq_item:cn,
%   \__bnvs_seq_remove_all:cn,
%   \__bnvs_seq_put_left:cv,
%   \__bnvs_seq_put_right:cn,
%   \__bnvs_seq_put_right:cv,
%   \__bnvs_seq_set_split:cnn,
%   \__bnvs_seq_set_split:cnv,
%   \__bnvs_seq_set_split:cnx,
%   \__bnvs_seq_pop_left:cc,
% }
% \begin{syntax}
% \cs{__bnvs_seq_new:c } \KWNmarg{core}
% \cs{__bnvs_seq_count:c } \KWNmarg{core}
% \cs{__bnvs_seq_clear:c } \KWNmarg{core}
% \cs{__bnvs_seq_set_eq:cc } \marg{\textsl{core}_1} \marg{\textsl{core}_2}
% \cs{__bnvs_seq_use:cn } \KWNmarg{core} \KWNmarg{separator}
% \cs{__bnvs_seq_item:cn } \KWNmarg{core} \KWNmarg{integer expression}
% \cs{__bnvs_seq_remove_all:cn } \KWNmarg{core} \KWNmarg{tl}
% \cs{__bnvs_seq_put_right:cn } \KWNmarg{seq core} \KWNmarg{tl}
% \cs{__bnvs_seq_put_right:cv } \KWNmarg{seq core} \KWNmarg{tl core}
% \cs{__bnvs_seq_set_split:cnn } \KWNmarg{seq core} \KWNmarg{tl} \KWNmarg{separator}
% \cs{__bnvs_seq_pop_left:cc } \marg{\textsl{core}_1} \marg{\textsl{core}_2}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\seq_set_eq:cc {l__bnvs_|\texttt{\meta{\textsl{core}_1}}|_seq} {l__bnvs_|\texttt{\meta{\textsl{core}_2}}|_seq}|
% \item |\seq_count:c {l__bnvs_|\texttt{\KWNmeta{core}}|_seq}|
% \item |\seq_use:cn {l__bnvs_|\texttt{\KWNmeta{core}}|_seq}|\texttt{\KWNmarg{separator}}
% \item |\seq_item:cn {l__bnvs_|\texttt{\KWNmeta{core}}|_seq}|\texttt{\KWNmarg{integer expression}}
% \item |\seq_remove_all:cn {l__bnvs_|\texttt{\KWNmeta{core}}|_seq}|\texttt{\KWNmarg{tl}}
% \item |\__bnvs_seq_clear:c {l__bnvs_|\texttt{\KWNmeta{core}}|_seq}|
% \item |\seq_put_right:cv {l__bnvs_|\texttt{\meta{seq core}}|_seq} {l__bnvs_|\texttt{\meta{tl core}}|_tl}|
% \item |\seq_set_split:cnn{l__bnvs_|\texttt{\meta{seq core}}|_seq}{l__bnvs_|\texttt{\meta{tl core}}|_tl}{|\texttt{\meta{tl}}|}|
% \end{itemize}
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { seq } { count }
\BNVS_new_c:nc   { seq } { clear }
\BNVS_new_cn:nc  { seq } { use }
\BNVS_new_cn:nc  { seq } { item }
\BNVS_new_cn:nc  { seq } { remove_all }
\BNVS_new_cn:nc  { seq } { map_inline }
\BNVS_new_cc:nc  { seq } { set_eq }
\BNVS_new_cc:nc  { seq } { gset_eq }
\BNVS_new_cv:ncn { seq } { put_left  } { tl }
\BNVS_new_cn:ncn { seq } { put_right } { tl }
\BNVS_new_cv:ncn { seq } { put_right } { tl }
\BNVS_new_cnn:nc { seq } { set_split }
\BNVS_new_cnv:nc { seq } { set_split }
\BNVS_new_cnx:nc { seq } { set_split }
\BNVS_new_cc:ncn { seq } { pop_left  } { tl }
\BNVS_new_cc:ncn { seq } { pop_right } { tl }
%    \end{macrocode}
% \begin{BNVS.test}{:Nn=\__bnvs_seq{...}, noigre}
% \BNVS_seq_new:c { B_TEST }
% \__bnvs_seq_clear:c { A_TEST }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \assert_size_not_equal:nnn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { 0 }
% \__bnvs_seq_put_right:cv { A_TEST } { TEST_B }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 1 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { FAILURE } { 1 }
% \__bnvs_seq_put_left:cv { A_TEST } { TEST_A }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 2 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \seq_use:Nn \l__bnvs_A_TEST_seq { , } } { SUCCESS , FAILURE } { 5 }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { SUCCESS , FAILURE } { 6 }
% \__bnvs_seq_set_eq:cc { B_TEST } { A_TEST }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { B_TEST } { , } } { SUCCESS , FAILURE } { 7 }
% \BNVS_seq_undefine:c { A_TEST }
% \BNVS_seq_undefine:c { B_TEST }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_seq_split:cnn/pop_right:cc, noigre}
% \__bnvs_seq_clear:c { TEST }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 1 } } { A } { 1 }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 2 } } { B } { 2 }
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { B } { \test_fail:n { 3 } }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { A } { \test_fail:n { 4 } }
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_seq_if_empty:c,
%   \__bnvs_seq_get_right:cc,
%   \__bnvs_seq_pop_left:cc,
%   \__bnvs_seq_pop_right:cc,
% }
% \begin{syntax}
% \cs{ __bnvs_seq_if_empty:cTF } \KWNmarg{seq core} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{ __bnvs_seq_get_right:ccTF } \KWNmarg{seq core} \KWNmarg{tl core} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cc:ncnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1_#2:cc } ##1 ##2 { #4 } {
    \BNVS_use:ncncn {
      \BNVS_use_raw:c { #1_#2:NNTF }
    } { ##1 } { #1 } { ##2 } { #3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\BNVS_new_conditional_c:ncn { seq } { if_empty } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { get_right } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_left  } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_right } { tl } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_seq_get_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_get_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { B } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_seq_pop_left:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_left:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { A } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_seq_pop_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { C } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \BNVS_Test:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 4 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsubsection{Integers}
% \begin{function}{
%   \__bnvs_int_new:c,
%   \__bnvs_int_use:c,
%   \__bnvs_int_zero:c,
%   \__bnvs_int_inc:c,
%   \__bnvs_int_decr:c,
%   \__bnvs_int_set:cn,
%   \__bnvs_int_set:cv
% }
% \begin{syntax}
% \cs{ __bnvs_int_new:c  } \KWNmarg{core}
% \cs{ __bnvs_int_use:c  } \KWNmarg{core}
% \cs{ __bnvs_int_incr:c } \KWNmarg{core}
% \cs{ __bnvs_int_decr:c } \KWNmarg{core}
% \cs{ __bnvs_int_set:cn } \KWNmarg{core} \marg{\textsl{value}}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\int_new:c   {l__bnvs_|\texttt{\KWNmeta{core}}|_int}|
% \item |\int_use:c   {l__bnvs_|\texttt{\KWNmeta{core}}|_int}|
% \item |\int_incr:c  {l__bnvs_|\texttt{\KWNmeta{core}}|_int}|
% \item |\int_idecr:c {l__bnvs_|\texttt{\KWNmeta{core}}|_int}|
% \item |\int_set:cn  {l__bnvs_|\texttt{\KWNmeta{core}}|_int}| \texttt{\meta{\textsl{value}}}
% \end{itemize}
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { int } { new  }
\BNVS_new_c:nc   { int } { use  }
\BNVS_new_c:nc   { int } { zero }
\BNVS_new_c:nc   { int } { incr }
\BNVS_new_c:nc   { int } { decr }
\BNVS_new_cn:nc  { int } { set  }
\BNVS_new_cv:ncn { int } { set  } { int }
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_int_new:c/use:c/set:cn, noigre}
% \BNVS_int_new:c  { A_TEST }
% \__bnvs_int_set:cn { A_TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { A_TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_set:cn { A_TEST } { 2 }
% \BNVS_Test:nn { 2 } { 2 }
% \cs_undefine:N \BNVS_Test:nn
% \BNVS_int_undefine:c { A_TEST }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_int_incr:c/decr:c, noigre}
% \__bnvs_int_set:cn { TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_incr:c { TEST }
% \BNVS_Test:nn { 2 } { 2 }
% \__bnvs_int_decr:c { TEST }
% \BNVS_Test:nn { 1 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_int_set:cv, noigre}
% \__bnvs_int_set:cn { TEST_A } { 421 }
% \__bnvs_int_set:cv { TEST_B } { TEST_A }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST_B } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 421 } { 1 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsection{Debug facilities}
% Typesetting file |beanoves.dtx| creates both \pkg{beanoves}
% and \pkg{beanoves-debug} style files. The former is intended for everyday
% use whereas the latter contains supplemental debugging and testing
% facilities which are intentionally left undocumented.
% In particular, we have aliases for |\group_begin:| and |\group_end:|
% to allow the display of supplemental informations while debugging.
%
% \subsection{Debug messages}
% \begin{BNVS.gobble}
%<*!debug>
\cs_new:Npn \BeanovesDebugOn {
  \BNVS_warning:x { Debugging~mode~requires~\jobname-debug.sty,~typeset~\jobname.dtx}
}
\cs_new:Npn \BeanovesDebugOff { \BeanovesDebugOn }
%</!debug>
%<*!final>
\cs_set_eq:NN \BeanovesDebugOn \BNVS_DEBUG_on:
\cs_set_eq:NN \BeanovesDebugOff \BNVS_DEBUG_off:
\cs_generate_variant:Nn \BNVS_DEBUG_log:nn { nx, nV }
%</!final>
% \end{BNVS.gobble}
%
%
% \subsection{Testing facilities}
% \begin{BNVS.gobble}
% Next documentation is only in the source.
% In order to ensure that grouping is properly managed,
% we use dedicated commands to begin or end a group.
% In final mode, there is no added value.
% In debug mode, the depth is recorded and a label is possibly used.
%<*final>
\cs_set_eq:NN \BNVS_begin: \group_begin:
\cs_set_eq:NN \BNVS_end: \group_end:
\cs_new:Npn \BNVS_end_return_false: {
  \BNVS_end:
  \prg_return_false:
}
%</final>
% DEBUG type= G => group
%<*!final>
\str_new:N \l__BNVS_DEBUG_group_str
\cs_new:Npn \BNVS_DEBUG_end_set:n #1 {
  \cs_set:Npn \BNVS_end: {
    \int_compare:nNnTF { #1 } > { \int_use:N \l__BNVS_DEBUG_group_int } {
      \BNVS_error:x {Internal~error:~too~many~group~end.}
    } {
      \int_compare:nNnT { #1 } < { \int_use:N \l__BNVS_DEBUG_group_int } {
        \BNVS_error:x {Internal~error:~missing~group~end.}
      }
    }
    \group_end:
    \str_if_empty:NTF \l__BNVS_DEBUG_group_str {
      \BNVS_DEBUG_log:nx G { Almost~top~level }
    } {
      \BNVS_DEBUG_log:nx G
        { Back~to~\l__BNVS_DEBUG_group_str / \int_use:N \l__BNVS_DEBUG_group_int }
    }
  }
}
\cs_new:Npn \BNVS_begin: {
  \group_begin:
  \str_clear:N \l__BNVS_DEBUG_group_str
  \int_incr:N \l__BNVS_DEBUG_group_int
  \exp_args:Nx \BNVS_DEBUG_end_set:n
    { \int_use:N \l__BNVS_DEBUG_group_int }
}
\cs_new:Npn \BNVS_DEBUG_end_set:nn #1 #2 {
  \str_set:Nn \l__BNVS_DEBUG_group_str { #2 }
  \cs_set:Npn \BNVS_end: {
    \str_if_eq:VnF \l__BNVS_DEBUG_group_str { #2 } {
      \BNVS_error:x
        { Wrong~grouping~\l__BNVS_DEBUG_group_str!=#2 }
    }
    \int_compare:nNnTF { #1 } > { \int_use:N \l__BNVS_DEBUG_group_int } {
      \BNVS_error:n {Internal~error:~too~many~group~end.}
    } {
      \int_compare:nNnT { #1 } < { \int_use:N \l__BNVS_DEBUG_group_int } {
        \BNVS_error:n {Internal~error:~missing~group~end.}
      }
    }
    \BNVS_DEBUG_log:nx G {END~#2/\int_use:N \l__BNVS_DEBUG_group_int}
    \group_end:
    \str_if_empty:NTF \l__BNVS_DEBUG_group_str {
      \BNVS_DEBUG_log:nx G { Almost~top~level }
    } {
      \BNVS_DEBUG_log:nx G {
        Back~to~\l__BNVS_DEBUG_group_str / \int_use:N \l__BNVS_DEBUG_group_int
      }
    }
  }
}
\cs_set:Npn \BNVS_DEBUG_begin:n #1 {
  \BNVS_begin:
  \BNVS_DEBUG_log:nx G { BEGIN~#1/\int_use:N \l__BNVS_DEBUG_group_int }
  \str_set:Nx \l__BNVS_DEBUG_group_str { #1 }
  \exp_args:Nxx
  \BNVS_DEBUG_end_set:nn { \int_use:N \l__BNVS_DEBUG_group_int } { #1 }
}
\cs_set_eq:NN \BNVS_end: \group_end:
\bool_new:N \l__bnvs_TEST_ignore_bool
\bool_set_false:N \l__bnvs_TEST_ignore_bool
\cs_new:Npn \BNVS_DEBUG_log_nnn:nnn #1 #2 #3 {
  \BNVS_DEBUG_log:nn { #1 } { #2~#3 }
}
\cs_new:Npn \BNVS_DEBUG_log:nnn #1 #2 {
  \exp_args:Nnx
  \BNVS_DEBUG_log_nnn:nnn { #1 }
  { ▄▄ \prg_replicate:nn {\l__BNVS_DEBUG_group_int + 1} { #2 } }
}
\ProvideDocumentEnvironment {BNVS.failure} {} {} {}
\bool_new:N \l__bnvs_TEST_bool
\bool_new:N \l__bnvs_TEST_append_bool
\bool_set_false:N \l__bnvs_TEST_append_bool
\tl_new:N \g__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_banner_tl
\tl_new:N \l__bnvs_TEST_done_tl
\tl_clear:N \l__bnvs_TEST_done_tl
\tl_new:N \l__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_A_tl
\tl_new:N \l__bnvs_TEST_B_tl
\tl_new:N \l__bnvs_TEST_C_tl
\str_new:N \l__bnvs_TEST_str
\str_new:N \l__bnvs_TEST_A_str
\str_new:N \l__bnvs_TEST_B_str
\str_new:N \l__bnvs_TEST_C_str
\seq_new:N \l__bnvs_TEST_seq
\seq_new:N \l__bnvs_TEST_A_seq
\seq_new:N \l__bnvs_TEST_B_seq
\seq_new:N \l__bnvs_TEST_C_seq
\int_new:N \l__bnvs_TEST_int
\int_new:N \l__bnvs_TEST_group_int
\prop_new:N \l__bnvs_TEST_prop
\prop_new:N \g__bnvs_TEST_prop
\regex_const:Nn \c__bnvs_TEST_comma_regex { , }
\NewDocumentEnvironment{BNVS.test} {} {
  \color{red}\bfseries\ExplSyntaxOn
  \debug_on:n { check-declarations }
  \__bnvs_gunset:
  \int_gset:Nn \g__bnvs_call_int { 128 }
  \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
  \__bnvs_provide_off:
  \BNVS_DEBUG_log_set:ncnnc a { if_resolve_query:ncTF } { QUERY } { ? } { ans }
  \BNVS_TEST_BEGIN:n
} {
  \assert_equal:xxn {
    \int_use:N \l__BNVS_DEBUG_group_int
  } {
    \int_use:N \l__bnvs_TEST_group_int
  } { Bad~group~nesting }
  \tl_use:N \l__bnvs_TEST_done_tl
  \__bnvs_gunset:
  \ExplSyntaxOff\ignorespacesafterend
}
\keys_define:nn { BNVS.test } {
  banner  .code:n = \tl_set:Nn \l__bnvs_TEST_banner_tl { #1 },
  :N      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:N #1
  },
  :Nn     .code:n = \exp_args:NNo \tl_set:No \l__bnvs_TEST_banner_tl { 
    \exp_last_unbraced:No \token_to_str:N { \use_i:nn #1 }
    \use_ii:nn #1
  },
  :c      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { #1 }
  },
  :cn     .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \use_i:nn #1 } \use_ii:nn #1
  },
  bnvs:c  .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { #1 } }
  },
  bnvs:cn .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { \use_i:nn #1 } } \use_ii:nn #1
  },
  debug  .code:n = \BNVS_DEBUG_on:,
  debug:n .code:n = \BNVS_DEBUG_push:n { #1 },
  reset  .code:n = \reset:n { #1 },
  ignore .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { \BNVS_use_raw:c { c_#1_bool } },
  ignore .default:n = true,
  % ignore .code:n = {}, % uncomment this line to ignore no tests
  noigre .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { !(\BNVS_use_raw:c { c_#1_bool }) },
  noigre .default:n = false,
  noigre .code:n = {}, % comment this line to ignore tests
}
\regex_const:Nn \c_BNVS_DEBUG_equal_regex { ^(?:X|[^,\s]+\s*=) }
\int_new:N \l__bnvs_TEST_A_int
\int_new:N \l__bnvs_TEST_B_int
\cs_new:Npn \BNVS_TEST_BEGIN:n #1 {
  \cs_set:Npn \reset:n ##1 {
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \tl_if_empty:nF { ##1 } {
      \__bnvs_gunset:
      \__bnvs_v_gunset:
      \__bnvs_gunset_cache:
    }
    \BNVS_end:
    \__bnvs_tl_clear:c { id_last }
    \Beanoves { FIRST = 220+2, LENGTH = 440+5, LAST = 660+6 }
    \__bnvs_provide_off:
  }
  \cs_set:Npn \reset_X: {
    \reset:n { YES }
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \Beanoves {
      X1  = FIRST,
      X2  = LAST-LENGTH+1,
      A1  = FIRST:,
      A2  = LAST-LENGTH+1:,
      AA1 = FIRST::,
      AA2 = LAST-LENGTH+1::,
      Z1  = :LAST,
      Z2  = :FIRST+LENGTH-1,
      AL11 = FIRST::LENGTH,
      AL12 = FIRST::LAST-FIRST+1,
      AL21 = LAST-LENGTH+1::LENGTH,
      AL22 = LAST-LENGTH+1::LAST-FIRST+1,
      AZ11 = FIRST:LAST,
      AZ12 = FIRST:FIRST+LENGTH-1,
      AZ21 = LAST-LENGTH+1:LAST,
      AZ22 = LAST-LENGTH+1:FIRST+LENGTH-1,
      LZ11 = ::LENGTH:LAST,
      LZ12 = ::LENGTH:FIRST+LENGTH-1,
      LZ21 = ::LAST-FIRST+1:LAST,
      LZ22 = ::LAST-FIRST+1:FIRST+LENGTH-1,
      ZL11 = :LAST::LENGTH,
      ZL12 = :LAST::LAST-FIRST+1,
      ZL21 = :FIRST+LENGTH-1::LENGTH,
      ZL22 = :FIRST+LENGTH-1::LAST-FIRST+1,
    }
    \BNVS_end:
  }
  \tl_if_empty:nF { #1 } { \keys_set_known:nn {BNVS.test} {#1} }
  \bool_if:NTF \l__bnvs_TEST_ignore_bool {
    \tl_clear:N \l__bnvs_TEST_done_tl
    \RenewDocumentEnvironment{BNVS.test}{+b}{
      \BNVS_set:cpn { end_test: } {
        \BNVS_set:cpn { end_test: } { }
        \end{BNVS.test}
      }
    } {
      \__bnvs_end_test:
    }
    \begin{BNVS.test}
  } {
    \cs_set:Npn \banner:n ##1 {
      \__bnvs_greset_call:
      \BNVS_log_a:xn { ▶︎▶︎▶︎▶︎▶︎~TEST~##1~/~line:~\the\inputlineno} {}
    }
    \RenewDocumentEnvironment{BNVS.failure}{}
      {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
         \setlength{\itemindent}{0pt}%
         \setlength{\leftmargin}{0pt}%
         \setlength{\labelwidth}{0pt}%
         \addtolength{\topsep}{-0.5\parskip}%
         \listparindent \parindent
         \setlength{\parsep}{\parskip}}}
      {\end{list}}  
% Utilities
    \cs_set_eq:NN \test_extract:nnnn \BNVS_TEST_extract:nnnn
    \cs_set_eq:NN \test_extract:Nnnn \BNVS_TEST_extract:Nnnn
    \cs_set_eq:NN \test_split:Nnnn \BNVS_TEST_split:Nnnn
    \cs_set_eq:NN \assert_equal:nnn \BNVS_ASSERT_equal:nnn
    \cs_set_eq:NN \assert_equal:xnn \BNVS_ASSERT_equal:xnn
    \cs_set_eq:NN \assert_equal:xxn \BNVS_ASSERT_equal:xxn
    \cs_set_eq:NN \assert_size_equal:nnn \BNVS_ASSERT_size_equal:nnn
    \cs_set_eq:NN \assert_size_not_equal:nnn \BNVS_ASSERT_size_not_equal:nnn
    \cs_set_eq:NN \assert_equal_tl:vnn \BNVS_ASSERT_equal_tl:vnn
    \cs_set_eq:NN \assert_equal_tl:vxn \BNVS_ASSERT_equal_tl:vxn
    \cs_set_eq:NN \assert_equal_int:vnn \BNVS_ASSERT_equal_int:vnn
    \cs_set_eq:NN \assert_equal_int:vxn \BNVS_ASSERT_equal_int:vxn
    \cs_set_eq:NN \test_fail:n \BNVS_TEST_fail:n
    \cs_set_eq:NN \test_fail:x \BNVS_TEST_fail:x
    \cs_set:Npn \assert_equal_ans:nn {
      \assert_equal_tl:vnn { ans }
    }
%   Usage ##1: banner
    \cs_set:Npn \preflight:n ##1 {
      \banner:n { ##1 }
      \BNVS_DEBUG_begin:n { preflight:n }
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \bool_if:NTF \l__bnvs_TEST_append_bool {
        \BNVS_DEBUG_log_tl:nc * { ans }
      } {
        \__bnvs_tl_clear:c { ans }
      }
    }
%   Usage ##1: sub banner
%         ##2: banner
    \cs_set:Npn \preflight:nn ##1 ##2 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2 }
      } {
        \regex_match:NnTF \c_BNVS_DEBUG_equal_regex { ##1 } {
          \banner:n { ##2~/~##1 }
          \group_begin:
          \BNVS_DEBUG_off:
          \Beanoves { ##1 }
        } {
          \banner:n { ##2~/~X=##1 }
          \group_begin:
          \BNVS_DEBUG_off:
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_g:nn D {}
      }
      \BNVS_DEBUG_begin:n { preflight:nn }
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \bool_if:NTF \l__bnvs_TEST_append_bool {
        \BNVS_DEBUG_log_tl:nc * { ans }
      } {
        \__bnvs_tl_clear:c { ans }
      }
    }
%   Usage ##1: declaration shortcut, X.1=234
%         ##2: main banner
%         ##3: sub banner when no declaration
    \cs_set:Npn \preflight:nnn ##1 ##2 ##3 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2~/~##3~/ }
      } {
        \regex_match:NnTF \c_BNVS_DEBUG_equal_regex { ##1 } {
          \banner:n { ##2~/~##1->##2~/ }
          \group_begin:
          \BNVS_DEBUG_off:
          \Beanoves { ##1 }
        } {
          \banner:n { ##2~/~X=##1->##2~/ }
          \group_begin:
          \BNVS_DEBUG_off:
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_g:nn D {}
      }
      \BNVS_DEBUG_begin:n { preflight:nnn }
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \bool_if:NTF \l__bnvs_TEST_append_bool {
        \BNVS_DEBUG_log_tl:nc * { ans }
      } {
        \__bnvs_tl_clear:c { ans }
      }
    }
    \cs_set:Npn \postflight: {
      \assert_equal:xxn {
        \int_use:N \l__BNVS_DEBUG_group_int
      } {
        \int_use:N \l__bnvs_TEST_group_int
      } { Bad~group~nesting }
      \BNVS_end:
    }
    \cs_set:Npn \flight:nT ##1 ##2 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:n { ##1 }
        ##2
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnT ##1 ##2 ##3 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nn { ##1 } { ##2 }
        ##3
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnnT ##1 ##2 ##3 ##4 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nnn { ##1 } { ##2 } { ##3 }
        ##4
        \postflight:
      }
    }
% Utilities
%   Usage ##1: control sequence with signature :ncTF
%         ##2: declaration
%         ##3: 1st argument of the control sequence
%         ##4: expected 2nd argument of the control sequence
%         ##5: Human readable label
% DEBUG type: T -> Test
    \cs_set:Npn \Test_generic_ncTF:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        \__bnvs_int_set:cn { TEST_A } { \int_use:N \l__BNVS_DEBUG_group_int }
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { !X } { ##3 } } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-TRUE }
        } {
          \test_fail:x { ##5-FALSE(cs:~\token_to_str:N ##1) }
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__BNVS_DEBUG_group_int } {
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__bnvs_TEST_A_int = \int_use:N \l__bnvs_TEST_A_int }
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__BNVS_DEBUG_group_int = \int_use:N \l__BNVS_DEBUG_group_int }
          \test_fail:n { ##5~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_ncTF:Nnnnn { c }
%   Usage ##1: control sequence with signature :nncTF
%         ##2: declaration
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected 3rd argument of the control sequence
%         ##6: Human readable label
    \cs_set:Npn \Test_generic_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##2 } { ##6 } {
        \__bnvs_int_set:cn { TEST_A } { \int_use:N \l__BNVS_DEBUG_group_int }
        \exp_args:Nne
        ##1 { ##3 } { \tl_if_empty:nTF { ##4 } { X } { ##4 } } { ans } {
          \assert_equal_ans:nn { ##5 } { ##6-TRUE }
        } {
          \test_fail:x { ##6-FALSE(cs:~\token_to_str:N ##1) }
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__BNVS_DEBUG_group_int } {
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__bnvs_TEST_A_int = \int_use:N \l__bnvs_TEST_A_int }
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__BNVS_DEBUG_group_int = \int_use:N \l__BNVS_DEBUG_group_int }
          \test_fail:n { ##6~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_nncTF:Nnnnnn { c }
%   Usage ##1: control sequence with signature :nnncTF
%         ##2: declaration
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: 3rd argument of the control sequence
%         ##6: expected 4th argument of the control sequence
%         ##7: Human readable label
    \cs_set:Npn \Test_generic_nnncTF:Nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \flight:nnT { ##2 } { ##7 } {
        \__bnvs_int_set:cn { TEST_A } { \int_use:N \l__BNVS_DEBUG_group_int }
        \exp_args:Nnne
        ##1 { ##3 } { ##4 } { \tl_if_empty:nTF { ##5 } { X } { ##5 } } { ans } {
          \assert_equal_ans:nn { ##6 } { ##7-TRUE }
        } {
          \test_fail:x { ##7-FALSE(cs:~\token_to_str:N ##1) }
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__BNVS_DEBUG_group_int } {
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__bnvs_TEST_A_int = \int_use:N \l__bnvs_TEST_A_int }
          \BNVS_DEBUG_log:nx T { \token_to_str:N\l__BNVS_DEBUG_group_int = \int_use:N \l__BNVS_DEBUG_group_int }
          \test_fail:n { ##7~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_nnncTF:Nnnnnnn { c }
%   Utilities
%   Usage ##1, ##2: control sequence with signature :ncTF
%         ##3: declaration
%         ##4: 1st argument of the control sequence
%         ##5: expected 2nd argument of the control sequence
%         ##6: Human readable label
    \cs_set:Npn \Test_what_action_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF { __bnvs_##1_##2:ncTF } {
        \Test_generic_ncTF:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:c { __bnvs_##1_##2:ncTF } }
      }
    }
%   Usage ##1, ##2: control sequence with signature :nncTF
%         ##3: declaration
%         ##4: 1st argument of the control sequence
%         ##5: 2nd argument of the control sequence
%         ##6: expected 3rd argument of the control sequence
%         ##7: Human readable label
    \cs_set:Npn \Test_what_action_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nncTF } {
        \Test_generic_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:c{__bnvs_##1_##2:nncTF } }
      }
    }
%   Usage ##1, ##2: control sequence with signature :nnncTF
%         ##3: declaration
%         ##4: 1st argument of the control sequence
%         ##5: 2nd argument of the control sequence
%         ##6: 3rd argument of the control sequence
%         ##7: expected 4th argument of the control sequence
%         ##8: Human readable label
    \cs_set:Npn \Test_what_action_nnncTF:nnnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nnncTF } {
        \Test_generic_nnncTF:cnnnnnn { __bnvs_##1_##2:nnncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 } { ##8 }
      } {
        \test_fail:x { ##8-NO~\token_to_str:c{__bnvs_##1_##2:nnncTF } }
      }
    }
%   Usage \Test_generic_X_ncTF:Nnnn \__bnvs_if_append_previous:ncTF {X=123} {122} {label}
%   Usage ##1: control sequence with signature :ncTF
%         ##2: declaration
%         ##3: expected 2nd argument of the control sequence
%         ##4: Human readable label
    \cs_set:Npn \Test_generic_X_ncTF:Nnnn ##1 ##2 {
      \Test_generic_ncTF:Nnnnn ##1 { ##2 } {}
    }
    \cs_generate_variant:Nn \Test_generic_X_ncTF:Nnnn { c }
%   Use \Test_generic_X_ncTF:Nnnn if ##1_##2:ncTF exists, fails with ##4 diagnostic otherwise.
%   Usage ##1: control sequence with signature :ncTF
%         ##2: declaration
%         ##3: expected 2nd argument of the control sequence
%         ##4: Human readable label
    \cs_set:Npn \Test_what_action_X_ncTF:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \cs_if_exist:cTF { __bnvs_##1_##2:ncTF } {
        \BNVS_use:Nc
        \Test_generic_X_ncTF:Nnnn { ##1_##2:ncTF } { ##3 } { ##4 } { ##5 }
      } {
        \test_fail:x { ##5-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
%   Usage ##1, ##2: base name of a control sequence with a :nncTF signature
%         ##3: declaration (A.1=123)
%         ##4: optional qualified dotted name , defaults to !X, 1st argument of ##1
%         ##5: 2nd argument of ##1
%         ##6: expected content of the 3rd argument of ##1
%         ##7: human readable label
    \cs_set:Npn \Test_what_action_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \tl_if_eq:nnT { ##1 } { if_append } {
          \bool_set_true:N \l__bnvs_TEST_append_bool
        }
        \Test_generic_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
%   Usage ##1: control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: expected value of the 3rd argument of ##1
%         ##4: human readable label
    \cs_set:Npn \Test_generic_X_nncTF:Nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##2 } { X } {
        ##1 {  } { X } { ans } {
          \assert_equal_ans:nn { ##3 } { ##4-X-TRUE }
        } {
          \test_fail:x { ##4-X-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_X_nncTF:Nnnn { c }
%   Usage ##1: control sequence with a :nnncTF signature
%         ##2: declaration (A.1=123)
%         ##3: expected value of the 3rd argument of ##1
%         ##4: human readable label
    \cs_set:Npn \Test_generic_X_nnncTF:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { X } {
        ##1 {  } { X } { ##3 } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-X-TRUE }
        } {
          \test_fail:x { ##5-X-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_X_nnncTF:Nnnnn { c }
%   Usage ##1, ##2: base name of a control sequence with a :nncTF signature
%         ##3: declaration (A.1=123)
%         ##4: expected value of the 3rd argument of the control sequence
%         ##5: human readable label
    \cs_set:Npn \Test_what_action_X_nncTF:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nncTF } {
        \Test_generic_X_nncTF:cnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 }
      } {
        \test_fail:x { ##5-NO~\token_to_str:c { __bnvs_##1_##2:nncTF } }
      }
    }
%   Usage ##1, ##2: base name of a control sequence with a :nnncTF signature
%         ##3: declaration (A.1=123)
%         ##4: value of the 3rd argument of the control sequence
%         ##5: expected value of the 4th argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_action_X_nnncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nnncTF } {
        \tl_if_eq:nnT { ##1 } { if_append } {
          \bool_set_true:N \l__bnvs_TEST_append_bool
        }
        \Test_generic_X_nnncTF:cnnnn { __bnvs_##1_##2:nnncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:c { __bnvs_##1_##2:nnncTF } }
      }
    }
%   Usage ##1: control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: expected value of the 2nd argument of the control sequence
%         ##5: human readable label
    \cs_set:Npn \Test_generic_check_value_X:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnnT { ##2 } { ##5 } { ##2~/~##3 } {
        \group_begin:
        \__bnvs_if_resolve_V:nncTF {} { X } { TEST_A } {
          \group_end:
          ##1 { !X } { ##3 } { ans } {
            \assert_equal_ans:nn { ##4 } { ##5-b }
          } {
            \test_fail:x { ##5-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##5-d(if_resolve_V:nncTF) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_X:Nnnnn { c }
%   Usage ##1: control sequence with a :ncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 2nd argument of the control sequence
%         ##4: expected value of the 3rd argument of the control sequence
%         ##5: human readable label
    \cs_set:Npn \Test_what_action_check_value_X_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_check_value_X:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
%   Usage ##1: control sequence with a :nnncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: 3rd argument of the control sequence
%         ##6: expected value of the 4th argument of the control sequence
%         ##7: human readable label
    \cs_set:Npn \Test_generic_check_value_nnncTF:Nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \flight:nnnT { ##2 } { ##7 } { ##2~/~##3!##4 } {
        \group_begin:
        \exp_args:Nne
        \__bnvs_if_resolve_V:nncTF
          { ##3 }
          { \tl_if_empty:nTF { ##4 } { X } { ##4 } }
          { TEST_A } {
          \group_end:
          \exp_args:Nne
          ##1 { ##3 } { \tl_if_empty:nTF { ##4 } { X } { ##4 } } { ##5 } { ans } {
            \assert_equal_ans:nn { ##6 } { ##7-b }
          } {
            \test_fail:n { ##7-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##7-d(if_resolve_V:nncTF-2) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_nnncTF:Nnnnnnn { c }
%   Usage ##1: control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_generic_check_value_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnnT { ##2 } { ##6 } { ##2~/~##4 } {
        \group_begin:
        \exp_args:Ne
        \__bnvs_if_resolve_V:nncTF
          { \tl_if_empty:nTF { ##3 } { !X } { ##3 } } { TEST_A } {
          \group_end:
          \exp_args:Nx
          ##1 { \tl_if_empty:nTF { ##3 } { !X } { ##3 } } { ##4 } { ans } {
            \assert_equal_ans:nn { ##5 } { ##6-b }
          } {
            \test_fail:n { ##6-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##6-d(if_resolve_V:nncTF-2) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_nncTF:Nnnnnn { c }
%   Usage ##1, ##2: control sequence with a :nncTF signature
%         ##3: declaration (A.1=123)
%         ##4: 1st argument of the control sequence
%         ##5: 2nd argument of the control sequence
%         ##6: 3rd argument of the control sequence
%         ##7: expected value of the 4th argument of the control sequence
%         ##8: human readable label
    \cs_set:Npn \Test_what_action_check_value_nnncTF:nnnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nnncTF } {
        \tl_if_eq:nnT { ##1 } { if_append } {
          \bool_set_true:N \l__bnvs_TEST_append_bool
        }
        \Test_generic_check_value_nnncTF:cnnnnnn { __bnvs_##1_##2:nnncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 } { ##8 }
      } {
        \test_fail:x { ##8-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
%   Usage ##1, ##2: control sequence with a :nncTF signature
%         ##3: declaration (A.1=123)
%         ##4: 1st argument of the control sequence
%         ##5: 2nd argument of the control sequence
%         ##6: expected value of the 3rd argument of the control sequence
%         ##7: human readable label
    \cs_set:Npn \Test_what_action_check_value_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nncTF } {
        \Test_generic_check_value_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
%   Usage ##1: second half control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_if_resolve_X_nncTF:nnnn {
      \Test_what_action_X_nncTF:nnnnn { if_resolve }
    }
%   Usage ##1: second half control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_if_append_X_nncTF:nnnn {
      \Test_what_action_X_nncTF:nnnnn { if_append }
    }
%   Usage ##1: second half control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_if_assign_X_nncTF:nnnn {
      \Test_what_action_X_nncTF:nnnnn { if_assign }
    }
%   Usage ##1: second half control sequence with a :ncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: expected value of the 2nd argument of the control sequence
%         ##5: human readable label
    \cs_set:Npn \Test_what_if_resolve_ncTF:nnnnn {
      \Test_what_action_ncTF:nnnnnn { if_resolve }
    }
%   Usage ##1: second half control sequence with a :ncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: expected value of the 2nd argument of the control sequence
%         ##5: human readable label
    \cs_set:Npn \Test_what_if_append_ncTF:nnnnn {
      \Test_what_action_ncTF:nnnnnn { if_append }
    }
%   Usage ##1: second half control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_if_resolve_nncTF:nnnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_resolve }
    }
%   Usage ##1: second half control sequence with a :nncTF signature
%         ##2: declaration (A.1=123)
%         ##3: 1st argument of the control sequence
%         ##4: 2nd argument of the control sequence
%         ##5: expected value of the 3rd argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_what_if_append_nncTF:nnnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_append }
    }
% General
%   Usage ##1: declaration (A.1=123)
%         ##2: value of the 3rd argument of the control sequence
%         ##3: expected value of the 4th argument of the control sequence
%         ##4: human readable label
    \cs_set:Npn \Test_if_resolve_index_X:nnnn {
      \Test_what_action_X_nnncTF:nnnnnn { if_resolve } { index }
    }
    \cs_set:Npn \Test_if_append_index_X:nnnn {
      \Test_what_action_X_nnncTF:nnnnnn { if_append } { index }
    }
% General
%   Usage ##1: declaration (A.1=123)
%         ##2: 1st argument of the control sequence
%         ##3: 2nd argument of the control sequence
%         ##4: 3rd argument of the control sequence
%         ##5: expected value of the 4th argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_if_resolve_index:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_resolve } { index }
    }
    \cs_set:Npn \Test_if_append_index:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_append } { index }
    }
%   Usage ##1: declaration (A.1=123)
%         ##2: expected value of the 3rd argument of the control sequence
%         ##3: human readable label
    \cs_set:Npn \Test_if_resolve_range:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_resolve } { range }
    }
    \cs_set:Npn \Test_if_append_range:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_append } { range }
    }
% data
%   Usage ##1: definition
%         ##2: key
%         ##3: id
%         ##4: tag
%         ##5: expected value of the 4th argument of the control sequence
%         ##6: human readable label
    \cs_set:Npn \Test_if_get:nnnnnn {
      \Test_generic_nnncTF:Nnnnnnn \__bnvs_if_get:nnncTF
    }
    \cs_set:Npn \Test_if_get_X:nnnn {
      \Test_generic_X_nnncTF:Nnnnn \__bnvs_if_get:nnncTF
    }
% n index
%   Usage ##1: definition
%         ##2: id
%         ##3: tag
%         ##4: expected 3rd argument
%         ##5: human readable label
    \cs_set:Npn \Test_if_resolve_n:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_resolve } { n }
    }
    \cs_set:Npn \Test_if_append_n:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_append } { n }
    }
%   Usage ##1: definition
%         ##2: expected 3rd argument
%         ##3: human readable label
    \cs_set:Npn \Test_resolve_n_X:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_resolve } { n }
    }
    \cs_set:Npn \Test_if_append_n_X:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_append } { n }
    }
% n index
%   Usage ##1: definition
%         ##2: 3rd argument
%         ##3: expected 4th argument
%         ##4: human readable label
    \cs_set:Npn \Test_if_resolve_n_index_X:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_resolve } { n_index }
    }
    \cs_set:Npn \Test_if_append_n_index_X:nnn {
      \Test_what_action_X_nncTF:nnnnn  { if_append }{ n_index }
    }
% n index
%   Usage ##1: definition
%         ##2: 1st argument
%         ##3: 2nd argument
%         ##4: expected 3rd argument
%         ##5: human readable label
    \cs_set:Npn \Test_if_resolve_n_index:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_resolve } { n_index }
    }
    \cs_set:Npn \Test_if_append_n_index:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_append } { n_index }
    }
%   Usage ##1: definition
%         ##2: expected 3rd argument
%         ##3: human readable label
    \cs_set:Npn \Test_if_resolve_n_index_X:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_resolve } { n_index }
    }
    \cs_set:Npn \Test_if_append_n_index_X:nnn {
      \Test_what_action_X_nncTF:nnnnn { if_append } { n_index }
    }
% n index
%   Usage ##1: definition
%         ##2: 1st argument
%         ##3: 2nd argument
%         ##4: 3rd argument
%         ##5: expected 4th argument
%         ##6: human readable label
    \cs_set:Npn \Test_if_resolve_n_incr:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_resolve } { n_incr }
    }
    \cs_set:Npn \Test_if_append_n_incr:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_append } { n_incr }
    }
    \cs_set:Npn \Test_if_resolve_n_post:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_resolve } { n_post }
    }
    \cs_set:Npn \Test_if_append_n_post:nnnnnn {
      \Test_what_action_nnncTF:nnnnnnnn { if_append } { n_post }
    }
% v
    \cs_set:Npn \Test_if_resolve_v:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_resolve } { v }
%      \Test_what_action_check_value_nncTF:nnnnnnnn { if_resolve } { v }
    }
    \cs_set:Npn \Test_if_append_v:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { if_append } { v }
%      \Test_what_action_check_value_nncTF:nnnnnnnn { if_append } { v }
    }
    \cs_set:Npn \Test_if_append_v_incr:nnnnnn {
      \Test_what_action_check_value_nnncTF:nnnnnnnn { if_append } { v }
    }
    \cs_set:Npn \Test_if_resolve_v_incr:nnnnnn {
      \Test_what_action_check_value_nnncTF:nnnnnnnn { if_resolve } { v_incr }
    }
    \cs_set:Npn \Test_if_append_v_incr:nnnnnn {
      \Test_what_action_check_value_nnncTF:nnnnnnnn { if_append } { v_incr }
    }
    \cs_set:Npn \Test_if_resolve_v_post:nnnnnn {
      \Test_what_action_check_value_nnncTF:nnnnnnnn { if_resolve } { v_post }
    }
    \cs_set:Npn \Test_if_append_v_post:nnnnnn {
      \Test_what_action_check_value_nnncTF:nnnnnnnn { if_append } { v_post }
    }
% query, ...:ncTF
    \cs_set:Npn \Test_if_append:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { append }
    }
    \cs_set:Npn \Test_if_resolve:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { resolve }
    }
    \cs_set:Npn \Test_if_resolve_query:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { resolve_query }
    }
    \cs_set:Npn \Test_if_resolve_queries:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { resolve_queries }
    }
%   Usage ##1: regex core name
%         ##2: query
%         ##3: match
%         ##4: human readable label
    \cs_set:Npn \Test_regex:nnnn ##1 {
      \bool_if:NTF \l__bnvs_TEST_ignore_bool {
        \use_none:nnn
      } {
        \tl_if_exist:cTF { c__bnvs_##1_regex } {
          \BNVS_TEST_extract:cnnn { c__bnvs_##1_regex }
        } {
          \test_fail:n { Bad~name:~##1}
          \use_none:nnn
        }
      }
    }
%   Usage ##1: definition
%         ##2: query
%         ##3: expectation
%         ##4: human readable label
    \cs_set:Npn \Test_query:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \__bnvs_tl_clear:c { TEST_A }
        \__bnvs_if_resolve_query:ncTF { ##2 } { TEST_A } {
          \assert_equal_tl:vnn { TEST_A } { ##3 } {
            Test~\cs{__bnvs_if_resolve_query:nc}:~##4-a
          }
        } {
          \test_fail:n { ##4-CALL }
        }
      }
    }
%   Usage ##1: definition
%         ##2: query
%         ##3: expectation
%         ##4: human readable label
    \cs_set:Npn \Test_resolve:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \BeanovesResolve[in=\l__bnvs_ans_tl]{ ##2 }
        \assert_equal_ans:nn { ##3 } { ##4 }
      }
    }
    \BNVS_log_a:nn {▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎} {}
    \BNVS_log_a:xn {TEST~\l__bnvs_TEST_banner_tl\space file:~\BeanovesCurrentTestFile,~line:~\the\inputlineno} {}
    \tl_set:Nn \l__bnvs_TEST_done_tl {
      \BNVS_log_a:xn { TEST~\l__bnvs_TEST_banner_tl...~DONE} {}
      \BNVS_log_a:nn {◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀} {}
    }
  }
}
\cs_new:Npn \BeanovesCurrentTestFile {
  \tl_if_empty:VF \CurrentFilePath { \CurrentFilePath / }
  \CurrentFile
}
\cs_set:Npn \BNVS_TEST_extract:nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \tl_if_empty:nT { #3 } {
    \__bnvs_match_if_once:nnT { #1 } { #2 } {
      \test_fail:n { #4-a }
    }
  } {
    \__bnvs_match_if_once:nnTF { #1 } { #2 } {
      \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_seq_use:cn { match } , }
      \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
      \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_TEST_B_tl {
        \__bnvs_tl_if_empty:cTF { TEST_B } {
          \seq_put_left:Nn \l__bnvs_match_seq { #2 }
        } {
          \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_TEST_B_tl
        }
      }
      \tl_set:Nx \l__bnvs_TEST_B_tl { \__bnvs_seq_use:cn { split } , }
      \assert_equal:xxn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { #4-seq }
    } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_set:Npn \BNVS_TEST_extract:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_extract_once:NnNTF #1 { #2 } \l__bnvs_match_seq {
    \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_seq_use:cn { match } , }
    \seq_set_from_clist:Nn \l__bnvs_match_seq { #3 }
    \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_TEST_B_tl {
      \__bnvs_tl_if_empty:cTF { TEST_B } {
        \seq_put_left:Nn \l__bnvs_match_seq { #2 }
      } {
        \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_TEST_B_tl
      }
    }
    \tl_set:Nx \l__bnvs_TEST_B_tl { \__bnvs_seq_use:cn { match } , }
    \assert_equal:xxn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-Missing~match }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn \BNVS_TEST_extract:Nnnn { cnnn }
\cs_set:Npn \BNVS_TEST_split:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_split:NnNTF #1 { #2 } \l__bnvs_split_seq {
    \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_seq_use:cn { split } , }
    \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
    \tl_set:Nx \l__bnvs_TEST_B_tl { \__bnvs_seq_use:cn { split } , }
    \assert_equal:xxn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn \msg_error:nnnn { nnnx }
\cs_set:Npn \BNVS_ASSERT_equal:nnn #1 #2 #3 {
  \tl_if_eq:nnF { #1 } { #2 } {
    \msg_error:nnnx { beanoves } { :nn } { FAILED~`#1'!=`#2' } { \BeanovesCurrentTestFile :\the\inputlineno :#3}
    \begin{BNVS.failure}
    \item FAILURE~`#1'!=`#2'~(\BeanovesCurrentTestFile :\the\inputlineno)
    \item #3
    \end{BNVS.failure}
  }
}
\box_new:N \l__bnvs_TEST_A_box
\box_new:N \l__bnvs_TEST_B_box
\cs_set:Npn \BNVS_ASSERT_size_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{BNVS.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{BNVS.failure}
    }
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_ASSERT_size_not_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{BNVS.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{BNVS.failure}
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_TEST_fail:n #1 {
  \msg_error:nnnx { beanoves } { :nn } { TEST~FAILED } { \BeanovesCurrentTestFile :\the\inputlineno :#1~(\int_use:N \g__bnvs_call_int)}
  \begin{BNVS.failure}
  \item FAILURE~unexpected~branch~(\BeanovesCurrentTestFile :\the\inputlineno)
  \item #1
  \end{BNVS.failure}
}
\cs_generate_variant:Nn \BNVS_ASSERT_equal:nnn { x, xx }
\cs_set:Npn \BNVS_ASSERT_equal_tl:vnn {
  \BNVS_tl_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_set:Npn \BNVS_ASSERT_equal_tl:vxn {
  \exp_args:NNnx \BNVS_tl_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_set:Npn \BNVS_ASSERT_equal_int:vnn {
  \BNVS_int_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_set:Npn \BNVS_ASSERT_equal_int:vxn {
  \exp_args:NNnx \BNVS_int_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_generate_variant:Nn \BNVS_TEST_fail:n { x }
\cs_new:Npn \BNVS_DEBUG_log_tl:nc #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } {
    \BNVS_tl_use:Nc \token_to_str:N { #2 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #2 } /
  }
}
% \BNVS_DEBUG_log_int:nnc {⟨type⟩} {⟨label⟩} {⟨core name⟩}
\cs_new:Npn \BNVS_DEBUG_log_int:nnc #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } {
    \exp_not:n { #2 }
    -> / \BNVS_int_use:Nv \tl_to_str:n { #3 } /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { v }
\cs_new:Npn \BNVS_DEBUG_log_tl:nnc #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } {
    \tl_if_empty:nF { #2 } { #2 -> }
    \BNVS_tl_use:Nc \token_to_str:N  { #3 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #3 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_tl:nc #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } {
    \BNVS_tl_use:Nc \token_to_str:N { #2 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #2 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_bool:nc #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } {
    \BNVS_bool_use:Nc \token_to_str:N { #2 }
    -> / \BNVS_bool_use:Nc \bool_to_str:N { #2 } /
  }
}

% \BNVS_DEBUG_log_arg:nnc {⟨type⟩} {⟨label⟩} {⟨core name⟩}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnc #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } {
    \tl_to_str:n { #2 }
    -> / \tl_to_str:n { #3 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnn #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } { \tl_to_str:n { #2 } -> / \tl_to_str:n { #3 } / }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 } 
  \BNVS_DEBUG_log_arg:nnn { #1 } 
}
\cs_new:Npn \BNVS_DEBUG_log_arg_IT:nnn #1 #2 {
  \BNVS_DEBUG_log_arg:nnnnn { #1 } { ID } { #2 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_arg_IT:nnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg_IT:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_arg_KIT:nnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnnnnnn { #1 } { KEY } { #2 } { ID } { #3 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_arg_KIT:nnnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnnnnnnnn { #1 } { KEY } { #2 } { ID } { #3 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_arg:nnn { #1 } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnnnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:nc #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } { \token_to_str:c { \BNVS:c { #2 } } }
}
\cs_new:Npn \BNVS_DEBUG_log_f:nncn #1 #2 #3 #4 {
  \BNVS_DEBUG_log:nx { #1 } { #2 \token_to_str:c { \BNVS:c { #3 } } #4 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f_IT:ncnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg_IT:nnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f_IT:ncnnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg_IT:nnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f_KIT:ncnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg_KIT:nnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnnnnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f_KIT:ncnnnnn #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg_KIT:nnnnnn { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnc #1 #2 {
  \BNVS_DEBUG_log_f:nc { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_f:nncn { #1 } { } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncnnnnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_f:nncn { #1 } { } { #2 } { #3 }
  \BNVS_DEBUG_log_arg:nnnnnnc { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_cs:nnN #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } { \tl_to_str:n { #2 } == \token_to_str:N #3 }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nN #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } {
    \token_to_str:N #2 => / \seq_count:N 2 / \seq_use:Nn #2 / /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nnN #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } {
    \tl_to_str:n { #2 } => / \seq_count:N #3 / \seq_use:Nn #3 / /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { x }
\cs_new:Npn \BNVS_DEBUG_log_seq:nxc #1 #2 #3 {
  \BNVS_DEBUG_log:nx { #1 } {
    #2
    => / \seq_count:c { l__bnvs_#3_seq }
       / \seq_use:cn { l__bnvs_#3_seq } / /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nc #1 #2 {
  \BNVS_DEBUG_log:nx { #1 } {
    \token_to_str:c { l__bnvs_#2_seq }
    => / \seq_count:c { l__bnvs_#2_seq }
       / \seq_use:cn { l__bnvs_#2_seq } / /
  }
}
\tl_new:N \BNVS_DEBUG_tl
\cs_new:Npn \BNVS_DEBUG_log_cs_set:cpn #1 {
  \tl_set:Nn \BNVS_DEBUG_tl { #1 }
  \tl_replace_once:Nnn \BNVS_DEBUG_tl { : } { _ }
  \cs_set:cpn { BNVS_DEBUG_log_ \BNVS_DEBUG_tl :nn }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncn #1 #2 #3 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    #3
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnn #1 #2 #3 #4 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnn { #1 } { #3 } { #4 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnnc #1 #2 #3 #4 #5 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnc { #1 } { #3 } { #4 } { IN } { #5 }
    \cs_if_exist:cT { l__bnvs_#5_tl } {
      \BNVS_DEBUG_log_tl:nc { #1 } { #5 }
    }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnnnn #1 #2 #3 #4 #5 #6 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnn { #1 } { #3 } { #4 } { #5 } { #6 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set_IT:ncnn #1 #2 #3 {
  \BNVS_DEBUG_log_set:ncnnnn { #1 } { #2 } { ID } { #3 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnn { #1 } { #3 } { #4 } { #5 } { #6 } { #7 } { #8 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set_IT:ncnnnn #1 #2 #3 {
  \BNVS_DEBUG_log_set:ncnnnnnn { #1 } { #2 } { ID } { #3 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnnnnc #1 #2 #3 #4 #5 #6 #7 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnc { #1 } { #3 } { #4 } { #5 } { #6 } { IN } { #7 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set_IT:ncnnc #1 #2 #3 {
  \BNVS_DEBUG_log_set:ncnnnnc { #1 } { #2 } { ID } { #3 } { TAG }
}
\cs_new:Npn \BNVS_DEBUG_log_set:ncnnnnnnc #1 #2 #3 #4 #5 #6 #7 #8 #9 {
  \BNVS_DEBUG_log_cs_set:cpn { #2 } ##1 ##2 {
    \BNVS_DEBUG_log_f:nncn { #1 } { ##1 } { #2 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnnnc { #1 } { #3 } { #4 } { #5 } { #6 } { #7 } { #8 } { IN } { #9 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set_IT:ncnnnnc #1 #2 #3 {
  \BNVS_DEBUG_log_set:ncnnnnnnc { #1 } { #2 } { ID } { #3 } { TAG }
}
\tl_new:N \l__bnvs_Test_item_nnn_tl
\cs_set:Npn \BNVS_Test_item:nnn #1 #2 #3 {
  \__bnvs_if_get:nnncT { #1 } { #2 } { #3 } { Test_item_nnn } {
    \__bnvs_tl_use:c { Test_item_nnn }
  }
}
%</!final>
% \end{BNVS.gobble}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% The number of variables used has not been optimized,
% nor the \TeX\ groups used.
% Optimization often goes against readability.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_id_last_tl
\tl_new:N \l__bnvs_id_tl
\tl_new:N \l__bnvs_kri_tl
\tl_new:N \l__bnvs_short_tl
\tl_new:N \l__bnvs_path_tl
\tl_new:N \l__bnvs_n_tl
\tl_new:N \l__bnvs_ref_tl
\tl_new:N \l__bnvs_tag_tl
\tl_new:N \l__bnvs_a_tl
\tl_new:N \l__bnvs_b_tl
\tl_new:N \l__bnvs_c_tl
\tl_new:N \l__bnvs_V_tl
\tl_new:N \l__bnvs_A_tl
\tl_new:N \l__bnvs_L_tl
\tl_new:N \l__bnvs_Z_tl
\tl_new:N \l__bnvs_ans_tl
\tl_new:N \l__bnvs_base_tl
\tl_new:N \l__bnvs_group_tl
\tl_new:N \l__bnvs_scan_tl
\tl_new:N \l__bnvs_query_tl
\tl_new:N \l__bnvs_token_tl
\tl_new:N \l__bnvs_root_tl
\tl_new:N \l__bnvs_n_incr_tl
\tl_new:N \l__bnvs_incr_tl
\tl_new:N \l__bnvs_plus_tl
\tl_new:N \l__bnvs_rhs_tl
\tl_new:N \l__bnvs_post_tl
\tl_new:N \l__bnvs_suffix_tl
\tl_new:N \l__bnvs_index_tl
\int_new:N \g__bnvs_call_int
\int_new:N \l__bnvs_int
\int_new:N \l__bnvs_i_int
\seq_new:N \g__bnvs_def_seq
\seq_new:N \l__bnvs_a_seq
\seq_new:N \l__bnvs_b_seq
\seq_new:N \l__bnvs_ans_seq
\seq_new:N \l__bnvs_match_seq
\seq_new:N \l__bnvs_split_seq
\seq_new:N \l__bnvs_path_seq
\seq_new:N \l__bnvs_path_head_seq
\seq_new:N \l__bnvs_path_tail_seq
\seq_new:N \l__bnvs_query_seq
\seq_new:N \l__bnvs_token_seq
\bool_new:N \l__bnvs_in_frame_bool
\bool_set_false:N \l__bnvs_in_frame_bool
\bool_new:N \l__bnvs_parse_bool
\bool_set_false:N \l__bnvs_parse_bool
\bool_new:N \l__bnvs_deep_bool
\bool_set_false:N \l__bnvs_deep_bool
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_error_ans:x {
  \__bnvs_tl_put_right:cn { ans } { 0 }
  \BNVS_error:x
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% In order to implement the provide feature, we
% add getters and setters
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\bool_new:N \l__bnvs_provide_bool
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { set_true:c } #1 {
  \exp_args:Nc \bool_set_true:N { l__bnvs_#1_bool }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { set_false:c } #1 {
  \exp_args:Nc \bool_set_false:N { l__bnvs_#1_bool }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { provide_on: } {
  \__bnvs_set_true:c { provide }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn D { PROVIDE...ON }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { provide_off: } {
  \__bnvs_set_false:c { provide }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn D { PROVIDE...OFF }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
\__bnvs_provide_off:
%    \end{macrocode}
% \end{BNVS.macrocode}
% \subsection{Infinite loop management}
% Unending recursivity is managed here.
% \begin{variable} {\g__bnvs_call_int}
% Some functions calls, as well as some loop bodies, decrement this counter.
% When this counter reaches 0, an error is raised or
% a computation is aborted.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\int_const:Nn \c__bnvs_max_call_int { 8192 }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{\__bnvs_greset_call:}
% \begin{syntax}
% \cs{__bnvs_greset_call:}
% \end{syntax}
% Reset globally the call stack counter to its maximum value.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn  { greset_call: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: D => Data
%<*!final>
\BNVS_DEBUG_log_f:nc D { greset_call: }
\BNVS_DEBUG_log:nx D { \token_to_str:N \g__bnvs_call_int: \int_use:N \g__bnvs_call_int }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \int_gset:Nn \g__bnvs_call_int { \c__bnvs_max_call_int }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{function}
% \begin{function}[TF]{\__bnvs_if_call:}
% \begin{syntax}
% \cs{__bnvs_call_do:TF} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Decrement the \cs{g__bnvs_call_int} counter globally and
% execute \KWNmeta{yes code} if we have not reached 0,
% \KWNmarg{no code} otherwise.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_call: } { T, F, TF } {
  \int_gdecr:N \g__bnvs_call_int
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: o => other
%<*!final>
\BNVS_DEBUG_log_f:nc o { if_call:TF }
\BNVS_DEBUG_log:nx o { \token_to_str:N \g__bnvs_call_int: \int_use:N \g__bnvs_call_int }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \int_compare:nNnTF \g__bnvs_call_int > 0 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{function}
%
% \subsection{Overlay specification}
% \subsubsection{Registration}
% We keep track of the \KWNmeta{id} \KWNmeta{tag} combinations and provide
% looping mechanisms.
% \begin{function}{
%   \__bnvs_name:nnn,
%   \__bnvs_name:nn
%   \__bnvs_id_seq:n
% }
% \begin{syntax}
% \cs{__bnvs_name:nnn} \KWNmarg{subkey} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_name:nn} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_id_seq:nn} \KWNmarg{id}
% \end{syntax}
% Create a unique name from the arguments.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { name:nnn } #1 #2 #3 { __bnvs_#2!#3/#1: }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { name:nn } #1 #2 { __bnvs_#1!#2: }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { id_seq:n } #1 { g__bnvs_#1!_seq }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{variable}{\g__bnvs_I_seq}
% List of registered identifiers.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\seq_new:N \g__bnvs_I_seq
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_register:nn,
%   \__bnvs_unregister:nn,
%   \__bnvs_unregister:n,
%   \__bnvs_unregister:
% }
% \begin{syntax}
% \cs{__bnvs_register:nn}   \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_unregister:nn} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_unregister:n}  \KWNmarg{id}
% \cs{__bnvs_unregister:}
% \end{syntax}
% Register and unregister according to the arguments.
% The \texttt{\KWNmeta{id}!\KWNmeta{tag}} combination
% must be registered on definition and unregistered on disposal.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\seq_new:N \l__bnvs_register_NNnn_seq
\BNVS_new:cpn { register:NNnn } #1 #2 #3 #4 {
  \cs_if_exist:NF #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: R => register
%<*!final>
\BNVS_DEBUG_log:nn R { register~ID!TAG:#3!#4 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \cs_gset:Npn #1 { }
    \seq_if_exist:NTF #2 {
      \__bnvs_seq_clear:c { register_NNnn }
      \cs_set:Npn \BNVS_register_NNnn: {
        \__bnvs_seq_put_right:cn { register_NNnn } { #4 }
        \cs_set:Npn \BNVS_register_NNnn: { }
      }
      \cs_set:Npn \BNVS_register_NNnn:w ##1 ##2 {
        \str_compare:nNnTF { ##2 } < { #4 } {
          \__bnvs_seq_put_right:cn { register_NNnn } { ##2 }
        } {
          \BNVS_register_NNnn:
          \__bnvs_seq_put_right:cn { register_NNnn } { ##2 }
          \cs_set:Npn \BNVS_register_NNnn:w ####1 ####2 {
            \__bnvs_seq_put_right:cn { register_NNnn } { ####2 }
          }
        }
      }
      \__bnvs_foreach_T:nNTF { #3 } \BNVS_register_NNnn:w {
        \BNVS_register_NNnn:
        \seq_gset_eq:NN #2 \l__bnvs_register_NNnn_seq
      } {
        \BNVS_error:n { Unreachable/register:NNnn~id~#3 }
      }
    } {
      \seq_new:N #2
      \seq_gput_right:Nn #2 { #4 }
      \__bnvs_seq_clear:c { register_NNnn }
      \cs_set:Npn \BNVS_register_NNnn: {
        \__bnvs_seq_put_right:cn { register_NNnn } { #3 }
        \cs_set:Npn \BNVS_register_NNnn: {}
      }
      \cs_set:Npn \BNVS_register_NNnn:w ##1 {
        \str_compare:nNnTF { ##1 } < { #3 } {
          \__bnvs_seq_put_right:cn { register_NNnn } { ##1 }
        } {
          \BNVS_register_NNnn:
          \__bnvs_seq_put_right:cn { register_NNnn } { ##1 }
          \cs_set:Npn \BNVS_register_NNnn:w ####1 {
            \__bnvs_seq_put_right:cn { register_NNnn } { ####1 }
          }
        }
      }
      \__bnvs_foreach_I:N \BNVS_register_NNnn:w
      \BNVS_register_NNnn:
      \seq_gset_eq:NN \g__bnvs_I_seq \l__bnvs_register_NNnn_seq
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx R { / \seq_use:Nn \g__bnvs_I_seq / / }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { register:nn } #1 #2 {
  \exp_args:Ncc \__bnvs_register:NNnn
    { \__bnvs_name:nn { #1 } { #2 } } { \__bnvs_id_seq:n { #1 } }
    { #1 } { #2 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_unregister:NNnn,
% }
% \begin{syntax}
% \cs{__bnvs_unregister:NNnn} \meta{cs} \meta{seq} \KWNmarg{id} \KWNmarg{tag}
% \end{syntax}
% Unregistering a \KWNmeta{id} \KWNmeta{tag} combination
% is not straightforward.
% \meta{cs} and \meta{seq} are respectively the command
% and the sequence uniquely associated to this combination.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\seq_new:N \l__bnvs_unregister_NNnn_seq
\BNVS_new:cpn { unregister:NNnn } #1 #2 #3 #4 {
  \cs_if_exist:NT #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn R { unregister~ID!TAG:#3!#4 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \cs_undefine:N #1
    \__bnvs_seq_clear:c { unregister_NNnn }
    \cs_set:Npn \BNVS_unregister_NNnn:n ##1 { ##1 }
    \cs_set:Npn \BNVS_unregister_NNnn:w ##1 ##2 {
      \str_compare:nNnTF { ##2 } < { #4 } {
        \__bnvs_seq_put_right:cn { unregister_NNnn } { ##2 }
        \cs_set:Npn \BNVS_unregister_NNnn:n ####1 { }
      } {
        \cs_set:Npn \BNVS_unregister_NNnn:w ####1 ####2 {
          \__bnvs_seq_put_right:cn { unregister_NNnn } { ####2 }
          \cs_set:Npn \BNVS_unregister_NNnn:n ########1 { }
        }
      }
    }
    \__bnvs_foreach_T:nNTF { #3 } \BNVS_unregister_NNnn:w {
      \seq_gset_eq:NN #2 \l__bnvs_unregister_NNnn_seq
    } {
      \BNVS_error:n { Unreachable / unregister:NNnn~#3!#4 }
    }
    \BNVS_unregister_NNnn:n {
      \__bnvs_seq_clear:c { unregister_NNnn }
      \cs_set:Npn \BNVS_unregister_NNnn:w ##1 {
        \str_compare:nNnTF { ##1 } < { #3 } {
          \__bnvs_seq_put_right:cn { unregister_NNnn } { ##1 }
        } {
          \cs_set:Npn \BNVS_unregister_NNnn:n ####1 {
            \__bnvs_seq_put_right:cn { unregister_NNnn } { ####1 }
          }
        }
      }
      \__bnvs_foreach_I:N \BNVS_unregister_NNnn:w
      \seq_gset_eq:NN \g__bnvs_I_seq \l__bnvs_unregister_NNnn_seq
      \cs_undefine:N #2
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx R { sequence~I:/ \seq_use:Nn \g__bnvs_I_seq / / }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { unregister:nn } #1 #2 {
  \exp_args:Ncc \__bnvs_unregister:NNnn
    { \__bnvs_name:nn { #1 } { #2 } } { \__bnvs_id_seq:n { #1 } }
    { #1 } { #2 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_registered:nn,
% }
% \begin{syntax}
% \cs{__bnvs_if_register:nnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Execute \KWNmeta{yes code} or \KWNmeta{no code} depending on
% the \texttt{\KWNmeta{id}!\KWNmeta{tag}} combination
% being registered.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_registered:nn } #1 #2 { T, F, TF } {
  \cs_if_exist:cTF { \__bnvs_name:nn { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ if_registered:nnTF }, noigre}
% \__bnvs_if_registered:nnT { ID } { TAG } {
%   \test_fail:n { A }
% }
% \__bnvs_register:nn { ID } { TAG }
% \__bnvs_if_registered:nnF { ID } { TAG } {
%   \test_fail:n { B }
% }
% \__bnvs_unregister:nn { ID } { TAG }
% \__bnvs_if_registered:nnT { ID } { TAG } {
%   \test_fail:n { C }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_foreach_I:N,
%   \__bnvs_foreach_I:n,
% }
% \begin{syntax}
% \cs{__bnvs_foreach_I:N} \KWNmeta{function:n}
% \cs{__bnvs_foreach_I:n} \KWNmarg{code}
% \end{syntax}
% Execute the \KWNmeta{function:n} or the \KWNmeta{code} for each declared
% identifier.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_I:N } {
  \seq_map_function:NN \g__bnvs_I_seq
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ foreach_I:N }, noigre}
% \__bnvs_register:nn { I1 } { T1 }
% \cs_set:Npn \BNVS_TEST:n #1 {
%   \__bnvs_tl_put_right:cn { ans } { #1 }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_foreach_I:N \BNVS_TEST:n
% \assert_equal_ans:nn { I1 } { A }
% \__bnvs_register:nn { I1 } { T1 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_foreach_I:N \BNVS_TEST:n
% \assert_equal_ans:nn { I1 } { B }
% \__bnvs_unregister:nn { I1 } { T1 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={ foreach_I:N }, noigre}
% \cs_set:Npn \BNVS_TEST:n #1 {
%   \__bnvs_tl_put_right:cn { ans } { #1 }
% }
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \tl_map_inline:nn { #1 } {
%     \__bnvs_register:nn ##1
%   }
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_foreach_I:N \BNVS_TEST:n
%   \assert_equal_ans:nn { #2 } { #3-registered }
%   \tl_map_inline:nn { #1 } {
%     \__bnvs_unregister:nn ##1
%   }
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_foreach_I:N \BNVS_TEST:n
%   \assert_equal_ans:nn { } { #3-unregistered }
% }
% \Test:nnn {{{I1}{T1}}}           { I1 } { 1-1-a }
% \Test:nnn {{{I1}{T1}}{{I1}{T1}}} { I1 } { 1-1-b }
% \Test:nnn {{{I1}{T1}}{{I1}{T2}}} { I1 } { 1-2-b }
% \Test:nnn {{{I1}{T2}}{{I1}{T1}}} { I1 } { 1-2-c }
% \Test:nnn {{{I1}{T1}}{{I2}{T1}}} { I1I2 } { 2-1-a }
% \Test:nnn {{{I1}{T1}}{{I1}{T1}}{{I2}{T1}}} { I1I2 } { 2-1-a' }
% \Test:nnn {{{I1}{T1}}{{I2}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-a'' }
% \Test:nnn {{{I2}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-b }
% \Test:nnn {{{I2}{T1}}{{I1}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-b' }
% \Test:nnn {{{I1}{T1}}{{I1}{T1}}{{I2}{T1}}{{I2}{T1}}} { I1I2 } { 2-1-c }
% \Test:nnn {{{I1}{T1}}{{I2}{T1}}{{I1}{T1}}{{I2}{T1}}} { I1I2 } { 2-1-d }
% \Test:nnn {{{I1}{T1}}{{I2}{T1}}{{I2}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-e }
% \Test:nnn {{{I2}{T1}}{{I1}{T1}}{{I1}{T1}}{{I2}{T1}}} { I1I2 } { 2-1-f }
% \Test:nnn {{{I2}{T1}}{{I1}{T1}}{{I2}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-g }
% \Test:nnn {{{I2}{T1}}{{I2}{T1}}{{I1}{T1}}{{I1}{T1}}} { I1I2 } { 2-1-h }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
% \begin{BNVS.gobble}
%<*final>
% \end{BNVS.gobble}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_I:n } {
  \seq_map_inline:Nn \g__bnvs_I_seq
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%</final>
% \end{BNVS.gobble}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_new:cpn { foreach_I:n } {
  \seq_map_inline:Nn \g__bnvs_I_seq
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:c={ foreach_I:n }, noigre}
% \int_step_inline:nn { 5 } {
%   \seq_set_from_clist:Nn \l__bnvs_TEST_seq { I1, I2, I3, I4, I5 }
%   \seq_shuffle:N \l__bnvs_TEST_seq
%   \typeout { TEST:/ \seq_use:Nn \l__bnvs_TEST_seq / / }
%   \seq_map_inline:Nn \l__bnvs_TEST_seq {
%     \__bnvs_register:nn { ##1 } { T1 }
%   }
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_foreach_I:n {
%     \__bnvs_tl_put_right:cn { ans } { ##1 }
%   }
%   \assert_equal_ans:nn { I1I2I3I4I5 } { A-#1 }
%   \seq_map_inline:Nn \l__bnvs_TEST_seq {
%     \__bnvs_unregister:nn { ##1 } { T1 }
%   }
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_foreach_I:n {
%     \__bnvs_tl_put_right:cn { ans } { ##1 }
%   }
%   \assert_equal_ans:nn { } { B-#1 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_foreach_T:nN,
%   \__bnvs_foreach_T:nn,
% }
% \begin{syntax}
% \cs{__bnvs_foreach_T:nNTF} \KWNmarg{id} \meta{function:nn} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_foreach_T:nnTF} \KWNmarg{id} \KWNmarg{code} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% If \KWNmeta{id} is a declared identifier, execute \meta{function:nn}
% or \KWNmeta{code} for each combination of \KWNmeta{id} and its associate 
% \KWNmeta{tag}s.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { foreach_T:nN } #1 #2 { T, F, TF } {
  \seq_if_exist:cTF { g__bnvs_#1!_seq } {
    \seq_map_inline:cn { g__bnvs_#1!_seq } { #2 { #1 } { ##1 } }
    \prg_return_true:
  } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { foreach_T:nn } #1 #2 { T, F, TF } {
  \seq_if_exist:cTF { g__bnvs_#1!_seq } {
    \cs_set:Npn \BNVS_foreach_T_nn:nn ##1 ##2 { #2 }
    \seq_map_inline:cn { g__bnvs_#1!_seq }
      { \BNVS_foreach_T_nn:nn { #1 } { ##1 } }
    \prg_return_true:
  } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_foreach_IT:N,
%   \__bnvs_foreach_IT:n,
% }
% \begin{syntax}
% \cs{__bnvs_foreach_IT:N} \meta{function:nn}
% \cs{__bnvs_foreach_IT:n} \KWNmarg{code}
% \end{syntax}
% Execute the \meta{function:nn} or the \KWNmeta{code} for each combination
% of \KWNmeta{id} and \KWNmeta{tag}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_IT:N } #1 {
  \__bnvs_foreach_I:n {
    \__bnvs_foreach_T:nNT { ##1 } #1 { }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_IT:n } #1 {
  \cs_set:Npn \BNVS_foreach_IT_n:nn ##1 ##2 { #1 }
  \__bnvs_foreach_I:n {
    \__bnvs_foreach_T:nNT { ##1 } \BNVS_foreach_IT_n:nn { }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ foreach_I:n }, noigre}
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \begin{function}{
%   \__bnvs_foreach_I:N,
%   \__bnvs_foreach_I:n,
% }
% \begin{syntax}
% \cs{__bnvs_foreach_key:N} \KWNmeta{function:n}
% \cs{__bnvs_foreach_key:n} \KWNmarg{code}
% \cs{__bnvs_foreach_key_main:N} \KWNmeta{function:n}
% \cs{__bnvs_foreach_key_main:n} \KWNmarg{code}
% \cs{__bnvs_foreach_key_sub:N} \KWNmeta{function:n}
% \cs{__bnvs_foreach_key_sub:n} \KWNmarg{code}
% \cs{__bnvs_foreach_key_cache:N} \KWNmeta{function:n}
% \cs{__bnvs_foreach_key_cache:n} \KWNmarg{code}
% \end{syntax}
% Execute the \KWNmeta{function:n} or the \KWNmeta{code} for each concerned
% key.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_main:N } {
  \tl_map_function:nN { VAZL }
}
%    \end{macrocode}
% \begin{BNVS.test}{.bnvs:c=key_main:N}
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \TEST:n {
%   \tl_put_right:Nn \l__bnvs_TEST_tl
% }
% \__bnvs_foreach_key_main:N \TEST:n
% \assert_equal_tl:vnn { TEST } { VAZL } { 1 }
% \cs_undefine:N \TEST:n
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_main:n } {
  \tl_map_inline:nn { VAZL }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_sub:N } {
  \tl_map_function:nN { PNvn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_sub:n } {
  \tl_map_inline:nn { PNvn }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key:n } #1 {
  \__bnvs_foreach_key_main:n { #1 }
  \__bnvs_foreach_key_sub:n  { #1 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key:N } #1 {
  \__bnvs_foreach_key_main:N #1
  \__bnvs_foreach_key_sub:N  #1
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_cache:N } {
  \tl_map_function:nN { {V*}{A*}{Z*}{L*}{P*}{N*} }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { foreach_key_cache:n } {
  \tl_map_inline:nn { {V*}{A*}{Z*}{L*}{P*}{N*} }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsubsection{Basic functions}
% \begin{BNVS.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_g:nn #1 #2 {
  \BNVS_DEBUG_log:nx #1 { ◓◓◓◓◓ ~line:~\the\inputlineno }
  \__bnvs_int_set:cn { i } { \tl_if_empty:nTF { #2 } { 20 } { #2 } }
  \cs_set:Npn \BNVS_DEBUG_log_g_nn:nn ##1 ##2 {
    \int_compare:nNnTF { \__bnvs_int_use:c { i } } > { 0 } {
      \__bnvs_foreach_key:n {
        \__bnvs_if_get:nnncT { ####1 } { ##1 } { ##2 } { DEBUG } {
          \BNVS_DEBUG_log:nx { #1 } { ##1!##2/####1 -> \BNVS_tl_use:Nv \exp_not:n { DEBUG } }
          \__bnvs_int_decr:c { i }
        }        
        \__bnvs_if_get_cache:nnncT { ####1 } { ##1 } { ##2 } { DEBUG } {
          \BNVS_DEBUG_log:nx { #1 } { ##1!##2/####1* -> \BNVS_tl_use:Nv \exp_not:n { DEBUG } }
          \__bnvs_int_decr:c { i }
        }        
      }
    } {
      \cs_set:Npn \BNVS_DEBUG_log_g_nn:nn ####1 ####2 {}
    }
  }
  \__bnvs_foreach_IT:N \BNVS_DEBUG_log_g_nn:nn
  \BNVS_DEBUG_log:nx { #1 } { ◒◒◒◒◒ ~line:~\the\inputlineno }
}
\NewDocumentCommand\BeanovesLogG {O{20}} { \BNVS_DEBUG_log_g:nn D {#1} }
%</!final>
% \end{BNVS.gobble}
%
% \begin{function}{
%   \__bnvs_gset:nnnn,
%   \__bnvs_gset:nnnv,
%   \__bnvs_gset:nvnn,
%   \__bnvs_gset:nvvn,
%   \__bnvs_gset:nvvv,
% }
% \begin{syntax}
% \cs{__bnvs_gset:nnnn} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{spec}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset:nnnn } #1 #2 #3 {
  \regex_match:nnTF { ^[a-z_]+$ } { #3 } {
    \use_none:n
  } {
    \__bnvs_register:nn { #2 } { #3 }
    \cs_gset:cpn { \__bnvs_name:nnn { #1 } { #2 } { #3 } }
  }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_set:cpn { gset:nnnn } #1 #2 #3 #4 {
  \BNVS_DEBUG_log_f:nc D { gset:nnnn }
  \BNVS_DEBUG_log:nn D { #2!#3/#1~<=~#4 }
  \tl_if_empty:nT { #3 } {
    \BNVS_error:n { Unexpected~empty~tag}   
  }
  \regex_match:nnTF { ^[a-z_]+$ } { #3 } {
    \BNVS_error:n { Reserved~tag}   
  } {
    \__bnvs_register:nn { #2 } { #3 }
    \cs_gset:cpn { \__bnvs_name:nnn { #1 } { #2 } { #3} } { #4 }
    \BNVS_DEBUG_log_g:nn D {}
  }
}
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset:nvnn } #1 {
  \BNVS_tl_use:nv { \__bnvs_gset:nnnn { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset:nvvn } #1 {
  \BNVS_tl_use:nvv { \__bnvs_gset:nnnn { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset:nnnv } #1 #2 #3 {
  \BNVS_tl_use:nv {
    \__bnvs_gset:nnnn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset:nvvv } #1 {
  \BNVS_tl_use:nvvv { \__bnvs_gset:nnnn { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}{
%   \__bnvs_gunset:nnn,
%   \__bnvs_gunset:nn,
%   \__bnvs_gunset:n,
%   \__bnvs_gunset:,
% }
% \begin{syntax}
% \cs{__bnvs_gunset:nnn} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_gunset:nn} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_gunset:n} \KWNmarg{id}
% \cs{__bnvs_gunset:}
% \end{syntax}
% Removes the specifications for the \KWNmeta{key}, \KWNmeta{id}, \KWNmeta{tag}
% combination.
% In the variant, all possible \KWNmeta{key}s and \KWNmeta{tag}s are used.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset:nnn } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
  \BNVS_DEBUG_log:nx D { \exp_not:n { \__bnvs_gunset:nnn~}\__bnvs_name:nnn { #1 } { #2 } { #3 } }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_undefine:c { \__bnvs_name:nnn { #1 } { #2 } { #3 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset:nvv } #1 {
  \BNVS_tl_use:nvv { \__bnvs_gunset:nnn { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset:nn } #1 #2 {
  \__bnvs_if_registered:nnT { #1 } { #2 } {
    \tl_map_inline:nn {
      \__bnvs_foreach_key_main:n
      \__bnvs_foreach_key_sub:n
      \__bnvs_foreach_key_cache:n
    } {
      ##1 {
        \__bnvs_gunset:nnn { ####1 } { #1 } { #2 }
      }
    }
    \__bnvs_unregister:nn { #1 } { #2 }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ gunset:nn }, noigre}
% \__bnvs_if_registered:nnT { ID } { TAG } {
%   \test_fail:n { A }
% }
% \__bnvs_gset:nnnn V { ID } { TAG } { }
% \__bnvs_if_registered:nnF { ID } { TAG } {
%   \test_fail:n { B }
% }
% \__bnvs_gunset:nn { ID } { TAG }
% \__bnvs_if_registered:nnT { ID } { TAG } {
%   \test_fail:n { C }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_deep:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncnn D { gunset_deep:nn } { ID } { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_foreach_IT:n {
    \tl_if_eq:nnT { #1 } { ##1 } {
		\tl_if_in:nnT { .. ##2 } { .. #2 . } {
		  \__bnvs_gunset:nn { #1 } { ##2 }
		}
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset:vn } {
  \BNVS_tl_use:Nv \__bnvs_gunset:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset:vv } {
  \BNVS_tl_use:Nvv \__bnvs_gunset:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_deep:vv } {
  \BNVS_tl_use:Nvv \__bnvs_gunset_deep:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\seq_new:N \l__bnvs_gunset_n_seq
\BNVS_new:cpn { gunset:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncnn D { gunset:n } { ID } { #1 } 
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_seq_clear:c { gunset_n }
  \__bnvs_foreach_I:n {
    \tl_if_eq:nnTF { ##1 } { #1 } {
      \__bnvs_foreach_T:nn { #1 } {
        \__bnvs_gunset:nn { #1  } { ####1 }
      }
    } {
      \__bnvs_seq_put_right:cn { gunset_n } { ##1 }
    }
  }
  \seq_gset_eq:NN \g__bnvs_I_seq \l__bnvs_gunset_n_seq
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset: } {
  \__bnvs_foreach_IT:N \__bnvs_gunset:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_is_gset:nnn,
%   \__bnvs_is_gset:nvv,
%   \__bnvs_is_gset:nvx,
%   \__bnvs_is_gset:nn,
%   \__bnvs_if_spec:nnn,
%   \__bnvs_if_spec:nn,
% }
% \begin{syntax}
% \cs{__bnvs_is_gset:nnnTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_is_gset:nnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_spec:nnnTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_spec:nnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of a \meta{\textsl{spec}}
% for that \KWNmeta{key}, \KWNmeta{id}, \KWNmeta{tag} combination.
% The version with no \KWNmeta{key} is the or combination for keys
% |V|, |A| and |Z|.
%
% The |_spec:...| variant is similar except that it uses
% \KWNmeta{key}, \KWNmeta{id}, \meta{\textsl{ref}} or
% \KWNmeta{key}\, empty \KWNmeta{id}, \KWNmeta{tag} combinations.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_gset:nnn } #1 #2 #3 { T, F, TF } {
  \cs_if_exist:cTF { \__bnvs_name:nnn { #1 } { #2 } { #3 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_gset:nvx } #1 #2 #3 { T, F, TF } {
  \exp_args:Nnnx \BNVS_tl_use:nv {
    \__bnvs_is_gset:nnnTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_gset:nvv } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nvv {
    \__bnvs_is_gset:nnnTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_gset:nn } #1 #2 { T, F, TF } {
  \__bnvs_is_gset:nnnTF V { #1 } { #2 } {
    \prg_return_true:
  } {
    \__bnvs_is_gset:nnnTF A { #1 } { #2 } {
      \prg_return_true:
    } {
      \__bnvs_is_gset:nnnTF Z { #1 } { #2 } {
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:cn={...gset:nnn...}{A/B!C}, noigre}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnTF A B C
%   { \test_fail:n { 1 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 2 }
% \__bnvs_gset:nnnn A B C { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \__bnvs_tl_clear:c { ans }
% \use:c { \__bnvs_name:nnn A B C }
% \assert_equal_ans:nn { SUCCESS } { 2' }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnTF A B C
%   { \__bnvs_tl_set:cn { ans } { SUCCESS } } { \test_fail:n { 3 } }
% \assert_equal_ans:nn { SUCCESS } { 4 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnTF B C
%   { \__bnvs_tl_set:cn { ans } { SUCCESS } } { \test_fail:n { 4 } }
% \assert_equal_ans:nn { SUCCESS } { 5 }
% \__bnvs_gunset:nnn A B C
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnTF A B C
%   { \test_fail:n { 6 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 7 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnTF B C
%   { \test_fail:n { 8 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 9 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={gunset:nn}, noigre}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_gset:nnnn A B C { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \__bnvs_gset:nnnn Z B C { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \__bnvs_tl_clear:c { ans }
% \use:c { \__bnvs_name:nnn A B C }
% \assert_equal_ans:nn { SUCCESS } { 1 }
% \__bnvs_tl_clear:c { ans }
% \use:c { \__bnvs_name:nnn Z B C }
% \assert_equal_ans:nn { SUCCESS } { 2 }
% \__bnvs_gunset:nn B C
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnTF A B C
%   { \test_fail:n { 3A } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 4A }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnTF Z B C
%   { \test_fail:n { 3Z } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 4Z }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_spec:nnn } #1 #2 #3 { T, F, TF } {
  \__bnvs_is_gset:nnnTF { #1 } { #2 } { #3 } {
    \prg_return_true:
  } {
    \tl_if_empty:nTF { #2 } {
      \prg_return_false:
    } {
      \__bnvs_is_gset:nnnTF { #1 } { } { #3 } {
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_spec:nnn}, noigre}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_spec:nnnTF A B C
%   { \test_fail:n { 1 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 2 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_gset:nnnn A {} C { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \__bnvs_tl_clear:c { ans }
% \use:c { \__bnvs_name:nnn A {} C }
% \assert_equal_ans:nn { SUCCESS } { 3 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_spec:nnnTF A B C
%  { \__bnvs_tl_set:cn { ans } { SUCCESS } } { \test_fail:n { 1 } } 
% \assert_equal_ans:nn { SUCCESS } { 4 }
% \__bnvs_gunset:nnn A {} C
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_spec:nnnTF A B C
%   { \test_fail:n { 5 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 6 }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_spec:nn } #1 #2 { T, F, TF } {
  \__bnvs_is_gset:nnTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \tl_if_empty:nTF { #1 } {
      \prg_return_false:
    } {
      \__bnvs_is_gset:nnTF { } { #2 } {
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_spec:nn}, noigre}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_spec:nnTF B C
%   { \test_fail:n { 1 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { 2 }
% \tl_map_inline:nn { VAZ } {
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_gset:nnnn #1 B C { \__bnvs_tl_set:cn { ans } { SUCCESS } }
%   \__bnvs_tl_clear:c { ans }
%   \use:c { \__bnvs_name:nnn #1 B C }
%   \assert_equal_ans:nn { SUCCESS } { 3 }
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_if_spec:nnTF B C
%     { \__bnvs_tl_set:cn { ans } { SUCCESS } } { \test_fail:n { 1 } }
%   \assert_equal_ans:nn { SUCCESS } { 4 }
%   \__bnvs_gunset:nnn #1 B C
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_if_spec:nnTF B C
%     { \test_fail:n { 5 } } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
%   \assert_equal_ans:nn { SUCCESS } { 6 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_get:nnnc,
%   \__bnvs_spec:nnnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_get:nnncTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans}
% \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_spec:nnncTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans}
% \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% The \cs{__bnvs_if_get:nnnc...} variant puts what was stored
% for \KWNmeta{key}, \KWNmeta{id} and \KWNmeta{tag} into
% the \KWNmeta{ans} variable, if any, then executes the \KWNmeta{yes code}.
% Otherwise executes the \KWNmarg{no code} without changing the contents
% of the \KWNmeta{ans} |tl| variable.
%
% The \cs{__bnvs_spec:nnnc...} is similar except that is uses what was
% stored for \KWNmeta{key}, \KWNmeta{id} and \KWNmeta{tag} or \KWNmeta{key},
% an empty \KWNmeta{id} and \KWNmeta{tag}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_get:nnnc } #1 #2 #3 #4 { T, F, TF } {
  \__bnvs_is_gset:nnnTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%    \cs_set_eq:cc
%      { \BNVS_l:cn { #4 } { tl } } { \__bnvs_name:nnn { #1 } { #2 } { #3 } }
% \end{BNVS.gobble}
%    \begin{macrocode}
    \exp_args:Nnc \use:n { \exp_args:Nno \cs_set:cpn { \BNVS_l:cn { #4 } { tl } } } { \__bnvs_name:nnn { #1 } { #2 } { #3 } }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{.bnvs:c={if_get:nnnc}, noigre}
% \__bnvs_gset:nnnn KITV
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_if_get:nnncT KIT { TEST } {}
% \BNVS_DEBUG_on:
% \BNVS_DEBUG_log_g:nn D {}
% \__bnvs_gunset:nnn KIT
% \BNVS_DEBUG_log_g:nn D {}
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_get:nvvc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:nvv {
    \__bnvs_if_get:nnncTF { #1 }
  } { #2 } { #3 } { #4 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_spec:nnnc } #1 #2 #3 #4 { T, F, TF } {
  \__bnvs_if_get:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \prg_return_true:
  } {
    \tl_if_empty:nTF { #2 } {
      \prg_return_false:
    } {
      \__bnvs_if_get:nnncTF { #1 } { } { #3 } { #4 } {
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_is_provide_gset:nnn,
%   \__bnvs_is_provide_gset:nvv,
% }
% \begin{syntax}
% \cs{__bnvs_is_provide_gset:nnnTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Execute \KWNmeta{yes code} when in provide mode and gset, 
% \KWNmeta{no code} otherwise.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_provide_gset:nnn } #1 #2 #3 { T, F, TF } {
  \__bnvs_if:cTF { provide } {
    \cs_if_exist:cTF { \__bnvs_name:nnn { #1 } { #2 } { #3 } } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p { is_provide_gset:nnn...TRUE(#2!#3/#1)}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p { is_provide_gset:nnn...FALSE~is_gset(#2!#3/#1)}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p { is_provide_gset:nnn...FALSE~provide(#2!#3/#1)}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { is_provide_gset:nvv } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nvv { \__bnvs_is_provide_gset:nnnTF { #1 } } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_gprovide:TnnnnF,
%   \__bnvs_gprovide:TnvnnF,
%   \__bnvs_gprovide:TnvvnF,
% }
% \begin{syntax}
% \cs{__bnvs_gprovide:TnnnnF} \KWNmarg{yes code} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{value}} \KWNmarg{no code}
% \end{syntax}
% Execute \KWNmeta{no code} exclusively when not in provide mode.
% Does nothing when something was set for the
% \texttt{\KWNmeta{id}!\KWNmeta{tag}/\KWNmeta{key}} combination.
% Execute \KWNmeta{yes code} before providing.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gprovide:TnnnnF } #1 #2 #3 #4 #5 {
  \__bnvs_if:cTF { provide } {
    \__bnvs_is_gset:nnnF { #2 } { #3 } { #4 } {
      #1
      \__bnvs_gset:nnnn { #2 } { #3 } { #4 } { #5 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f_KIT:ncnnnnn P { gprovide:TnnnnF } { #2 } { #3 } { #4 } { VALUE } { #5 }
\BNVS_DEBUG_log_g:nn P {}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    }
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ gprovide:TnnnnF }, noigre}
% \__bnvs_gunset:
% \__bnvs_provide_off:
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnT { KK } { II } { TT } { \test_fail:n { A } }
% \__bnvs_gprovide:TnnnnF { \test_fail:n { B } } { KK } { II } { TT } { VV } { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { C }
% \__bnvs_is_gset:nnnT { KK } { II } { TT } { \test_fail:n { D } }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_provide_on:
% \__bnvs_gprovide:TnnnnF { \__bnvs_tl_set:cn { ans } { SUCCESS } } { KK } { II } { TT } { VV } { \test_fail:n { E } }
% \assert_equal_ans:nn { SUCCESS } { F }
% \__bnvs_is_gset:nnnF { KK } { II } { TT } { \test_fail:n { G } }
% \__bnvs_gprovide:TnnnnF { \test_fail:n { H } } { KK } { II } { TT } { VV } { \test_fail:n { I } }
% \__bnvs_is_gset:nnnF { KK } { II } { TT } { \test_fail:n { J } }
% \__bnvs_gunset:nnn { KK } { II } { TT }
% \__bnvs_is_gset:nnnT { KK } { II } { TT } { \test_fail:n { K } }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gprovide:TnvnnF } #1 #2 {
  \BNVS_tl_use:nv { \__bnvs_gprovide:TnnnnF { #1 } { #2 } }
}
\BNVS_new:cpn { gprovide:TnvvnF } #1 #2 {
  \BNVS_tl_use:nvv { \__bnvs_gprovide:TnnnnF { #1 } { #2 } }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={gprovide:TnnnnF}, noigre}
% \__bnvs_gunset:
% \__bnvs_is_gset:nnnT KIT { \test_fail:n { A } }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_provide_on:
% \__bnvs_gprovide:TnnnnF { \__bnvs_tl_set:cn { ans } { SUCCESS } } KITV { \__bnvs_tl_set:cn { ans } { SUCCESS } }
%   {}
% \assert_equal_ans:nn { SUCCESS } { 1 }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_is_gset:nnnF KIT { \test_fail:n { B } }
% \__bnvs_gprovide:TnnnnF { \test_fail:n { C } } KITV { \__bnvs_tl_set:cn { ans } { SUCCESS } }
%   {}
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \begin{BNVS.test}{bnvs:c=if_get:nnncTF, noigre}
% \__bnvs_gunset:
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_if_get:nnncTF { a_key } { a_id } { a_Tag } { TEST } { \test_fail:n { A/1 } } { }
% \__bnvs_tl_clear:c { TEST }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \__bnvs_tl_clear:c { TEST }
%   \BNVS_use_raw:c { __bnvs_if_get:nnnc#1 } { a_key } { a_id } { a_Tag } { TEST }
% }
% \__bnvs_tl_clear:c { ans }
% \BNVS_Test:n { TF } { \test_fail:n { A/TF } }
%                       { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { A/TF }
% \BNVS_Test:n { T  } { \test_fail:n { A/T } }
% \__bnvs_tl_clear:c { ans }
% \BNVS_Test:n {  F }   { \__bnvs_tl_set:cn { ans } { SUCCESS } }
% \assert_equal_ans:nn { SUCCESS } { A/F }
% \__bnvs_gset:nnnn { a_key } { a_id } { a_Tag } { a_value }
% \cs_new:Npn \BNVS_TestT:n {
%   \assert_equal_tl:vnn { TEST } { a_value }
% }
% \__bnvs_tl_clear:c { ans }
% \BNVS_DEBUG_on:
% \BNVS_DEBUG_log_g:nn D{}
% \__bnvs_if_get:nnncTF { a_key } { a_id } { a_Tag } { TEST }
%   { \BNVS_TestT:n { B/TF } } { \test_fail:n { B'/TF } }
% \BNVS_Test:n { TF } { \BNVS_TestT:n { B/TF } } 
%                       { \test_fail:n { B'/TF } }
% \BNVS_Test:n { T  } { \BNVS_TestT:n { B/T } }
% \BNVS_Test:n {  F }   { \test_fail:n { B'/F } }
% \__bnvs_gunset:nn { a_id } { a_Tag }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_TestT:n
% \end{BNVS.test}
%
% \subsubsection{Functions with cache}
% \begin{BNVS.gobble}
%<*!final>
\int_new:N \l__bnvs_DEBUG_int
\tl_new:N \l__bnvs_DEBUG_tl
\cs_new:Npn \BNVS_DEBUG_D_log_cache:n #1 {
  \BNVS_group_begin:
  \__bnvs_int_set:cn { DEBUG } { \tl_if_empty:nTF { #1 } { 20 } { #1 } }
  \cs_set:Npn \BNVS_D_log_cache_n:nn ##1 ##2 {
    \int_compare:nNnF { \__bnvs_int_use:c { DEBUG } } > { 0 } {
      \__bnvs_foreach_key_cache:n {
        \__bnvs_if_get_cache:nnncT { ####1 } { ##1 } { ##2 } { DEBUG } {
          \BNVS_DEBUG_log:nx D { n: ##1!##2 -> \BNVS_tl_use:Nv
          \exp_not:n { \__bnvs_int_decr:c { i } } }
        }
      }
    } {
      \cs_set:Npn \BNVS_D_log_cache_n:nn ####1 ####2 {}
    }
  }
  \__bnvs_foreach_IT:n { \BNVS_D_log_cache_n:nn { ##1 } { ##2 } }
  \BNVS_group_end:
}

\NewDocumentCommand\BeanovesLogC {O{20}} { \BNVS_DEBUG_D_log_cache:n {#1} }
%</!final>
% \end{BNVS.gobble}
% \begin{function}{
%   \__bnvs_gset_cache:nnnn,
%   \__bnvs_gset_cache:nnnv,
%   \__bnvs_gset_cache:nvvn,
% }
% \begin{syntax}
% \cs{__bnvs_gset_cache:nnnn} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{value}}
% \end{syntax}
% Wrapper over the functions above for \KWNmeta{key}|*| instead of \KWNmeta{key}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset_cache:nnnn } #1 {
  \__bnvs_gset:nnnn { #1 * }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_set:cpn { gset_cache:nnnn } #1 #2 #3 #4 {
\BNVS_DEBUG_log_f_KIT:ncnnnnn D { gset_cache:nnnn } { #1 } { #2 } { #3 } { VALUE } { #4 }
  \__bnvs_gset:nnnn { #1 * } { #2 } { #3 } { #4 }
}
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset_cache:nvvn } #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:nv {
      \__bnvs_gset_cache:nnnn { #1 }
    } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gset_cache:nnnv } #1 #2 #3 {
  \BNVS_tl_use:nv {
    \__bnvs_gset_cache:nnnn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_get_cache:nnnc
% }
% \begin{syntax}
% \cs{__bnvs_if_get_cache:nnncTF} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans}
%   \KWNmarg{yes code} \marg{false code}
% \end{syntax}
% Wrapper over the functions above for \KWNmeta{key}|*| instead of \KWNmeta{key}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_get_cache:nnnc } #1 #2 #3 #4 { T, F, TF } {
  \__bnvs_if_get:nnncTF { #1 * } { #2 } { #3 } { #4 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_gunset_cache:nnn,
%   \__bnvs_gunset_cache:nvv,
%   \__bnvs_gunset_cache:nn,
%   \__bnvs_gunset_cache:vv,
%   \__bnvs_gunset_cache:n,
%   \__bnvs_gunset_cache:
% }
% \begin{syntax}
% \cs{__bnvs_gunset_cache:nnn} \KWNmarg{key} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_gunset_cache:nn} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_gunset_cache:n} \KWNmarg{id}
% \cs{__bnvs_gunset_cache:}
% \end{syntax}
% Wrapper over the functions above for \KWNmeta{key}|*| instead of \KWNmeta{key}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache:nnn } #1 {
  \__bnvs_gunset:nnn { #1 * }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache:nvv } #1 {
  \__bnvs_gunset:nvv { #1 * }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache:nn } #1 #2 {
  \__bnvs_foreach_key_cache:n {
    \__bnvs_gunset:nnn { ##1 } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache:vv } {
  \BNVS_tl_use:Nvv \__bnvs_gunset:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache:n } #1 {
  \__bnvs_foreach_IT:n {
    \tl_if_eq:nnT { #1 } { ##1 } {
      \__bnvs_gunset_cache:nn { ##1 } { ##2 }
    }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncnn D { gunset_cache:n } { ID } { #1 }
\BNVS_DEBUG_log_g:nn D { }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gunset_cache: } {
  \__bnvs_foreach_IT:n {
    \__bnvs_gunset_cache:nn { ##1 } { ##2 }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nc D { gunset_cache: }
\BNVS_DEBUG_log_g:nn D { }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{Implicit value counter}
% The implicit value counter is local to the current frame.
% It is defined at the global level because changes made
% at any depth must be made at the frame depth.
% If the frame were a closure, this counter would belong to that closure.
% When used for the first time, it either defaults to the first index or last index.
% \begin{function}{
%   \__bnvs_v_gunset:nn,
%   \__bnvs_v_gunset:n,
%   \__bnvs_v_gunset:
% }
% \begin{syntax}
% \cs{__bnvs_v_gunset:n} \KWNmarg{id} \KWNmarg{tag}
% \cs{__bnvs_v_gunset:n} \KWNmarg{id}
% \cs{__bnvs_v_gunset:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_gunset: } {
  \__bnvs_foreach_IT:n {
    \__bnvs_gunset:nnn   v { ##1 } { ##2 }
    \__bnvs_gunset_cache:nnn v { ##1 } { ##2 }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nc D { v_gunset: }
\BNVS_DEBUG_log_g:nn D {}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_nil:c } #1 { T, F, TF } {
  \BNVS_tl_use:nc { \exp_args:No \quark_if_nil:nTF } { #1 } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={quark_if_nil}, noigre}
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_quark_if_nil:cT { TEST } {
%   \test_fail:n { A }
% }
% \__bnvs_tl_set:cn { TEST } { \q_nil }
% \__bnvs_quark_if_nil:cF { TEST } {
%   \test_fail:n { B }
% }
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn q { } { quark_if_nil:cTF } { /#1/TRUE }
\BNVS_tl_use:nc { \BNVS_DEBUG_log:nn q } { #1 }
\BNVS_tl_use:nv { \BNVS_DEBUG_log:nn q } { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn q { } { quark_if_nil:cTF } { /#1/FALSE }
\BNVS_tl_use:nc { \BNVS_DEBUG_log:nn q } { #1 }
\BNVS_tl_use:nv { \BNVS_DEBUG_log:nn q } { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_no_value:c } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn q { } { quark_if_no_value:cTF } { ... }
\BNVS_tl_use:nc { \BNVS_DEBUG_log:nn q } { #1 }
\BNVS_tl_use:nv { \BNVS_DEBUG_log:nn q } { #1 }
%\BNVS_tl_use:nv { \BNVS_DEBUG_log:nn q } { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_tl_use:nc { \exp_args:No \quark_if_no_value:nTF } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn q { } { quark_if_no_value:c } { /#1/TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn q { } { quark_if_no_value:c } { /#1/FALSE }
\BNVS_tl_use:nc { \BNVS_DEBUG_log:nn q } { #1 }
\BNVS_tl_use:nv { \BNVS_DEBUG_log:nn q } { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_greset_all:nnn,
%   \__bnvs_if_greset_all:vvn,
% }
% \begin{syntax}
% \cs{__bnvs_if_greset_all:nnnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{initial value} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% If the \KWNmeta{id}!\KWNmeta{tag} combination is known, reset the value counter the given
% \KWNmeta{initial value} and execute \KWNmeta{yes code}
% otherwise \KWNmeta{no code} is executed.
% The |..._all| variant also cleans the cached values and all the subvalues.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_greset_all:nnn } #1 #2 #3 { T, F, TF } {
  \__bnvs_is_gset:nnTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f_IT:ncnnnn D { if_greset_all:nnnTF } { #1 } { #2 } { VALUE } { #3 }
    \BNVS_DEBUG_begin:n { if_greset_all:nnnTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_foreach_key_main:n {
      \__bnvs_if_get:nnncT { ##1 } { #1 } { #2 } { a } {
        \__bnvs_quark_if_nil:cT { a } {
          \__bnvs_if_get_cache:nnncTF { ##1 } { #1 } { #2 } { a } {
            \__bnvs_gset:nnnv { ##1 } { #1 } { #2 } { a }
          } {
            \__bnvs_gset:nnnn { ##1 } { #1 } { #2 } { 1 }
          }
        }
      }
    }
    \BNVS_end:
    \__bnvs_gunset_cache:nn { #1 } { #2 }
    \__bnvs_foreach_key_sub:n {
      \__bnvs_gunset:nnn { ##1 } { #1 } { #2 }
    }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_greset_all:vvn } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_if_greset_all:nnnTF { #1 }
  } { #2 } { #3 } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{Regular expressions}
%
% \begin{variable}{\c__bnvs_short_regex}
% This regular expressioin is used for both short names and dot path components.
% The short name of an overlay set consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_short_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{banner=short_regex, noigre}
% \Test_regex:nnnn { short } {A} {A} {1}
% \Test_regex:nnnn { short } {_A1} {_A1} {2}
% \end{BNVS.test}
% \end{variable}
% \begin{variable}{\c__bnvs_path_regex}
% A sequence of \texttt{.\KWNmeta{positive integer}} or \texttt{.\KWNmeta{short name}} items representing a path.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_path_regex {
  (?: \. \ur{c__bnvs_short_regex} | \. [-+]? \d+ )*
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{banner=path_regex, noigre}
% \Test_regex:nnnn { path } {} {} {1}
% \Test_regex:nnnn { path } {.1} {.1} {2}
% \Test_regex:nnnn { path } {.1.2} {.1.2} {3}
% \Test_regex:nnnn { path } {.1.-2} {.1.-2} {4}
% \Test_regex:nnnn { path } {.-1} {.-1} {5}
% \Test_regex:nnnn { path } {.-1.2} {.-1.2} {6}
% \Test_regex:nnnn { path } {.-1.-2} {.-1.-2} {7}
% \Test_regex:nnnn { path } {.1.n} {.1.n} {2'}
% \Test_regex:nnnn { path } {.1.2.n} {.1.2.n} {3'}
% \Test_regex:nnnn { path } {.1.-2.n} {.1.-2.n} {4'}
% \Test_regex:nnnn { path } {.-1.n} {.-1.n} {5'}
% \Test_regex:nnnn { path } {.-1.2.n} {.-1.2.n} {6'}
% \Test_regex:nnnn { path } {.-1.-2.n} {.-1.-2.n} {7'}
% \Test_regex:nnnn { path } {.n.1} {.n.1} {2''}
% \Test_regex:nnnn { path } {.1.n.2} {.1.n.2} {3''}
% \Test_regex:nnnn { path } {.1.n.-2} {.1.n.-2} {4''}
% \Test_regex:nnnn { path } {.n.-1} {.n.-1} {5''}
% \Test_regex:nnnn { path } {.-1.n.2} {.-1.n.2} {6''}
% \Test_regex:nnnn { path } {.-1.n.-2} {.-1.n.-2} {7''}
% \end{BNVS.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_A_integer_Z_regex}
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_integer_Z_regex { \A[-+]?\d+\Z }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\c__bnvs_A_integer_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_integer_Z_regex { #1 } { #1 } { a-#2 }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \BNVS_Test:nn { 11 } { 2 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_integer_Z_regex { #1 } { } { b-#2 }
% }
% \BNVS_Test:nn { a } { 1 }
% \BNVS_Test:nn { 1a } { 2 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
% \begin{variable}{\c__bnvs_A_index_Z_regex}
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_index_Z_regex { \A[-+]?\d+\Z }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\c__bnvs_A_index_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_index_Z_regex { #1 } { #1 } { a-#2 }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \BNVS_Test:nn { 11 } { 2 }
% \BNVS_Test:nn { +1 } { 3 }
% \BNVS_Test:nn { +11 } { 4 }
% \BNVS_Test:nn { -1 } { 5 }
% \BNVS_Test:nn { -11 } { 6 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_index_Z_regex { #1 } { } { b-#2 }
% }
% \BNVS_Test:nn { a } { 1 }
% \BNVS_Test:nn { 1a } { 2 }
% \BNVS_Test:nn { +1_ } { 3 }
% \BNVS_Test:nn { +1a } { 4 }
% \BNVS_Test:nn { --1 } { 5 }
% \BNVS_Test:nn { -1a } { 6 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
% \begin{variable}{\c__bnvs_A_reserved_Z_regex}
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_reserved_Z_regex {
  \A_*[a-z][_a-z0-9]*\Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\c__bnvs_A_reserved_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_reserved_Z_regex { #1 } { #1 } { a-#2 }
% }
% \BNVS_Test:nn { a } { 1 }
% \BNVS_Test:nn { aa } { 2 }
% \BNVS_Test:nn { a_ } { 3 }
% \BNVS_Test:nn { a0 } { 4 }
% \BNVS_Test:nn { _a } { 11 }
% \BNVS_Test:nn { _aa } { 12 }
% \BNVS_Test:nn { _a_ } { 13 }
% \BNVS_Test:nn { _a0 } { 14 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_reserved_Z_regex { #1 } { } { b-#2 }
% }
% \BNVS_Test:nn { A } { 1 }
% \BNVS_Test:nn { aA } { 2 }
% \BNVS_Test:nn { A_ } { 3 }
% \BNVS_Test:nn { A0 } { 4 }
% \BNVS_Test:nn { _A } { 11 }
% \BNVS_Test:nn { _aA } { 12 }
% \BNVS_Test:nn { _A_ } { 13 }
% \BNVS_Test:nn { _A0 } { 14 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
%
% \begin{variable}{\c__bnvs_A_ref_Z_regex}
% A qualified dotted name is the qualified name of an overlay set
% possibly followed by a dotted path.
% Matches the whole string.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_ref_Z_regex {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{myList}
% \item[1:] the \meta{\textsl{frame id}}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \A (?: ( \ur{c__bnvs_short_regex} )? ! )?
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[2:] The short name.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_short_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[3:] the path, if any.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_regex} ) \Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{myList}
% \begin{BNVS.test}{:N=\c__bnvs_A_ref_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \test_extract:Nnnn \c__bnvs_A_ref_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {{}, A,{}} {1}
% \BNVS_Test:nnn {_A1} {{}, _A1,{}} {2}
% \BNVS_Test:nnn {A.1} {{}, A, .1} {3}
% \BNVS_Test:nnn {_A1.1} {{}, _A1, .1} {4}
% \BNVS_Test:nnn {_A1.1.2} {{}, _A1, .1.2} {5}
% \BNVS_Test:nnn {!A} {{}, A, {}} {1-!}
% \BNVS_Test:nnn {!_A1} {{}, _A1, {}} {2-!}
% \BNVS_Test:nnn {!A.1} {{}, A, .1} {3-!}
% \BNVS_Test:nnn {!_A1.1} {{}, _A1, .1} {4-!}
% \BNVS_Test:nnn {!_A1.1.2} {{}, _A1, .1.2} {5-!}
% \BNVS_Test:nnn {X!A} {X, A, {}} {1-X!}
% \BNVS_Test:nnn {X!_A1} {X, _A1, {}} {2-X!}
% \BNVS_Test:nnn {X!A.1} {X, A, .1} {3-X!}
% \BNVS_Test:nnn {X!_A1.1} {X, _A1, .1} {4-X!}
% \BNVS_Test:nnn {X!_A1.1.2} {X, _A1, .1.2} {5-X!}
% \BNVS_Test:nnn {A.n} {{},A,.n} {1'}
% \BNVS_Test:nnn {_A1.n} {{},_A1, .n} {2'}
% \BNVS_Test:nnn {A.1.n} {{}, A, .1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {{}, _A1, .1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {{}, _A1, .1.2.n} {5'}
% \BNVS_Test:nnn {!A.n} {{}, A, .n} {1'-!}
% \BNVS_Test:nnn {!_A1.n} {{}, _A1, .n} {2'-!}
% \BNVS_Test:nnn {!A.1.n} {{}, A, .1.n} {3'-!}
% \BNVS_Test:nnn {!_A1.1.n} {{}, _A1, .1.n} {4'-!}
% \BNVS_Test:nnn {!_A1.1.2.n} {{}, _A1, .1.2.n} {5'-!}
% \BNVS_Test:nnn {X!A.n} {X, A, .n} {1'-X!}
% \BNVS_Test:nnn {X!_A1.n} {X, _A1, .n} {2'-X!}
% \BNVS_Test:nnn {X!A.1.n} {X, A, .1.n} {3'-!}
% \BNVS_Test:nnn {X!_A1.1.n} {X, _A1, .1.n} {4'-X!}
% \BNVS_Test:nnn {X!_A1.1.2.n} {X, _A1, .1.2.n} {5'-X!}
% \end{BNVS.test}
%
% \begin{variable}{\c__bnvs_A_IKT_Z_regex}
% Matches the whole string, split into \KWNmeta{id} and \KWNmeta{tag}.
% \end{variable}
% \begin{itemize}
% \item[1:] The full match,
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_IKT_Z_regex {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[2:] the frame \KWNmeta{id}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \A (?: ( \ur{c__bnvs_short_regex} )? (!) )?
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[3:] The short name
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_short_regex}
  (?: \. \ur{c__bnvs_short_regex} | \. [-+]? \d+ )* ) \Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{itemize}
% \begin{BNVS.test}{banner=A_IKT_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_IKT_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {{},{},A} {1}
% \BNVS_Test:nnn {_A1} {{},{},_A1} {2}
% \BNVS_Test:nnn {A.1} {{},{},A.1} {3}
% \BNVS_Test:nnn {_A1.1} {{},{},_A1.1} {4}
% \BNVS_Test:nnn {_A1.1.2} {{},{},_A1.1.2} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {{},{},_A1.1.2.n} {6}
% \BNVS_Test:nnn {!A} {{},{!}, A} {1-!}
% \BNVS_Test:nnn {!_A1} {{}, {!}, _A1}  {2-!}
% \BNVS_Test:nnn {!A.1} {{}, {!}, A.1} {3-!}
% \BNVS_Test:nnn {!_A1.1} {{}, {!}, _A1.1} {4-!}
% \BNVS_Test:nnn {!_A1.1.2} {{}, {!}, _A1.1.2} {5-!}
% \BNVS_Test:nnn {X!A} {X, {!}, A} {1-X!}
% \BNVS_Test:nnn {X!_A1} {X, {!}, _A1} {2-X!}
% \BNVS_Test:nnn {X!A.1} {X, {!}, A.1} {3-X!}
% \BNVS_Test:nnn {X!_A1.1} {X, {!}, _A1.1} {4-X!}
% \BNVS_Test:nnn {X!_A1.1.2} {X, {!}, _A1.1.2} {5-X!}
% \BNVS_Test:nnn {A.n} {{}, {},A.n} {1'}
% \BNVS_Test:nnn {_A1.n} {{}, {},_A1.n} {2'}
% \BNVS_Test:nnn {A.1.n} {{}, {}, A.1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {{}, {}, _A1.1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {{}, {}, _A1.1.2.n} {5'}
% \BNVS_Test:nnn {!A.n} {{}, {!}, A.n} {1'-!}
% \BNVS_Test:nnn {!_A1.n} {{}, {!}, _A1.n} {2'-!}
% \BNVS_Test:nnn {!A.1.n} {{}, {!}, A.1.n} {3'-!}
% \BNVS_Test:nnn {!_A1.1.n} {{}, {!}, _A1.1.n} {4'-!}
% \BNVS_Test:nnn {!_A1.1.2.n} {{}, {!}, _A1.1.2.n} {5'-!}
% \BNVS_Test:nnn {!_A1.1.n.2.n} {{}, {!}, _A1.1.n.2.n} {5''-!}
% \BNVS_Test:nnn {X!A.n} {X, {!}, A.n} {1'-X!}
% \BNVS_Test:nnn {X!_A1.n} {X, {!}, _A1.n} {2'-X!}
% \BNVS_Test:nnn {X!A.1.n} {X, {!}, A.1.n} {3'-X!}
% \BNVS_Test:nnn {X!_A1.1.n} {X, {!}, _A1.1.n} {4'-X!}
% \BNVS_Test:nnn {X!_A1.1.2.n} {X, {!}, _A1.1.2.n} {5'-X!}
% \BNVS_Test:nnn {X!_A1.1.n.2} {X, {!}, _A1.1.n.2} {5''-X!}
% \end{BNVS.test}
% \begin{variable}{\c__bnvs_A_ISP_Z_regex}
% Matches the whole string.
% \end{variable}
% \begin{itemize}
% \item[1:] The full match,
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_ISP_Z_regex {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[2:] the frame \KWNmeta{id}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \A (?: ( \ur{c__bnvs_short_regex} )? (!) )?
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[3:] The short name
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_short_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[4:] The dotted path.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( (?: \. \ur{c__bnvs_short_regex} | \. [-+]? \d+ )* ) \Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{itemize}
% \begin{BNVS.test}{banner=A_ISP_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_ISP_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {{},{},A,{}} {1}
% \BNVS_Test:nnn {_A1} {{},{},_A1,{}} {2}
% \BNVS_Test:nnn {A.1} {{},{},A,.1} {3}
% \BNVS_Test:nnn {_A1.1} {{},{},_A1,.1} {4}
% \BNVS_Test:nnn {_A1.1.2} {{},{},_A1,.1.2} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {{},{},_A1,.1.2.n} {6}
% \BNVS_Test:nnn {!A} {{},{!}, A,{}} {1-!}
% \BNVS_Test:nnn {!_A1} {{}, {!}, _A1, {}} {2-!}
% \BNVS_Test:nnn {!A.1} {{}, {!}, A, .1} {3-!}
% \BNVS_Test:nnn {!_A1.1} {{}, {!}, _A1, .1} {4-!}
% \BNVS_Test:nnn {!_A1.1.2} {{}, {!}, _A1, .1.2} {5-!}
% \BNVS_Test:nnn {X!A} {X, {!}, A, {}} {1-X!}
% \BNVS_Test:nnn {X!_A1} {X, {!}, _A1, {}} {2-X!}
% \BNVS_Test:nnn {X!A.1} {X, {!}, A, .1} {3-X!}
% \BNVS_Test:nnn {X!_A1.1} {X, {!}, _A1, .1} {4-X!}
% \BNVS_Test:nnn {X!_A1.1.2} {X, {!}, _A1, .1.2} {5-X!}
% \BNVS_Test:nnn {A.n} {{}, {},A,.n} {1'}
% \BNVS_Test:nnn {_A1.n} {{}, {},_A1,.n} {2'}
% \BNVS_Test:nnn {A.1.n} {{}, {}, A,.1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {{}, {}, _A1,.1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {{}, {}, _A1,.1.2.n} {5'}
% \BNVS_Test:nnn {!A.n} {{}, {!}, A, .n} {1'-!}
% \BNVS_Test:nnn {!_A1.n} {{}, {!}, _A1, .n} {2'-!}
% \BNVS_Test:nnn {!A.1.n} {{}, {!}, A, .1.n} {3'-!}
% \BNVS_Test:nnn {!_A1.1.n} {{}, {!}, _A1, .1.n} {4'-!}
% \BNVS_Test:nnn {!_A1.1.2.n} {{}, {!}, _A1, .1.2.n} {5'-!}
% \BNVS_Test:nnn {!_A1.1.n.2.n} {{}, {!}, _A1, .1.n.2.n} {5''-!}
% \BNVS_Test:nnn {X!A.n} {X, {!}, A, .n} {1'-X!}
% \BNVS_Test:nnn {X!_A1.n} {X, {!}, _A1, .n} {2'-X!}
% \BNVS_Test:nnn {X!A.1.n} {X, {!}, A, .1.n} {3'-X!}
% \BNVS_Test:nnn {X!_A1.1.n} {X, {!}, _A1, .1.n} {4'-X!}
% \BNVS_Test:nnn {X!_A1.1.2.n} {X, {!}, _A1, .1.2.n} {5'-X!}
% \BNVS_Test:nnn {X!_A1.1.n.2} {X, {!}, _A1, .1.n.2} {5''-X!}
% \end{BNVS.test}
%
% \begin{variable}{\c__bnvs_A_SP_Z_regex}
% Matches the whole string.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_SP_Z_regex {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{itemize}
% \item[1:] The full match,
% \item[2:] the frame \KWNmeta{id}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \A ( \ur{c__bnvs_short_regex} | [-+]? \d+ )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item[3:] The dotted path.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  ( (?: \. \ur{c__bnvs_short_regex} | \. [-+]? \d+ )* ) \Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{itemize}
% \begin{BNVS.test}{banner=A_SP_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_SP_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{}} {1}
% \BNVS_Test:nnn {_A1} {_A1,{}} {2}
% \BNVS_Test:nnn {A.1} {A,.1} {3}
% \BNVS_Test:nnn {_A1.1} {_A1,.1} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1,.1.2} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1,.1.2.n} {6}
% \BNVS_Test:nnn {1} {1,{}} {7}
% \BNVS_Test:nnn {1.2} {1,.2} {8}
% \BNVS_Test:nnn {1.2.3} {1,.2.3} {9}
% \BNVS_Test:nnn {1.B.C} {1,.B.C} {10}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1,.1.2.n} {16}
% \BNVS_Test:nnn {A.n} {A,.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1,.n} {2'}
% \BNVS_Test:nnn {A.1.n} { A,.1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} { _A1,.1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} { _A1,.1.2.n} {5'}
% \BNVS_Test:nnn {1.n} {1,.n} {7'}
% \BNVS_Test:nnn {1.2.n} {1,.2.n} {8'}
% \BNVS_Test:nnn {1.2.3.n} {1,.2.3.n} {9'}
% \BNVS_Test:nnn {1.B.C.n} {1,.B.C.n} {10'}
% \end{BNVS.test}
%
% \begin{variable}{\c__bnvs_colons_regex}
% For ranges defined by a colon syntax.
% One catching group for more than one colon.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_colons_regex { :(:+)? }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{banner=colons_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn {
%   \BNVS_TEST_split:Nnnn \c__bnvs_colons_regex
% }
% \BNVS_Test:nnn { A:C } {{A},{},{C}} {1}
% \BNVS_Test:nnn { A::C } {{A},{:},{C}} {2}
% \BNVS_Test:nnn { A:::C } {{A},{::},{C}} {3}
% \BNVS_Test:nnn { :B::C } {{},{},{B},{:},{C}} {4}
% \end{BNVS.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 12 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{BNVS.macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
% \begin{myList}
% \item[1] incrementation prefix
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \+\+
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{myList}
%   \item[1.1:] optional identifier: optional \meta{\textsl{frame id}}
%   \item[1.2:] followed by required |!|
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    (?: ( \ur{c__bnvs_short_regex} )? (!) )?
%    \end{macrocode}
% \end{BNVS.macrocode}
%   \item[1.3:] \KWNmeta{short name}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_short_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
%   \item[1.4:] optionally followed by a dotted path with a heading dot
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:Nn=\c__bnvs_split_regex{/:}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{},{}} { 1|2|3-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_TEST_A_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_TEST_A_tl
% }
% \BNVS_Test:nnnn { ++ABC } {} {{},{},{ABC},{}} {a'}
% \BNVS_Test:nnnn { ++ABC.1.2~~ }  {} {{},{},{ABC},{.1.2}} {b'}
% \BNVS_Test:nnnn { ++!ABC }       {} {{},{!},{ABC},{}} {c'}
% \BNVS_Test:nnnn { ++!ABC.1.2~~ } {} {{},{!},{ABC},{.1.2}} {d'}
% \BNVS_Test:nnnn { ++!ABC.1.2~X~ } {++!ABC.1.2~} {{},{!},{ABC},{.1.2}} {e'}
% \BNVS_Test:nnnn { ++X!ABC } {} {{X},{!},{ABC},{}} {c''}
% \BNVS_Test:nnnn { ++X!ABC.1.2~~ } {} {{X},{!},{ABC},{.1.2}} {d''}
% \BNVS_Test:nnnn { ++X!ABC.1.2~X~ } {++X!ABC.1.2~} {{X},{!},{ABC},{.1.2}} {e''}
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \__bnvs:nnnn
% \end{BNVS.test}
% \end{myList}
% \item[2:] without incement prefix
% \begin{myList}
%   \item[2.1:] optional \meta{\textsl{frame id}} followed by
%   \item[2.2:] required |!|
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    | (?: ( \ur{c__bnvs_short_regex} )? (!) )?
%    \end{macrocode}
% \end{BNVS.macrocode}
%   \item[2.3:] \KWNmeta{short name}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      ( \ur{c__bnvs_short_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
%   \item[2.4:] optionally followed by a dotted path
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:Nn=\c__bnvs_split_regex{/:}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},{},#3,{},{},{}} { 4|5|6-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_TEST_A_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_TEST_A_tl
% }
% \BNVS_Test:nnnn { ABC } {} {{},{},{ABC},{}} { a }
% \BNVS_Test:nnnn { ABC~~ } {} {{},{},{ABC},{}} { b }
% \BNVS_Test:nnnn { ABC.1.2 } {} {{},{},{ABC},{.1.2}} { c }
% \BNVS_Test:nnnn { ABC.1.2~~ } {} {{},{},{ABC},{.1.2}} { d }
% \BNVS_Test:nnnn { !ABC } {} {{},{!},{ABC},{}} { a' }
% \BNVS_Test:nnnn { !ABC~~ } {} {{},{!},{ABC},{}} { b' }
% \BNVS_Test:nnnn { !ABC.1.2 } {} {{},{!},{ABC},{.1.2}} { c' }
% \BNVS_Test:nnnn { !ABC.1.2~~ } {} {{},{!},{ABC},{.1.2}} { d' }
% \BNVS_Test:nnnn { ID!ABC } {} {{ID},{!},{ABC},{}} { a'' }
% \BNVS_Test:nnnn { ID!ABC~~ } {} {{ID},{!},{ABC},{}} { b'' }
% \BNVS_Test:nnnn { ID!ABC.1.2 } {} {{ID},{!},{ABC},{.1.2}} { c'' }
% \BNVS_Test:nnnn { ID!ABC.1.2~~ } {} {{ID},{!},{ABC},{.1.2}} { d'' }
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \__bnvs_:nnnn
% \end{BNVS.test}
% We continue with other expressions
%   \item[2.5:] the `|+|' in `|+=|' versus standalone `|=|'.
%   \item[2.6:] the poor man integer expression after `|+?=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    (?: \s* (\+?)= \s* ( \S+ )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{banner={\token_to_str:N\c__bnvs_split_regex/=}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { `='~#4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},{},#3,{} } { `+'-9-#4~(+=) } 
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_TEST_A_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_TEST_A_tl { #3, {}, #4 }
% }
% \BNVS_Test:nnnnn { ABC = 421 } {} {{}, {}, {ABC}, {}} {421} {1}
% \BNVS_Test:nnnnn { ABC = 1+P.1 } {} {{}, {}, {ABC}, {}} {1+P.1} {2}
% \BNVS_Test:nnnnn { ABC = 1+P.1~X } { ABC = 1+P.1~ } {{}, {}, {ABC}, {}} {1+P.1} {3}
% \BNVS_Test:nnnnn { ABC = (P.1+1)~~^^A(
% ) } { ABC = (P.1+1)~~ } {{}, {}, {ABC}, {}} {(P.1+1)} {4}
% \BNVS_Test:nnnnn { !ABC = 421 } {} {{}, {!}, {ABC}, {}} {421} {1'}
% \BNVS_Test:nnnnn { !ABC = 1+P.1 } {} {{}, {!}, {ABC}, {}} {1+P.1} {2'}
% \BNVS_Test:nnnnn { !ABC = 1+P.1~X } { !ABC = 1+P.1~ } {{}, {!}, {ABC}, {}} {1+P.1} {3'}
% \BNVS_Test:nnnnn { !ABC = (P.1+1)~~^^A(
% ) } { !ABC = (P.1+1)~~ } {{}, {!}, {ABC}, {}} {(P.1+1)} {4'}
% \BNVS_Test:nnnnn { ID!ABC = 421 } {} {{ID}, {!}, {ABC}, {}} {421} {1'}
% \BNVS_Test:nnnnn { ID!ABC = 1+P.1 } {} {{ID}, {!}, {ABC}, {}} {1+P.1} {2'}
% \BNVS_Test:nnnnn { ID!ABC = 1+P.1~X } { ID!ABC = 1+P.1~ } {{ID}, {!}, {ABC}, {}} {1+P.1} {3'}
% \BNVS_Test:nnnnn { ID!ABC = (P.1+1)~~^^A(
% ) } { ID!ABC = (P.1+1)~~ } {{ID}, {!}, {ABC}, {}} {(P.1+1)} {4'}
% \cs_undefine:N \BNVS_Test:nnnnn
% \cs_undefine:N \__bnvs_:nnnn
% \end{BNVS.test}
% \begin{BNVS.test}{banner={\token_to_str:N\c__bnvs_split_regex/+=}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { `+='~#4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},{},#3,{} } { `+'-9-#4~(+=) } 
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_TEST_A_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_TEST_A_tl { #3, {}, {+}, #4 }
% }
% \BNVS_Test:nnnnn { ABC += 421 } {} {{}, {}, {ABC}} {421} {1}
% \BNVS_Test:nnnnn { ABC += 1+P.1 } {} {{}, {}, {ABC}} {1+P.1} {2}
% \BNVS_Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{}, {}, {ABC}} {1+P.1} {3}
% \BNVS_Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{}, {}, {ABC}} {(P.1+1)} {4}
% \BNVS_Test:nnnnn { !ABC += 421 } {} {{}, {!}, {ABC}} {421} {1'}
% \BNVS_Test:nnnnn { !ABC += 1+P.1 } {} {{}, {!}, {ABC}} {1+P.1} {2'}
% \BNVS_Test:nnnnn { !ABC += 1+P.1~X } { !ABC += 1+P.1~ } {{}, {!}, {ABC}} {1+P.1} {3'}
% \BNVS_Test:nnnnn { !ABC += (P.1+1)~~^^A(
% ) } { !ABC += (P.1+1)~~ } {{}, {!}, {ABC}} {(P.1+1)} {4'}
% \BNVS_Test:nnnnn { ID!ABC += 421 } {} {{ID}, {!}, {ABC}} {421} {1''}
% \BNVS_Test:nnnnn { ID!ABC += 1+P.1 } {} {{ID}, {!}, {ABC}} {1+P.1} {2''}
% \BNVS_Test:nnnnn { ID!ABC += 1+P.1~X } { ID!ABC += 1+P.1~ } {{ID}, {!}, {ABC}} {1+P.1} {3''}
% \BNVS_Test:nnnnn { ID!ABC += (P.1+1)~~^^A(
% ) } { ID!ABC += (P.1+1)~~ } {{ID}, {!}, {ABC}} {(P.1+1)} {4''}
% \cs_undefine:N \BNVS_Test:nnnnn
% \cs_undefine:N \__bnvs_:nnnn
% \end{BNVS.test}
%   \item[2.7:] the post increment
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    | (\+)\+
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:Nn=\c__bnvs_split_regex{/:...++}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},{},#3,{},{},{+}} { 9-#4~(...++) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_TEST_A_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_TEST_A_tl
% }
% \BNVS_Test:nnnn { ABC++ } {} {{},{},{ABC},{}} { a }
% \BNVS_Test:nnnn { ABC.1.2++ } {} {{},{},{ABC},{.1.2}} {b}
% \BNVS_Test:nnnn { ABC++~~ } {} {{},{},{ABC},{}} { c }
% \BNVS_Test:nnnn { ABC.1.2++~~ } {} {{},{},{ABC},{.1.2}} {d}
% \BNVS_Test:nnnn { ABC++~~X~ } { ABC++~~ } {{},{},{ABC},{}} { e }
% \BNVS_Test:nnnn { ABC.1.2++~~X~ } { ABC.1.2++~~ } {{},{},{ABC},{.1.2}} {f}
% \BNVS_Test:nnnn { !ABC++ } {} {{},{!},{ABC},{}} { a' }
% \BNVS_Test:nnnn { !ABC.1.2++ } {} {{},{!},{ABC},{.1.2}} {b'}
% \BNVS_Test:nnnn { !ABC++~~ } {} {{},{!},{ABC},{}} { c' }
% \BNVS_Test:nnnn { !ABC.1.2++~~ } {} {{},{!},{ABC},{.1.2}} {d'}
% \BNVS_Test:nnnn { !ABC++~~X~ } { !ABC++~~ } {{},{!},{ABC},{}} { e' }
% \BNVS_Test:nnnn { !ABC.1.2++~~X~ } { !ABC.1.2++~~ } {{},{!},{ABC},{.1.2}} {f'}
% \BNVS_Test:nnnn { ID!ABC++ } {} {{ID},{!},{ABC},{}} { a'' }
% \BNVS_Test:nnnn { ID!ABC.1.2++ } {} {{ID},{!},{ABC},{.1.2}} {b''}
% \BNVS_Test:nnnn { ID!ABC++~~ } {} {{ID},{!},{ABC},{}} { c'' }
% \BNVS_Test:nnnn { ID!ABC.1.2++~~ } {} {{ID},{!},{ABC},{.1.2}} {d''}
% \BNVS_Test:nnnn { ID!ABC++~~X~ } { ID!ABC++~~ } {{ID},{!},{ABC},{}} { e'' }
% \BNVS_Test:nnnn { ID!ABC.1.2++~~X~ } { ID!ABC.1.2++~~ } {{ID},{!},{ABC},{.1.2}} {f''}
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \__bnvs_:nnnn
% \end{BNVS.test}
% \end{myList}
% \end{myList}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    )?
  ) \s*
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\c__bnvs_split_regex/split, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%     { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},{},/2 } { split-#3 }
% }
% \BNVS_Test:nnn { ++A }     {{}, {}, {A},{}}   { 1-a }
% \BNVS_Test:nnn { ++!A }    {{}, {!},{A},{}}   { 1-b }
% \BNVS_Test:nnn { ++X!A }   {{X},{!},{A},{}}   { 1-b' }
% \BNVS_Test:nnn { ++A.3 }   {{}, {}, {A},{.3}} { 1-c }
% \BNVS_Test:nnn { ++!A.3 }  {{}, {!},{A},{.3}} { 1-d }
% \BNVS_Test:nnn { ++!A.3 }  {{}, {!},{A},{.3}} { 1-d' }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,{},{},{},{},#2,/2 } { split-#3 }
% }
% \BNVS_Test:nnn { A              } {{ },{ },{A},{  },{},{},{}} { 2-a }
% \BNVS_Test:nnn { !A             } {{ },{!},{A},{  },{},{},{}} { 2-c }
% \BNVS_Test:nnn { X!A            } {{X},{!},{A},{  },{},{},{}} { 2-c' }
% \BNVS_Test:nnn { A.3            } {{ },{ },{A},{.3},{},{},{}} { 2-e }
% \BNVS_Test:nnn { !A.3           } {{ },{!},{A},{.3},{},{},{}} { 2-g }
% \BNVS_Test:nnn { X!A.3          } {{X},{!},{A},{.3},{},{},{}} { 2-g' }
% \BNVS_Test:nnn { A++            } {{ },{ },{A},{  },{},{},{+}} { 3-a }
% \BNVS_Test:nnn { !A++           } {{ },{!},{A},{  },{},{},{+}} { 3-c }
% \BNVS_Test:nnn { X!A++          } {{X},{!},{A},{  },{},{},{+}} { 3-c' }
% \BNVS_Test:nnn { A.3++          } {{ },{ },{A},{.3},{},{},{+}} { 3-e }
% \BNVS_Test:nnn { A.3.n++        } {{ },{ },{A},{.3.n},{},{},{+}} { 3-f }
% \BNVS_Test:nnn { !A.3++         } {{ },{!},{A},{.3},{},{},{+}} { 3-g }
% \BNVS_Test:nnn { X!A.3++        } {{X},{!},{A},{.3},{},{},{+}} { 3-g' }
% \BNVS_Test:nnn { !A.3.n++       } {{ },{!},{A},{.3.n},{},{},{+}} { 3-h }
% \BNVS_Test:nnn { X!A.3.n++      } {{X},{!},{A},{.3.n},{},{},{+}} { 3-h' }{},
% \BNVS_Test:nnn { A.length       } {{ },{ },{A},{.length},{},{},{}} { 4-a }
% \BNVS_Test:nnn { A.3.length     } {{ },{ },{A},{.3.length},{},{},{}} { 4-b }
% \BNVS_Test:nnn { !A.length      } {{ },{!},{A},{.length},{},{},{}} { 4-c }
% \BNVS_Test:nnn { X!A.length     } {{X},{!},{A},{.length},{},{},{}} { 4-c' }
% \BNVS_Test:nnn { !A.3.length    } {{ },{!},{A},{.3.length},{},{},{}} { 4-d }
% \BNVS_Test:nnn { X!A.3.length   } {{X},{!},{A},{.3.length},{},{},{}} { 4-d' }
% \BNVS_Test:nnn { A.first        } {{ },{ },{A},{.first},{},{},{}} { 5-a }
% \BNVS_Test:nnn { !A.first       } {{ },{!},{A},{.first},{},{},{}} { 5-b }{},
% \BNVS_Test:nnn { X!A.first      } {{X},{!},{A},{.first},{},{},{}} { 5-b' }
% \BNVS_Test:nnn { A.3.first      } {{ },{ },{A},{.3.first},{},{},{}} { 5-c }
% \BNVS_Test:nnn { !A.3.first     } {{ },{!},{A},{.3.first},{},{},{}} { 5-d }
% \BNVS_Test:nnn { X!A.3.first    } {{X},{!},{A},{.3.first},{},{},{}} { 5-d' }
% \BNVS_Test:nnn { A.last         } {{ },{ },{A},{.last},{},{},{}} { 6-a }
% \BNVS_Test:nnn { !A.last        } {{ },{!},{A},{.last},{},{},{}} { 6-b }
% \BNVS_Test:nnn { X!A.last       } {{X},{!},{A},{.last},{},{},{}} { 6-b' }
% \BNVS_Test:nnn { A.3.last       } {{ },{ },{A},{.3.last},{},{},{}} { 6-c }
% \BNVS_Test:nnn { !A.3.last      } {{ },{!},{A},{.3.last},{},{},{}} { 6-d }
% \BNVS_Test:nnn { X!A.3.last     } {{X},{!},{A},{.3.last},{},{},{}} { 6-d' }
% \BNVS_Test:nnn { A.previous     } {{ },{ },{A},{.previous},{},{},{}} { 7-a }
% \BNVS_Test:nnn { !A.previous    } {{ },{!},{A},{.previous},{},{},{}} { 7-b }
% \BNVS_Test:nnn { X!A.previous   } {{X},{!},{A},{.previous},{},{},{}} { 7-b' }
% \BNVS_Test:nnn { A.3.previous   } {{ },{ },{A},{.3.previous},{},{},{}} { 7-c }
% \BNVS_Test:nnn { !A.3.previous  } {{ },{!},{A},{.3.previous},{},{},{}} { 7-d }
% \BNVS_Test:nnn { X!A.3.previous } {{X},{!},{A},{.3.previous},{},{},{}} { 7-d' }
% \BNVS_Test:nnn { A.next         } {{ },{ },{A},{.next},{},{},{}} { 8-a }
% \BNVS_Test:nnn { !A.next        } {{ },{!},{A},{.next},{},{},{}} { 8-b }
% \BNVS_Test:nnn { X!A.next       } {{X},{!},{A},{.next},{},{},{}} { 8-b' }
% \BNVS_Test:nnn { A.3.next       } {{ },{ },{A},{.3.next},{},{},{}} { 8-c }
% \BNVS_Test:nnn { !A.3.next      } {{ },{!},{A},{.3.next},{},{},{}} { 8-d }
% \BNVS_Test:nnn { X!A.3.next     } {{X},{!},{A},{.3.next},{},{},{}} { 8-d' }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\c__bnvs_split_regex{...=...}, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%  { 1/#1~1/2 } { 1/,{},{},{},{},#2,1/2 } { split-#3 }
% }
% \BNVS_Test:nnn { A=42 }  {{},{},{A},{},{ },{42},{}} { a }
% \BNVS_Test:nnn { A+=42 } {{},{},{A},{},{+},{42},{}} { b }
% \BNVS_Test:nnn { !A=42 }  {{},{!},{A},{},{},{42},{}} { a' }
% \BNVS_Test:nnn { !A+=42 } {{},{!},{A},{},{+},{42},{}} { b' }
% \BNVS_Test:nnn { X!A=42 }  {{X},{!},{A},{},{ },{42},{}} { a'' }
% \BNVS_Test:nnn { X!A+=42 } {{X},{!},{A},{},{+},{42},{}} { b'' }
% \cs_undefine:N \BNVS_Test:nnn
% \end{BNVS.test}
% \end{variable}
%
% \subsection{\pkg{beamer.cls} interface}
% Work in progress.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\RequirePackage{keyval}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l__bnvs_id_last_tl { #1 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_KEY} {}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\AddToHook{env/beamer@frameslide/before}{
  \__bnvs_greset_call:
  \__bnvs_v_gunset:
  \__bnvs_set_true:c { in_frame }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\AddToHook{env/beamer@frameslide/after}{
  \__bnvs_set_false:c { in_frame }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{Defining named slide ranges}
%
% \begin{function}[TF]{\__bnvs_range_if_set:cccn}
%   \begin{syntax}
%     \cs{__bnvs_range_if_set:cccnTF} \marg{\textsl{core first}} \marg{\textsl{core end}} \marg{\textsl{core length}} \KWNmarg{tl} \KWNmarg{yes code} \KWNmarg{no code}
%   \end{syntax}
% Parse \meta{tl} as a range according to \cs{c__bnvs_colons_regex} and set the variables accordingly.
% \meta{tl} is expected to only contain colons and integers.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { split_if_pop_left:c } #1 { T, F, TF } {
  \__bnvs_seq_pop_left:ccTF { split } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn s { } { split_if_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:nc s { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn s { } { split_if_pop_left:cTF } { ...FALSE }
\BNVS_DEBUG_log_seq:nc s { split }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_if_pop_left:cTn } #1 #2 #3 {
  \__bnvs_split_if_pop_left:cTF { #1 } { #2 } { \BNVS_split_F:n { #3 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_if_pop_left_or:cT } #1 #2 {
  \__bnvs_split_if_pop_left:cTF { #1 } { #2 } { \BNVS_split_F:n { #1 } }
}
%    \end{macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVV }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { range_if_set:cccn } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn r { range_if_set:cccnTF } {
  \BNVS_DEBUG_log_tl:nc r { #1 }
  \BNVS_DEBUG_log_tl:nc r { #2 }
  \BNVS_DEBUG_log_tl:nc r { #3 }
  \BNVS_DEBUG_log_arg:nnn r { IN } { #4 }
  \BNVS_DEBUG_log_g:nn r {}
}
\BNVS_DEBUG_log_range_if_set_cccnTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { range_if_set:cccnTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c A
  \__bnvs_tl_clear:c Z
  \__bnvs_tl_clear:c L
  \__bnvs_if_regex_split:cnTF { colons } { #4 } {
    \__bnvs_seq_pop_left:ccTF { split } A {
%    \end{macrocode}
% \end{BNVS.macrocode}
% |A| may contain the \KWNmeta{first}, possibly empty, kept arround.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_split_if_pop_left:cTF Z {
        \__bnvs_tl_if_empty:cTF Z {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a one colon \texttt{\KWNmeta{A}:[\^{}:]*}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
          \__bnvs_split_if_pop_left:cTF Z {
            \__bnvs_split_if_pop_left:cT L {
%    \end{macrocode}
% \end{BNVS.macrocode}
% |Z| may contain the \KWNmeta{last} and there is more material.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
              \__bnvs_tl_if_empty:cTF L {
%    \end{macrocode}
% \end{BNVS.macrocode}
% A |::| was expected:
% \begin{BNVS.macrocode}
%    \begin{macrocode}
                \BNVS_error:n { Invalid~range~expression(1):~#4 }
              } {
                \int_compare:nNnT { \__bnvs_tl_count:c L } > { 1 } {
                  \BNVS_error:n { Invalid~range~expression(2):~#4 }
                }
                \__bnvs_split_if_pop_left:cTF L {
%    \end{macrocode}
% \end{BNVS.macrocode}
% |L| may contain the \KWNmeta{length}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
                  \__bnvs_seq_if_empty:cF { split } {
                    \BNVS_error:n { Invalid~range~expression(3):~#4 }
                  }
                } {
                  \BNVS_error:n { Unreachable~6~(range_if_set_cccnTF:nn) }
                }
              }
            }
          } {
            \BNVS_error:n { Unreachable~5~(range_if_set_cccnTF:nn) }
          }
        } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a two colons \texttt{\KWNmeta{A}::...},
% we expect a length.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
          \int_compare:nNnT { \__bnvs_tl_count:c Z } > { 1 } {
            \BNVS_error:n { Too~many~colons(1):~#4 }
          }
          \__bnvs_split_if_pop_left:cTF L {
%    \end{macrocode}
% \end{BNVS.macrocode}
% |L| may contain the \KWNmeta{length}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
            \__bnvs_split_if_pop_left:cTF Z {
              \__bnvs_tl_if_empty:cF Z {
                \BNVS_error:n { Too~many~colons(2):~#4 }
              }
              \__bnvs_split_if_pop_left:cTF Z {
%    \end{macrocode}
% \end{BNVS.macrocode}
% |Z| may contain the \KWNmeta{last}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
                \__bnvs_seq_if_empty:cF { split } {
                  \BNVS_error:n { Invalid~range~expression(5):~#4 }
                }
              } {
                \BNVS_error:n { Invalid~range~expression(6):~#4 }
              }
            } {
              \__bnvs_tl_clear:c Z
            }
          } {
            \BNVS_error:n { Unreachable~3~(range_if_set_cccnTF:nn) }
          }
        }
      } {
        \BNVS_error:n { Unreachable~2~(range_if_set_cccnTF:nn) }
      }
    } {
      \BNVS_error:n { Unreachable~1~(range_if_set_cccnTF:nn) }
    }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Providing both the \KWNmeta{first}, \KWNmeta{last}
% and \KWNmeta{length} of a range is not allowed,
% even if they happen to be consistent.
% If there is not enough information, use 1 as \KWNmeta{first}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_tl_if_empty:cT A {
      \__bnvs_tl_if_empty:cTF Z {
        \__bnvs_tl_if_empty:cTF L {
          \BNVS_error:n { Invalid~range~expression(7):~#3 }
        } {
          \__bnvs_tl_set:cn A 1
        }
      } {
        \__bnvs_tl_if_empty:cT L {
          \__bnvs_tl_set:cn A 1
        }
      }
    }
    \cs_set:Npn \BNVS_range_if_set_cccnTF:w ##1 ##2 ##3 {
      \BNVS_end:
      \__bnvs_tl_set:cn { #1 } { ##1 }
      \__bnvs_tl_set:cn { #2 } { ##2 }
      \__bnvs_tl_set:cn { #3 } { ##3 }
    }
    \BNVS_exp_args:Nvvv \BNVS_range_if_set_cccnTF:w A Z L
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_range_if_set_cccnTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_range_if_set:cccnTF, noigre}
% \__bnvs_range_if_set:cccnTF { TEST_A } { TEST_B } { TEST_C } { 1:2 } {} {}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_clear:c { TEST_A }
%   \__bnvs_tl_clear:c { TEST_B }
%   \__bnvs_tl_clear:c { TEST_C }
%   \BNVS_use:c { range_if_set:cccn#1 } { TEST_A } { TEST_B } { TEST_C } { #2 }
% }
% \BNVS_Test:nn { TF } { } { \test_fail:n { A } } { }
% \BNVS_Test:nn { T  } { } { \test_fail:n { A } }
% \BNVS_Test:nn {  F } { }                          { }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \__bnvs_tl_if_eq:cnTF { TEST_A } { #1 } {
%     \__bnvs_tl_if_eq:cnTF { TEST_B } { #2 } {
%       \__bnvs_tl_if_eq:cnF { TEST_C } { #3 } {
%         \test_fail:n { #4/c }
%       }
%     } {
%       \test_fail:n { #4/b }
%     }
%   } {
%     \test_fail:n { #4/a }
%   }
% }
% \BNVS_Test:nnnn {} {} { } { X }
% \__bnvs_range_if_set:cccnTF { TEST_A } { TEST_B } { TEST_C } { 1:2 } {} {}
% \BNVS_Test:nn { TF } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } } { \test_fail:n { B/a } }
% \BNVS_Test:nn { T  } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } }
% \BNVS_Test:nn {  F } { 1:2 }     { \test_fail:n { #4/a } }
% \BNVS_Test:nn { TF } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } } { \test_fail:n { C/a } }
% \BNVS_Test:nn { T  } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn {  F } { 1::3 }     { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn { TF } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } } { \test_fail:n { D/a } }
% \BNVS_Test:nn { T  } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } }
% \BNVS_Test:nn {  F } { :2::3 }     { \test_fail:n { #4/a } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \BNVS_Test:nnnn
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \begin{function}{
%   \__bnvs_parse_I:nn,
%   \__bnvs_parse_I:nv,
%   \__bnvs_parsed_IT:n,
% }
%   \begin{syntax}
%     \cs{__bnvs_parse_I:nn} \KWNmarg{tag} \marg{\textsl{value}}
%     \cs{__bnvs_parsed_IT:n} \marg{\textsl{value}}
%   \end{syntax}
% Auxiliary function for \cs{__bnvs_parse:n} and \cs{__bnvs_parse:nn} below.
% If \meta{\textsl{value}} does not correspond to a range,
% the \texttt{V} key is used.
% The \texttt{_n} variant concerns the index counter.
% These are bottlenecks.
% \end{function}
% \begin{function}{
%   \__bnvs_range:nnnnn,
%   \__bnvs_range:nnvvv,
% }
%   \begin{syntax}
%     \cs{__bnvs_range:nnnnn} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{first} \KWNmarg{last} \KWNmarg{length}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { range:nnnnn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnn r { range:nnnnn } { #1 } { #2 }
\BNVS_DEBUG_log_range_nnnnn:nn { } { ... }
\BNVS_DEBUG_log_g:nn r {}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if:cTF { provide } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnnn:nn { ... } { ...PROVIDE... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_is_gset:nnnTF A { #1 } { #2 } {
      \use_none:nnn
    } {
      \__bnvs_is_gset:nnnTF Z { #1 } { #2 } {
        \use_none:nnn
      } {
        \__bnvs_is_gset:nnnTF L { #1 } { #2 } {
          \use_none:nnn
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnnn:nn { ... } { .../DO~RANGE(1) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \__bnvs_do_range:nnnnn { #1 } { #2 }
        }
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnnn:nn { ... } { .../DO~RANGE(2) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_do_range:nnnnn { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { range:nnvvv } #1 #2 {
  \BNVS_tl_use:nvvv {
     \__bnvs_range:nnnnn { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { do_range:nnnnn } #1 #2 #3 #4 #5 {
  \__bnvs_gunset_deep:nn { #1 } { #2 }
  \__bnvs_gunset:nn { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={range:nnnnn}, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \cs_set:Npn \BNVS_Test:wnnn ##1 ##2 ##3 ##4 {
%     \__bnvs_if_get:nnncTF { ##1 } { #1 } { #2 } { TEST } {
%       \assert_equal_tl:vxn { TEST } {
%         \tl_if_empty:nTF { ##3 } { ##2 } { ##3 } } {##4-!#1/##1}
%     } {
%       \tl_if_empty:nF { ##2 } { \test_fail:n { ##4-no-get-!#1/##1 } }
%     }
%   }
%   \cs_set:Npn \BNVS_Test:nnnn ##1 ##2 ##3 ##4 {
%     \__bnvs_range:nnnnn { #1 } { #2 } { ##1 } { ##2 } { ##3 }
%     \BNVS_Test:wnnn A { #3 } { #6 } {##4 }
%     \BNVS_Test:wnnn Z { #4 } { #7 } {##4 }
%     \BNVS_Test:wnnn L { #5 } { #8 } {##4 }
%   }
%   \__bnvs_provide_off:
%   \BNVS_Test:nnnn { #3 } { #4 } { #5 } { 1 }
%   \__bnvs_provide_on:
%   \BNVS_Test:nnnn {FIRST'} {LAST'} {LENGTH'} { 2 }
%   \BNVS_Test:nnnn {}       {LAST'} {LENGTH'} { 3 }
%   \BNVS_Test:nnnn {FIRST'} {LAST'} {}        { 4 }
%   \BNVS_Test:nnnn {FIRST'} {}      {LENGTH'} { 5 }
%   \BNVS_Test:nnnn {FIRST'} {}      {}        { 6 }
%   \BNVS_Test:nnnn {}       {LAST'} {}        { 7 }
%   \BNVS_Test:nnnn {}       {}      {LENGTH'} { 8 }
% }
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnnn {} { X } {     } {LAST} {      } { 1 } {} {}
% \BNVS_Test:nnnnnnnn {} { X } {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {     } {LAST} {      } { 1 } {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnnn {} { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \cs_undefine:N \BNVS_Test:nnnnnnnn
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \BNVS_Test:wnnn
% \end{BNVS.test}
%
% \begin{BNVS.test}{bnvs:c={range:nnvvv}, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \cs_set:Npn \BNVS_Test:wnnn ##1 ##2 ##3 ##4 {
%     \__bnvs_if_get:nnncTF { ##1 } { #1 } { #2 } { TEST } {
%       \assert_equal_tl:vxn { TEST } {
%         \tl_if_empty:nTF { ##3 } { ##2 } { ##3 } } {##4-!#1/##1}
%     } {
%       \tl_if_empty:nF { ##2 } {
%         \BNVS_DEBUG_log_g:nn D {}
%         \test_fail:n { ##4-no-get-!#1/##1 }
%       }
%     }
%   }
%   \cs_set:Npn \BNVS_Test:nnnn ##1 ##2 ##3 ##4 {
%     \__bnvs_tl_set:cn { TEST_A } { ##1 }
%     \__bnvs_tl_set:cn { TEST_B } { ##2 }
%     \__bnvs_tl_set:cn { TEST_C } { ##3 }
%     \__bnvs_range:nnvvv { #1 } { #2 } { TEST_A } { TEST_B } { TEST_C }
%     \BNVS_Test:wnnn A { #3 } { #6 } {##4 }
%     \BNVS_Test:wnnn Z { #4 } { #7 } {##4 }
%     \BNVS_Test:wnnn L { #5 } { #8 } {##4 }
%   }
%   \__bnvs_provide_off:
%   \BNVS_Test:nnnn { #3 } { #4 } { #5 } { 1 }
%   \__bnvs_provide_on:
%   \BNVS_Test:nnnn {FIRST'} {LAST'} {LENGTH'} { 2 }
%   \BNVS_Test:nnnn {}       {LAST'} {LENGTH'} { 3 }
%   \BNVS_Test:nnnn {FIRST'} {LAST'} {}        { 4 }
%   \BNVS_Test:nnnn {FIRST'} {}      {LENGTH'} { 5 }
%   \BNVS_Test:nnnn {FIRST'} {}      {}        { 6 }
%   \BNVS_Test:nnnn {}       {}      {LENGTH'} { 7 }
%   \BNVS_Test:nnnn {}       {LAST'} {}        { 8 }
% }
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnnn {} { X } {     } {LAST} {      } { 1 } {} {}
% \BNVS_Test:nnnnnnnn {} { X } {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnnn {} {X.1} {     } {LAST} {      } { 1 } {} {}
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnnn {} { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnnn {} { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \cs_undefine:N \BNVS_Test:nnnnnnnn
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \BNVS_Test:wnnn
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn r { do_range:nnnnn } {
  \BNVS_DEBUG_log_arg_IT:nnn r { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnnn
    r { FIRST } { #3 } { LAST } { #4 } { LENGTH } { #5 }
  \BNVS_DEBUG_log_g:nn r {}
}
\BNVS_DEBUG_log_do_range_nnnnn:nn {  } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #5 } {
    \tl_if_empty:nTF { #3 } {
      \tl_if_empty:nTF { #4 } {
        \BNVS_error:n { Not~a~range:~#1!#2 }
      } {
        \__bnvs_gset:nnnn Z { #1 } { #2 } { #4 }
        \__bnvs_gset:nnnn A { #1 } { #2 } {  1 }
        \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
      }
    } {
      \__bnvs_gset:nnnn A { #1 } { #2 } { #3 }
      \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
      \tl_if_empty:nF { #4 } {
        \__bnvs_gset:nnnn Z { #1 } { #2 } { #4 }
        \__bnvs_gset:nnnn L { #1 } { #2 } { \q_nil }
      }
    }
  } {
    \tl_if_empty:nTF { #3 } {
      \__bnvs_gset:nnnn L { #1 } { #2 } { #5 }
      \tl_if_empty:nF { #4 } {
        \__bnvs_gset:nnnn Z { #1 } { #2 } { #4 }
        \__bnvs_gset:nnnn A { #1 } { #2 } { \q_nil }
        \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
      }
    } {
      \__bnvs_gset:nnnn A { #1 } { #2 } { #3 }
      \__bnvs_gset:nnnn L { #1 } { #2 } { #5 }
      \__bnvs_gset:nnnn Z { #1 } { #2 } { \q_nil }
      \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
    }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_do_range_nnnnn:nn { ... } { ...DONE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { range_IT:vvv } {
  \__bnvs_range:nnvvv { id } { tag }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_parsed:nnn
% }
% \begin{syntax}
% \cs{__bnvs_parsed:nnn} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{one spec}
% \end{syntax}
% Sets the internal model for the given \KWNmeta{one spec},
% either a value or a range specification.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parsed:nnn } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn p { parsed:nnn } {
  \BNVS_DEBUG_log_arg:nnn p { ID } { #1 }
  \BNVS_DEBUG_log_arg:nnn p { TAG } { #2 }
  \BNVS_DEBUG_log_arg:nnn p { SPEC } { #3 }
}
\BNVS_DEBUG_log_parsed_nnn:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_range_if_set:cccnTF AZL { #3 } {
    \__bnvs_range:nnvvv { #1 } { #2 } AZL
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_parsed_nnn:nn { ... } { ...RANGE... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  } {
    \__bnvs_is_provide_gset:nvvF V { #1 } { #2 } {
      \__bnvs_gunset_deep:nn { #1 } { #2 }
      \__bnvs_gunset:nn { #1 } { #2 }
      \tl_if_empty:nF { #3 } {
        \__bnvs_gset:nnnn V { #1 } { #2 } { #3 }
      }
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_parsed_nnn:nn { ... } { ...VALUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_I:nv } #1 {
  \BNVS_tl_use:nv { \__bnvs_parse_I:nn { #1 } }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_ref:n,
%   \__bnvs_if_ref:nn,
%   \__bnvs_if_ref:vn,
%   \__bnvs_if_ref_relative:nn,
% }
% \begin{syntax}
% \cs{__bnvs_if_ref:nTF} \KWNmarg{name} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_ref:nnTF} \KWNmarg{root} \KWNmarg{relative} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_ref_relative:nnTF} \KWNmarg{root} \KWNmarg{relative} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% If \meta{\textsl{name}} is a reference,
% put the frame id it defines into |id|
% the short name into |short|,
% the dotted path into |path|,
% then execute \KWNmeta{yes code}.
% Otherwise execute \KWNmarg{no code}.
%
% The second version calls the first one with \meta{\textsl{name}} equals
% \KWNmeta{relative} prepended with \KWNmeta{root}.
%
% The third version accepts integers as \KWNmeta{relative} argument.
% It assumes that \KWNmeta{id}, \KWNmeta{short} and \KWNmeta{path} are
% already set. The \KWNmeta{path} and \KWNmeta{tag} are updated accordingly
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_ref:n } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn f { if_ref:nTF } {
  \BNVS_DEBUG_log_arg:nnn f { :n } { #1 }
  \BNVS_DEBUG_tl:nc f { id }
  \BNVS_DEBUG_tl:nc f { short }
  \BNVS_DEBUG_tl:nc f { path }
  \BNVS_DEBUG_tl:nc f { tag }
  \BNVS_DEBUG_tl:nc f { n }
  \BNVS_DEBUG_bool:nc f { n }
  \BNVS_DEBUG_tl:nc f { id_last }
}
  \BNVS_DEBUG_log_if_ref_nTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_ref:nTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NnTF \c__bnvs_A_ISP_Z_regex { #1 } {
    \__bnvs_if_match_pop_left:cTF { n } {
      \__bnvs_if_match_pop_left:cTF { id } {
        \__bnvs_if_match_pop_left:cTF { kri } {
          \__bnvs_if_match_pop_left:cTF { short } {
            \__bnvs_if_match_pop_left:cTF { path } {
              \cs_set:Npn \BNVS_aux_if_ref_nTF:nnn ##1 ##2 ##3 {
                \BNVS_end:
                \__bnvs_tl_set:cn { id } { ##1 }
                \__bnvs_tl_set:cn { short } { ##2 }
                \__bnvs_tl_set:cn { path } { ##3 }
              }
              \__bnvs_tl_if_empty:cTF { kri } {
                \BNVS_exp_args:Nvvv
                \BNVS_aux_if_ref_nTF:nnn
                  { id_last }
              } {
                \BNVS_exp_args:Nvvv
                \BNVS_aux_if_ref_nTF:nnn
                  { id }
              } { short } { path }
              \__bnvs_tl_set:cv { tag } { path }
              \__bnvs_tl_put_left:cv { tag } { short }
              \__bnvs_tl_set:cv { id_last } { id }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_ref_nTF:nn { } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
              \prg_return_true:
            } {
              \BNVS_end_unreachable_return_false:n { A_ISP_Z/path }
            }
          } {
            \BNVS_end_unreachable_return_false:n  { A_ISP_Z/short }
          }
        } {
          \BNVS_end_unreachable_return_false:n  { A_ISP_Z/kri }
        }
      } {
        \BNVS_end_unreachable_return_false:n  { A_ISP_Z/id }
      }      
    } {
      \BNVS_end_unreachable_return_false:n  { A_ISP_Z/full_match }
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_ref_nTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_ref_relative:nn } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn f { if_ref_relative:nnTF } {
  \BNVS_DEBUG_log_arg:nnn f { :n  } { #1 }
  \BNVS_DEBUG_log_arg:nnn f { ::n } { #2 }
  \BNVS_DEBUG_tl:nc f { id }
  \BNVS_DEBUG_tl:nc f { short }
  \BNVS_DEBUG_tl:nc f { path }
  \BNVS_DEBUG_tl:nc f { tag }
  \BNVS_DEBUG_tl:nc f { n }
  \BNVS_DEBUG_bool:nc f { n }
  \BNVS_DEBUG_tl:nc f { id_last }
}
  \BNVS_DEBUG_log_if_ref_relative_nnTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_ref_relative:nnTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NnTF \c__bnvs_A_SP_Z_regex { #2 } {
    \__bnvs_if_match_pop_left:cTF { n } {
      \__bnvs_if_match_pop_left:cTF { short } {
        \__bnvs_if_match_pop_left:cTF { path } {
          \cs_set:Npn \BNVS_aux_if_ref_nTF:nn ##1 ##2 {
            \BNVS_end:
            \__bnvs_tl_put_right:cn { path } { . ##1 ##2 }
          }
          \BNVS_exp_args:Nvv
          \BNVS_aux_if_ref_nTF:nn { short } { path }
          \__bnvs_tl_set:cv { tag } { path }
          \__bnvs_tl_put_left:cv { tag } { short }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_ref_relative_nnTF:nn { } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
          \BNVS_end_unreachable_return_false:n { A_SP_Z/path }
        }
      } {
        \BNVS_end_unreachable_return_false:n  { A_SP_Z/short }
      }
    } {
      \BNVS_end_unreachable_return_false:n  { A_SP_Z/full_match }
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_ref_relative_nnTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_ref:nn } #1 #2 { T, F, TF } {
  \tl_if_empty:nTF { #1 } {
    \__bnvs_if_ref:nTF { #2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \__bnvs_if_ref_relative:nnTF { #1 } { #2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_ref:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_ref:nnTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_ref:nTF, noigre}
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_if_ref:nTF { #1 } {
%     \assert_equal_tl:vnn { id } { #2 } { #5-id }
%     \assert_equal_tl:vnn { short } { #3 } { #5-short }
%     \assert_equal_tl:vnn { path } { #4 } { #5-path }
%   } {
%     \test_fail:n { FAIL }
%   }
% }
% \BNVS_Test:nnnnn { X       } {   } { X } {    } { 1 }
% \BNVS_Test:nnnnn { X.1     } {   } { X } { .1 } { 2 }
% \BNVS_Test:nnnnn { F!X     } { F } { X } {    } { 3 }
% \BNVS_Test:nnnnn { X       } { F } { X } {    } { 4 }
% \BNVS_Test:nnnnn { G!X     } { G } { X } {    } { 5 }
% \BNVS_Test:nnnnn { Y!X.1   } { Y } { X } { .1 } { 6 }
% \BNVS_Test:nnnnn { !X      } {   } { X } {    } { 7 }
% \cs_undefine:N \BNVS_Test:nnnnn
% \__bnvs_if_ref:nT { !!X.1 } {
%   \test_fail:n { FAIL(bid) }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_if_ref:nTF, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnn #1 #2 #3 #4 #5 #6 {
%   \banner:n { #6 }
%   \__bnvs_if_ref:nTF { #1 } {
%     \assert_equal_tl:vnn { id    } { #2 } { #6-id }
%     \assert_equal_tl:vnn { short } { #3 } { #6-short }
%     \assert_equal_tl:vnn { path  } { #4 } { #6-path }
%     \assert_equal_tl:vnn { n     } { #5 } { #6-n }
%   } {
%     \test_fail:n { FAIL }
%   }
% }
% \BNVS_Test:nnnnnn { X       } {   } { X } {    } {    } { 1 }
% \BNVS_Test:nnnnnn { X.1     } {   } { X } { .1 } {    } { 2 }
% \BNVS_begin:
% \BNVS_Test:nnnnnn { F!X     } { F } { X } {    } {    } { 3 }
% \BNVS_Test:nnnnnn { X       } { F } { X } {    } {    } { 4 }
% \BNVS_end:
% \BNVS_Test:nnnnnn { X       } {   } { X } {    } {    } { 4' }
% \cs_undefine:N \BNVS_Test:nnnnnn
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_if_ref:nTF, noigre}
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_if_ref:nTF { #1 } {
%     \assert_equal_tl:vnn { id  } { #2 } { #5-id }
%     \assert_equal_tl:vnn { tag } { #3 } { #5-name }
%     \assert_equal_tl:vnn { n   } { #4 } { #5-n }
%   } {
%     \test_fail:n { FAIL }
%   }
% }
% \BNVS_Test:nnnnn { X       } {   } { X   } {    } { 1 }
% \BNVS_Test:nnnnn { X.1     } {   } { X.1 } {    } { 2 }
% \BNVS_Test:nnnnn { F!X     } { F } { X   } {    } { 3 }
% \BNVS_Test:nnnnn { X       } { F } { X   } {    } { 4 }
% \BNVS_Test:nnnnn { G!X     } { G } { X   } {    } { 5 }
% \BNVS_Test:nnnnn { Y!X.1   } { Y } { X.1 } {    } { 6 }
% \BNVS_Test:nnnnn { !X      } {   } { X   } {    } { 7 }
% \cs_undefine:N \BNVS_Test:nnnnn
% \end{BNVS.test}
% \begin{variable}{\c__bnvs_A_cln_Z_regex}
% Used to parse named overlay specifications.
% V, A:Z, A::L on one side, :Z, :Z::L and ::L:Z on the other sides.
% Next are the capture groups. The first one is for the whole match.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{myList}
% \item 2 $\to$ V
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    ( [^:]+? )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item 3, 4, 5 $\to$ A : Z? or A :: L?
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    | (?: ( [^:]+? ) \s* : (?: \s* ( [^:]*? ) | : \s* ( [^:]*? ) ) )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item 6, 7 $\to$ ::(L:Z)?
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    | (?: :: \s* (?: ( [^:]+? ) \s* : \s* ( [^:]+? ) )? )
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item 8, 9 $\to$ :(Z::L)?
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    | (?: : \s* (?: ( [^:]+? ) \s* :: \s* ( [^:]*? ) )? )
  )
  \s* \Z
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{myList}
% \begin{BNVS.test}{:N=\c__bnvs_A_cln_Z_regex, noigre}
% \Test_regex:nnnn { A_cln_Z } {V           } {{},{V},{ },{ },{ },{ },{ },{ },{ }} {1}
% \Test_regex:nnnn { A_cln_Z } {VV          } {{},{VV},{ },{ },{ },{ },{ },{ },{ }} {1a}
% \Test_regex:nnnn { A_cln_Z } {A:Z         } {{},{ },{A},{Z},{ },{ },{ },{ },{ }} {2}
% \Test_regex:nnnn { A_cln_Z } {AA:ZZ       } {{},{ },{AA},{ZZ},{ },{ },{ },{ },{ }} {2a}
% \Test_regex:nnnn { A_cln_Z } {~AA:ZZ      } {{},{ },{AA},{ZZ},{ },{ },{ },{ },{ }} {2b}
% \Test_regex:nnnn { A_cln_Z } {A:          } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3}
% \Test_regex:nnnn { A_cln_Z } {~A:         } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3a}
% \Test_regex:nnnn { A_cln_Z } {~AA:        } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {3b}
% \Test_regex:nnnn { A_cln_Z } {A::L        } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4}
% \Test_regex:nnnn { A_cln_Z } {~A::L       } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4a}
% \Test_regex:nnnn { A_cln_Z } {~AA::L      } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4b}
% \Test_regex:nnnn { A_cln_Z } {~AA~::L     } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4d}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~L    } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4e}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~LL   } {{},{ },{AA},{ },{LL},{ },{ },{ },{ }} {4f}
% \Test_regex:nnnn { A_cln_Z } {A::         } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5}
% \Test_regex:nnnn { A_cln_Z } {~A::        } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5a}
% \Test_regex:nnnn { A_cln_Z } {~AA::       } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5b}
% \Test_regex:nnnn { A_cln_Z } {~AA~::      } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5d}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~     } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5e}
% \Test_regex:nnnn { A_cln_Z } {::L:Z       } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6}
% \Test_regex:nnnn { A_cln_Z } {~::L:Z      } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6a}
% \Test_regex:nnnn { A_cln_Z } {~::~L:Z     } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6b}
% \Test_regex:nnnn { A_cln_Z } {~::~LL:Z    } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6c}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:Z   } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6e}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:~Z  } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6f}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:~ZZ} {{},{ },{ },{ },{ },{LL},{ZZ},{ },{ }} {6g}
% \Test_regex:nnnn { A_cln_Z } {::          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7}
% \Test_regex:nnnn { A_cln_Z } {~::         } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7a}
% \Test_regex:nnnn { A_cln_Z } {~::~        } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7b}
% \Test_regex:nnnn { A_cln_Z } {:Z::L       } {{},{ },{ },{ },{ },{ },{ },{Z},{L}} {8}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::L      } {{},{ },{ },{ },{ },{ },{ },{ZZ},{L}} {8a}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::LL     } {{},{ },{ },{ },{ },{ },{ },{ZZ},{LL}} {8b}
%\Test_regex:nnnn { A_cln_Z } {:Z::         } {{},{ },{ },{ },{ },{ },{ },{Z},{ }} {9}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::       } {{},{ },{ },{ },{ },{ },{ },{ZZ},{ }} {9a}
% \Test_regex:nnnn { A_cln_Z } {:           } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10}
% \Test_regex:nnnn { A_cln_Z } {~:          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10a}
% \Test_regex:nnnn { A_cln_Z } {:~          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10b}
% \Test_regex:nnnn { A_cln_Z } {~:~         } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10c}
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_int_new:c { next_IT }
\BNVS_tl_new:c { next_IT }
\BNVS_new:cpn { next_IT: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_int:nnc p { Start~index: } { next_IT }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_int_incr:c { next_IT }
  \__bnvs_tl_set_eq:cc { next_IT } { tag }
  \__bnvs_tl_put_right:cn { next_IT } { . }
  \BNVS_int_use:nv { \__bnvs_tl_put_right:cn { next_IT } } { next_IT }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_is_gset:nvvT V { id } { next_IT } { \__bnvs_next_IT: }
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
%<*!final>
  \__bnvs_is_gset:nvvTF V { id } { next_IT } { \__bnvs_next_IT: } {
\BNVS_DEBUG_log_int:nnc p { Available~index: } { next_IT }
\BNVS_DEBUG_log_tl:nc p { next_IT }
  }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:c={next_IT:}, noigre}
% \__bnvs_tl_set:cn { id } { ID }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_int_set:cn { next_IT } { 21 }
% \__bnvs_int_incr:c { next_IT }
% \assert_equal_int:vnn { next_IT } { 22 } { 0 }
% \__bnvs_next_IT:
% \assert_equal_int:vnn { next_IT } { 23 } { 1 }
% \__bnvs_gset:nnnn V { ID } { TAG.24 } { }
% \assert_equal_int:vnn { next_IT } { 23 } { 1-a }
% \__bnvs_next_IT:
% \assert_equal_int:vnn { next_IT } { 25 } { 2 }
% \__bnvs_gset:nnnn V { ID } { TAG.26 } { }
% \__bnvs_gset:nnnn V { ID } { TAG.27 } { }
% \__bnvs_next_IT:
% \assert_equal_int:vnn { next_IT } { 28 } { 3 }
% \tl_map_inline:nn { 467 } {
%   \__bnvs_gunset:nnn V { ID } { TAG.2#1 }
% }
% \end{BNVS.test}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { next_IT:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*debug>
  \BNVS_DEBUG_begin:n { next_IT:n }
%</debug>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_next_IT:
  \__bnvs_tl_put_right:cn { tag } { . }
  \BNVS_int_use:nv { \__bnvs_tl_put_right:cn { tag } } { next_IT }
  #1
  \BNVS_end_int_set:cv { next_IT } { next_IT }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={next_IT:n}, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_next_IT:n {
%   \assert_equal_tl:vnn { id  } { ID    } { 1-id }
%   \assert_equal_tl:vnn { tag } { TAG.1 } { 1-tag }
% }
% \assert_equal_int:vnn { next_IT } { 1 } { 1-next_IT }
% \__bnvs_next_IT:n {
%   \assert_equal_tl:vnn { id  } { ID    } { 2-id }
%   \assert_equal_tl:vnn { tag } { TAG.2 } { 2-tag }
% }
% \assert_equal_int:vnn { next_IT } { 2 } { 2-next_IT }
% \__bnvs_gset:nnnn V { ID  } { TAG.3 } { FOO }
% \__bnvs_next_IT:n {
%   \assert_equal_tl:vnn { id  } { ID    } { 4-id }
%   \assert_equal_tl:vnn { tag } { TAG.4 } { 4-tag }
% }
% \assert_equal_int:vnn { next_IT } { 4 } { 4-next_IT }
% \__bnvs_gunset_deep:nn { ID  } { TAG }
% \__bnvs_gunset:nn { ID  } { TAG }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \subsubsection{Square brackets}
% See section \ref{section:ValueSpecifiers}.
% \begin{function}{
%   \__bnvs_bracket_parse_IT:n,
%   \__bnvs_bracket_parse_IT:nn,
%   \__bnvs_bracket_keyval_IT:n,
% }
%   \begin{syntax}
%     \cs{__bnvs_bracket_keyval_IT:n} \marg{\textsl{definitions}}
%     \cs{__bnvs_bracket_parse_IT:nn} \KWNmarg{name} \KWNmarg{spec}
%     \cs{__bnvs_bracket_parse_IT:n} \KWNmarg{spec}
%   \end{syntax}
% To parse what is inside square brackets.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { bracket_assign:nnn } #1 #2 #3 {
  \__bnvs_gunset_deep:nn { #1 } { #2 }
  \__bnvs_gunset:nn { #1 } { #2 }
  \tl_if_empty:nF { #3 } {
    \__bnvs_gset:nnnn V { #1 } { #2 } { #3 }
  }
}
\BNVS_new:cpn { bracket_assign_I:cn } {
  \BNVS_tl_use:Nvv  \__bnvs_bracket_assign:nnn { id }
}
\BNVS_new:cpn { bracket_assign_IT:n } {
  \__bnvs_bracket_assign_I:cn { tag }
}
\BNVS_tl_new:c { bracket_assign_IT_nn }
\BNVS_new:cpn { bracket_assign_IT:nn } #1 {
  \__bnvs_tl_set_eq:cc { bracket_assign_IT_nn } { tag }
  \__bnvs_tl_put_right:cn { bracket_assign_IT_nn } { .#1 }
  \__bnvs_bracket_assign_I:cn { bracket_assign_IT_nn }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ bracket_assign_IT:nn }, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_if_get:nnncT V { ID  } { TAG.421 } { ans } {
%   \test_fail:n { A }
% }
% \__bnvs_bracket_assign_IT:nn { 421 } { FOO }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID  } { TAG.421 } { ans } {
%   \assert_equal_ans:nn { FOO } { B }
% } {
%   \test_fail:n { C }
% }
% \__bnvs_gunset_deep:nn { ID  } { TAG }
% \__bnvs_if_get:nnncT V { ID  } { TAG.421 } { ans } {
%   \test_fail:n { D }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { bracket_parse_IT:nn } #1 #2 {
  \__bnvs_match_if_once:NnTF \c__bnvs_colons_regex { #2 } {
    \BNVS_error:n { No~colon~allowed:~[...=#2...]}
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnnn p { bracket_parse_IT:nn } { :n } { #1 } { :nn } { #2 }
\BNVS_DEBUG_log_bracket_parse_IT_nn:nn { } { ... }
%</!final>
%% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_match_if_once:NnTF \c__bnvs_A_integer_Z_regex { #1 } {
      \__bnvs_bracket_assign_IT:nn {#1 } { #2 }
    } {
      \BNVS_error:n { Not~an~integer:~#1 }
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_bracket_parse_IT_nn:nn { ... } { ...DONE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ bracket_parse_IT:nn }, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncT V { ID  } { TAG.421 } { ans } {
%   \test_fail:n { A }
% }
% \__bnvs_bracket_parse_IT:nn { 421 } { FOO }
% \__bnvs_if_get:nnncTF V { ID  } { TAG.421 } { ans } {
%   \assert_equal_ans:nn { FOO } { B }
% } {
%   \test_fail:n { C }
% }
% \__bnvs_tl_clear:c { ans }
% \cs_set:Npn \BNVS_error:n { \__bnvs_tl_set:cn { ans } }
% \__bnvs_bracket_parse_IT:nn { 421 } { F:OO }
% \BNVS_tl_use:Nv \tl_if_in:nnF { ans } { allowed } {
%   \test_fail:n { D }
% }
% \__bnvs_bracket_parse_IT:nn { 4x1 } { FOO }
% \BNVS_tl_use:nv \tl_if_in:nnF { ans } { integer } {
%   \test_fail:n { E }
% }
% \__bnvs_gunset:nn { ID  } { TAG }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { bracket_parse_IT:n } #1 {
  \__bnvs_match_if_once:NnTF \c__bnvs_colons_regex { #1 } {
    \BNVS_error:n { No~colon~allowed:~[...#1...] }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnn p { bracket_parse_IT:n } { :n } { #1 }
\BNVS_DEBUG_log_bracket_parse_IT_n:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% Find the first available index.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_next_IT:n { \__bnvs_bracket_assign_IT:n { #1 } }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_bracket_parse_IT_n:nn { ... } { ...DONE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ bracket_parse_IT:n }, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncT V { ID  } { TAG.421 } { ans } {
%   \test_fail:n { A }
% }
% \__bnvs_bracket_parse_IT:nn { 421 } { FOO }
% \__bnvs_if_get:nnncTF V { ID  } { TAG.421 } { ans } {
%   \assert_equal_ans:nn { FOO } { B }
% } {
%   \test_fail:n { C }
% }
% \__bnvs_tl_clear:c { ans }
% \cs_set:Npn \BNVS_error:n { \__bnvs_tl_set:cn { ans } }
% \__bnvs_bracket_parse_IT:nn { 421 } { F:OO }
% \BNVS_tl_use:nv \tl_if_empty:nT { ans } {
%   \test_fail:n { D }
% }
% \__bnvs_gunset:nn { ID  } { TAG }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% For \mintinline{latex}{X=[...]}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { bracket_keyval_IT:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnn p { bracket_keyval_IT:n } { :n } { #1 }
\BNVS_DEBUG_log_bracket_keyval_IT_n:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% The |root| tl variable is set and not empty.
% Remove what is related to |tag|.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_tl_if_empty:cTF { tag } {
    \BNVS_error:n { Unexpected~list~at~top~level. }
  } {
    \__bnvs_is_provide_gset:nvvF V { id } { tag } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
      \BNVS_DEBUG_begin:n { bracket_keyval_IT:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_gunset_deep:vv { id } { tag }
      \__bnvs_gunset:vv { id } { tag }
      \__bnvs_int_zero:c { next_IT }
      \keyval_parse:nnn
        \__bnvs_bracket_parse_IT:n \__bnvs_bracket_parse_IT:nn { #1 } 
      \BNVS_end:
    }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_bracket_keyval_IT_n:nn { } { ...DONE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c=bracket_keyval_IT:n, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_bracket_keyval_IT:n { FOO }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.1 } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_gunset:nn { ID } { TAG.1 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=bracket_keyval_IT:n, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_bracket_keyval_IT:n { FOO, CHI, MEE }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.1 } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.2 } { ans } {
%   \assert_equal_ans:nn { CHI } { A' }
% } {
%   \test_fail:n { B' }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.3 } { ans } {
%   \assert_equal_ans:nn { MEE } { A'' }
% } {
%   \test_fail:n { B'' }
% }
% \__bnvs_if_get:nnncT V { ID } { TAG.4 } { ans } {
%   \test_fail:n { C }
% }
% \__bnvs_gunset_deep:nn { ID } { TAG }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=bracket_keyval_IT:n, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_bracket_keyval_IT:n { FOO, CHI, MEE }
% \__bnvs_bracket_keyval_IT:n { FOO, CHI }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.1 } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.2 } { ans } {
%   \assert_equal_ans:nn { CHI } { A' }
% } {
%   \test_fail:n { B' }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncT V { ID } { TAG.3 } { ans } {
%   \test_fail:n { C }
% }
% \__bnvs_gunset_deep:nn { ID } { TAG }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=bracket_keyval_IT:n, noigre}
% \__bnvs_tl_set:cn { id  } { ID  }
% \__bnvs_tl_set:cn { tag } { TAG }
% \__bnvs_bracket_keyval_IT:n { 2=CHI, FOO, MEE }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.1 } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.2 } { ans } {
%   \assert_equal_ans:nn { CHI } { A' }
% } {
%   \test_fail:n { B' }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { ID } { TAG.3 } { ans } {
%   \assert_equal_ans:nn { MEE } { A'' }
% } {
%   \test_fail:n { B'' }
% }
% \__bnvs_if_get:nnncT V { ID } { TAG.4 } { ans } {
%   \test_fail:n { C }
% }
% \__bnvs_gunset_deep:nn { ID } { TAG }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \subsubsection{Root level}
% \begin{function}{
%   \__bnvs_root_parse:n,
%   \__bnvs_root_parse:nn,
%   \__bnvs_root_keyval:n,
% }
%   \begin{syntax}
%     \cs{__bnvs_root_keyval:n} \marg{\textsl{definitions}}
%     \cs{__bnvs_root_parse:nn} \KWNmarg{name} \KWNmarg{spec}
%     \cs{__bnvs_root_parse:n} \KWNmarg{name}
%   \end{syntax}
% To parse what is at the root level.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { root_parse:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\__bnvs_tl_if_empty:cTF { root } {
\BNVS_DEBUG_log:nn p  { root_parse:n... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NnTF \c__bnvs_A_IKT_Z_regex { #1 } {
    \__bnvs_if_match_pop_left:cTF { a } {
      \__bnvs_if_match_pop_left:cTF { id } {
        \__bnvs_if_match_pop_left:cTF { kri } {
          \__bnvs_if_match_pop_left:cTF { tag } {
            \__bnvs_tl_if_empty:cTF { kri } {
              \__bnvs_tl_set_eq:cc { id } { id_last }
            } {
              \__bnvs_tl_set_eq:cc { id_last } { id }
            }
            \__bnvs_is_provide_gset:nvvF V { id } { tag } {
              \__bnvs_gunset_deep:vv { id } { tag }
              \__bnvs_gunset:vv { id } { tag }
              \__bnvs_gset:nvvn V { id } { tag } { 1 }
            }
%    \end{macrocode}
% \begin{BNVS.test}{}
% \end{BNVS.test}
%    \begin{macrocode}
          } {
            \BNVS_error:n { Unreachable~3 }
          }
        } {
          \BNVS_error:n { Unreachable~2 }
        }
      } {
        \BNVS_error:n { Unreachable~1 }
      }
    } {
      \BNVS_error:n { Unreachable~0 }
    }
  } {
    \BNVS_error:n { Unexpected~ref:~#1}
  }
  %    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p  { root_parse:n~...END }
} {
  \BNVS_error:n { Not~at~root}
}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={ root_parse:n }, noigre}
% \__bnvs_tl_set:cn { root } { ROOT }
% \__bnvs_tl_clear:c { ans }
% \cs_set:Npn \BNVS_error:n {
%   \__bnvs_tl_set:cn { ans }
% }
% \__bnvs_root_parse:n {}
% \BNVS_tl_use:Nv \tl_if_in:nnF { ans } { root } {
%   \test_fail:n { A }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={ root_parse:n }, noigre}
% \__bnvs_tl_clear:c { root }
% \__bnvs_root_parse:n { A }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { 1 } { A }
% } {
%   \test_fail:n { B }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={ root_parse:n }, noigre}
% \__bnvs_tl_clear:c { root }
% \__bnvs_provide_on:
% \__bnvs_gset:nnnn V {} A { FOO }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_root_parse:n { A }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { root_parse:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\__bnvs_tl_if_empty:cTF { root } {
\BNVS_DEBUG_log:nn p  { root_parse:nn }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NnTF \c__bnvs_A_IKT_Z_regex { #1 } {
    \__bnvs_if_match_pop_left:cTF { a } {
      \__bnvs_if_match_pop_left:cTF { id } {
        \__bnvs_if_match_pop_left:cTF { kri } {
          \__bnvs_if_match_pop_left:cTF { tag } {
            \__bnvs_tl_if_empty:cTF { kri } {
              \__bnvs_tl_set_eq:cc { id } { id_last }
            } {
              \__bnvs_tl_set_eq:cc { id_last } { id }
            }
            \__bnvs_is_provide_gset:nvvF V { id } { tag } {
              \__bnvs_gunset_deep:vv { id } { tag }
              \__bnvs_gunset:vv { id } { tag }
              \__bnvs_parsed_IT:n { #2 }
            } 
          } {
            \BNVS_error:n { Unreachable~3 }
          }
        } {
          \BNVS_error:n { Unreachable~2 }
        }
      } {
        \BNVS_error:n { Unreachable~1 }
      }
    } {
      \BNVS_error:n { Unreachable~0 }
    }
  } {
    \BNVS_error:n { Unexpected~ref:~#1}
  }
  %    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
} {
  \BNVS_error:n { Not~at~root}
}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:c={ root_parse:nn }, noigre}
% \__bnvs_tl_set:cn { root } { ROOT }
% \__bnvs_tl_clear:c { ans }
% \cs_set:Npn \BNVS_error:n {
%   \__bnvs_tl_set:cn { ans }
% }
% \__bnvs_root_parse:nn {} {}
% \BNVS_tl_use:Nv \tl_if_in:nnF { ans } { root } {
%   \test_fail:n { A }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={ root_parse:nn }, noigre}
% \__bnvs_tl_clear:c { root }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_root_parse:nn { A } { 421 }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { 421 } { A }
% } {
%   \test_fail:n { B }
% }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c={ root_parse:nn }, noigre}
% \__bnvs_tl_clear:c { root }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_provide_on:
% \__bnvs_root_parse:nn { A } { FOO }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_root_parse:nn { A } { BAR }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_get:nnncTF V { } { A } { ans } {
%   \assert_equal_ans:nn { FOO } { A }
% } {
%   \test_fail:n { B }
% }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { root_keyval:n } #1 {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a list, possibly at the top
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p  { root_keyval:n }
  \BNVS_DEBUG_begin:n { root_keyval:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \keyval_parse:nnn \BNVS_root_parse:n \BNVS_root_parse:nn { #1 }
  \BNVS_end:
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a list, possibly at the top
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p  { root_keyval:n ~END}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{variable}{\l__bnvs_match_seq}
% Local storage for the match result.
% \end{variable}
% The |a| tl auxiliary variable is used.
% \begin{variable}{\c__bnvs_one_suffix_regex}
% To catch the suffix |1| or |first|.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_one_suffix_regex { \A(.*)\.(?:1|first)\Z }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \subsubsection{List specifiers}
% \label{implementation/section:ListSpecifiers}
% Here is the \hyperref[section:ListSpecifiers]{documentation}.
% For \texttt{\KWNmeta{ref}=\KWNmeta{spec}}.
% \begin{function}{
%   \__bnvs_list_keyval_IT:n,
% }
%   \begin{syntax}
%     \cs{__bnvs_list_keyval_IT:n} \KWNmarg{definitions}
%   \end{syntax}
% Auxiliary functions called within a group by |\keyval_parse:nnn|.
% \KWNmeta{name} is the overlay set name, 
% including eventually a dotted path or a frame identifier,
% \KWNmeta{definition} is the corresponding definition.
% The |id| and |tag| |tl| variables are set beforehands.
% \end{function}
% We parse all at once, then manage what is parsed.
% We could avoid a grouping level.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { list_keyval_IT:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn p  {} { list_keyval_IT:n} { ... }
  \BNVS_DEBUG_begin:n { list_keyval_IT:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { V }
  \__bnvs_tl_clear:c { a }
  \cs_set:Npn \BNVS: {
    \cs_set:Npn \BNVS:n ####1 {
      \__bnvs_tl_put_right:cn { a } { \BNVS:n { ####1 } }
    }
    \cs_set:Npn \BNVS:nn ####1 ####2 {
      \__bnvs_tl_put_right:cn { a } { \BNVS:nn { ####1 } { ####2 } }
    }
  }
  \cs_set:Npn \BNVS:n {
    \BNVS:
    \__bnvs_tl_set:cn { V }
  }
  \cs_set:Npn \BNVS:nn {
    \BNVS:
    \BNVS:nn
  }
  \keyval_parse:nnn \BNVS:n \BNVS:nn { #1 }
  \__bnvs_tl_if_empty:cTF { a } {
    \__bnvs_tl_if_empty:cTF { V } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn p  {} { list_keyval_IT:n} { ...~END(EMPTY) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    } {
      \BNVS_tl_use:nv { \__bnvs_range_if_set:cccnTF A Z L } V {
      } {
        \__bnvs_is_provide_gset:nvvF V { id } { tag } {
          \__bnvs_gunset_deep:vv { id } { tag }
          \__bnvs_gunset:vv { id } { tag }
          \__bnvs_gset:nvvv V { id } { tag } V
        }
      }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn p  {} { list_keyval_IT:n} { ...~END(SINGLE) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    }
%    \end{macrocode}
% \end{BNVS.macrocode}
% A single value or range specification.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn p  {} { list_keyval_IT:n} { ...~END(non~VOID) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  }
  \BNVS_end:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_brace_parse:n,
%   \__bnvs_brace_parse:nn,
% }
%   \begin{syntax}
%     \cs{__bnvs_brace_parse:nn} \KWNmarg{name} \KWNmarg{spec}
%     \cs{__bnvs_brace_parse:n} \KWNmarg{named}
%   \end{syntax}
% Auxiliary functions called within a group by |\keyval:nnn|.
% \meta{\textsl{name}} is the overlay set name, 
% including eventually a dotted path or a frame identifier,
% \KWNmeta{definition} is the corresponding definition.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\exp_args_generate:n { nne }
\exp_args_generate:n { nnne }
\BNVS_new:cpn { brace_parse:n } #1 {
%    \end{macrocode}
% \end{BNVS.macrocode}
% For \mintinline{latex}{X={{...,Y,...}}}.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnn p { brace_parse:n } { NORD } { #1 }
\BNVS_DEBUG_log_brace_parse_n:nn { } { ... }
\BNVS_DEBUG_log_tl:nc p { id }
\BNVS_DEBUG_log_tl:nc p { tag }
\BNVS_DEBUG_log_tl:nc p { root }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_range_if_set:cccnTF A Z L { #1 } {
    \__bnvs_int_zero:c { next_IT }
    \__bnvs_next_IT:n {s
      \__bnvs_set_true:c { deep }
      \BNVS_log_tl:c A
      \BNVS_log_tl:c Z
      \BNVS_log_tl:c L
      \typein { F00000000-#1 }
      \BNVS_int_use:Nv \__bnvs_parsed:nn { next_IT } { #1 }
    }
  } {
    \typein { F000000-#1 }
    \__bnvs_set_true:c { deep }
    \__bnvs_parsed:nn { #1 } { 1 }
    \typein { F000000-#1 }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_brace_parse_n:nn { ... } { ...DONE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { brace_parse:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: p => parse
%<*!final>
\BNVS_DEBUG_log_set:ncnnnn p { brace_parse:nn } { NAME } { #1 } { DEF } { #2 }
\BNVS_DEBUG_log_brace_parse_nn:nn { } { ... }
\BNVS_DEBUG_log_tl:nc p { root }
  \BNVS_DEBUG_begin:n { brace_parse:nn }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% We prepend the argument with |root|, in case we are recursive.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_if_ref:vnTF { root } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
%\cs_set:Npn \BNVS[]:w { \BNVS[]:w }
\BNVS_DEBUG_log_brace_parse_nn:nn { ... } { ...START... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \exp_args:Nc
    \peek_meaning:NTF { BNVS[]:w } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a \texttt{X=[...]} list, for an indexed list of range specification.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p      { brace_parse:nn(X=[...]) }
      \BNVS_DEBUG_begin:n { brace_parse:nn(X=[...]) }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% We will prepend the argument with |root|, in case we are recursive.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \cs_set:cpn { BNVS[]:w } ##1 ##2 \s_stop {
        \regex_match:nnT { \S } { ##2 } {
          \BNVS_warning:n { Ignoring~##2 }
        }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
        \BNVS_DEBUG_log:nn p { BNVS[]:w }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={brace_parse:nn}{/[]}, ignore}
% \BNVS_DEBUG_push:n { pD }
% \__bnvs_brace_parse:nn { X } { 123 }
% \BNVS_DEBUG_log_g:nn D {}
% \typein { F00000 }
% \__bnvs_if_get:nnncTF V { } { X } { TEST_A } {
%   \assert_equal_tl:vnn { TEST_A } { 123 } { 1 }
% } {
%   \test_fail:n { MISSING~KEY~!X/V }
% }
% \__bnvs_parsed:nn { X } { }
% \BNVS_DEBUG_log_g:nn D {}
% \typein { F00000 }
% \__bnvs_if_get:nnncT V { } { X } { TEST_A } {
%   \test_fail:n { UNEXPECTED~KEY~!X/V }
% }
% \end{BNVS.test}
%    \begin{macrocode}
        \__bnvs_bracket_keyval_IT:n { ##1 }
        \BNVS_end:
      }
    } {
      \peek_meaning:NTF \s_stop: {
        \use_none:n
      } {
        \BNVS_use:c { X={...}:w }
      }
    }
    #2 \s_stop
  } {
    \BNVS_error:n { Invalid~name:~#2 }
  }
%    \end{macrocode}
% \end{BNVS.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_match_if_once:NvT \c__bnvs_one_suffix_regex { tag } {
    \__bnvs_if_match_pop_left:cTF { a } {
      \__bnvs_if_match_pop_left:cTF { a } {
        \cs_set:Npn \BNVS_aux_parsed_nn: {
          \__bnvs_gset:nvvn V { id } { a } { #2 }
        }
        \__bnvs_if_get:nvvcT V { id } { a } { b } {
          \__bnvs_quark_if_nil:cF { b } {
            \cs_set:Npn \BNVS_aux_parsed_nn: { }
          }
        }
        \BNVS_aux_parsed_nn:
      } {
        \BNVS_error:n { Unreachable~2 }
      }
    } {
      \BNVS_error:n { Unreachable~1 }
    }
  }
%    \end{macrocode}
% \end{BNVS.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_brace_parse_nn:nn { ... } { ...END }
\BNVS_DEBUG_log_tl:nc p { id }
\BNVS_DEBUG_log_tl:nc p { tag }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_end_tl_set:cv { id_last } { id_last }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:cn={parse:nn}{/...=...,...}, ignore}
% \Beanoves{X,Y=2,Z}
% \Test_if_resolve:nnnn { } { X } { 1 } { A }
% \Test_if_resolve:nnnn { } { Z } { 1 } { B }
% \end{BNVS.test}
% \end{BNVS.macrocode}




% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_exp_args:NNcv #1 #2 #3 #4 {
  \BNVS_tl_use:nc { \exp_args:NNnV #1 #2 { #3 } }
    { #4 }
}
%    \end{macrocode}
% \begin{BNVS.test}{:N=\BNVS_exp_args:NNcv, ignore}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \cs_set:Npn \BNVS_Test:cnn  #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { #2 } {
%     \test_fail:n { #3 }
%   }
% }
% \BNVS_exp_args:NNcv \relax \BNVS_Test:cnn { A } { TEST_A } { A }
% \cs_undefine:N \BNVS_Test:cnn
% \end{BNVS.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_set:cv #1 {
  \BNVS_tl_use:nv {
    \BNVS_end: \__bnvs_tl_set:cn { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_int_set:cv #1 {
  \BNVS_int_use:nv {
    \BNVS_end: \__bnvs_int_set:cn { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% Helper for |\keyval_parse:nnn| used in \cs{Beanoves} command.
% We have three requirements:
% \begin{itemize}
% \item raw \pkg{beamer} lists \texttt{X=A} or \texttt{X=\{A,...\}},
% \item integer--value lists \texttt{X=[A,B]}.
% \item key--value lists \texttt{X=\{\{A,B\}\}},
% \end{itemize}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parsed:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: p => parse
%<*!final>
\BNVS_DEBUG_log_set:ncnnnn p { parsed:nn } { NAME } { #1 } { DEF } { #2 }
\BNVS_DEBUG_log_parsed_nn:nn { } { ... }
\BNVS_DEBUG_log_tl:nc p { root }
  \BNVS_DEBUG_begin:n { parsed:nn }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% We prepend the argument with |root|, in case we are recursive.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_if_ref:vnTF { root } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
%\cs_set:Npn \BNVS[]:w { \BNVS[]:w }
\BNVS_DEBUG_log_parsed_nn:nn { ... } { ...START... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \exp_args:Nc
    \peek_meaning:NTF { BNVS[]:w } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a \texttt{X=[...]} list, for an indexed list of range specification.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p      { parsed:nn(X=[...]) }
      \BNVS_DEBUG_begin:n { parsed:nn(X=[...]) }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% We will prepend the argument with |root|, in case we are recursive.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \cs_set:cpn { BNVS[]:w } ##1 ##2 \s_stop {
        \regex_match:nnT { \S } { ##2 } {
          \BNVS_warning:n { Ignoring~##2 }
        }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
        \BNVS_DEBUG_log:nn p { BNVS[]:w }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \__bnvs_bracket_keyval_IT:n { ##1 }
        \BNVS_end:
      }
    } {
      \peek_meaning:NTF \s_stop: {
        \use_none:n
      } {
        \BNVS_use:c { X={...}:w }      
      }
    }
    #2 \s_stop
  } {
    \BNVS_error:n { Invalid~name:~#2 }
  }
%    \end{macrocode}
% \end{BNVS.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_match_if_once:NvT \c__bnvs_one_suffix_regex { tag } {
    \__bnvs_if_match_pop_left:cTF { a } {
      \__bnvs_if_match_pop_left:cTF { a } {
        \cs_set:Npn \BNVS_aux_parsed_nn: {
          \__bnvs_gset:nvvn V { id } { a } { #2 }
        }
        \__bnvs_if_get:nvvcT V { id } { a } { b } {
          \__bnvs_quark_if_nil:cF { b } {
            \cs_set:Npn \BNVS_aux_parsed_nn: { }
          }
        }
        \BNVS_aux_parsed_nn:
      } {
        \BNVS_error:n { Unreachable~2 }
      }
    } {
      \BNVS_error:n { Unreachable~1 }
    }
  }
%    \end{macrocode}
% \end{BNVS.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_parsed_nn:nn { ... } { ...END }
\BNVS_DEBUG_log_tl:nc p { id }
\BNVS_DEBUG_log_tl:nc p { tag }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_end_tl_set:cv { id_last } { id_last }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { X={...}:w } #1 \s_stop {
  \__bnvs_gunset_deep:vv { id } { tag }
%    \end{macrocode}
% \end{BNVS.macrocode}
% A \texttt{X=\{...\}} list,
% for a \meta{\textsl{name}}--\KWNmeta{definition} dictionary.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn S {} { X={...}:w } { ... }
  \BNVS_DEBUG_begin:n { X={...}:w }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% Remove the elements that contain a |=|.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_tl_put_right:cv { root } { tag }
  \__bnvs_tl_put_right:cn { root } { . }
  \__bnvs_brace_keyval:n { #1 }
  \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:cn={parse:nn}{/A={}}, ignore}
% \Beanoves{A={1}}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_if_get:nnncTF V {} { #1 } { ans } {
%     \assert_equal_ans:nn  { #2 } { #1/V }
%   } {
%     \tl_if_empty:nF { #2 } { \test_fail:n { #1/¬V } }
%   }
% }
% \BNVS_Test:nn { A.1 } { 1 }
% \Beanoves{A={}}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_clear:c { ans }
%   \__bnvs_if_get:nnncTF V {} { #1 } { ans } {
%     \tl_if_empty:nT { #2 } { \test_fail:n { #1/V } }
%   } {
%     \assert_equal_ans:nn  { #2 } { #1/¬V }
%   }
% }
% \BNVS_Test:nn { A.1 } { }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={parse:nn}{/A={1, 2, 3}}, ignore}
% \Beanoves{A={1,2,3}}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_if_get:nnncTF V {} { #1 } { ans } {
%     \assert_equal_ans:nn  { #2 } { #1/V }
%   } {
%     \tl_if_empty:nF { #2 } { \test_fail:n { #1/¬V } }
%   }
% }
% \BNVS_Test:nn { A.1 } { 1 }
% \BNVS_Test:nn { A.2 } { 1 }
% \BNVS_Test:nn { A.3 } { 1 }
% \BNVS_Test:nn { A.4 } {   }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={parse:nn}{A={1, 2=22, 3}}, ignore}
% \Beanoves{A={1,2=22,3}}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_if_get:nnncTF V {} { #1 } { ans } {
%     \assert_equal_ans:nn  { #2 } { #1/V }
%   } {
%     \tl_if_empty:nF { #2 } { \test_fail:n { #1/¬V } }
%   }
% }
% \BNVS_Test:nn { A.1 } { 1  }
% \BNVS_Test:nn { A.2 } { 22 }
% \BNVS_Test:nn { A.3 } { 1  }
% \BNVS_Test:nn { A.4 } {    }
% \end{BNVS.test}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { X=...:n } #1 {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a \texttt{X=...}.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p  { X=...:n }
  \BNVS_DEBUG_begin:n { X=...:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c  { a }
  \__bnvs_seq_clear:c { a }
  \cs_set:Npn \BNVS_aux_parsed_nn:n ##1 {
    \__bnvs_tl_set:cn { a } { ##1 }
    \cs_set:Npn \BNVS_aux_parsed_nn:n ####1 {
      \__bnvs_seq_put_right:cn { a } { ####1 }
    }
  }
  \cs_set:Npn \BNVS_aux_parsed_nn:nn ##1 ##2 {
    \BNVS_warning:n { Ignored:~##1=##2 }
  }
  \keyval_parse:nnn \BNVS_aux_parsed_nn:n \BNVS_aux_parsed_nn:nn { #1 }
  \__bnvs_tl_if_empty:cTF { a } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Clean everything, whether in provide mode or not.
% \begin{BNVS.test}{bnvs:cn={parsed_IT[=...]:n}{/X=}, ignore}
% \Beanoves{X={1:2,3:4,5:6}}
% \BNVS_DEBUG_log_g:nn D { }
% \Test_if_resolve:nnnn {X={1:2,3:4,5:6}} { X } { 1 } { A }
% \Test_if_resolve:nnnn {X=} { X } { 0 } { B }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
   \__bnvs_gunset_deep:vv { id } { tag }
   \__bnvs_gunset:vv { id } { tag }
  } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The first definition.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \BNVS_tl_use:Nv \__bnvs_parsed_IT:n { a }
  }
  \BNVS_end:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_parsed_IT[=...]:n
% }
% \begin{syntax}
% \cs{__bnvs_parsed_IT[=...]:n}   \marg{definitions}
% \end{syntax}
% Used by \cs{__bnvs_parse:nn }.
% \KWNmeta{id} and \KWNmeta{tag} are set.
% Store the associate values.
% \meta{definitions} is a comma separated list of \KWNmeta{definition}'s,
% either for ranges or values.
% The first \KWNmeta{definition} is for the |V| and |AZL| keys.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parsed_IT[=...]:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
  \BNVS_DEBUG_begin:n { parsed_IT[=...]:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c  { a }
  \__bnvs_seq_clear:c { a }
  \cs_set:Npn \BNVS_aux_parsed_nn:n ##1 {
    \__bnvs_tl_set:cn { a } { ##1 }
    \cs_set:Npn \BNVS_aux_parsed_nn:n ##1 {
      \__bnvs_seq_put_right:cn { a } { ##1 }
    }
  }
  \cs_set:Npn \BNVS_aux_parsed_nn:nn ##1 ##2 {
    \BNVS_warning:n { Ignored:~##1=##2 }
  }
  \keyval_parse:nnn \BNVS_aux_parsed_nn:n \BNVS_aux_parsed_nn:nn { #1 }
  \__bnvs_tl_if_empty:cTF { a } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Clean everything, whether in provide mode or not.
% \begin{BNVS.test}{bnvs:cn={parsed_IT[=...]:n}{/X=}, ignore}
% \Test_if_resolve:nnnn {X={1:2,3:4,5:6}} { X } { 1 } { A }
% \Test_if_resolve:nnnn {X=} { X } { 0 } { B }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_gunset:vv { id } { tag }
  } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The first definition.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_seq_if_empty:cTF { a } {
      \BNVS_tl_use:Nv \__bnvs_parsed_IT:n { a }
    } {
      \__bnvs_int_zero:c { i }
      \__bnvs_seq_map_inline:cn { a } {
        \__bnvs_int_incr:c { i }
        {
          \__bnvs_tl_put_right:cn { tag } { . }
          \exp_args:Nnx \__bnvs_tl_put_right:cn { tag } {
            \__bnvs_int_use:c { i }
          }
          \__bnvs_parsed_IT:n { i }
        }
      }
    }
  }
  \BNVS_end:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:c={parse_nn}{/Automatic~counter}, ignore}
% \Test_if_resolve:nnnn { Z.1=421 } { Z } { 421 } { 1 }
% \end{BNVS.test}
% \begin{BNVS.test}{:N=\__bnvs_parse_prepare:N, ignore}
% \__bnvs_tl_set:cn { TEST_A } {A[B]C}
% \__bnvs_parse_prepare:N \l__bnvs_TEST_A_tl
% \assert_equal:xxn { \tl_to_str:V \l__bnvs_TEST_A_tl } { \tl_to_str:n { A \use:c { BNVS[]:w } {B} C } } {1}
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_prepare:N } #1 {
  \tl_set:Nx #1 #1
  \__bnvs_set_false:c { parse }
  \bool_do_until:Nn \l__bnvs_parse_bool {
    \tl_if_in:NnTF #1 {%---[
    ]} {
      \regex_replace_all:nnNF { \[ ([^\]%---)
      ]*%---[(
      ) \] } { \c{BNVS[]:w} { \1 } } #1 {
        \__bnvs_set_true:c { parse }
      }
    } {
      \__bnvs_set_true:c { parse }
    }
  }
  \tl_if_in:NnTF #1 {%---[
  ]} {
    \BNVS_error:n { Unbalanced~%---[
    ]}
  } {
    \tl_if_in:NnT #1 { [%---]
    } {
      \BNVS_error:n { Unbalanced~[ %---]
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_bracket_keyval_IT:n,
%   \__bnvs_brace_keyval:n,
% }
%   \begin{syntax}
%     \cs{__bnvs_bracket_keyval_IT:n} \marg{\textsl{definitions}}
%     \cs{__bnvs_brace_keyval:n} \marg{\textsl{definitions}}
%   \end{syntax}
% \end{function}
% At the top level, the \mintinline{latex}{Y}
% in \mintinline{latex}{X=123, Y, Z=456}
% or \mintinline{latex}{X={X=123, Y, Z=456}}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { brace_keyval:n } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn p { \__bnvs_brace_keyval:n }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \keyval_parse:nnn \__bnvs_brace_parse:n \__bnvs_brace_parse:nn
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key–value list}
%   \end{syntax}
%   The keys are the slide overlay references.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{\textsl{key–value}} items are parsed by \cs{__bnvs_parse:nn}.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_put_right:cv #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_gset:nnnv #1 #2 #3 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_gset:nnnn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
  \__bnvs_set_false:c { reset }
  \__bnvs_set_false:c { reset_all }
  \__bnvs_set_false:c { only }
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: B => top level API
%<*!final>
\BNVS_DEBUG_log:nx B { \token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_arg:nnn B { IN } { #2 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \seq_gput_right:Nn \g__bnvs_def_seq { #2 }
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% At the top level, clear everything.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_gunset:
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { Beanoves }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_tl_clear:c { root }
    \__bnvs_int_zero:c { i }
    \__bnvs_tl_set:cn { a } { #2 }
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% At the top level, use the global definitions.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \seq_if_empty:NF \g__bnvs_def_seq {
        \__bnvs_tl_put_left:cx { a } {
          \seq_use:Nn \g__bnvs_def_seq , ,
        }
      }
    }
    \__bnvs_parse_prepare:N \l__bnvs_a_tl
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx B { ...\token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_tl:nc B { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \IfBooleanTF {#1} {
      \__bnvs_provide_on:
    } {
      \__bnvs_provide_off:
    }
    \BNVS_tl_use:Nv \__bnvs_brace_keyval:n { a }
    \BNVS_end_tl_set:cv { id_last } { id_last }
    \ignorespaces
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \subsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\__bnvs@frame, \__bnvs@masterdecode}
% \begin{syntax}
% \cs{__bnvs@frame} \marg{overlay specification}
% \cs{__bnvs@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} reads it.
% \begin{variable}{\l__bnvs_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% 
% Save the original macros \cs{beamer@frame} and
% \cs{beamer@masterdecode} then override them
% to properly preprocess the argument.
% We start by defining the overloads.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\makeatletter
\cs_set:Npn \__bnvs@frame < #1 > {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
%<*!final>
  \BNVS_DEBUG_begin:n { bnvs@frame }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_if_resolve:ncTF { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn B { bnvs@frame:~#1 }
\BNVS_DEBUG_log_tl:nc B { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_set:cpn { :n } ##1 { \BNVS_end: \BNVS_saved@frame < ##1 > }
  \BNVS_tl_use:cv { :n } { ans }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_set:Npn \__bnvs@masterdecode #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
%<*!final>
  \BNVS_DEBUG_begin:n { bnvs@masterdecode }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_if_resolve_queries:ncTF { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn B { bnvs@masterdecode:~<#1> }
\BNVS_DEBUG_log_tl:nc B { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_tl_use:nv {
    \BNVS_end:
    \BNVS_saved@masterdecode
  } { ans }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BeanovesOff {
  \cs_set_eq:NN \beamer@frame \BNVS_saved@frame 
  \cs_set_eq:NN \beamer@masterdecode \BNVS_saved@masterdecode
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BeanovesOn {
  \cs_set_eq:NN \beamer@frame \__bnvs@frame
  \cs_set_eq:NN \beamer@masterdecode \__bnvs@masterdecode
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\AddToHook{begindocument/before}{
  \cs_if_exist:NTF \beamer@frame {
    \cs_set_eq:NN \BNVS_saved@frame \beamer@frame
    \cs_set_eq:NN \BNVS_saved@masterdecode \beamer@masterdecode
  } {
    \cs_set:Npn \BNVS_saved@frame < #1 > {
      \BNVS_error:n {Missing~package~beamer}
    }
    \cs_set:Npn \BNVS_saved@masterdecode < #1 > {
      \BNVS_error:n {Missing~package~beamer}
    }
  }
  \BeanovesOn
}
\makeatother
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{\__bnvs_scan:nNc}
% \begin{syntax}
% \cs{__bnvs_scan:nNc} \KWNmarg{overlay query} \KWNmeta{resolve} \KWNmarg{ans}
% \end{syntax}
% Scan the \meta{overlay query} argument and feed the \KWNmeta{ans} |tl| variable replacing |?(...)| instructions by their static counterpart
% with help from the \KWNmeta{resolve} function, which is \cs{__bnvs_if_resolve:ncTF}.
% A group is created to use local variables:
% \begin{variable}{\l__bnvs_ans_tl}
% The token list that will be appended to \meta{tl variable} on return.
% \end{variable}
% \begin{variable}{\l__bnvs_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l__bnvs_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l__bnvs_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l__bnvs_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
% \begin{function}[TF]{\__bnvs_scan:nNc}
% \begin{syntax}
% \cs{__bnvs_scan:nNcTF} \KWNmarg{overlay query} \KWNmeta{resolve} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% Next are helpers.
% \begin{function}{
%   \__bnvs_scan_for_query_then_end_return:
% }
% \begin{syntax}
% \cs{__bnvs_scan_for_query_then_end_return:}
% \end{syntax}
% At top level state, scan the tokens of the
% \meta{named overlay expression} looking for a `|?|' character.
% If a `|?(...)|' is found, then the \KWNmeta{code} is executed.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { scan_for_query_then_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: S => scan
%<*!final>
\BNVS_DEBUG_log_f:nncn S { } { scan_for_query_then_end_return: } { }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \__bnvs_tl_if_eq:cnTF { token } { ? } {
      \__bnvs_scan_require_open_end_return:
    } {
      \__bnvs_tl_put_right:cv { ans } { token }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_scan_for_query_then_end_return:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn S { end~of~query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_scan_end_return_true:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_scan_require_open_end_return:
% }
% \begin{syntax}
% \cs{__bnvs_scan_require_open_end_return:}
% \end{syntax}
% We just found a `|?|',
% we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
%
% \end{function}

%    \begin{macrocode}
\BNVS_new:cpn { scan_require_open_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn S { } { scan_require_open_end_return: } { }
%</!final>
% \end{BNVS.gobble}
% Get next token.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \str_if_eq:VnTF \l__bnvs_token_tl { ( %)
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Set the parenthesis depth to 1 (on first passage).
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_int_set:cn { } { 1 }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Record the forthcomming content in
% the \cs{l__bnvs_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_tl_clear:c { query }
      \__bnvs_scan_require_close_and_return:
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Ignore this token and loop.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_scan_require_open_end_return:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn S { } { scan_require_open_end_return: } { ...? }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% Get next token.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% \end{BNVS.macrocode}
% End reached but no opening parenthesis found, raise.
% As this is a standalone raising |?|, this is not a fatal error.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \BNVS_error:x {Missing~'('%---)
      ~after~a~? }
    \__bnvs_scan_end_return_true:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:cn={scan:nNc}{...?}, ignore}
% \tl_gclear:N \g__bnvs_TEST_tl
% \cs_set:Npn \BNVS_error:x #1 {
%   \tl_gset:Nn \g__bnvs_TEST_tl { SUCCESS }
% }
% \cs_set:Npn \BNVS_TEST_resolve:ncTF #1 #2 #3 #4 {
%   \tl_if_empty:nTF { #1 } {
%     #4
%   } {
%     \__bnvs_tl_put_right:cn { #2 } { !(#1) }
%     #3
%   }
% }
% \__bnvs_tl_clear:c { TEST_A }
% \__bnvs_tl_clear:c { TEST_B }
% \__bnvs_scan:nNcTF {abc?} \BNVS_TEST_resolve:ncTF { TEST_A } {
%   \__bnvs_tl_set:cn { TEST_B } { SUCCESS }
% } {
%   \__bnvs_tl_set:cn { TEST_B } { FAILURE }
% }
% \exp_args:NV \assert_equal:nnn \g__bnvs_TEST_tl  { SUCCESS } { A }
% \assert_equal_tl:vnn { TEST_A } { abc } { C }
% \assert_equal_tl:vnn { TEST_B } { SUCCESS } { C }
% \cs_undefine:N \BNVS_TEST_resolve:ncTF
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{function}{
%   \__bnvs_scan_require_close_and_return:
% }
% \begin{syntax}
% \cs{__bnvs_scan_require_close_and_return:}
% \end{syntax}
% We found a `|?(|', we record the forthcomming content in the |query| variable,
% up to the next balancing `|)|`.
% \end{function}
%    \begin{macrocode}
\BNVS_new:cpn { scan_require_close_and_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn S { } { scan_require_close_and_return: } { }
%</!final>
% \end{BNVS.gobble}
% Get next token.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \str_case:VnF \l__bnvs_token_tl {
      { ( %---)
      } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to |query|,
% then scan for a ^^A---(
% `|)|'.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_int_incr:c { }
        \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \__bnvs_scan_require_close_and_return:
      }
      { %(---
        )
      } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We found a balancing ^^A(---
% `|)|', we decrement and test the depth.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_int_decr:c { }
        \int_compare:nNnTF { \__bnvs_int_use:c { } } = 0 {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to |ans|
% and look for the next `|?|'.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
          \__bnvs_scan_handle_query_then_end_return:
        } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to |query| because it is not yet the
% end of sequence marker.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
          \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \__bnvs_scan_require_close_and_return:
        }
      }
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to |query|
% and look for a balancing^^A(---
% |)|.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_scan_require_close_and_return:
    }
  } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Above ends the code for Not a  `|(|'. ^^A---)
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and terminate.
% As recovery we feed |query| with the missing ^^A(---
% `|)|'.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \BNVS_error:x { Missing~%(---
      `)' }
    \__bnvs_tl_put_right:cx { query } {
      \prg_replicate:nn { \l__bnvs_int } {%(---
      )}
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_scan_end_return_true:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:cn={scan:nNc}{A}, ignore}
% \cs_set:Npn \BNVS_TEST_resolve:ncTF #1 #2 #3 #4 {
%   \tl_if_empty:nTF { #1 } {
%     #4
%   } {
%     \__bnvs_tl_put_right:cn { #2 } { !(#1) }
%     #3
%   }
% }
% \__bnvs_tl_clear:c { TEST_A }
% \__bnvs_scan:nNc {} \BNVS_TEST_resolve:ncTF { TEST_A }
% \__bnvs_scan:nNc {?(A)} \BNVS_TEST_resolve:ncTF { TEST_A }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \banner:n { Test:~scan/#3/#1/}
%   \__bnvs_tl_clear:c { TEST_A }
%   \__bnvs_scan:nNc { #1 } \BNVS_TEST_resolve:ncTF { TEST_A }
%   \assert_equal_tl:vnn { TEST_A } { #2 } { #3 }
% }
% \BNVS_Test:nnn {} {} {1}
% \BNVS_Test:nnn {1+1} {1+1} {2}
% \BNVS_Test:nnn {1?(+)1} {1!(+)1} {3}
% \BNVS_Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \cs_undefine:N \BNVS_TEST_resolve:ncTF
% \cs_undefine:N \BNVS_Test:nnn
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { scan:nNc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn S { scan:nNcTF } {
  \BNVS_DEBUG_log_arg:nnn S { WHAT } { #1 }
  \BNVS_DEBUG_log_cs:nnN S { CMD } #2
  \BNVS_DEBUG_log_arg:nnc S { IN } { #3 }
  \BNVS_DEBUG_tl:nc S { #3 }
}
\BNVS_DEBUG_log_scan_nNcTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { scan:nNcTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_set:cpn { error:x } ##1 {
    \msg_error:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \__bnvs_tl_set:cn { scan } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_seq_clear:c { token }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Explode the \meta{named overlay expression} into a list of individual tokens:
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \regex_split:nnN { } { #1 } \l__bnvs_token_seq
%    \end{macrocode}
% \end{BNVS.macrocode}
% Run the top level loop to scan for a `|?|' character:
% Error recovery is missing.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_set:cpn { scan_handle_query_then_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn S {} { scan_handle_query_then_end_return: } { }
\BNVS_DEBUG_tl:nc S { query }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_tl_use:Nv #2 { query } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
\BNVS_DEBUG_tl:nc S { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_scan_for_query_then_end_return:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_tl:nc S { query }
\BNVS_DEBUG_tl:nc S { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \BNVS_end_tl_put_right:cv { #3 } { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_scan_nNcTF:nn { ... } { ...DONE/FALSE }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% Stop on the first error.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
  \BNVS_set:cpn { scan_end_return_true: } {
    \BNVS_end_tl_put_right:cv { #3 } { ans }
    \prg_return_true:
  }
  \BNVS_set:cpn { scan_end_return_false: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn S { scan_end_return_false: }
\BNVS_DEBUG_tl:nc S { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end_tl_put_right:cv { #3 } { ans }
    \prg_return_false:
  }
  \__bnvs_scan_for_query_then_end_return:
}
\BNVS_new:cpn { scan:nNc } #1 #2 #3 {
  \BNVS_use:c { scan:nNcTF } { #1 } #2 { #3 } {} {}
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={scan:nNcTF}, ignore}
% \end{BNVS.test}
% \end{BNVS.macrocode}
%
% \subsection{Resolution}
%
% Given a name, a frame id and a dotted path,
% we resolve any intermediate standalone reference.
% For example, with |A=B| and |B=C|, |A| is resolved in |C|.
% But with |A=B+1| and |B=C|, |A| is not resolved in |C+1|.
% With |A=B:D| and |B=C|, |A| is not resolved in |C:D| neither.
%
% \begin{function}[TF]{
%   \__bnvs_if_TIP:ccc
% }
% \begin{syntax}
% \cs{__bnvs_if_TIP:cccTF} \KWNmarg{name} \KWNmarg{id} \marg{path} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Auxiliary function. On input,
% the \meta{\textsl{name}} tl variable contains a set name whereas
% the \KWNmeta{id} tl variable contains a frame id.
% If \meta{\textsl{name}} tl variable contents is a recorded set, on return,
% \KWNmeta{tag} tl variable contains the resolved name,
% \KWNmeta{id} tl variable contains the used frame id,
% \KWNmeta{path} seq variable is prepended with new dotted path components,
% \KWNmeta{yes code} is executed, otherwise variables are left untouched and
% \KWNmarg{no code} is executed.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_TIP:ccc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncn { if_TIP:cccTF } {
  \BNVS_DEBUG_log_tl:nc T { #1 }
  \BNVS_DEBUG_log_tl:nc T { #2 }
  \BNVS_DEBUG_log_seq:nc T { #3 }
}
\BNVS_DEBUG_log_if_TIP_cccTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_TIP:cccTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NvTF \c__bnvs_A_ref_Z_regex { #1 }  {
%    \end{macrocode}
% \end{BNVS.macrocode}
% This is a correct \KWNmeta{tag}, update the path sequence accordingly.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_if_match_pop_TIP:cccTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_TIP_cccTF:nn { } {...ID...}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_export_TIP:cccN { #1 } { #2 } { #3 }
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_TIP_cccTF:nn {...} {...TRUE}
\BNVS_DEBUG_log_seq:nc T { path }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_TIP_cccTF:nn {...} {...UNREACHABLE}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_TIP_cccTF:nn {...} {...FALSE/Not~a~ref}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\quark_new:N \q__bnvs
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_export_TIP_cccN_tl
\BNVS_new:cpn { export_TIP:cccN } #1 #2 #3 #4 {
  \cs_set:Npn \BNVS_export_TIP_cccN:w ##1 ##2 ##3 {
    #4
    \__bnvs_tl_set:cn { #1 } { ##1 }
    \__bnvs_tl_set:cn { #2 } { ##2 }
    \__bnvs_tl_set:cn { export_TIP_cccN } { ##3 }
  }
  \__bnvs_tl_set:cx { export_TIP_cccN }
    { \__bnvs_seq_use:cn { #1 } { \q__bnvs } }
  \BNVS_tl_use:nvv {
    \BNVS_tl_use:Nv \BNVS_export_TIP_cccN:w { #1 }
  } { #2 } { export_TIP_cccN }
  \BNVS_tl_use:nv {
    \__bnvs_seq_set_split:cnn { #3 } { \q__bnvs }
  } { export_TIP_cccN }
  \__bnvs_seq_remove_all:cn { #3 } { }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_if_match_export_ISPn_cccc_tl
\BNVS_new:cpn { if_match_export_ISPn:ccccN } #1 #2 #3 #4 #5 {
  \cs_set:Npn \BNVS_if_match_export_ISPn_ccccN:w ##1 ##2 ##3 ##4 {
    #5
    \__bnvs_tl_set:cn { #1 } { ##1 }
    \__bnvs_tl_set:cn { #2 } { ##2 }
    \__bnvs_tl_set:cn { #3 } { ##3 }
    \__bnvs_tl_set:cn { #4 } { ##4 }
  }
  \__bnvs_tl_set:cx { if_match_export_ISPn_cccc }
    { \__bnvs_seq_use:cn { #1 } { \q__bnvs } }
  \BNVS_tl_use:nvvv {
    \BNVS_tl_use:Nv \BNVS_if_match_export_ISPn_ccccN:w { #1 }
  } { #2 } { if_match_export_ISPn_cccc } { #4 }
  \BNVS_tl_use:nv {
    \__bnvs_seq_set_split:cnn { #3 } { \q__bnvs }
  } { if_match_export_ISPn_cccc }
  \__bnvs_seq_remove_all:cn { #3 } { }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_match_pop_ISPn:cccc } #1 #2 #3 #4 { TF } {
  \BNVS_begin:
  \__bnvs_if_match_pop_left:cTF { #1 } {
    \__bnvs_if_match_pop_left:cTF { #1 } {
      \__bnvs_if_match_pop_left:cTF { #2 } {
        \__bnvs_if_match_pop_left:cTF { #3 } {
          \__bnvs_seq_set_split:cnv { #3 } { . } { #3 }
          \__bnvs_seq_remove_all:cn { #3 } { }
          \__bnvs_if_match_pop_left:cTF { #4 } {
            \__bnvs_if_match_export_ISPn:ccccN { #1 } { #2 } { #3 } { #4 }
              \BNVS_end:
            \prg_return_true:
          } {
            \BNVS_end_return_false:
          }
        } {
         \BNVS_end_return_false:
        }
      } {
        \BNVS_end_return_false:
      }
    } {
      \BNVS_end_return_false:
    }
  } {
    \BNVS_end_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_path_head_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_path_tail_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { seq_merge:cc } #1 #2 {
  \__bnvs_seq_if_empty:cF { #2 } {
    \__bnvs_seq_set_split:cnx { #1 } { \q__bnvs } {
      \__bnvs_seq_use:cn { #1 } { \q__bnvs }
      \exp_not:n { \q__bnvs }
      \__bnvs_seq_use:cn { #2 } { \q__bnvs } 
    }
    \__bnvs_seq_remove_all:cn { #1 } { }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% 
% \subsection{Evaluation bricks}
% We start by helpers.
% \begin{function}{
%  \__bnvs_round:N,
%  \__bnvs_round:c,
%}
% \begin{syntax}
% \cs{__bnvs_round:N} \meta{tl variable}
% \cs{__bnvs_round:c} \marg{tl core name}
% \end{syntax}
% Replaces the variable content with its rounded floating point evaluation.
% \end{function}
% \begin{BNVS.test}{bnvs:c={round:c}, ignore}
% \banner:n {1}
% \__bnvs_tl_set:cn { TEST_A } {11+(1)-111}
% \__bnvs_round:c { TEST_A }
% \assert_equal:xxn { \l__bnvs_TEST_A_tl } { -99 } { 1 }
% \__bnvs_tl_clear:c { TEST_A }
% \__bnvs_round:c { TEST_A }
% \assert_equal_tl:vnn { TEST_A } { 0 } { 2 }
% \__bnvs_tl_set:cn { ans } {11+(1)-111}
% \__bnvs_round:c { ans }
% \assert_equal_tl:vnn { ans } { -99 } { 3 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:N } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: r => round and range
%<*!final>
\BNVS_DEBUG_log_f:nncn r { } { round:N } { }
\BNVS_DEBUG_log:nx r { \token_to_str:N #1 -> / \tl_to_str:V #1 / }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF #1 {
    \tl_set:Nn #1 { 0 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn r { EMPTY(2) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  } {
    \tl_set:Nx #1 { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx r { OUT -> / \tl_to_str:V #1 / }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:c } {
  \BNVS_tl_use:Nc \__bnvs_round:N
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_assign_value:nnn,
%   \__bnvs_if_assign_value:nnv,
%   \__bnvs_if_assign_value:vvv,
% }
% \begin{syntax}
% \cs{__bnvs_if_assign_value:nnnTF} \KWNmarg{id} \KWNmarg{tag} \meta{\textsl{value}} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_assign_value:nnn } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnn a { if_assign_value:nnnTF } { #1 } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_if_assign_value_nnnTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_assign_value:nnnTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #3 } { a } {
    \__bnvs_gunset:nn { #1 } { #2 }
    \tl_map_inline:nn { V { V * } v } {
      \__bnvs_gset:nnnv { ##1 } { #1 } { #2 } { a }
    }
    \BNVS_end:
    \prg_return_true:
  } {
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_assign_value:nnv } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_if_assign_value:nnnTF { #1 } { #2 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_assign_value:vvv } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nvv {
    \BNVS_tl_use:Nv \_bnvs_if_assign_value:nnnTF { #1 }
  } { #2 } { #3 } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c=if_assign_value:nnnTF, ignore}
% \__bnvs_if_assign_value:nnnTF {} { Value.Path } { 200+20+2 } {
%   \__bnvs_if_resolve:ncTF { Value.Path } { ans } {
%     \assert_equal_ans:nn { 222 } { if_assign_value:nnnTF/1-a }
%   } {
%     \test_fail:n {if_assign_value:nnnTF/1-b}
%   }
% } {
%   \test_fail:n {if_assign_value:nnnTF/1-c}
% }
% \__bnvs_if_assign_value:nnnTF { id } { Value.Path } { 200+20+2 } {
%   \__bnvs_if_resolve:ncTF { id!Value.Path } { ans } {
%     \assert_equal_ans:nn { 222 } { if_assign_value:nnnTF/2-a }
%   } {
%     \test_fail:n {if_assign_value:nnnTF/2-b}
%   }
% } {
%   \test_fail:n {if_assign_value:nnnTF/2-c}
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_V:nnc,
%   \__bnvs_if_resolve_V:nvc,
%   \__bnvs_if_append_V:nnc,
%   \__bnvs_if_append_V:nxc,
%   \__bnvs_if_append_V:nvc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_V:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_V:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the content of the \KWNmeta{id}, \KWNmeta{tag} value counter
% into the \KWNmeta{ans} |tl| variable or
% append this value to the right of this variable.
% Execute \KWNmeta{yes code} when there is a \meta{\textsl{value}}, \KWNmarg{no code} otherwise.
% Inside the \KWNmarg{no code} branch,
% the content of the \KWNmeta{ans} |tl| variable is undefined.
% Implementation detail: in \KWNmeta{ans} we return the first in the cache for subkey V
% and in the general prop for subkey V (once resolved).
% Once we have found a value, we feed the previous items
% such that the next search stops at the first item.
% The cache contains an integer which is the computed value from the general prop.
% A local group is created while appending but not while resolving.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_V_return:nnncT } #1 #2 #3 #4 #5 {
  \__bnvs_tl_if_empty:cTF { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...FALSE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } {
    \__bnvs_gset_cache:nnnv V { #2 } { #3 } { #4 }
    #5
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...TRUE/#1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\makeatletter
\BNVS_new_conditional:cpnn { if_resolve_V:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_V:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF V { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nnncTF V { #1 } { #2 } { #3 } {
      \__bnvs_quark_if_nil:cTF { #3 } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We can retrieve the value from either the first or last index.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_gset:nnnn V { #1 } { #2 } { \q_no_value }
        \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 } {
          \__bnvs_if_resolve_V_return:nnncT A { #1 } { #2 } { #3 } {
            \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
          }
        } {
          \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
            \__bnvs_if_resolve_V_return:nnncT Z { #1 } { #2 } { #3 } {
              \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...FALSE/#1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
            \prg_return_false:
          }
        }
      } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Possible recursive call.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_quark_if_no_value:cTF { #3 } {
          \BNVS_error:n {Circular~definition:~#1!#2 (Error~recovery~1)}
          \__bnvs_gset:nnnn V { #1 } { #2 } { 1 }
          \__bnvs_tl_set:cn { #3 } { 1 }
          \prg_return_true:
        } {
          \__bnvs_if_resolve:vcTF { #3 } { #3 } {
            \__bnvs_if_resolve_V_return:nnncT V { #1 } { #2 } { #3 } {
              \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \__bnvs_gset:nnnn V { #1 } { #2 } { \q_nil }
            \prg_return_false:
          }
        }
      }
    } {
      \tl_if_eq:nnTF { #2 } { pauses } {
        \cs_if_exist:NTF \c@beamerpauses {
          \exp_args:Nnx \__bnvs_tl_set:cn { #3 } { \the\c@beamerpauses }
          \__bnvs_gunset:nn { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...TRUE/pauses }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \makeatletter
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{...=pauses}, ignore}
% \cs_if_exist:NF \c@beamerpauses {
%   \newcounter{beamerpauses}
%   \cs_if_exist:NF \c@beamerpauses {
%     \test_fail:n { A }
%   }
% }
% \setcounter{beamerpauses}{421}
% \__bnvs_if_resolve:ncTF { pauses } { ans } {
%   \assert_equal_ans:nn { 421 } { B }
% } {
%   \test_fail:n { C }
% }
% \setcounter{beamerpauses}{666}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_resolve:ncTF { PAUSES = pauses } { ans } {
%   \assert_equal_ans:nn { 666 } { B' }
% } {
%   \test_fail:n { C' }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_resolve:ncTF { PAUSES } { ans } {
%   \assert_equal_ans:nn { 666 } { D }
% } {
%   \test_fail:n { E }
% }
% \end{BNVS.test}
% \makeatother
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...NO~PAUSES }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
        \tl_if_eq:nnTF { #2 } { slideinframe } {
          \cs_if_exist:NTF \beamer@slideinframe {
            \exp_args:Nnx \__bnvs_tl_set:cn { #3 } { \beamer@slideinframe }
          \__bnvs_gunset:nn { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...TRUE/slideinframe }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \makeatletter
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{...=slideinframe}, ignore}
% \cs_if_exist:NF \beamer@slideinframe {
%   \def\beamer@slideinframe{400+20+1}

% }
% \__bnvs_if_resolve:ncTF { SIF = slideinframe } { ans } {
%   \assert_equal_ans:nn { 421 } { A }
% } {
%   \test_fail:n { B }
% }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_resolve:ncTF { SIF } { ans } {
%   \assert_equal_ans:nn { 421 } { C }
% } {
%   \test_fail:n { D }
% }
% \end{BNVS.test}
% \makeatother
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...FALSE/NO~SLIDEINFRAME }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BeanovesLogG
\BNVS_DEBUG_log_if_resolve_V_nncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      }
    }
  }
}
\makeatother
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_V } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_put_right:vc } #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #2 }
  } { #1 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_V:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_V:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_V_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_V:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_V:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_V_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_V_nncTF:nn { ... } { ...FALSE(FAILED) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_V } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:c=if_append_V:nncTF, ignore}
% \Test_what_if_append_X_nncTF:nnnn { V } { 222 } { 222 } { 1 }
% \reset:n { YES }
% \BNVS_DEBUG_log_g:nn D { }
% \BNVS_DEBUG_tl:nc D { ans }
% \__bnvs_if_resolve:ncTF { FIRST } { ans } {} {
%   \assert_equal_ans:nn { ans } { BAD }
%   \Test_what_if_append_X_:nn { 222 } { NO~WAY }
% }
% \__bnvs_tl_clear:c { ans }
% \cs_new:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_if_resolve_V:nncTF { } { X } { ans } {
%     \assert_equal_tl:vnn { ans } { #1 } { #2/A }
%     \__bnvs_if_get_cache:nnncTF V { X } { ans } {
%       \assert_equal_tl:vnn { ans } { #1 } { #2/B }
%     } {
%       \test_fail:n { #2/C }
%     } 
%   } {
%     \test_fail:n { #2/D }
%   }
% }
% \__bnvs_gset:nnnn V {} { X } { 421 }
% \BNVS_Test:nn { 421 } { 1 }
% \__bnvs_gunset:nn {} { X }
% \__bnvs_gset:nnnn A {} { X } { 422 }
% \__bnvs_gset:nnnn V {} { X } { \q_nil }
% \BNVS_Test:nn { 422 } { 2 }
% \__bnvs_gunset:nn {} { X }
% \__bnvs_gset:nnnn Z {} { X } { 423 }
% \__bnvs_gset:nnnn V {} { X } { \q_nil }
% \BNVS_Test:nn { 423 } { 3 }
%
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_A:nnc,
%   \__bnvs_if_append_A:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_A:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_A:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the first index of the \KWNmeta{tag} slide range
% into the \KWNmeta{ans} |tl| variable or
% append the first index of the \KWNmeta{tag} slide range
% to the \KWNmeta{ans} |tl| variable.
% If no resolution occurs the content of the
% \KWNmeta{ans} |tl| variable is undefined in the first case
% and unmodified in the second.
% Cache the result.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{first}, \KWNmarg{no code} otherwise.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_A:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_resolve_A:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF A { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_resolve_A:nncTF/C, ignore}
% \__bnvs_gset:nnnn A {} { X } { 421 }
% \__bnvs_if_resolve_A:nncTF {} { X } { ans } {
%   \assert_equal_ans:nn { 421 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nnncTF A { #1 } { #2 } { #3 } {
      \__bnvs_quark_if_nil:cTF { #3 } {
        \__bnvs_gset:nnnn A { #1 } { #2 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS.macrocode}
% The first index must be computed separately from the length and the last index.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
          \__bnvs_tl_put_right:cn { #3 } { - }
          \__bnvs_if_append_L:nncTF { #1 } { #2 } { #3 } {
            \__bnvs_tl_put_right:cn { #3 } { + 1 }
            \__bnvs_round:c { #3 }
            \__bnvs_tl_if_empty:cTF { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
              \__bnvs_gset:nnnn A { #1 } { #2 } { \q_nil }
              \prg_return_false:
            } {
%    \end{macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_resolve_A:nncTF/q_nil-ZL, ignore}
% \__bnvs_gset:nnnn A { } { X } { \q_nil }
% \__bnvs_gset:nnnn Z { } { X } { 666 }
% \__bnvs_gset:nnnn L { } { X } { 445 }
% \__bnvs_if_resolve_A:nncTF { } { X } { ans } {
%   \assert_equal_ans:nn { 222 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
              \__bnvs_gset:nnnn   A { #1 } { #2 } { \q_nil }
              \__bnvs_gset_cache:nnnv A { #1 } { #2 } { #3 }
              \prg_return_true:
            }
          } {
            \BNVS_error:n {
Unavailable~length~for~#1~(\token_to_str:N\__bnvs_if_resolve_A:nncTF/2) }
            \__bnvs_gset:nnnn A { #1 } { #2 } { \q_nil }
            \prg_return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\token_to_str:N\__bnvs_if_resolve_A:nncTF/1) }
          \__bnvs_gset:nnnn A { #1 } { #2 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { a } {
          \BNVS_error:n {Circular~definition:~#1!#2 (Error~recovery~1)}
          \__bnvs_gset:nnnn A { #1 } { #2 } { 1 }
          \__bnvs_tl_set:cn { #3 } { 1 }
          \prg_return_true:
        } {
          \__bnvs_if_resolve:vcTF { #3 } { #3 } {
            \__bnvs_gset:nnnv A { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BeanovesLogG
\BNVS_DEBUG_log_if_resolve_A_nncTF:nn { ... } { ...FALSE/C^^J Unknown~KEY = / #1!#2 / A / }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_A:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_append_A:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_A_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_A:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_A_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_A_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_append_A:ncTF, ignore}
% \Test_what_if_append_X_nncTF:nnnn { A } { 222: } { 222 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { A } { 222: } { 222 } { 1' }
% \reset:n { YES }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST: } { 222 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST: } { 222 } { 2' }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST::LENGTH } { 222 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST::LENGTH } { 222 } { 3' }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST:LAST } { 222 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { A } { FIRST:LAST } { 222 } { 4' }
% \Test_what_if_append_X_nncTF:nnnn { A } { ::LENGTH:LAST } { 222 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { A } { ::LENGTH:LAST } { 222 } { 5' }
% \Test_what_if_append_X_nncTF:nnnn { A } { :LAST::LENGTH } { 222 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { A } { :LAST::LENGTH } { 222 } { 6' }
% \end{BNVS.test}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_Z:nnc,
%   \__bnvs_if_append_Z:nnc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_Z:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_Z:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the last index of the \KWNmeta{id}!\KWNmeta{tag} range
% into or to the right of the \KWNmeta{ans} |tl| variable, when possible.
% Execute \KWNmeta{yes code} when a last index was given,
% \KWNmeta{no code} otherwise.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_Z:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_Z:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF Z { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }  {
    \__bnvs_if_get:nnncTF Z { #1 } { #2 } { #3 } {
      \__bnvs_quark_if_nil:cTF { #3 } {
        \__bnvs_gset:nnnn Z { #1 } { #2 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS.macrocode}
% The last index must be computed separately from the start and the length.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...A+L... }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 } {          
          \__bnvs_tl_put_right:cn { #3 } { + }
          \__bnvs_if_append_L:nncTF { #1 } { #2 } { #3 } {
            \__bnvs_tl_put_right:cn { #3 } { - 1 }
            \__bnvs_round:c { #3 }
            \__bnvs_gset_cache:nnnv Z { #1 } { #2 } { #3 }
            \__bnvs_gset:nnnn   Z { #1 } { #2 } { \q_nil }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_error:x {
 Unavailable~last~for~#1~(\token_to_str:N \__bnvs_if_resolve_Z:ncTF/1) }
            \__bnvs_gset:nnnn Z { #1 } { #2 } { \q_nil }
            \prg_return_false:
          }
        } {
          \BNVS_error:x {
Unavailable~first~for~#1~(\token_to_str:N \__bnvs_if_resolve_Z:ncTF/1) }
          \__bnvs_gset:nnnn Z { #1 } { #2 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #3 } {
          \BNVS_error:n {Circular~definition:~#1!#2 (Error~recovery~1)}
          \__bnvs_tl_set:cn { #3 } { 1 }
          \__bnvs_gset_cache:nnnv Z { #1 } { #2 } { #3 }
          \prg_return_true:
        } {
          \__bnvs_if_resolve:vcTF { #3 } { #3 } {
            \__bnvs_gset_cache:nnnv Z { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...TRUE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_Z_nncTF:nn { ... } { ...FALSE/B }
\BNVS_DEBUG_log_tl:nc a { #3 }
\BNVS_DEBUG_log_g:nn a {}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_Z } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_Z:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_Z:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_Z_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_Z:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_Z_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_Z_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_Z } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{banner=last, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :666 } { 666 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :666 } { 666 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :LAST } { 666 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :LAST } { 666 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { FIRST:LAST } { 666 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { FIRST:LAST } { 666 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { :LAST::LENGTH } { 666 } { 10 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { FIRST::LENGTH } { 666 } { 10 }
% \Test_what_if_append_X_nncTF:nnnn { Z } { FIRST::LENGTH } { 666 } { 11 }
% \end{BNVS.test}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_L:nnc,
%   \__bnvs_if_append_L:nnc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_L:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_L:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the length of the \KWNmeta{id}!\KWNmeta{tag} slide range into \KWNmeta{ans} |tl| variable,
% or append the length of the \KWNmeta{key} slide range to this variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{length}, \KWNmeta{no code} otherwise.
% \end{function}
% \begin{BNVS.test}{bnvs:c=if_append_L:nncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::445 } { 445 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::445 } { 445 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::LENGTH } { 445 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::LENGTH } { 445 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { L } { FIRST::LENGTH } { 445 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { L } { FIRST::LENGTH } { 445 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::LENGTH:LAST } { 445 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { L } { ::LENGTH:LAST } { 445 } { 8 }
% \Test_what_if_append_X_nncTF:nnnn { L } { :LAST::LENGTH } { 445 } { 9 }
% \Test_what_if_append_X_nncTF:nnnn { L } { :LAST::LENGTH } { 445 } { 10 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{last}, ignore}
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { A }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=if_append:ncTF, ignore}
% \Test_if_append:nnnn { 222:666 } { X.last } { 666 } { A }
% \Test_if_append:nnnn { 222:666 } { X.1 } { 222 } { B }
% \Test_if_append:nnnn { 222:666 } { X.last - X.1 } { 444 } { C }
% \Test_if_append:nnnn { 222:666 } { X.last - (X.1) } { 444 } { D }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 0 } { A2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 0 } { B2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 0 } { C2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 0 } { D2i }
% \reset:n { Y }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 666 } { A2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 222 } { B2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 444 } { C2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 444 } { D2 }
% \Test_what_if_append_X_nncTF:nnnn { L } { FIRST:LAST } { 445 } { 11 }
% \Test_what_if_append_X_nncTF:nnnn { L } { FIRST:LAST } { 445 } { 12 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_L:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_L:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF L { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nnncTF L { #1 } { #2 } { #3 } {
      \__bnvs_quark_if_nil:cTF { #3 } {
        \__bnvs_gset:nnnn L { #1 } { #2 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS.macrocode}
% The length must be computed separately from the start and the last index.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
          \__bnvs_tl_put_right:cn { #3 } { - }
          \__bnvs_if_append_A:nncTF { #1 } { #2 } { #3 } {
            \__bnvs_tl_put_right:cn { #3 } { + 1 }
            \__bnvs_round:c { #3 }
            \__bnvs_gset:nnnn   L { #1 } { #2 } { \q_nil }
            \__bnvs_gset_cache:nnnv L { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_error:n {
Unavailable~first~for~#1~(\__bnvs_if_resolve_L:nncTF/2) }
            \prg_return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\__bnvs_if_resolve_L:nncTF/1) }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #3 } {
          \BNVS_error:n {Circular~definition:~#1!#2 (Error~recovery~1)}
          \__bnvs_gset_cache:nnnn L { #1 } { #2 } { 1 }
          \__bnvs_tl_set:cn { #3 } { 1 }
          \prg_return_true:
        } {
          \__bnvs_if_resolve:vcTF { #3 } { #3 } {
            \__bnvs_gset_cache:nnnv L { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_L_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_L } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_L:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_L:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_L_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_L:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_L:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_L_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_L_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_L } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%

% \begin{function}[TF]{
%   \__bnvs_if_resolve_previous:nnc,
%   \__bnvs_if_append_previous:nnc
% }
% \begin{syntax}
% \cs{__bnvs_if_append_previous:ncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the index after the \KWNmeta{id}!\KWNmeta{key} slide range into the \KWNmeta{ans} |tl| variable,
% or append this index to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{next} index, \KWNmeta{no code} otherwise.
% In the latter case, the \KWNmeta{ans} |tl| is undefined
% on resolution only.
% \end{function}
% \begin{BNVS.test}{bnvs:c=if_append_previous:nncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { previous } { 222: } { 221 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6' }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=if_append_previous:nncTF, ignore}
% \reset:n { Y }
% \Beanoves { X = :LAST::LENGTH }
% \Test_what_if_append_X_nncTF:nnnn { Z } { } { 666 } { A }
% \Test_what_if_append_X_nncTF:nnnn { L } { } { 445 } { B }
% \Test_what_if_append_X_nncTF:nnnn { A } { } { 222 } { C }
% \Test_what_if_append_X_nncTF:nnnn { previous } {  } { 221 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { :LAST+1::LENGTH } { 222 } { 7' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { :LAST } { 0 } { 7'' }
% \end{BNVS.test}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_first:nnc,
%   \__bnvs_if_resolve_first:vvc,
%   \__bnvs_if_append_first:nnc,
%   \__bnvs_if_append_first:vvc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_first:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_first:nncTF}  \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the first index starting the \KWNmeta{id}!\KWNmeta{tag} slide range into the \KWNmeta{ans} |tl| variable,
% or append this index to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{first} index, \KWNmarg{no code} otherwise.
% In the latter case, on resolution only, the content of the \KWNmeta{ans} |tl| variable
% is undefined.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_first:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_first:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_first_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_V:nncTF { #1 } { #2.first } { #3 }
    { \prg_return_true: }
    { \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 }
        { \prg_return_true: }
        { \__bnvs_if_resolve_v:nncTF { #1 } { #2.1 } { #3 }
            { \prg_return_true: } { \prg_return_false: }
        }
    }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_first } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_first:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_first:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_first_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:c=if_resolve_first:nncTF, ignore}
% \Test_if_resolve:nnnn { X.1=100 } { X.first } { 100 } { A }
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_append_index:nnncTF { #1 } { #2 } { 1 } { #3 } { \prg_return_true: } {
    \__bnvs_if_append_A:nncTF { #1 } { #2 } { #3 }
      { \prg_return_true: } { \prg_return_false: }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_first } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_last:nnc,
%   \__bnvs_if_resolve_last:vvc,
%   \__bnvs_if_append_last:nnc,
%   \__bnvs_if_append_last:vvc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_last:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_last:nncTF}  \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the last index of the \KWNmeta{id}!\KWNmeta{tag} slide range into the \KWNmeta{ans} |tl| variable,
% or append this index to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{last} index, \KWNmarg{no code} otherwise.
% In the latter case, the content of the \KWNmeta{ans} |tl| variable
% is undefined, on resolution only.
% \end{function}
% \begin{BNVS.test}{:N=\__bnvs_if_append_last:ncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { last } { :666 } { 666 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :666 } { 666 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST } { 666 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST } { 666 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { last } { FIRST:LAST } { 666 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { last } { FIRST:LAST } { 666 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 10 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_last:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_last:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_last_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_last } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_last:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_last:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_last_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_append_Z:nncTF { #1 } { #2 } { #3 }
    { \prg_return_true: } {\prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_last } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_length:nnc,
%   \__bnvs_if_append_length:nnc,
%   \__bnvs_if_append_length:vvc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_length:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_length:nncTF}  \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the length of the \KWNmeta{id}!\KWNmeta{tag} slide range into the \KWNmeta{ans} |tl| variable,
% or append this number to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{last} index, \KWNmarg{no code} otherwise.
% In the latter case, the content of the \KWNmeta{ans} |tl| variable
% is undefined, on resolution only.
% \end{function}
% \begin{BNVS.test}{bnvs:c=if_append_length:nncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { last } { :666 } { 666 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :666 } { 666 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST } { 666 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST } { 666 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { last } { FIRST:LAST } { 666 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { last } { FIRST:LAST } { 666 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_if_append_X_nncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 10 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_length:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_length:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_length_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_L:nncTF { #1 } { #2 } { #3 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_length } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_length:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_length:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_length_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_append_L:nncTF { #1 } { #2 } { #3 }
    { \prg_return_true: } {\prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_length } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_range:nnc,
%   \__bnvs_if_append_range:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_range:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_range:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the range of the \KWNmeta{id}!\KWNmeta{key} slide range into the \KWNmeta{ans} |tl| variable
% or append this range to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{range}, \KWNmeta{no code} otherwise, in that latter case
% the content the \KWNmeta{ans} |tl| variable is undefined
% on resolution only.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_range:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_range:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_range_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_range:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { a } {
    \BNVS_tl_use:Nv \int_compare:nNnT { a } < 0 {
      \__bnvs_tl_set:cn { a } { 0 }
    }
    \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { b } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Limited from above and below.
% \begin{BNVS.test}{bnvs:cn={if_append_range:ncTF}{A-Z}, ignore}
% \Test_if_append_range:nnn { 222:666 } { 222-666 } { 3 }
% \Test_if_append_range:nnn { 222::445 } { 222-666 } { 4 }
% \Test_if_append_range:nnn { ::445:666 } { 222-666 } { 5 }
% \Test_if_append_range:nnn { :666::445 } { 222-666 } { 6 }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST:LAST } { 222-666 } { 3 }
% ^^A\Test_if_append_range:nnn { FIRST::LENGTH } { 222-666 } { 4 }
% \Test_if_append_range:nnn { ::LENGTH:LAST } { 222-666 } { 5 }
% \Test_if_append_range:nnn { :LAST::LENGTH } { 222-666 } { 6 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_right:cn { a } { - }
      \__bnvs_tl_put_right:cv { a } { b }
      \BNVS_end_tl_put_right:cv { #3 } { a }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_nncTF:nn { ... } { ...TRUE/A-Z }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Limited from below.
% \begin{BNVS.test}{:N=\__bnvs_if_append_range:nncTF/A-, ignore}
% \reset:n { Y }
% \Test_if_append_range:nnn { 222 } { 222- } { 1 }
% \Test_if_append_range:nnn { 222: } { 222- } { 1' }
% \Test_if_append_range:nnn { 222:: } { 222- } { 1'' }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST } { 222- } { 1 }
% \Test_if_append_range:nnn { FIRST: } { 222- } { 1' }
% \Test_if_append_range:nnn { FIRST:: } { 222- } { 1'' }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_end_tl_put_right:cv { #3 } { a }
      \__bnvs_tl_put_right:cn { #3 } { - }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_nncTF:nn { ... } { ...TRUE/A- }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { b } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Limited from above.
% \begin{BNVS.test}{:N=\__bnvs_if_append_range:ncTF/-Z, ignore}
% \reset:n { Y }
% \Test_if_append_range:nnn { :666 } { 1-666 } { 1 }
% \reset:n { Y }
% \Test_if_append_range:nnn { :LAST } { 1-666 } { 1' }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_left:cn { b } { - }
      \BNVS_end_tl_put_right:cv { #3 } { b }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_nncTF:nn { ... } { ...TRUE/-Z }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_if_resolve_V:nncTF { #1 } { #2 } { b } {
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Unlimited range.
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_range:ncTF{/:-}, ignore}
% \reset:n { Y }
% \Test_if_append_range:nnn { 222 } { 222- } { 1 }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST } { 222- } { 1' }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \BNVS_end_tl_put_right:cv { #3 } { b }
        \__bnvs_tl_put_right:cn { #3 } { - }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_nncTF:nn { ... } { ...TRUE/V }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \BNVS_end:
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_range } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_range:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_range_nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_range_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { #3 }
  \__bnvs_if_append_range:ncTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_range_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_range_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } 
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_range } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_previous:nnc,
%   \__bnvs_if_append_previous:nnc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_previous:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_previous:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the index after the \KWNmeta{key} slide range into the \KWNmeta{ans} |tl| variable,
% or append this index to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{next} index, \KWNmeta{no code} otherwise.
% In the latter case, the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{BNVS.test}{bnvs:c=if_append_previous:nncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { previous } { 222: } { 221 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6' }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=if_append_previous:nncTF, ignore}
% \reset:n { Y }
% \Beanoves { X = :LAST::LENGTH }
% \Test_what_if_append_X_nncTF:nnnn { Z } { } { 666 } { A }
% \Test_what_if_append_X_nncTF:nnnn { L } { } { 445 } { B }
% \Test_what_if_append_X_nncTF:nnnn { A } { } { 222 } { C }
% \Test_what_if_append_X_nncTF:nnnn { previous } {  } { 221 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { previous } { :LAST+1::LENGTH } { 222 } { 7' }
% \Test_what_if_append_X_nncTF:nnnn { previous } { :LAST } { 0 } { 7'' }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_previous:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_previous:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_previous_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF P { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_nncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 } {
      \__bnvs_tl_put_right:cn { #3 } { -1 }
      \__bnvs_round:c { #3 }
      \__bnvs_gset_cache:nnnv P { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_previous } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_previous:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_previous:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_previous_nncTF:nn { } { ... }
\BNVS_DEBUG_begin:n { if_append_previous:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_previous:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_previous_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_previous_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_previous } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_next:nnc,
%   \__bnvs_if_append_next:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_next:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_next:nncTF}  \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the index after the \KWNmeta{id}! slide range into the \KWNmeta{ans} |tl| variable,
% or append this index to that variable.
% Execute \KWNmeta{yes code} when there is a \KWNmeta{next} index, \KWNmeta{no code} otherwise.
% In the latter case, the content of the \KWNmeta{ans} |tl| variable
% is undefined, on resolution only.
% \end{function}
% \begin{BNVS.test}{:N=\__bnvs_if_append_next:nncTF, ignore}
% \reset:n { Y }
% \Test_what_if_append_X_nncTF:nnnn { next } { :666 } { 667 } { 1 }
% \Test_what_if_append_X_nncTF:nnnn { next } { :666 } { 667 } { 2 }
% \Test_what_if_append_X_nncTF:nnnn { next } { :LAST } { 667 } { 3 }
% \Test_what_if_append_X_nncTF:nnnn { next } { :LAST } { 667 } { 4 }
% \Test_what_if_append_X_nncTF:nnnn { next } { FIRST:LAST } { 667 } { 5 }
% \Test_what_if_append_X_nncTF:nnnn { next } { FIRST:LAST } { 667 } { 6 }
% \Test_what_if_append_X_nncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 7 }
% \Test_what_if_append_X_nncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 8 }
% \Test_what_if_append_X_nncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 9 }
% \Test_what_if_append_X_nncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 10 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_next:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_next:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_next_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get_cache:nnncTF N { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_next_nncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
      \__bnvs_tl_put_right:cn { #3 } { +1 }
      \__bnvs_round:c { #3 }
      \__bnvs_gset_cache:nnnv N { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_next_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_next_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_next } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_next:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_next:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_next_nncTF:nn { } { ... }
\BNVS_DEBUG_begin:n { if_append_next:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_next:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_next_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_next_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_next } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_v:nnc,
%   \__bnvs_if_resolve_v:vvc,
%   \__bnvs_if_append_v:nnc
%   \__bnvs_if_append_v:vvc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_v:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_v:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the value of the \KWNmeta{id}!\KWNmeta{tag} overlay set
% into the \KWNmeta{ans} |tl| variable or
% append this value to the right of this variable.
% Execute \KWNmeta{yes code} when there is a \meta{\textsl{value}}, \KWNmeta{no code} otherwise.
% In the latter case, the content of the \KWNmeta{ans} |tl| variable
% is undefined, on resolution only.
% Calls |\__bnvs_if_resolve_V:nncTF|.
% \end{function}
% \begin{BNVS.test}{bnvs:c=if_resolve_v:nncTF, ignore}
% \reset:n { Y }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_v:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get:nnncTF v { #1 } { #2 } { #3 } { 
    \__bnvs_quark_if_no_value:cTF { #3 } {
          \BNVS_error:n {Circular~definition:~#1!#2 (Error~recovery~1)}
          \__bnvs_gset:nnnn V { #1 } { #2 } { 1 }
          \__bnvs_tl_set:cn { #3 } { 1 }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { ... } { ...TRUE/ALREADY }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_gset:nnnn v { #1 } { #2 } { \q_no_value }
    \__bnvs_if_resolve_V:nncTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c=if_resolve_v:nncTF, ignore}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_resolve_nncTF:nnnnnn { v } {} { #1 } { #2 } { 222 } { #1!#2 }
% }
% \reset_X:
% \BNVS_DEBUG_log_g:nn D { 100 }
% \BNVS_Test:nn {} { X1 }
% \BNVS_Test:nn {} { X2 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=if_append_v:nncTF, ignore}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_append_nncTF:nnnnnn { v } {} { #1 } { #2 } { 222 } { #1!#2 }
% }
% \reset_X:
% \BNVS_Test:nn {} { A1   }
% \BNVS_Test:nn {} { A2   }
% \BNVS_Test:nn {} { AA1  }
% \BNVS_Test:nn {} { AA2  }
% \BNVS_Test:nn {} { AL11 }
% \BNVS_Test:nn {} { AL12 }
% \BNVS_Test:nn {} { AL21 }
% \BNVS_Test:nn {} { AL22 }
% \BNVS_Test:nn {} { AZ11 }
% \BNVS_Test:nn {} { AZ12 }
% \BNVS_Test:nn {} { AZ21 }
% \BNVS_Test:nn {} { AZ22 }
% \BNVS_Test:nn {} { LZ11 }
% \BNVS_Test:nn {} { LZ12 }
% \BNVS_Test:nn {} { LZ21 }
% \BNVS_Test:nn {} { LZ22 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_append_nncTF:nnnnnn { v } {} { #1 } { #2 } { 1 } { #1!#2 }
% }
% \BNVS_Test:nn {} { Z1 }
% \BNVS_Test:nn {} { Z2 }
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_gset:nnnv v { #1 } { #2 } { #3 }
      \prg_return_true:
    } {
      \__bnvs_if_resolve_A:nncTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \__bnvs_gset:nnnv v { #1 } { #2 } { #3 }
        \prg_return_true:
      } {
        \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { ... } { ...TRUE/Z }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \__bnvs_gset:nnnv v { #1 } { #2 } { #3 }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_nncTF:nn { ... } { ...FALSE/Z }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \__bnvs_gunset:nnn v { #1 } { #2 }
          \prg_return_false:
        }
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_v } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_v:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_v:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_v_nncTF:nn { } { ... }
\BNVS_DEBUG_begin:n { if_append_v:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:c=if_append_V:nncTF, ignore}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_append_nncTF:nnnnnn { V } {} { #1 } { #2 } { 222 } { #1!#2 }
% }
% \reset_X:
% \BNVS_Test:nn { } { X1   }
% \BNVS_Test:nn { } { X2   }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:c=if_append_V:nncTF, ignore}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_append_nncTF:nnnnnn { V } {} { #1 } { #2 } { 222 } { #1!#2 }
% }
% \reset_X:
% \BNVS_Test:nn { } { A1   }
% \BNVS_Test:nn { } { A2   }
% \BNVS_Test:nn { } { AA1  }
% \BNVS_Test:nn { } { AA2  }
% \BNVS_Test:nn { } { AL11 }
% \BNVS_Test:nn { } { AL12 }
% \BNVS_Test:nn { } { AL21 }
% \BNVS_Test:nn { } { AL22 }
% \BNVS_Test:nn { } { AZ11 }
% \BNVS_Test:nn { } { AZ12 }
% \BNVS_Test:nn { } { AZ21 }
% \BNVS_Test:nn { } { AZ22 }
% \BNVS_Test:nn { } { LZ11 }
% \BNVS_Test:nn { } { LZ12 }
% \BNVS_Test:nn { } { LZ21 }
% \BNVS_Test:nn { } { LZ22 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_what_if_append_nncTF:nnnnnn { V } {} { #1 } { #2 } { 1 } { #1!#2 }
% }
% \BNVS_Test:nn { } { Z1   }
% \BNVS_Test:nn { } { Z2   }
% \end{BNVS.test}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_v } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_index_can:nn,
%   \__bnvs_index_can:vv,
%   \__bnvs_if_resolve_index:nnnc,
%   \__bnvs_if_resolve_index:vvvc,
%   \__bnvs_if_append_index:nnnc,
%   \__bnvs_if_append_index:vvvc
% }
% \begin{syntax}
% \cs{__bnvs_index_can:nnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_resolve_index:nnncTF} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{integer}} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_index:nnncTF} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{integer}} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the index associated to the \KWNmeta{id}!\KWNmeta{tag} set and \meta{\textsl{integer}} slide range
% into the \KWNmeta{ans} |tl| variable or
% append this index to the right of that variable.
% When \meta{\textsl{integer}} is 1, this is the first index,
% when \meta{\textsl{integer}} is 2, this is the second index, and so on.
% When \meta{\textsl{integer}} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \KWNmeta{yes code} is executed, otherwise
% \KWNmarg{no code} is executed.
% In the latter case, the content of the \KWNmeta{ans} |tl| variable
% is undefined, on resolution only.
% The computation may fail when too many recursion calls are required.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:nn } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnn a { index_can:nnTF } { #1 } { #2 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_is_gset:nnnTF V { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nnTF:nn { } { ...TRUE/V}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_is_gset:nnnTF A { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nnTF:nn { } { ...TRUE/A}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_is_gset:nnnTF Z { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nnTF:nn { } { ...TRUE/Z}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nnTF:nn { } { ...FALSE}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:vv } #1 #2 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_index_can:nTF { #1 }
  } { #2 } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_resolve_index:nnncTF } { #1 } { #2 } { INDEX } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \exp_args:Ne \__bnvs_if_resolve_V:nncTF { #1 } { #2.#3 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
  } {
    \__bnvs_if_resolve_first:nncTF { #1 } { #2 } { #4 } {
      \__bnvs_tl_put_right:cn { #4 } { + #3 - 1 }
      \__bnvs_round:c { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...TRUE/FIRST }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
%    \end{macrocode}
% \end{BNVS.macrocode}
% Limited overlay set.
% \begin{BNVS.test}{bnvs:c={if_resolve_index:nnncTF}, ignore}
% \Test_if_resolve_index:nnnnnn { 3 } {} { X } { -2 } {  0 } { A-1 }
% \Test_if_resolve_index:nnnnnn { } {} { X } { 0 } { 2 } { A-2 }
% \Test_if_resolve_index:nnnnnn { } {} { X } { 1 } { 3 } { A-3 }
% \Test_if_resolve_index:nnnnnn { } {} { X } { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } { -2 } { 219 } { #1-1 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  0 } { 221 } { #1-2 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  1 } { 222 } { #1-3 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } { -2 } { -2 } { #1-1 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  0 } { 0 } { #1-2 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  1 } { 1 } { #1-3 }
%   \Test_if_resolve_index:nnnnnn { } {} { #1 } {  2 } { 2 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve_index:nnncTF}{A.0}, ignore}
% \Test_if_resolve:nnnn { } { A.0 } { 0 } { A-1 }
% \Test_if_resolve:nnnn { A.1 = 100 } { A.0 } { 99 } { A-2 }
% \Test_if_resolve:nnnn { A.first = 1000 } { A.0 } { 999 } { A-3 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    } {
      \__bnvs_if_resolve_Z:nncTF { #1 } { #2 } { #4 } {
        \__bnvs_tl_put_right:cn { #4 } { + #3 - 1 }
        \__bnvs_round:c { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...TRUE/LAST }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_if_resolve_V:nncTF { #1 } { #2 } { #4 } {
          \__bnvs_tl_put_right:cn { #4 } { + #3 - 1 }
          \__bnvs_round:c { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...TRUE/V }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
          \__bnvs_if_resolve_v:nncTF { #1 } { #2 } { #4 } {
            \__bnvs_tl_put_right:cn { #4 } { + #3 - 1 }
            \__bnvs_round:c { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...TRUE/v }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:nnvc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_if_resolve_index:nnncTF { #1 } { #2 }
  } { #3 } { #4 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:vvvc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:nvv {
    \BNVS_tl_use:Nv \__bnvs_if_resolve_index:nnncTF { #1 }
  } { #2 } { #3 } { #4 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_index:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_append_index:nnncTF } { #1 } { #2 } { INDEX } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_index_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_index:nnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_index:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_index_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c=if_append_index:nnncTF, ignore}
% \Test_if_append_index:nnnnnn { 3 } {} {X} { -2 } {  0 } { A-1 }
% \Test_if_append_index:nnnnnn { } {} {X} { 0 } { 2 } { A-2 }
% \Test_if_append_index:nnnnnn { } {} {X} { 1 } { 3 } { A-3 }
% \Test_if_append_index:nnnnnn { } {} {X} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } { -2 } { 219 } { #1!#2-1 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  0 } { 221 } { #1!#2-2 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  1 } { 222 } { #1!#2-3 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  2 } { 223 } { #1!#2-4 }
% }
% \reset_X:
% \BNVS_Test:nn {} { A1   }
% \BNVS_Test:nn {} { A2   }
% \BNVS_Test:nn {} { AA1  }
% \BNVS_Test:nn {} { AA2  }
% \BNVS_Test:nn {} { AL11 }
% \BNVS_Test:nn {} { AL12 }
% \BNVS_Test:nn {} { AL21 }
% \BNVS_Test:nn {} { AL22 }
% \BNVS_Test:nn {} { AZ11 }
% \BNVS_Test:nn {} { AZ12 }
% \BNVS_Test:nn {} { AZ21 }
% \BNVS_Test:nn {} { AZ22 }
% \BNVS_Test:nn {} { LZ11 }
% \BNVS_Test:nn {} { LZ12 }
% \BNVS_Test:nn {} { LZ21 }
% \BNVS_Test:nn {} { LZ22 }
% \cs_undefine:N \BNVS_Test:nn
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } { -2 } { -2 } { #1!#2-1 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  0 } {  0 } { #1!#2-2 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  1 } {  1 } { #1!#2-3 }
%   \Test_if_append_index:nnnnnn { } { #1 } { #2 } {  2 } {  2 } { #1!#2-4 }
% }
% \reset_X:
% \BNVS_Test:nn {} { Z1 }
% \BNVS_Test:nn {} { Z2 }
% \end{BNVS.test}
%    \begin{macrocode}
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_index_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_index:vvvc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:nvv {
    \BNVS_tl_use:Nv \__bnvs_if_append_index:nnncTF { #1 }
  } { #2 } { #3 } { #4 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \subsection{Index counter}
% \begin{function}{
%   \__bnvs_n_assign:nnn,
%   \__bnvs_n_assign:vvv
% }
% \begin{syntax}
% \cs{__bnvs_n_assign:nnn} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{value}}
% \end{syntax}
% Assigns the resolved \meta{\textsl{value}} to |n| counter \KWNmeta{id}!\KWNmeta{tag}.
% Execute \KWNmeta{yes code} when resolution succeeds, \KWNmeta{no code} otherwise.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { n_assign:nnn } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnn a { n_assign:nnn } { #1 } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_n_assign_nnn:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get:nnncF V { #1 } { #2 } { a } {
    \BNVS_warning:n { Unknwown~ #1!#2,~defaults~to~0 }
    \__bnvs_gset:nnnn V { #1 } { #2 } { 0 }
  }
  \__bnvs_if_resolve:ncTF { #3 } { a } {
    \__bnvs_gset:nnnv v { #1 } { #2 } { a }
  } {
    \BNVS_error:n { NO~resolution~of~#3,~defaults~to~0 }
    \__bnvs_gset:nnnn v { #1 } { #2 } { 0 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { n_assign:vvv } #1 {
  \BNVS_tl_use:nvv {
    \BNVS_tl_use:cv { n_assign:nn } { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_n:nc,
%   \__bnvs_if_append_n:nc,
%   \__bnvs_if_append_n:vc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_n:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Evaluate the n counter associated to the \KWNmeta{id}!\KWNmeta{tag} overlay set
% into \KWNmeta{ans} |tl| variable.
% Initialize this counter to 1 on the first use.
% \KWNmeta{no code} is never executed.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_n:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_n_nncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_get:nnncTF n { #1 } { #2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_nncTF:nn { ... } { ...GOT }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve:vcTF { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_nncTF:nn { ... } { ...RESOLVED...IN~#3 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \__bnvs_tl_set:cn { #3 } { 1 }
    \__bnvs_gset:nnnn n { #1 } { #2 } { 1 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_resolve_n } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_n:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_n_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n:nnc }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_nncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:nc a { #3 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_n } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:c=if_append_n:ncTF, ignore}
% \Test_if_append_n_X:nnn { 1 } { 1 } { 1 }
% \__bnvs_gset:nnnn n {} { X } { 123 }
% \Test_if_append_n_X:nnn { } { 123 } { 2 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_if_append_n:nnnnn { } { #1 } { #2 } { 1 } { #1!#2 }
% }
% \reset_X:
% \BNVS_Test:nn {} { A1   }
% \BNVS_Test:nn {} { A2   }
% \BNVS_Test:nn {} { AA1  }
% \BNVS_Test:nn {} { AA2  }
% \BNVS_Test:nn {} { AL11 }
% \BNVS_Test:nn {} { AL12 }
% \BNVS_Test:nn {} { AL21 }
% \BNVS_Test:nn {} { AL22 }
% \BNVS_Test:nn {} { AZ11 }
% \BNVS_Test:nn {} { AZ12 }
% \BNVS_Test:nn {} { AZ21 }
% \BNVS_Test:nn {} { AZ22 }
% \BNVS_Test:nn {} { LZ11 }
% \BNVS_Test:nn {} { LZ12 }
% \BNVS_Test:nn {} { LZ21 }
% \BNVS_Test:nn {} { LZ22 }
% \BNVS_Test:nn {} { Z1 }
% \BNVS_Test:nn {} { Z2 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
% \begin{function}[TF]{
%  \__bnvs_if_resolve_n_index:nnc,
%  \__bnvs_if_append_n_index:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_n_index:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_n_index:nncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolve the index for the value of the n counter associated to the
% \KWNmarg{tag} overlay set into the \KWNmeta{ans} |tl| variable or
% append this value the right of that variable.
% Initialize this counter to 1 on the first use.
% If the computation is possible, \KWNmeta{yes code} is executed, otherwise
% \KWNmeta{no code} is executed.
% In the latter case, the content of the \KWNmeta{ans} tl variable
% is undefined on resolution only.
% \end{function}
% \begin{BNVS.test}{:N=\__bnvs_if_resolve_n_index:nncTF, ignore}
% \reset:n { YES }
% \Test_if_resolve_n_index_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_gset:nnnn n {} { X } { 445 }
% \Test_if_resolve_n_index_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_if_resolve_n_index:nnnnn {} { #1 } { #2 } { 222 } { #1!#2-A }
%   \__bnvs_gset:nnnn n { #1 } { #2 } { 445 }
%   \Test_if_resolve_n_index:nnnnn {} { #1 } { #2 } { 666 } { #1!#2-B }
% }
% \reset_X:
% \BNVS_Test:nn {} { A1   }
% \BNVS_Test:nn {} { A2   }
% \BNVS_Test:nn {} { AA1  }
% \BNVS_Test:nn {} { AA2  }
% \BNVS_Test:nn {} { AL11 }
% \BNVS_Test:nn {} { AL12 }
% \BNVS_Test:nn {} { AL21 }
% \BNVS_Test:nn {} { AL22 }
% \BNVS_Test:nn {} { AZ11 }
% \BNVS_Test:nn {} { AZ12 }
% \BNVS_Test:nn {} { AZ21 }
% \BNVS_Test:nn {} { AZ22 }
% \BNVS_Test:nn {} { LZ11 }
% \BNVS_Test:nn {} { LZ12 }
% \BNVS_Test:nn {} { LZ21 }
% \BNVS_Test:nn {} { LZ22 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \Test_if_resolve_n_index:nnnnn {} { #1 } { #2 } { 1 } { #1!#2-A }
%   \__bnvs_gset:nnnn n { #1 } { #2 } { 221 }
%   \Test_if_resolve_n_index:nnnnn {} { #1 } { #2 } { 221 } { #1!#2-B }
% }
% \BNVS_Test:nn {} { Z1 }
% \BNVS_Test:nn {} { Z2 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_index:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_resolve_n_index:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { } { ...START }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:nncTF { #1 } { #2 } { #3 } {
    \__bnvs_tl_put_left:cn { #3 } { #1!#2. }
    \__bnvs_if_resolve:vcTF { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_index:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnc a { if_append_n_index:nncTF } { #1 } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_index:nncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_index:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vvc:cn { if_append_n_index } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\__bnvs_if_append_n_index:nncTF, ignore}
% \prg_set_conditional:Npnn \__bnvs_if_append_n_index:nc #1 #2 { T, F, TF } {
%   \__bnvs_if_append_n_index:nncTF { #1 } { 0 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \reset:n { YES }
% \Test_if_append_n_index_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_gset:nnnn n {} { X } { 445 }
% \Test_if_append_n_X:nnn { } { 445 } { 2 }
% \Test_if_append_n_index_X:nnn { } { 666 } { 1 }
% \end{BNVS.test}
%
% \subsection{Value counter}
% \begin{function} [TF] {
%   \__bnvs_if_resolve_v_incr:nnnc,
%   \__bnvs_if_append_v_incr:nnnc,
%   \__bnvs_if_append_v_incr:vvnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_v_incr:nnnTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{offset} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_v_incr:nnncTF} \KWNmarg{id}  \KWNmarg{tag} \KWNmarg{offset} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% Increment the value counter position accordingly.
% Put the result in the \KWNmeta{ans} |tl| variable.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v_incr:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_resolve_v_incr_nnncTF } { #1 } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #3 } { #4 } {
    \BNVS_tl_use:Nv \int_compare:nNnTF { #4 } = 0 {
      \__bnvs_if_resolve_v:nncTF { #1 } { #2 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_v_incr:nnncTF}{/:1}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_incr:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Test_if_resolve_v_incr:nnnnnn {} {} { X } { 0 } { 222 } { 2 }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_resolve_v_incr:nnncTF{/:2}, ignore}
% \reset:n { Y }
% \__bnvs_if_resolve_v_incr:nnncT {} { X } { 0 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    } {
      \__bnvs_tl_put_right:cn { #4 } { + }
      \__bnvs_if_append_v:nncTF { #1 } { #2 } { #4 } {
        \__bnvs_round:c { #4 }
        \__bnvs_gset:nnnv v { #1 } { #2 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_resolve_v_incr:nnncTF{/:3}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_incr:nnncTF {} { X } { 444 } { ans } {
%   \assert_equal_ans:nn { 666 } { 3 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nnncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_v_incr:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_append_v_incr_nnncTF } { #1 } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_v_incr_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_v_incr:nnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v_incr:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_incr_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_v_incr:nnncTF{/:1}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 111 }
% \__bnvs_if_append_v_incr:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 111222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_set:cn { ans } { 111 }
% \Test_if_append_v_incr:nnnnnn {} {} { X } { 0 } { 111222 } { 2 }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_incr_nnncTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_v_incr:nnncTF{/:2}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_incr:nnncTF {} { X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } { 2 }
% } {
%   \test_fail:n { NO_WAY }
% }
%  \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \Test_if_append_v_incr:nnnnnn {} {} { X } { 2000 } { 22222 } { 2 }
% \end{BNVS.test}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { if_append_v_incr } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v_post:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_resolve_v_post:nnncTF } { #1 } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_v_post_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v:nncTF { #1 } { #2 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve_v_post:nnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve:ncTF { #3 } { a } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { a } = 0 {
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_v_post:nnncTF}{/:1}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_post:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_clear:c { ans }
% \Test_if_resolve_v_post:nnnnnn { X=FIRST } {} { X } { 0 } { 222 } { 2 }
% \Test_if_resolve_v:nnnnn {} {} { X } { 222 } { 2 }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_tl_put_right:cn { a } { + }
        \__bnvs_tl_put_right:cv { a } { #4 }
        \__bnvs_round:c { a }
        \BNVS_end_gset:nnnv v { #1 } { #2 } { a }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_v_post:nnncTF}{/:2}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_post:nnncTF {} { X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 222 } { 1 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_tl:vnn { ans } { 2222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_true:
      }
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nnncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_v_post:nncTF}{/:2}, ignore}
% \reset:n { Y }
% \end{BNVS.test}
%    \begin{macrocode}
      \BNVS_end:
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nnncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_v_post:nnncTF}{/:2}, ignore}
% \reset:n { Y }
% \__bnvs_if_resolve_v_post:nnncT {} { X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
      \prg_return_false:
  }
}
\BNVS_new_conditional_vvvc:cn { if_resolve_v_post } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_v_post:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_append_v_post:nnncTF } { #1 } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_v_post_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_v_post:nnnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v_post:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_post_nnncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_append_v_post:nnncTF}{/:1}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_post:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
%   \__bnvs_tl_set:cn { ans } { 2 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_post_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_v_post:nnncTF{/:2}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_post:nnncTF {} { X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 2 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 2222 } { 2' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { if_append_v_post } { T, F, TF }
\BNVS_new_conditional_vvvc:cn { if_append_v_post } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:cn={if_append_v_post:nnncTF}{/:*}, ignore, debug}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 888 }
% \__bnvs_if_append_v_post:nnncTF {} { X } { 999000 } { ans } {
%   \assert_equal_ans:nn { 888222 } { A }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 999222 } { A' }
%   } {
%     \test_fail:n { NO_WAY-A' }
%   }
% } {
%   \test_fail:n { NO_WAY-A }
% }
% \reset:n { Y }
% \Beanoves { ID!X=!FIRST}
% \__bnvs_tl_set:cn { ans } { 111 }
% \__bnvs_if_append_v_post:nnncTF { ID } { X } { 333000 }  { ans } {
%   \assert_equal_ans:nn { 111222 } { B }
%   \__bnvs_if_resolve_v:nncTF { ID } { X } { ans } {
%     \assert_equal_ans:nn { 333222 } { B' }
%   } {
%     \test_fail:n { NO_WAY-B' }
%   }
% } {
%   \test_fail:n { NO_WAY-B }
% }
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { TEST_A } { }
% \__bnvs_tl_set:cn { TEST_B } { X }
% \__bnvs_tl_set:cn { ans } { 444 }
% \__bnvs_if_append_v_post:vvncTF { TEST_A } { TEST_B } { 555000 }  { ans } {
%   \assert_equal_ans:nn { 444222 } { B }
%   \__bnvs_if_resolve_v:vvcTF { TEST_A } { TEST_B } { ans } {
%     \assert_equal_ans:nn { 555222 } { B' }
%   } {
%     \test_fail:n { NO_WAY-B' }
%   }
% } {
%   \test_fail:n { NO_WAY-B }
% }
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { TEST_A } { }
% \__bnvs_tl_set:cn { TEST_B } { X }
% \__bnvs_tl_set:cn { TEST_C } { 777000 }
% \__bnvs_tl_set:cn { ans } { 666 }
% \__bnvs_if_append_v_post:vvvcTF { TEST_A }  { TEST_B } { TEST_C } { ans } {
%   \assert_equal_ans:nn { 666222 } { C }
%   \__bnvs_if_resolve_v:vvcTF { TEST_A }  { TEST_B } { ans } {
%     \assert_equal_ans:nn { 777222 } { C' }
%   } {
%     \test_fail:n { NO_WAY-C' }
%   }
% } {
%   \test_fail:n { NO_WAY-C }
% }
% \end{BNVS.test}
% \begin{function} [TF] {
%   \__bnvs_if_resolve_n_incr:nnnnc,
%   \__bnvs_if_resolve_n_incr:nnnc,
%   \__bnvs_if_append_n_incr:nnnnc,
%   \__bnvs_if_append_n_incr:nnnc,
%   \__bnvs_if_append_n_incr:vvnc,
%   \__bnvs_if_resolve_n_post:nnnc,
%   \__bnvs_if_append_n_post:nnnc,
%   \__bnvs_if_append_n_post:vvnc
%   }
% \begin{syntax}
% \cs{__bnvs_if_resolve_n_incr:nnnncTF} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{base}} \KWNmarg{offset} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_resolve_n_incr:nnncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{offset} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_n_incr:nnnncTF} \KWNmarg{id} \KWNmarg{tag} \marg{\textsl{base}} \KWNmarg{offset} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_n_incr:nnncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{offset} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Increment the implicit |n| counter accordingly.
% When requested, put the resulting index in the \KWNmeta{ans} tl variable or append to its right.
% This is not run in a group.
% \end{function}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnnc}{/:*}, ignore}
% \reset:n{ YES }
% \Beanoves{ X = 123 }
% \__bnvs_if_resolve_n:nncTF {} { X } { ans } {
%   \assert_equal_ans:nn { 1 } { A }
% } {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_if_resolve_n_index:nncTF {} { X } { ans } {
%   \assert_equal_ans:nn { 123 } { B }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Beanoves{ X = 123 }
% \__bnvs_if_resolve_n_incr:nnncTF {} { X } { 123 } { ans } {
%   \assert_equal_ans:nn { 246 } { C }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Test_if_append_n_incr:nnnnnn { 123 } {} {X} { 123 } { 246 } { 1 }
% \Test_if_get:nnnnnn {} n {} {} { 124 } { 2 }
% \Test_if_append_n_incr:nnnnnn { 123 } {} {X} { 500+40+3 } { 666 } { 3 }
% \reset:n { YES }
% \Test_if_append_n_incr:nnnnnn { FIRST } {} {X} { LENGTH-1 } { 666 } { 4 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_incr:nnnc } #1 #2 #3 #4 { T, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_resolve_n_incr:nnncTF } { #1 } { #2 } { OF7 } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
% Resolve the \meta{\textsl{offset}} into the \KWNmeta{ans} variable.
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #3 } { #4 } {
    \BNVS_tl_use:Nv \int_compare:nNnTF { #4 } = 0 {
%    \end{macrocode}
% The offset is resolved to $0$, we just have to resolve the |...n|
%    \begin{macrocode}
      \__bnvs_if_resolve_n:nncTF { #1 } { #2 } { #4 } {
        \__bnvs_if_resolve_index:nnvcTF { #1 } { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:1}, ignore}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nnncTF { } { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{BNVS.test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:2}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nnncT { !X } { !X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
%    \end{macrocode}
% The \meta{\textsl{offset}} does not resolve to \(0\).
%    \begin{macrocode}
      \__bnvs_tl_put_right:cn { #4 } { + }
      \__bnvs_if_append_n:nncTF { #1 } { #2 } { #4 } {
        \__bnvs_round:c { #4 }
        \__bnvs_gset:nnnv n { #1 } { #2 } { #4 }
        \__bnvs_if_resolve_index:nnvcTF { #1 } { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:3}, ignore}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nnncTF { } { X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{BNVS.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:4}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nnncT { !X } { !X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bvs:cn={if_resolve_n_incr:nnncTF}{/:5}, ignore}
% \reset:n{ YES }
% \end{BNVS.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:6}, ignore}
% \reset:n{ YES }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn
  { if_append_n_incr:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_append_n_incr:nnncTF } { #1 } { #2 } { OF7 } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_incr:nnnc }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_incr:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_append_n_incr:nnncTF}{/:1}, ignore}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncTF {} { X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_append_n_incr:nnncTF}{/:2}, ignore}
% \reset:n{ YES }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncT { !X } { !X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncT { !X } { !X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { if_append_n_incr } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function} [TF] {
%   \__bnvs_if_resolve_v_post:nnnc,
%   \__bnvs_if_append_v_post:nnnc,
%   \__bnvs_if_append_v_post:vvnc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_v_post:nnncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{offset} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append_v_post:nnncTF} \KWNmarg{id} \KWNmarg{tag} \KWNmarg{offset} \KWNmeta{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% Resolve the value of the free counter for the given \KWNmeta{tag} into
% the \KWNmeta{ans} |tl| variable then increment this free counter position
% accordingly.
% The append version, appends the value to the right of the \KWNmeta{ans} |tl| variable.
% The content of \KWNmeta{ans} is undefined
% while in the \KWNmeta{no code} branch and on resolution only.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_post:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_resolve_n_post_nnncTF } { #1 } { #2 } { OF7 } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:nncTF { #1 } { #2 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve_n_post:nnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve:ncTF { #3 } { #4 } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { #4 } = 0 {
        \BNVS_end:
        \__bnvs_if_resolve_index:nnvcTF { #1 } { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_n_post:nnncTF{/:1}, ignore}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_post:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
%   \__bnvs_if_resolve_n_index:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{BNVS.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
        \__bnvs_tl_put_right:cn { #4 } { + }
        \__bnvs_if_append_n:nncTF { #1 } { #2 } { #4 } {

          \__bnvs_round:c { #4 }
          \__bnvs_gset:nnnv n { #1 } { #2 } { #4 }
          \BNVS_end:
          \__bnvs_if_resolve_index:nnvcTF { #1 } { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:nc a { #4 }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_n_post:nnncTF{/:2}, ignore}
% \reset:n { YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_post:nnncTF {} { X } { 111000 } { ans } {
%   \assert_equal_ans:nn { 222 } {2-A}
%   \__bnvs_if_resolve_n_index:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 111222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS.test}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_n_post:nnncTF{/:22'}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nnncT {} { X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS.test}
%    \begin{macrocode}
            \prg_return_false:
          }
        } {
          \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_resolve_n_post:nnncTF{/:3}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nnncT {} {X} { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      }
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_resolve_n_post:nnncTF{/:4}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nnncT {} {X} { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nnncTF:nn { ... } { ...FALSE/D }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_resolve_n_post:nnncTF{/:5}, ignore}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nnncT {} {X} { 2000 } { ans } {
%   \test_fail:n { NO_WAY/5-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_post:nnnc } #1 #2 #3 #4{ T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set_IT:ncnnnnc a { if_append_n_post_nnncTF } { #1 } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_n_post_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_post:nnncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_post:nnncTF { #1 } { #2 } { #3 } { #4 } {
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_post_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_n_post:nnncTF{/:1}, ignore}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 111 }
% \__bnvs_if_append_n_post:nnncTF {} { X } { 0 } { ans } {
%   \assert_equal_ans:nn { 111222 } {1-A}
%   \__bnvs_if_resolve_n_index:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 111 }
% \__bnvs_if_append_n_post:nnncTF {} { X } { 333000 } { ans } {
%   \assert_equal_ans:nn { 111222 } {2-A}
%   \__bnvs_if_resolve_n_index:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 333222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_post_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_n_post:nnncTF{/:2}, ignore}
% \reset:n{ YES }
% \__bnvs_if_append_n_post:nnncT {} { X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \reset:n{ YES }
% \__bnvs_if_append_n_post:nnncT {} { X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { if_append_n_post } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:Nn=\__bnvs_if_append_v_post:nnncTF{/:*}, ignore}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 111 }
% \__bnvs_if_append_v_post:nnncTF {} { X } { 333000 } { ans } {
%   \assert_equal_ans:nn { 111222 } { A-1 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 333222 } { A-2 }
%   } {
%     \test_fail:n { NO_WAY-A-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-A-4 }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { TEST_A } { }
% \__bnvs_tl_set:cn { TEST_B } { X }
% \__bnvs_if_append_v_post:vvncTF { TEST_A } { TEST_B } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 2222 } { B-1 }
%   \__bnvs_if_resolve_v:nncTF {} { X } { ans } {
%     \assert_equal_ans:nn { 2222 } { B-2 }
%   } {
%     \test_fail:n { NO_WAY-B-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-B-4 }
% }
% \end{BNVS.test}
%
% \subsection{Functions for the resolution }
% They manily start with |\__bnvs_if_resolve_| or |\__bnvs_split_|
%
% \begin{function}{
%   \__bnvs_split_pop_iksp:TFF,
%   \__bnvs_split_end_return_or_pop_complete:T,
%   \__bnvs_split_end_return_or_pop_void:T,
% }
% \begin{syntax}
% \cs{__bnvs_split_pop_iksp:TFF} \marg{\textsl{black code}} \marg{blank code} \marg{\textsl{end code}}
% \cs{__bnvs_split_end_return_or_pop_complete:T} \marg{blank code}
% \cs{__bnvs_split_end_return_or_pop_void:T} \marg{\textsl{black code}}
% \end{syntax}
% For |\__bnvs_split_pop_iksp:TFF|.
% If the |split| sequence is empty, execute \meta{end code}.
% Otherwise pops the 4 heading items of the |split| sequence into
% the four |tl| variables |id|, |kri|, |short|, |path|.
% If |short| is blank then execute \KWNmeta{blank code}, otherwise execute
% \KWNmeta{black code}.
%
% For |\__bnvs_split_end_return_or_pop_complete:T|: pops the four heading items of
% the |split| sequence into the four variables
% |n_incr|, |plus|, |rhs|, |post|.
% Then execute \KWNmeta{black code}.
%
% For |\__bnvs_split_end_return_or_pop_void:T|: pops the eight heading items of
% the |split| sequence then execute \KWNmeta{blank code}.
%
% This is called each time a |ref|, |id|, |path| has been parsed.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_pop_iksp:TFF } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...POP~IKSP... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_split_if_pop_left:cTF { id } {
    \__bnvs_split_if_pop_left:cTF { kri } {
      \__bnvs_split_if_pop_left:cTF { short } {
        \__bnvs_split_if_pop_left:cTF { path } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...POPED~IKSP... }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
          \__bnvs_tl_if_blank:vTF { short } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The first 4 capture groups are empty,
% and the 4 next ones are expected to contain the expected information.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...COMPLETE/1... }
\BNVS_DEBUG_log_tl:nc s { id }
\BNVS_DEBUG_log_tl:nc s { kri }
\BNVS_DEBUG_log_tl:nc s { short }
\BNVS_DEBUG_log_seq:nxc s { \BNVS_tl_use:c { path } } { path }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
            #2
          } {
            \BNVS_tl_use:nv {
              \regex_match:NnT \c__bnvs_A_reserved_Z_regex
            } { short } {
              \__bnvs_tl_if_eq:cnF { short } { pauses } {
                \__bnvs_tl_if_eq:cnF { short } { slideinframe } {
\BNVS_error:x { Use~of~reserved~``\BNVS_tl_use:c { tag }'' }
                }
              }
            }
            \__bnvs_tl_if_blank:vTF { kri } {
              \__bnvs_tl_set:cv { id } { id_last }
            } {
              \__bnvs_tl_set:cv { id_last } { id }
            }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Build the |path| sequence and lowercase components conditionals.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
            \__bnvs_seq_set_split:cnv { path } { . } { path }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...COMPLETE/2... }
\BNVS_DEBUG_log_tl:nc s { id }
\BNVS_DEBUG_log_tl:nc s { kri }
\BNVS_DEBUG_log_tl:nc s { short }
\BNVS_DEBUG_log_seq:nxc s { \BNVS_tl_use:c { path } } { path }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
            #1
          }
        } {
          \BNVS_fatal:n { split_pop_iksp:TFF/path }
        }
      } {
        \BNVS_fatal:n { split_pop_iksp:TFF/short }
      }
    } {
      \BNVS_fatal:n { split_pop_iksp:TFF/kri }
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...EMPTY }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    #3
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% conditional variants.
%
% \begin{BNVS.test}{bnvs:c=split_pop_iksp:TFF, ignore}
% \BNVS_DEBUG_log_set:ncn a { if_resolve:ncTF } {}
% \cs_set:Npn \BNVS_fatal:n #1 {
%   \__bnvs_tl_set:cn { ans } { #1 }
% }
% \cs_set:Npn \BNVS_Test:w #1 #2 #3 #4 #5 #6 #7 {
%   \__bnvs_tl_clear:c { ans   }
%   \__bnvs_tl_clear:c { id    }
%   \__bnvs_tl_clear:c { kri   }
%   \__bnvs_tl_clear:c { short }
%   \__bnvs_tl_clear:c { path  }
%   \tl_if_empty:nTF { #1 } {
%     \__bnvs_seq_clear:c { split }
%   } {
%     \__bnvs_seq_set_split:cnn { split } { . } { #1 }
%   }
%   \BNVS_DEBUG_log_seq:nc * { split }
%   \__bnvs_split_pop_iksp:TFF {
%   \typeout{FIRST}
%     \__bnvs_tl_set:cn { ans } { FIRST  }
%   } {
%     \__bnvs_tl_set:cn { ans } { SECOND }
%   } {
%     \__bnvs_tl_set:cn { ans } { THIRD  }
%   }
%   \assert_equal_ans:nn { #2 } { #7/ans }
%   \assert_equal_tl:vnn { id    } { #3 } { #7/id   }
%   \assert_equal_tl:vnn { kri   } { #4 } { #7/kri  }
%   \assert_equal_tl:vnn { short } { #5 } { #7/short   }
%   \assert_equal_tl:vnn { path  } { #6 } { #7/path }
% }
% \BNVS_Test:w { 1     } { split_pop_iksp:TFF/kri   } { 1 } {   } {   } { } { p }
% \BNVS_Test:w { 1.2   } { split_pop_iksp:TFF/short } { 1 } { 2 } {   } { } { p }
% \BNVS_Test:w { 1.2.3 } { split_pop_iksp:TFF/path  } { 1 } { 2 } { 3 } { } { p }
% \BNVS_Test:w { 1.2.3.4 } { FIRST  } { 1 } { 2 } { 3 } { 4 } { 1 }
% \BNVS_Test:w { 1.2. .4 } { SECOND } { 1 } { 2 } {   } { 4 } { 2 }
% \BNVS_Test:w {         } { THIRD  } {   } {   } {   } {   } { 3 }
% \cs_undefine:N \BNVS_Test:w
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_end_return_or_pop_complete:T } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { / split_end_return_or_pop_complete:T }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \cs_set:Npn \BNVS_split_F:n ##1 {
    \BNVS_end_unreachable_return_false:n {
      split_end_return_or_pop_complete: ##1
    }
  }
  \__bnvs_split_if_pop_left_or:cT { n_incr } {
    \__bnvs_split_if_pop_left_or:cT { plus } {
      \__bnvs_split_if_pop_left_or:cT { rhs } {
        \__bnvs_split_if_pop_left_or:cT { post } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { / return_or_pop_complete:T }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
          #1
        }
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_end_return_or_pop_void:T } #1 {
  \cs_set:Npn \BNVS_split_F:n ##1 {
    \BNVS_end_unreachable_return_false:n {
      split_end_return_or_pop_void: ##1
    }
  }
  \__bnvs_split_if_pop_left:cTn { a } {
    \__bnvs_split_if_pop_left:cTn { a } {
      \__bnvs_split_if_pop_left:cTn { a } {
        \__bnvs_split_if_pop_left:cTn { a } {
          \__bnvs_split_if_pop_left:cTn { a } {
            \__bnvs_split_if_pop_left:cTn { a } {
              \__bnvs_split_if_pop_left:cTn { a } {
                \__bnvs_split_if_pop_left:cTn { a } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { split_end_return_or_pop_void:T }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
                  #1
                } { T/8 }
              } { T/7 }
            } { T/6 }
          } { T/5 }
        } { T/4 }
      } { T/3 }
    } { T/2 }
  } { T/1 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve:nc,
%   \__bnvs_if_resolve:vc,
%   \__bnvs_if_append:nc,
%   \__bnvs_if_append:vc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve:ncTF} \marg{\textsl{expression}} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \cs{__bnvs_if_append:ncTF} \marg{\textsl{expression}} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Resolves the \meta{\textsl{expression}},
% replacing all the named overlay specifications by their static
% counterpart then put the rounded result in \KWNmeta{ans} |tl| variable when resolving or to
% the right of this variable when appending.
% 
% Implementation details. Executed within a group.
% Heavily used by \cs{..._if_resolve_query:ncTF}, where \meta{\textsl{expression}}
% was initially enclosed inside `|?(...)|'.
% Local variables: 
% \begin{variable}{\l__bnvs_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l__bnvs_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l__bnvs_split_int }
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_int_new:c { split }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{variable}{\l__bnvs_tag_tl}
%    Storage for |split| sequence items that represent names.
% \end{variable}
% \begin{variable}{\l__bnvs_path_tl}
%    Storage for |split| sequence items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% Open a main \TeX\ group to define local functions and variables,
% sometimes another grouping level is used.
% The main \TeX\ group is closed in the various \cs{...end_return...} functions.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append:nc } #1 #2 { TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_append:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append:nc }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}

% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vc:cn { if_append } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
% Heavily used.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_unreachable_return_false:n #1 {
  \BNVS_error:n { UNREACHABLE/#1 }
  \BNVS_end:
  \prg_return_false:
}
\cs_new:Npn \BNVS_end_unreachable_return_false:x #1 {
  \BNVS_error:x { UNREACHABLE/#1 }
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve:nc } #1 #2 { TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_resolve:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_call:TF {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve:ncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% This \TeX\ group will be closed just before returning.
% Implementation:
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \__bnvs_if_regex_split:cnTF { split } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...SPLIT... }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% The leftmost item is not a special item: we start feeding |\l__bnvs_ans_tl| with it.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \BNVS_set:cpn { if_resolve_end_return_true: } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% Normal and unique end of the loop.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_round_ans:
        \BNVS_end_tl_set:cv { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...FINAL_TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
%    \end{macrocode}
% Ranges are not rounded: for them |\...if_resolve_round_ans:| is a noop.
%    \begin{macrocode}
      \BNVS_set:cpn { if_resolve_round_ans: } { \__bnvs_round:c { ans } }
      \__bnvs_tl_clear:c { ans }
      \__bnvs_split_loop_or_end_return:
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ...TRUE/DIRECT }
%</!final>
% \end{BNVS.gobble}
% There is not reference.
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{none}, ignore}
% \Test_if_resolve:nnnn {} { 400+20+1 } { 421 } { 1 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_tl_set:cn { ans } { #1 }
      \__bnvs_round:c { ans }
      \BNVS_end_tl_set:cv { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_tl:nc a { ans }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:     
    }
  } {
    \BNVS_error:n { TOO_MANY_NESTED_CALLS/Resolution }
    \BNVS_end:
    \prg_return_false:
  }
}
\BNVS_new_conditional_vc:cn { if_resolve } { T, F, TF }
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { build_tag: } {
  \__bnvs_tl_set_eq:cc { tag } { short }
  \__bnvs_seq_map_inline:cn { path } {
    \__bnvs_tl_put_right:cn { tag} { . ##1 }
  } 
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nc a { build_tag: }
\BNVS_DEBUG_log_tl:nc a { tag }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { build_tag_head: } {
  \__bnvs_tl_set_eq:cc { tag } { short }
  \__bnvs_seq_map_inline:cn { path_head } {
    \__bnvs_tl_put_right:cn { tag } { . ##1 }
  } 
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nc a { build_tag_head: }
\BNVS_DEBUG_log_tl:nc a { tag }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{function}{
%   \__bnvs_split_loop_or_end_return:
% }
% \begin{syntax}
% \cs{__bnvs_split_loop_or_end_return:}
% \end{syntax}
% Manages the |split| sequence created by the |...if_resolve_query:...| conditional.
% Entry point. May call itself at the end.
% The first step is to collect the various information into variables.
% Then we separate the trailing lowercase components of the path and act accordingly.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\clist_map_inline:nn {
  n, reset, reset_all, v, first, last, length,
  previous, next, range, assign, only
} {
  \bool_new:c { l__bnvs_#1_bool }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if:c } #1 { p, T, F, TF } {
  \bool_if:cTF { l__bnvs_#1_bool } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { bool_if_exist:c } #1 { p, T, F, TF } {
  \bool_if_exist:cTF { l__bnvs_#1_bool } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { prepare_context:N } #1 {
  \clist_map_inline:nn {
    n, v, reset, reset_all, first, last, length,
    previous, next, range, assign, only
  } {
    \__bnvs_set_false:c { ##1 }
  }
  \__bnvs_seq_clear:c { path_head }
  \__bnvs_seq_clear:c { path_tail }
  \__bnvs_tl_clear:c { index }
  \__bnvs_tl_clear:c { suffix }
  \BNVS_set:cpn { :n } ##1 {
    \tl_if_blank:nF { ##1 } {
      \__bnvs_tl_if_empty:cF { index } {
      	  \__bnvs_seq_put_right:cv { path_head } { index }
        \__bnvs_tl_clear:c { index }
      }
      \__bnvs_seq_put_right:cn { path_head } { ##1 }
    }
  }
  \__bnvs_seq_map_inline:cn { path } {
    \__bnvs_bool_if_exist:cTF { ##1 } {
      \__bnvs_set_true:c { ##1 }
      \clist_if_in:nnF { n, v, reset, reset_all } { ##1 } {
        \bool_if:NT #1 {
          \BNVS_error:n {Unexpected~##1~in~assignment }
        }
        \__bnvs_tl_set:cn { suffix } { ##1 }
      }
      \BNVS_set:cpn { :n } ####1 {
        \tl_if_blank:nF { ####1 } {
          \BNVS_error:n {Unexpected~####1 }
        }
      }
    } {
      \regex_match:NnTF \c__bnvs_A_index_Z_regex { ##1 } {
        \__bnvs_tl_if_empty:cF { index } {
        	\__bnvs_seq_put_right:cv { path_head } { index }
        }
        \__bnvs_tl_set:cn { index } { ##1 }
      } {
        \regex_match:NnTF \c__bnvs_A_reserved_Z_regex { ##1 } {
          \BNVS_error:n { Unsupported~##1 }
        } {
          \__bnvs_:n { ##1 }
        }
      }
    }
  }
  \__bnvs_seq_set_eq:cc { path } { path_head }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...SPLIT~LOOP... }
\BNVS_DEBUG_log_seq:nc a { split }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_split_if_pop_left:cTF { a } {
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_split_pop_iksp:TFF {
      \__bnvs_split_end_return_or_pop_void:T {
        \__bnvs_prepare_context:N \c_true_bool
        \__bnvs_build_tag:
        \__bnvs_split_loop_or_end_return_iadd:n { 1 }
      }
    } {
      \__bnvs_split_pop_iksp:TFF {
        \__bnvs_split_end_return_or_pop_complete:T {
          \__bnvs_tl_if_blank:vTF { n_incr } {
            \__bnvs_tl_if_blank:vTF { plus } {
              \__bnvs_tl_if_blank:vTF { rhs } {
                \__bnvs_tl_if_blank:vTF { post } {
                  \__bnvs_prepare_context:N \c_false_bool
                  \__bnvs_build_tag:
%    \end{macrocode}
% \end{BNVS.macrocode}
% Only the dotted path, branch according to the last component, if any.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
                  \__bnvs_tl_if_empty:cTF { index } {
                    \__bnvs_tl_if_empty:cTF { suffix } {
                      \__bnvs_split_loop_or_end_return_v:
                    } {
                      \__bnvs_split_loop_or_end_return_suffix:
                    }
                  } {
                    \__bnvs_split_loop_or_end_return_index:
                  }
                } {
                  \__bnvs_prepare_context:N \c_true_bool
                  \__bnvs_build_tag:
                  \BNVS_use:c { split_loop_or_end_return[...++]: }
                }
              } {
                \__bnvs_prepare_context:N \c_true_bool
                \__bnvs_build_tag:
                \__bnvs_split_loop_or_end_return_assign:
              }
            } {
              \__bnvs_if_resolve:vcTF { rhs } { rhs } {
                \__bnvs_prepare_context:N \c_true_bool
                \__bnvs_build_tag:
                \BNVS_tl_use:Nv
                  \__bnvs_split_loop_or_end_return_iadd:n { rhs }
              } {
                \BNVS_error_ans:x { Error~in~\BNVS_tl_use:c { rhs }}
                \__bnvs_split_loop_or_end_return:
              }
            }
          } {
            \__bnvs_prepare_context:N \c_true_bool
            \__bnvs_build_tag:
            \__bnvs_set_true:c { n }
            \__bnvs_split_loop_or_end_return_iadd:n { 1 }
          }
        }
      } {
\BNVS_end_unreachable_return_false:n { split_loop_or_end_return:/3 }
      } {
\BNVS_end_unreachable_return_false:n { split_loop_or_end_return:/2 }
      }
    } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% The |split| sequence is empty.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \__bnvs_if_resolve_end_return_true:
    }
  } {
\BNVS_end_unreachable_return_false:n { split_loop_or_end_return:/1 }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_suffix: } { T, F, TF } {
  \__bnvs_tl_if_empty:cTF { suffix } {
    \__bnvs_seq_pop_right:ccTF { path } { suffix } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% Implementation detail: |tl| variable |a| is used.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { if_resolve_V_loop_or_end_return_true:F } #1 {
 
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { error_end_return_false:n } #1 {
  \__bnvs_build_tag:
  \__bnvs_tl_set:cx { a } {
     \BNVS_tl_use:c { tag } . \BNVS_tl_use:c { suffix }
  }
  \__bnvs_if_resolve_v:vvcTF { id } { a } { a } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(v) }
\BNVS_DEBUG_log_tl:nc a { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_split_loop_or_end_return:
  } {
    \__bnvs_if_resolve_V:vvcTF { id } { a } { a } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(V) }
\BNVS_DEBUG_log_tl:nc a { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_tl_put_right:cv { ans } { a }
      \__bnvs_split_loop_or_end_return:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...FALSE/... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      #1
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_branch_loop_or_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...BRANCH~LOOP }
\BNVS_DEBUG_log_tl:nc a { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_if_call:TF {
    \__bnvs_if_path_branch:TF {
      \__bnvs_path_branch_end_return:
    } {
      \__bnvs_if_get:nvvcTF V { id } { tag } { a } {
        \__bnvs_if_TIP:cccTF { id } { a } { path } {
          \__bnvs_tl_set_eq:cc { tag } { a }
          \__bnvs_seq_merge:cc { path } { path_tail }
          \__bnvs_seq_clear:c { path_tail }
          \__bnvs_seq_set_eq:cc { path_head } { path }
          \__bnvs_path_branch_TIPn_loop_or_end_return:
        } {
          \__bnvs_path_branch_head_to_tail_end_return:
        }
      } {
        \__bnvs_path_branch_head_to_tail_end_return:
      }
    }
  } {
    \__bnvs_path_branch_end_return_false:n {
      Too~many~calls.
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_branch_end_return: } {
  \__bnvs_split_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { set_if_path_branch:n } {
  \prg_set_conditional:Npnn \__bnvs_if_path_branch: { TF }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_branch_head_to_tail_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...HEAD->TAIL }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_seq_pop_right:ccTF { path_head } { a } {
    \__bnvs_seq_put_left:cv { path_tail } { a }
    \__bnvs_build_tag_head:
    \__bnvs_path_branch_TIPn_loop_or_end_return:
  } {
    \__bnvs_build_tag:
    \__bnvs_seq_set_eq:cc { path_head } { path_tail }
    \__bnvs_seq_clear:c { path_tail }
    \__bnvs_is_gset:nvxTF V { id } {
      \__bnvs_tl_use:c { tag }.1
    } {
      \__bnvs_tl_set:cn { index } { 1 }
      \__bnvs_split_loop_or_end_return_index:
    } {
      \__bnvs_gset:nvvn       V { id } { tag } { 0 }
      \__bnvs_gset_cache:nvvn V { id } { tag } { 0 }
      \__bnvs_path_branch_TIPn_loop_or_end_return:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% The \texttt{\textsl{a}} |tl| variable is used locally.
% Update the |QD| variable based on |ref| and |path|,
% then try to resolve it
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { path_branch_TIPn_loop_or_end_return: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../TIPn_loop }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_build_tag_head:
  \__bnvs_if_resolve_v:vvcTF { id } { tag } { a } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(v) }
\BNVS_DEBUG_log_tl:nc a { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_split_loop_or_end_return:
  } {
    \__bnvs_if_resolve_V:vvcTF { id } { tag } { a } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(V) }
\BNVS_DEBUG_log_tl:nc a { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \__bnvs_tl_put_right:cv { ans } { a }
      \__bnvs_split_loop_or_end_return:
    } {
      \__bnvs_path_branch_loop_or_end_return:
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% 
% \begin{myList}
% \item Case \texttt{....\meta{\textsl{index}}}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return_index: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: a => append or resolve
%<*!final>
\BNVS_DEBUG_log:nx a { ▃▃▃▃▃~CASE~....<index> }
\BNVS_DEBUG_log_tl:nc a { index }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/....<index>}, ignore}
% \Test_if_resolve:nnnn { 222 } { X.1 } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X.1 } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X.1 } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X.1 } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X.1 } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X.1 } { 1 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.1 } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X.1 } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X.1 } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.1 } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.1 } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X.1 } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.1 } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X.1 } { 1 } { 1-d' }
% \end{BNVS.test}
%    \begin{macrocode}
  % known, id, tag, path, suffix
  \__bnvs_set_if_path_branch:n {
    \__bnvs_if_append_index:vvvcTF { id } { tag } { index } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { /....<index> }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
  \__bnvs_path_branch_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_reset: } {
  \__bnvs_if:cT { reset_all } {
    \__bnvs_set_false:c { reset_all }
    \__bnvs_greset_cache:
  }  
  \__bnvs_if:cT { reset } {
    \__bnvs_set_false:c { reset }
    \__bnvs_gunset:nvv v { id } { tag }
  }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn a {} { split_loop_reset: } {...DONE}
\BNVS_DEBUG_log_tl:nc a { id }
\BNVS_DEBUG_log_tl:nc a { tag }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{...}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return_v: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx a { ▃▃▃▃▃~CASE~... }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/...}, ignore}
% \Test_if_resolve:nnnn { 222 } { X } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X } { 1 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X } { 1 } { 1-d' }
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_split_loop_reset:
  \__bnvs_set_if_path_branch:n {
    \__bnvs_if_append_v:vvcTF { id } { tag } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../OK(v) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_if_append_V:vvcTF { id } { tag } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../OK(V) }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
  \__bnvs_path_branch_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{....<suffix>}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return_suffix: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx a { ▃▃▃▃▃~CASE~....\__bnvs_tl_use:c { suffix } }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/length}, ignore}
% \Test_if_resolve:nnnn { 222::445 } { X.length } { 445 } { 1 }
% \Test_if_resolve:nnnn { 222:666 } { X.length } { 445 } { 2 }
% \Test_if_resolve:nnnn { ::445:666 } { X.length } { 445 } { 3 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length } { 445 } { 4 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length } { 445 } { 5 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length } { 445 } { 6 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222::445 } { X.length+X.length } { 890 } { 1' }
% \Test_if_resolve:nnnn { 222:666 } { X.length+X.length } { 890 } { 2' }
% \Test_if_resolve:nnnn { ::445:666 } { X.length+X.length } { 890 } { 3' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length+X.length } { 890 } { 4' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length+X.length } { 890 } { 5' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length+X.length } { 890 } { 6' }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/.first}, ignore}
% \Test_if_resolve:nnnn { :666 } { X.first } { 1 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.first } { 222 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.first } { 222 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.first } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.first } { 1 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.first } { 222 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.first } { 222 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.first } { 222 } { 8 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :666 } { X.first / 2 } { 0 } { 1' }
% \Test_if_resolve:nnnn { 222::445 } { X.first / 2 } { 111 } { 2' }
% \Test_if_resolve:nnnn { 222:666 } { X.first / 2 } { 111 } { 3' }
% \Test_if_resolve:nnnn { ::445:666 } { X.first / 2 } { 111 } { 4' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.first / 2 } { 0 } { 5' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.first / 2 } { 111 } { 6' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.first / 2 } { 111 } { 7' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.first / 2 } { 111 } { 8' }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/.last}, ignore}
% \Test_if_resolve:nnnn { :666 } { X.last } { 666 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.last } { 666 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last } { 666 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last } { 666 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last } { 666 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last } { 666 } { 8 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :666 } { X.last / 2 } { 333 } { 1' }
% \Test_if_resolve:nnnn { 222::445 } { X.last / 2 } { 333 } { 2' }
% \Test_if_resolve:nnnn { 222:666 } { X.last / 2 } { 333 } { 3' }
% \Test_if_resolve:nnnn { ::445:666 } { X.last / 2 } { 333 } { 4' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last / 2 } { 333 } { 5' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last / 2 } { 333 } { 6' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last / 2 } { 333 } { 7' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last / 2 } { 333 } { 8' }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/.range}, ignore}
% \Test_if_resolve:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_if_resolve:nnnn { 222: } { X.range } { 222- } { 1' }
% \Test_if_resolve:nnnn { 222:: } { X.range } { 222- } { 1'' }
% \Test_if_resolve:nnnn { :666 } { X.range } { 1-666 } { 2 }
% \Test_if_resolve:nnnn { 222::445 } { X.range } { 222-666 } { 3 }
% \Test_if_resolve:nnnn { 222:666 } { X.range } { 222-666 } { 4 }
% \Test_if_resolve:nnnn { ::445:666 } { X.range } { 222-666 } { 5 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_if_resolve:nnnn { FIRST: } { X.range } { 222- } { 6' }
% \Test_if_resolve:nnnn { FIRST:: } { X.range } { 222- } { 6'' }
% \Test_if_resolve:nnnn { :LAST } { X.range } { 1-666 } { 7 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.range } { 222-666 } { 8 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.range } { 222-666 } { 9 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.range } { 222-666 } { 10 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/.previous}, ignore}
% \Test_if_resolve:nnnn { 222: } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::' } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.previous } { 221 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.previous } { 221 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5 }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5' }
% \Test_if_resolve:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.previous } { 221 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.previous } { 221 } { 8 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/.next}, ignore}
% \Test_if_resolve:nnnn { :666 } { X.next } { 667 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.next } { 667 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.next } { 667 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { X.next } { 667 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.next } { 667 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.next } { 667 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.next } { 667 } { 8 }
% \end{BNVS.test}
%    \begin{macrocode}
 \__bnvs_if_resolve_V_loop_or_end_return_true:F {
    \__bnvs_set_if_path_branch:n {
      \BNVS_use:c {
        if_append_ \__bnvs_tl_use:c { suffix } :vvcTF
      } { id } { tag } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../OK(<suffix>) }
\BNVS_DEBUG_tl:nc r { suffix }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
        \__bnvs_if:cT { range } {
          \BNVS_set:cpn { if_resolve_round_ans: } { }
        }
        \prg_return_true:
      } {
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{...++}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return[...++]: } {
  \__bnvs_if:cTF { reset } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{....reset++}.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn a { ▃▃▃▃▃~CASE~....reset++ }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/....reset++}, ignore}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 3-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 4-a }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 5-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 6-a }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 7-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 8-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \BNVS_split_loop: {
      NO~....reset++~for
        ~\BNVS_tl_use:c { id }!\BNVS_tl_use:c { tag }
    }
  } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{...(.reset_all)++}.
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn a { ▃▃▃▃▃~CASE~...(.reset_all)++ }
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/...reset_all++}, ignore}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \BNVS_split_loop: {
      \BNVS_error_ans:x {
        NO~...(.reset_all)++~for
          ~\BNVS_tl_use:c { id }!\BNVS_tl_use:c { tag }
      }
    }
  }
  \__bnvs_build_tag:
  \__bnvs_split_loop_reset:
  \__bnvs_if_append_v_post:vvncTF { id } { tag } { 1 } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn a { ▃▃▃▃▃~OK~post }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  } {
    \BNVS_error_ans:x {
      Problem~with~\BNVS_tl_use:c { id }!\BNVS_tl_use:c { tag }~use.
    }
  }
  \__bnvs_split_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return_assign: } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{...=...}.
% Resolve the |rhs|, on success make the assignment and put the result to the right of
% the |ans| variable.
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{...=...}, ignore}
% \Test_if_resolve:nnnn { } { X = 444 } { 444 } { 1 }
% \Test_if_resolve:nnnn { } { X } { 444 } { 2 }
% \Test_if_resolve:nnnn { } { X = -555 } { -555 } { 3 }
% \Test_if_resolve:nnnn { } { X } { -555 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { } { X = 444 } { 444 } { A }
% \Test_if_resolve:nnnn { } { X } { 444 } { B }
% \Test_if_resolve:nnnn { } { X = (LENGTH - 1) } { 444 } { 7 }
% \Test_if_resolve:nnnn { } { X } { 444 } { 8 }
% \Test_if_resolve:nnnn { } { X = (-(LENGTH-1)) } { -444 } { 9 }
% \Test_if_resolve:nnnn { } { X } { -444 } { 10 }
% \Test_if_resolve:nnnn { } { X = LENGTH - 1 } { 444 } { 11 }
% \Test_if_resolve:nnnn { } { X } { 444 } { 12 }
% \Test_if_resolve:nnnn { } { X = LENGTH ~ - 1 } { 444 } { 13 }
% \Test_if_resolve:nnnn { } { X } { 445 } { 14 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { rhs } { rhs } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nn a { ▃▃▃▃▃~CASE~...=... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_gset:nvvv v { id } { tag } { rhs }
    \__bnvs_if_append_v:vvcTF { id } { tag } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { /...=... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    } {
      \BNVS_error_ans:n { No~...=... }
    }
  } {
    \BNVS_error_ans:x { Error~in~\__bnvs_tl_use:c { rhs }. }
  }
  \__bnvs_split_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \item Case \texttt{...+=...}.
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{...+=...}, ignore}
% \Test_if_resolve:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_if_resolve:nnnn { } { FIRST } { 222 } { B }
% \Test_if_resolve:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 8 }
% \Test_if_resolve:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 10 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 12 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 13 }
% \Test_if_resolve:nnnn { } { X } { 667 } { 14 }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/++X.reset}, ignore}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset } { 223 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST+1 } { ++X } { 224 } { 1-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { ++X } { 225 } { 3-b }
% \Test_if_resolve:nnnn { } { X  } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { ++X.reset } { 224 } { 5-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 6-b }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/reset_all}, ignore}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 223 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 223 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{BNVS.test}
% \begin{BNVS.test}{bnvs:cn={if_resolve:ncTF}{/++X}, ignore}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N } { 112 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N } { 112 } { 4-b }
% \Test_if_resolve:nnnn { } { B } { 111 } { 5-b }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { split_loop_or_end_return_iadd:n } #1 {
  \__bnvs_if_resolve:ncTF { #1 } { rhs } {
    \__bnvs_split_loop_reset:
    \__bnvs_if_append_v_incr:vvncTF { id } { tag } { #1 } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...+=... }
\BNVS_DEBUG_log_tl:nc a { id }
\BNVS_DEBUG_log_tl:nc a { tag }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    } {
      \BNVS_error_ans:n { No~...+=... }
    }
  } {
    \BNVS_error_ans:x { Error~in~\BNVS_tl_use:c { rhs } }
  }
  \__bnvs_split_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% 
% \end{myList}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_query:nc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_query:ncTF} \KWNmarg{overlay query} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of te \KWNmeta{ans} |tl| variable.
% Ranges are supported with the colon syntax.
% This is executed within a local \TeX\ group managed by the caller.
% Below are local variables and constants.
% \begin{variable}{\l__bnvs_V_tl}
% Storage for a single value out of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_A_tl}
% Storage for the first component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_Z_tl}
% Storage for the last component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_L_tl}
% Storage for the length component of a range.
% \end{variable}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_end_return_true: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_true:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_end_return_false: } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return_false:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \prg_return_false:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_error_return_false:n } #1 {
  \BNVS_error:n { #1 }
  \__bnvs_if_resolve_query_return_false:
}
\BNVS_generate_variant:cn { resolve_query_error_return_false:n } { x }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return_unreachable: } {
  \__bnvs_resolve_query_error_return_false:n { UNREACHABLE }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_blank:cTF } #1 {
  \BNVS_tl_use:Nc \tl_if_blank:VTF { #1 }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_match_pop_left:c } #1 { T, F, TF } {
  \BNVS_tl_use:nc {
    \BNVS_seq_use:Nc \seq_pop_left:NNTF { match }
  } { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
% DEBUG type: m => match
%<*!final>
\BNVS_DEBUG_log_f:nncn m { } { if_match_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:nc m { #1 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nncn m { } { if_match_pop_left:cTF } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_set:cpn { if_match_pop_left:cT } #1 #2 {
  \__bnvs_if_match_pop_left:cTF
    { #1 } { #2 } { \__bnvs_if_resolve_query_return_unreachable: }
}
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.test}{bnvs:c={if_match_pop_left:cTF}, ignore}
% \__bnvs_seq_clear:c { match }
% \__bnvs_seq_put_right:cn { match } { SUCCESS }
% \__bnvs_if_match_pop_left:cTF { A } {
%   \__bnvs_tl_if_eq:cnF { A } { SUCCESS } {
%     \test_fail:n { A/1 }
%   }
% } {
%   \test_fail:n { A/2 }
% }
% \end{BNVS.test}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_query_branch:
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_query_branch:TF} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% Called by |\__bnvs_if_resolve_query:ncTF| that just filled |\l__bnvs_match_seq| after the |c__bnvs_A_cln_Z_regex|.
% Puts the proper items of |\l__bnvs_match_seq| into the variables
% |\l__bnvs_V_tl|, |\l__bnvs_A_tl|, |\l__bnvs_Z_tl|, |\l__bnvs_L_tl|
% then branches accordingly on one of the returning\\
% |\__bnvs_if_resolve_query_return[|\meta{description}|]:|\\ functions.
% All these functions properly set the |\l__bnvs_ans_tl| variable and they end with either
% |\prg_return_true:| or |\prg_return_false:|.
% This is used only once but is not inlined for readability.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_query_branch: } { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...MATCH~BRANCH... }
%</!final>
% \end{BNVS.gobble}
% At start, we ignore the whole match.
%    \begin{macrocode}
  \__bnvs_if_match_pop_left:cT V {
    \__bnvs_if_match_pop_left:cT V {
      \__bnvs_if_blank:cTF V {
        \__bnvs_if_match_pop_left:cT A {
          \__bnvs_if_match_pop_left:cT Z {
            \__bnvs_if_match_pop_left:cT L {
              \__bnvs_if_blank:cTF A {
                \__bnvs_if_match_pop_left:cT L {
                  \__bnvs_if_match_pop_left:cT Z {
                    \__bnvs_if_blank:cTF L {
                      \__bnvs_if_match_pop_left:cT Z {
                        \__bnvs_if_match_pop_left:cT L {
                          \__bnvs_if_blank:cTF L {
                            \BNVS_use:c { if_resolve_query_return[:Z]: }
                          } {
                            \BNVS_use:c { if_resolve_query_return[:Z::L]: }
                          }
                        }
                      }
                    } {
                      \__bnvs_if_blank:cTF Z {
\__bnvs_resolve_query_error_return_false:n { Missing~first~or~last }
                      } {
                        \BNVS_use:c { if_resolve_query_return[:Z::L]: }
                      }
                    }
                  }
                }
              } {
                \__bnvs_if_blank:cTF Z {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { if_resolve_query_return[A:]: }
                  } {
                    \BNVS_use:c { if_resolve_query_return[A::L]: }
                  }
                } {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { if_resolve_query_return[A:Z]: }
                  } {
%    \end{macrocode}
% Logically unreachable code, the regular expression does not match this.
%    \begin{macrocode}
                    \__bnvs_if_resolve_query_return_unreachable:
                  }
                }
              }
            }
          }
        }
      } {
        \BNVS_use:c { if_resolve_query_return[V]: }
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} Single value
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[V]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[V]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { V } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[V]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { V } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[V]...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[V]...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{\KWNmeta{first}:\KWNmeta{last}} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[A:Z]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[A:Z]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \__bnvs_if_append:vcTF { Z } { ans } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...TRUE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{\KWNmeta{first}::\KWNmeta{length}} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[A::L]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[A::L]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { A } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { A }
      \__bnvs_tl_put_right:cn { ans } { -1 }
      \__bnvs_round:c { ans }
      \__bnvs_tl_put_left:cn { ans } { - }
      \__bnvs_tl_put_left:cv { ans } { A }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{\KWNmeta{first}:} and \texttt{\KWNmeta{first}::} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[A:]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[A:]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222- } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{:\KWNmeta{last}::\KWNmeta{length}} or \texttt{::\KWNmeta{length}:\KWNmeta{last}} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[:Z::L]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[:Z::L]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:Z::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { Z } { Z } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_left:cn  { ans } { 1-}
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \__bnvs_round:c { ans }
      \__bnvs_tl_put_right:cn { ans } { - }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[:]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[:]:}, ignore}
% \reset:n { Y }
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { - } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \prg_return_true:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \emoji{left-speech-bubble} \texttt{:\KWNmeta{last}} range
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return[:Z]: } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query_return[:Z]:}, ignore}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { -666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS.test}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \__bnvs_if_append:vcTF { Z } { ans } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{function}[TF]{
% \__bnvs_if_resolve_query:nc
%}
% \begin{syntax}
% \cs{__bnvs_if_resolve_query:ncTF} \KWNmarg{query} \KWNmarg{tl core} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% \end{function}
% Evaluate only one query.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_query:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_resolve_query:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { } { ... }
\BNVS_set:cpn { error:n } ##1 {
  \BNVS_error:n { #1 / ##1 }
}
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_greset_call:
  \__bnvs_match_if_once:NnTF \c__bnvs_A_cln_Z_regex { #1 } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...MATCH... }
\BNVS_DEBUG_log_seq:nc a { match }
    \BNVS_DEBUG_begin:n { if_resolve_query:nc }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve_query_branch:TF {
      \BNVS_end_tl_set:cv { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:nc a { #2 }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
      \BNVS_end:
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \end{BNVS.macrocode}
%    \begin{macrocode}
    \BNVS_error:n { Syntax~error:~#1 }
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_query:ncTF}, ignore}
% \Test_query:nnnn { 100 } { 1 } { 1 } { 1 }
% \Test_query:nnnn { } { 1+1 } { 2 } { 2 }
% \Test_query:nnnn { } { X.1 } { 100 } { 3a }
% \Test_query:nnnn { } { X.11 } { 110 } { 3b }
% \Test_query:nnnn { } { X.1+X.11 } { 210 } { 3c }
% \Test_query:nnnn { } { X.111 } { 210 } { 4a }
% \Test_query:nnnn { } { X.1:X.111 } { 100-210 } { 4b }
% \Test_query:nnnn { } { X.1::111 } { 100-210 } { 5 }
% \Test_query:nnnn { 4 } { X.1 } { 4 } { 6 }
% \Test_query:nnnn { } { X.0 } { 3 } { 7 }
% \Test_query:nnnn { } { X.-1 } { 2 } { 8 }
% \Test_query:nnnn { } { X.-2 } { 1 } { 9 }
% \Test_query:nnnn { } { X.-3 } { 0 } { 10 }
% \end{BNVS.test}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_queries:nc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_queries:ncTF} \KWNmarg{overlay query list} \KWNmarg{ans} \KWNmarg{yes code} \KWNmarg{no code}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated \KWNmeta{overlay query list},
% replacing all the individual named overlay specifications and integer expressions
% by their static counterparts by calling \cs{__bnvs_if_resolve_query:ncTF},
% then append the result to the right of the \KWNmeta{ans} |tl| variable .
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l__bnvs_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l__bnvs_ans_seq}
% Storage for the evaluated result.
% \end{variable}
% \begin{variable}{\c__bnvs_comma_regex}
% Used to parse slide range overlay specifications.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{BNVS.macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_queries:nc } #1 #2 { TF } {
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve_queries:ncTF}, ignore}
% \Test_if_resolve_queries:nnnn { } { 1+2, 2+3 } { 3, 5 } { A }
% \end{BNVS.test}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_set:ncnnc a { if_resolve_queries:ncTF } { IN } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_queries_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_resolve_queries:ncTF }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% Local variables cleared
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \__bnvs_seq_clear:c { ans }
%    \end{macrocode}
% \end{BNVS.macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\KWNmeta{first}::\KWNmeta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \regex_split:NnN \c__bnvs_comma_regex { #1 } \l__bnvs_query_seq
%    \end{macrocode}
% \end{BNVS.macrocode}
% Then each component is evaluated and the result is stored in \cs{l__bnvs_ans_seq}
% that we justed cleared above.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
  \BNVS_set:cpn { end_return: } {
    \__bnvs_seq_if_empty:cTF { ans } {
      \BNVS_end:
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_queries_ncTF:nn { } { ...DONE/Empty }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_queries_ncTF:nn { } { ...DONE/Nonempty }
\BNVS_DEBUG_log_seq:nc a { ans }
%</!final>
% \end{BNVS.gobble}
% \end{BNVS.macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to the return tl variable.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
      \exp_args:Nnx
      \use:n {
        \BNVS_end:
        \__bnvs_tl_put_right:cn { #2 }
      } { \__bnvs_seq_use:cn { ans } , }
    }
    \prg_return_true:
  }
  \__bnvs_seq_map_inline:cn { query } {
    \__bnvs_tl_clear:c { ans }
    \__bnvs_if_resolve_query:ncTF { ##1 } { ans } {
      \__bnvs_tl_if_empty:cF { ans } {
        \__bnvs_seq_put_right:cv { ans } { ans }
      }
    } {
      \seq_map_break:n {
        \BNVS_set:cpn { end_return: } {
          \BNVS_error:n { Circular/Undefined~dependency~in~#1}
%    \end{macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve:ncTF}, ignore}
% \reset:n { }
% \tl_gclear:N \g__bnvs_TEST_tl
% \cs_set:Npn \BNVS_error:n #1 {
%   \tl_gset:Nn \g__bnvs_TEST_tl { SUCCESS }
% }
% \Test_if_append:nnnn { X=X+Y } { X.1 } { 1 } { A }
% \exp_args:NnV \__bnvs_tl_set:cn { ans } \g__bnvs_TEST_tl
% \assert_equal_ans:nn { SUCCESS } { 1 }
% \end{BNVS.test}
%    \begin{macrocode}
          \exp_args:Nnx
          \use:n {
            \BNVS_end:
            \__bnvs_tl_put_right:cn { #2 }
          } { \__bnvs_seq_use:cn { ans } , }
          \prg_return_false:
        }
      }
    }
  }
  \__bnvs_end_return:
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{bnvs:c={if_resolve:ncTF}, ignore}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BNVS_DEBUG_log_tl:nc T { ans }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_if_resolve:ncTF {X.1} { ans } {
% 	\assert_equal_ans:nn { 222 } { 1 }
% } { \test_fail:n {Missed} }
% \end{BNVS.test}
%
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesResolve { O{} m } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
  \BNVS_DEBUG_begin:n { BeanovesResolve }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \keys_define:nn { BeanovesResolve } {
    in:N .tl_set:N = \l__bnvs_resolve_in_tl,
    in:N .initial:n = { },
    show .bool_set:N = \l__bnvs_resolve_show_bool,
    show .default:n = true,
    show .initial:n = false,
  }
  \keys_set:nn { BeanovesResolve } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_if_resolve_queries:ncTF { #2 } { ans } {
    \__bnvs_tl_if_empty:cTF { resolve_in } {
      \bool_if:nTF { \l__bnvs_resolve_show_bool } {
        \BNVS_tl_use:Nv \BNVS_end: { ans }
      } {
        \BNVS_end:
      }
    } {
      \bool_if:nTF { \l__bnvs_resolve_show_bool } {
        \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
          \BNVS_end:
          \tl_set:Nn ##1 { ##2 }
          ##2
        }
        \BNVS_tl_use:nv {
          \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_resolve_in_tl
        } { ans }
      } {
        \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
          \BNVS_end:
          \tl_set:Nn ##1 { ##2 }
        }
        \BNVS_tl_use:nv {
          \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_resolve_in_tl
        } { ans }
      }
    }
  } {}
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.test}{:N=\BeanovesResolve, ignore}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BeanovesResolve[in:N=\l__bnvs_TEST_A_tl]{X.2}
% \assert_equal_tl:vnn { TEST_A } { 223 } { 1 }
% \end{BNVS.test}
%
% \subsection{Reseting counters and values}
% \begin{BNVS.test}{bnvs:N=\BeanovesReset, ignore}
% \Test_if_resolve:nnnn { X.1=421} { X.1 } { 421 } { A }
% \Test_if_resolve:nnnn { } { X } { 421 } { B }
% \BeanovesReset{X}
% \Test_if_resolve:nnnn { } { X } { 1 } { C }
% \Test_if_resolve:nnnn { X=123 } { X.1 } { 123 } { D }
% \end{BNVS.test}
% \begin{BNVS.test}{:Nn=\BeanovesReset{/v}, ignore}
% \Test_if_resolve:nnnn { X=421 } { X } { 421 } { 1 }
% \Test_if_resolve:nnnn { } { X=222 } { 222 } { 2 }
% \BeanovesReset{X}
% \Test_if_resolve:nnnn { } { X } { 1 } { 3 }
% \BeanovesReset{X=222}
% \Test_if_resolve:nnnn { } { X } { 222 } { 4 }
% \end{BNVS.test}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { reset:n } #1 {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx D { \token_to_str:N \__bnvs_reset:n... }
  \BNVS_DEBUG_begin:n { __bnvs_reset:n }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_set_true:c { reset }
  \__bnvs_set_false:c { provide }
  \__bnvs_tl_clear:c { root }
  \__bnvs_int_zero:c { i }
  \__bnvs_tl_set:cn { a } { #1 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx D { ...\token_to_str:N \__bnvs_reset:n... }
\BNVS_DEBUG_log_tl:nc D { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \__bnvs_provide_off:
  \BNVS_tl_use:Nv \__bnvs_brace_keyval:n { a }
  \BNVS_end_tl_set:cv { id_last } { id_last }
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { reset:v } {
  \BNVS_tl_use:Nv \__bnvs_reset:n
}
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\makeatletter
\NewDocumentCommand \BeanovesReset { O{} m } {
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx B { \token_to_str:N \BeanovesReset... }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{BNVS.macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
    \BNVS_error:x {No~\token_to_str:N \BeanovesReset{}~in~the~preamble.}
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{BNVS.macrocode}
% At the top level, clear everything.
% \begin{BNVS.macrocode}
%    \begin{macrocode}
     \BNVS_error:x {No~\token_to_str:N \BeanovesReset{}~at~the~top~level.}
    }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { BeanovesReset }
%</!final>
%<*!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS.gobble}
%</!debug>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_set_true:c { reset }
    \__bnvs_set_false:c { provide }
    \keys_define:nn { BeanovesReset } {
      all .bool_set:N = \l__bnvs_reset_all_bool,
      all .default:n = true,
      all .initial:n = false,
      only .bool_set:N = \l__bnvs_only_bool,
      only .default:n = true,
      only .initial:n = false,
    }
    \keys_set:nn { BeanovesReset } { #1 }
    \__bnvs_tl_clear:c { root }
    \__bnvs_int_zero:c { i }
    \__bnvs_tl_set:cn { a } { #2 }
%    \end{macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_log:nx B { ...\token_to_str:N \BeanovesReset... }
\BNVS_DEBUG_log_tl:nc B { a }
%</!final>
% \end{BNVS.gobble}
%    \begin{macrocode}
    \__bnvs_provide_off:
    \BNVS_tl_use:Nv \__bnvs_brace_keyval:n { a }
    \BNVS_end_tl_set:cv { id_last } { id_last }
    \ignorespaces
  }
}
\makeatother
%    \end{macrocode}
% \end{BNVS.macrocode}
% \begin{BNVS.gobble}
%<*!final>
\BNVS_DEBUG_off:
%</!final>
% \end{BNVS.gobble}
% \begin{BNVS.macrocode}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \end{BNVS.macrocode}
%
% \begin{BNVS.gobble}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{BNVS.gobble}
%
% \begin{BNVS.test}{banner=misc, ignore}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \banner:n { #1 => #2}
%   \__bnvs_if_resolve:ncTF { #1 } { ans } {
%     \assert_equal_ans:nn { #2 } { A }
%   } {
%     \test_fail:n { B }
%   }
% }
% \Beanoves {
%   Air      = 1 : Gannet.last,
%   Chameleo = Air.2::1,
%   Gannet   = Chameleo.next::1,
%   Water    = Air.next : Picasso.last,
%   Octopus  = Water.2::1,
%   Starfish = Octopus.next::1,
%   StickyStarfish = Starfish.1::1,
%   Picasso = Starfish.next::1,
%   PicassoTrans = 1 : Picasso.previous,
%   Summary  = Water.next::1,
% }
% \BNVS_Test:nn { Chameleo.previous } {1}
% \BNVS_Test:nn { Gannet.previous } {2}
% \BNVS_Test:nn { Water.previous } {3}
% \BNVS_Test:nn { Octopus.previous } {4}
% \BNVS_Test:nn { Starfish.previous } {5}
% \BNVS_Test:nn { PicassoTrans.range } {1-6}
% \BNVS_Test:nn { Air.range } {1-3}
% \BNVS_Test:nn { Chameleo.1 } {2}
% \BNVS_Test:nn { Gannet.1 } {3}
% \BNVS_Test:nn { Water.range } {4-7}
% \BNVS_Test:nn { Octopus.1 } {5}
% \BNVS_Test:nn { Starfish.1 } {6}
% \BNVS_Test:nn { Picasso.range } {7-7}
% \BNVS_Test:nn { Summary.range } {8-8}
% \BNVS_Test:nn { Picasso.1 } {7}
% \BNVS_Test:nn { Air.last } {3}
% \BNVS_Test:nn { StickyStarfish.range } {6-6}
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS.test}
%
% \end{implementation}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
% \begin{BNVS.gobble}
%<*internal>
% \end{BNVS.gobble}
\iffalse
% \begin{BNVS.gobble}
%</internal>
% \end{BNVS.gobble}
%<*test-lua>
local Command = {}
Command.__index = Command

function Command:clear()
  self.all__ = {}
  self.by_name__ = {}
  self.output__ = {}
end

Command:clear()

function Command:output(message)
  if message == true then
    self.output__ = {}
  elseif message then
    self.output__[#self.output__+1] = message
  end
  return self.output__
end

function Command:already(name, signature) --> Command?
  if signature then
    name = name..":"..signature
  end
  return self.by_name__[name]
end

function Command:base_signature(name) --> String, String?
  local pattern = "^([a-zA-Z_@]*):([NncVvoxefpwDTF]*)"
  local base, signature = name:match(pattern)
  if base then
    return base, signature
  end
  return name
end

function Command:make(name, signature) --> Command?
  -- self:output("name: "..name..", signature: "..(signature or "")..", "..(name:find("bnvs") and "OK" or "KO"))
  if not name:find("bnvs") then
    return nil
  end
  if name:find("q__") then
    return nil
  end
  if name:find("DEBUG") then
    return nil
  end
  if name:len()<7 then
    return nil
  end
  if signature then
    name = name..":"..signature
  end
  local o = self.by_name__[name]
  if o then
    return o
  end
  local base, signature = self:base_signature(name)
  o = {
    name = name,
    base = base,
    signature = signature,
  }
  setmetatable(o, self)
  table.insert(self.all__, o)
  self.by_name__[name] = o
  if name:match("^c__") then
    o.is_constant = true
  elseif name:match("^[lg]__") then
    o.is_variable = true
  else
    o.is_function = true
  end
  return o
end

function iter (a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function Command:sorted()
  table.sort(self.all__, function(l, r) return l.name < r.name end)
  return iter, self.all__, 0
end

function Command:sorted_functions()
  local t = {}
  for _,cmd in self:sorted() do
    if cmd.is_function then
      t[#t+1] = cmd
    end
  end
  return iter, t, 0
end

function Command:parse_all(s)
  local n = 0
  local pattern = "%f[\\]"..--
[[\([a-zA-Z_@:]+)]]
  for name in string.gmatch (s, pattern) do
    if not self:already(name) and self:make(name) then
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs commands parsed")
end

function Command:parse_set_eq(s)
  local n = 0
  local pattern = "\\cs_set_eq:NN%s*"..
"\\([a-zA-Z_@:]+)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command copy")
end

function Command:parse_action(s, action)
  local n = 0
  local pattern = "\\cs_"..action..":Np?n%s+"..
"\\([a-zA-Z_@:]*)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." command definition "..action)
end

function Command:parse_BNVS_action(s, action)
  local n = 0
  local pattern = "\\BNVS_"..action..":cpn%s*{"..
"%s*([a-zA-Z_@:]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_"..name
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command definition "..action)
end

function Command:parse_BNVS_new_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_"..signature..":ncn?%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, name in string.gmatch (s, pattern) do
    name = "__bnvs_"..module.."_"..name
    local cmd = self:make(name..":"..signature)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new definition "..signature)
end

function Command:parse_BNVS_new_tl_signed(s, signature)
  local n = 0
  local pattern = "\\BNVS_new_tl_"..signature..":c?%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_tl_"..name..":"..signature
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new tl definition "..signature)
end

function Command:complete_variant(variant, signature) --> String
  if #variant < #signature then
    local ans = {}
    for i=1,#signature do
      ans[#ans+1] = signature:sub(i, i)
    end
    for i=1,#variant do
      ans[i] = variant:sub(i, i)
    end
    return table.concat(ans)
  end
  return variant
end

function Command:parse_generate_variant(s)
  local n = 0
  local pattern = "\\cs_generate_variant:Nn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_BNVS_generate_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_variant:cn%s*"..
"{%s*"..
"([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    core = "__bnvs_"..core
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_new_conditional(s)
  local n = 0
  local pattern = "\\prg_new_conditional:Npnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"[^{"..--}
"]*{([pTF,%s]-)}"
  for core, conditionals in string.gmatch (s, pattern) do
    local from = self:already(core)
    if from then
      from.is_conditional_core = true
    end
    local base, signature = self:base_signature(core)
    for c in conditionals:gmatch("([pTF]+)") do
      local name = c == "p" and (signature and base.."_p:"..signature or core.."_p") or core..c
      local generated = self:make(name)
      if generated then
        generated.is_defined = true
        generated.conditional_core = core
        n = n+1
      end
    end
  end
  self:output("-> "..n.." bnvs conditionals created")
end

function Command:parse_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\prg_generate_conditional_variant:Nnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_conditional_variant:cnn%s*"..
"{%s*([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    base = "__bnvs_"..base
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." "..signature.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional_nc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_([a-z]*):ncn?%s*{%s*"..
"([a-z]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for signature, module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs ncn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_cc:ncnn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":cc"..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":ncn*%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_tl(s, signature, is_tl)
  is_tl = is_tl == nil and false or is_tl
  local n = 0
  local pattern = "BNVS_new_conditional_tl_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  local prefix = is_tl and "__bnvs_tl_" or "__bnvs_"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = prefix..base..":"..signature..c
  self:output("-> "..name)
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cpnn(s)
  local n = 0
  local pattern = "BNVS_new_conditional:cpnn%s*{%s*"..
"([a-zA-Z_@]*):([a-zA-Z_@]*)%s*}[^{"..--}
"]*{%s*"..
"([pTF,%s]*)%s*}"
  local pattern_pTF = "([pTF]+)"
  for base, signature, pTFs in string.gmatch(s, pattern) do
    for pTF in string.gmatch(pTFs, pattern_pTF) do
      local name = "__bnvs_"..base
      if pTF == "p" then
        name = name.."_p:"..signature
      else
        name = name..":"..signature..pTF
      end
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = pTF == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = pTF == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs raw conditional variants generated")
end

function Command:check_unused_variants()
  self:output("-> check for unused variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused variants...DONE")
end

function Command:check_unused_conditional_variants(skip)
  if skip then
    return
  end
  self:output("-> check for unused conditional variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused_conditional then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused conditional variants...DONE")
end

function Command:check_undefined()
  self:output("-> check for undefined...")
  for _,cmd in self:sorted_functions() do
    if not cmd.is_defined and not cmd.is_conditional_core then
      if cmd.name:len() > 7 then
        self:output("!!!! "..cmd.name)
      end
    end
  end
  self:output("-> check for undefined...DONE")
end

function Command:check_variants(s) --> [String]
  self:clear()
  self:parse_all(s)
  self:parse_set_eq(s)
  self:parse_action(s,"new")
  self:parse_action(s,"set")
  self:parse_BNVS_action(s,"new")
  self:parse_BNVS_action(s,"set")
  self:parse_generate_variant(s)
  self:parse_BNVS_generate_variant(s)
  self:parse_new_conditional(s)
  self:parse_BNVS_new_signed(s, "c")
  self:parse_BNVS_new_signed(s, "cc")
  self:parse_BNVS_new_signed(s, "cn")
  self:parse_BNVS_new_signed(s, "cv")
  self:parse_BNVS_new_signed(s, "cnn")
  self:parse_BNVS_new_signed(s, "cnv")
  self:parse_BNVS_new_signed(s, "cnx")
  self:parse_BNVS_new_tl_signed(s, "c")
  self:parse_BNVS_new_tl_signed(s, "cn")
  self:parse_BNVS_new_tl_signed(s, "cv")
  self:parse_BNVS_new_conditional_cpnn(s)
  self:parse_BNVS_new_conditional_signed(s, "c")
  self:parse_BNVS_new_conditional_signed(s, "nc")
  self:parse_BNVS_new_conditional_signed(s, "cc")
  self:parse_BNVS_new_conditional_signed(s, "cn")
  self:parse_BNVS_new_conditional_signed(s, "cnn")
  self:parse_BNVS_new_conditional_signed(s, "cnv")
  self:parse_BNVS_new_conditional_signed(s, "cnx")
  self:parse_BNVS_new_conditional_tl(s, "cn", true)
  self:parse_BNVS_new_conditional_tl(s, "cv", true)
  self:parse_BNVS_new_conditional_tl(s, "vnc", false)
  self:parse_BNVS_new_conditional_tl(s, "vvc", false)
  self:parse_BNVS_new_conditional(s, "Nn")
  self:parse_BNVS_new_conditional(s, "Nv")
  self:parse_BNVS_new_conditional(s, "nn")
  self:parse_BNVS_new_conditional(s, "c")
  self:parse_BNVS_new_conditional(s, "cc")
  self:parse_BNVS_new_conditional(s, "cv")
  self:parse_BNVS_new_conditional(s, "vc")
  self:parse_BNVS_new_conditional(s, "vnc")
  self:parse_BNVS_new_conditional(s, "vvc")
  self:parse_BNVS_new_conditional(s, "vvnc")
  self:parse_BNVS_new_conditional(s, "vvvc")
  self:parse_generate_conditional_variant(s)
  self:parse_BNVS_generate_conditional_variant(s)
  self:check_unused_variants()
  self:check_unused_conditional_variants(true)
  self:check_undefined()
  return self:output()
end
local function check_variants (path) --> string?
  local file = io.open(path, "r")
  if file == nil then
    return nil
  end
  local s = file:read("a")
  file:close()
  local ra1 = Command:check_variants([[
\bnvs_TEST_A:n
\bnvs_TEST_B:nn
\cs_set:Npn \bnvs_TEST_B:nn {}
\cs_new:Npn \bnvs_C:nn {}
\BNVS_new_conditional:cpnn { if_get:nnnc } #1 #2 #3 #4 { p, T, F, TF } {}
\_generate_conditional_variant:Nnn
  \__bnvs_if_get:nnnc {nVV} { p, T, F, TF }
]])
  local ra2 = Command:check_variants(s)
  for _,v in ipairs(ra2) do
    ra1[#ra1+1] = v
  end
  return ra2
end
return {
  __INFO__ = "beanoves dedicated table for DEBUGGING",
  check_variants  = check_variants,
  Command__ = Command,
}
%</test-lua>
%<*internal>
\fi
% \begin{BNVS.gobble}
%</internal>
% \end{BNVS.gobble}
