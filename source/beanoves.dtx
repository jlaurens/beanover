% \iffalse meta-comment
% !TEX program  = LuaLaTeX
% !TEX encoding = UTF-8
%
% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2024 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of named overlay specifications in |beamer| documents.
Named overlay specifications are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\generate{
  \nopreamble
  \nopostamble
  \file{\jobname-test.lua}{\from{\jobname.dtx}{test-lua}}
}
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay specifications

Copyright (C) 2024 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf,
                                beanoves.sty and
                                beanoves-debug.sty.

\endpostamble
\generate{
  \file{\jobname-debug.sty}{\from{\jobname.dtx}{package,debug}}
}
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package,gubed,final}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% !TeX proot = ...
\PassOptionsToPackage{enable-debug}{expl3}
\documentclass{l3doc}
\RequirePackage{luacode}
\RequirePackage{beanoves-debug}
\ExplSyntaxOn
\cs_new:Npn \BNVSNote {
  \msg_note:nnn { beanoves } { :n }
}
\ExplSyntaxOff
\ProvideDocumentEnvironment{BNVS/test}{+b}{}{}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\RequirePackage{minted}
\tcbuselibrary{minted}
\ExplSyntaxOn
\debug_on:n {} % 
\ExplSyntaxOff
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specifications with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{\jobname-debug.sty}
\date{\fileversion \qquad \filedate}
\NewDocumentEnvironment{BNVS/macrocode}{}{
  \setlength{\topsep}{0.4em plus 0.15 em minus 0.15 em}
  \begin{trivlist}
  \setlist[trivlist]{nosep}
  \item\vspace{-\baselineskip}
}{
  \end{trivlist}
}
%\OnlyDescription
%\Beanoves {
%  B = [ 421, 666, C=[111, foo=777, 222], 246 ],
%}
%\typein{Press <enter> to continue}
%\BeanovesDebugOn
%\BeanovesResolve[in:N=\FOO]{B}
%\show\FOO
%\BeanovesDebugOn
%\BeanovesResolve[in:N=\FOO]{++B}
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\show\FOO
%\BeanovesResolve[in:N=\FOO]{B.C}
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\show\FOO
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\typein{Press <enter> to continue}
% \begin{BNVS/test}{bnvs:cn={parse:n}{/:nn}, noigre, debug}
% \BeanovesDebugOn
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_if_in:nnTF A {?!X.#5} {
%     \assert_equal:xxn {\__bnvs_item:nn A {?!X.#5} } {#1} {#4-a}
%     \assert_equal:xxn {\__bnvs_item:nn Z {?!X.#5} } {#2} {#4-b}
%     \assert_equal:xxn {\__bnvs_item:nn L {?!X.#5} } {#3} {#4-c}
%   } {
%     \__bnvs_if_in:nnTF V {?!X.#5} {
%       \assert_equal:xxn {\__bnvs_item:nn V {?!X.#5} } {#1} {#4-v}
%     } {
%       \test_fail:n {#4-F}
%     }
%   }
% }
% \__bnvs_parse:nn {X.3} {::C:B}
% \__bnvs_parse:nn {X.3} {{A:,A:B,A::C,:B::C,::C:B, D}}
% \BNVS_Test:nnnnn {A} {} {} {4-1} {3.1}
% \BNVS_Test:nnnnn {A} {B} { \exp_not:N \q_nil } {4-2} {3.2}
% \BNVS_Test:nnnnn {A} { \exp_not:N \q_nil } {C} {4-3} {3.3}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-4} {3.4}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-5} {3.5}
% \BNVS_Test:nnnnn {D} {} {} {4-6} {3.6}
% \cs_undefine:N \BNVS_Test:nnnnn
% \end{BNVS/test}
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\typein{Press <enter> to continue}
%\Beanoves{KEY={{SUBKEY=421}}}
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\typein{Press <enter> to continue}
%\BeanovesResolve[in:N=\FOO]{KEY.SUBKEY}
%\ExplSyntaxOn
%\BNVS_DEBUG_log:n {*****}
%\ExplSyntaxOff
%\show\FOO
%\BeanovesDebugOff
\begin{document}
\maketitle
\textcolor{red}{0 -> 1 initialize value counter}
\changes{v1.0}{2024/01/11}{First public release}
\begin{abstract}
This package allows the management of multiple named overlay specifications in \pkg{beamer} documents.
Named overlay specifications are very handy both during edition and
to manage complex and variable \pkg{beamer} overlay specifications.
In particular, they allow to replace raw numbers in \pkg{beamer}
|<...>| overlay specifications by logical identifiers.
Demonstration files are \href[pdfnewwindow]{https://github.com/jlaurens/beanoves/tree/main/demo}{available for download}
as part of the
\href[pdfnewwindow]{https://github.com/jlaurens/beanoves/}{development repository}.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanoves}
\begin{document}
\Beanoves {
      A = 1:3,
      B = A.last::3,
      C = B.next,
    }
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.range)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2:B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.next)-> {From slide 3}\\
\visible<?(B.3:B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare \emph{named overlay sets}.
On line 5, we declare an overlay set named `A', which is a range starting at slide 1 and ending at slide 3.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1 because 1 is the first index of the overlay set named A.
On line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.next)} stands for 3.
%
On line 6, we declare a second overlay set named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last slide number is 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide number after slide range `B' is 6
which is also the start of the third slide range
due to line 7.
\section{Named overlay sets}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn
according to overlay specifications. The main overlay set is a range of integers
covering all the slide numbers, from one to the total amount of slides.
In general, an overlay set is a range of positive integers identified by a unique name.
The main practical interest is that such sets may be defined relative to one another, we can even have lists of overlay sets.
Finally, we can use these lists to build and organize \pkg{beamer} overlay
specifications logically.
\subsection{Named overlay reference}
|A.1|, |C.2| are \emph{named overlay references}, as well as |A| and |Y!C.2|.
More precisely, they are string identifiers, each one representing
a well defined static integer to be used in \pkg{beamer} overlay specifications.
They can take one of the next forms.
\begin{description}
\item[\texttt{\meta{short name}}]: like |A| and |C|,
\item[\texttt{\meta{frame id}|!|\meta{short name}}]: denoted by \emph{qualified names}, like |X!A| and |Y!C|.
\item[\texttt{\meta{short name}\meta{dotted path}}]:
  denoted by \emph{full names} like |A.1| and |C.2|,
\item[\texttt{\meta{frame id}|!|\meta{short name}\meta{dotted path}}]:
  denoted by \emph{qualified full names} like |X!A.1| and |Y!C.2|.
\end{description}
The \emph{short names} and \emph{frame ids} are alphanumerical case sensitive
identifiers, with possible underscores but with no space nor leading digit.
Unicode symbols above \texttt{U+00A0} are allowed if the underlying \TeX\ engine
supports it.

The \emph{dotted path} is a string
\texttt{.\meta{component_1}.\meta{component_2}....\meta{component_n}},
where each \meta{component_i} denotes either an integer, eventually signed,
or a \meta{short name}. The \emph{dotted path} can be empty for which \texttt{n} is 0.

Identifiers consisting only of lowercase letters and underscores are reserved by the package. This includes \meta{component}s, unless explicitly documented like for ``|n|''.


The mapping from \emph{named overlay references} to integers is defined
at the global \TeX\ level to allow its use in |\begin{frame}<...>| and to share the same overlay sets between different frames.
Hence the \emph{frame id} due to the need to possibly target a particular frame.

\subsection{Defining named overlay sets}
In order to define \emph{named overlay sets}, we can either execute the next |\Beanoves| command  before a \pkg{beamer} \text{frame} environment, or use the |beanoves| option of this environment.
The value of the |beanoves| option is similar to the argument of the |\Beanoves| commands, but the latter takes precedence on the former.
This behaviour may be useful to input the very same source code into different frames and have different combinations of slides.
%
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
\begin{function}{\Beanoves}
  \begin{syntax}
    \cs{Beanoves}\{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
Each \meta{ref_i} key is a \emph{named overlay reference} whereas each \meta{spec} value
is an \emph{overlay set specifier}.
When the same \meta{ref} key is used multiple times, only the last one is taken into account.
\subsubsection{Basic case}
In the possible values for \meta{spec} hereafter, \meta{value}, \meta{first}, \meta{length} and \meta{last} are algebraic expression
(with algebraic operators \(+\), \(-\), ...) possibly
involving any \emph{named overlay reference} defined above.
\begin{description}
\item[\texttt{\meta{value}},]
the simple \emph{value specifiers} for the whole signed integers set.
If only the \meta{key} is provided, the \meta{value} defaults to 1.
\item[\texttt{\meta{first}:} and \texttt{\meta{first}::},]
for the infinite range of signed integers starting at and including \meta{first}.
\item[\texttt{:\meta{last}},]
for the infinite range of signed integers ending at and including \meta{last}.
\item[\texttt{\meta{first}:\meta{last}}, \texttt{\meta{first}::\meta{length}}, \texttt{:\meta{last}::\meta{length}}, \texttt{::\meta{length}:\meta{last}},]
are variants for the finite range of signed integers starting at and including \meta{first}, ending at and including \meta{last}.
At least one of \meta{first} or \meta{last} must be provided.
We always have \(\meta{first}+\meta{length}=\meta{last}+1\).
\end{description}

When performed at the document level, the \cs{Beanoves} command starts by cleaning 
what was set by previous calls. When performed inside \LaTeX\ environments,
each new call cumulates with the previous one.
Notice that the argument of this function can contain macros:
they will be exhaustively expanded at resolution time\footnote{Precision is needed for the exact time when the expansion occurs.}.

\subsubsection{List specifiers}
Also possible values are \emph{list specifiers} which
are comma separated lists of \meta{path}=\meta{spec} definitions.
The definition
\\[0.2ex]
\hphantom{xx}\texttt{\meta{ref}=\{\{\meta{path_1}=\meta{spec_1}, \meta{path_2}=\meta{spec_2},..., \meta{path_n}=\meta{spec_n}\}\}}
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\texttt{\meta{ref}.\meta{path_1}=\meta{spec_1},}
\\\hphantom{xx}\texttt{\meta{ref}.\meta{path_2}=\meta{spec_2},}
\\\hphantom{xx}\texttt{...,}
\\\hphantom{xx}\texttt{\meta{ref}.\meta{path_n}=\meta{spec_n}.}
\\[0.2ex]
The rules above can apply individually to each line.

To support an array like syntax, we can omit the \meta{path} key and only give the \meta{spec} value.
The first missing \meta{path} key is replaced by 1, the second by 2, and so on.

Notice that you can replace each opening pair |\{\{| by a single |[|%]
and each closing pair |\}\}|%[
by a single |]|. Anyway, delimiters should be properly balanced.
\subsubsection{\texttt{.n} specifiers}
\texttt{\meta{ref}.n=\meta{value}} is used to set the value of
the index counter defined below.
%
\section{Overlay resolution}
The named overlay sets defined above are queried for integer numerical values
that will be passed to \pkg{beamer}.
Turning an \emph{overlay query} into the static integer it represents,
as when above \texttt{<?(A.1)>} was replaced by 1, is denoted by \emph{overlay resolution} or simply \emph{resolution}. This section is devoted to \emph{overlay queries} and their \emph{resolution rules} depending
on the definition of the named overlay set, from the simplest to the more advanced.
Here \meta{i} denotes a signed integer whereas \meta{value}, \meta{first}, \meta{last} and \meta{length} stand for integers, or integer valued algebraic expressions.
%
\subsection{Range definitions}
\begin{description}
\item[\texttt{\meta{ref} = \meta{value}}]
For an unlimited range
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\meta{ref}.1 & \(\meta{value}\)\\
\meta{ref}.2 & \(\meta{value}+1\) \\
\meta{ref}.\meta{i} & \(\meta{value} + \meta{i} - 1\) \\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{ref} = \meta{first}:}] as well as \texttt{\meta{first}::}.
For a range limited from below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\meta{ref}.1 & \(\meta{first}\)\\
\meta{ref}.2 & \(\meta{first}+1\) \\
\meta{ref}.\meta{i} & \(\meta{first} + \meta{i} - 1\) \\
\meta{ref}.previous & \(\meta{first}-1\)\\
\hline
\end{tabular}
\end{center}
Notice that \texttt{\meta{ref}.previous} and \texttt{\meta{ref}.0} are sometimes synonyms.
\item[\texttt{\meta{ref} = :\meta{last}}]
For a range limited from above:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\meta{ref}.1 & \(\meta{last}\)\\
\meta{ref}.0 & \(\meta{last}-1\) \\
\meta{ref}.\meta{i} & \(\meta{last} + \meta{i} - 1\) \\
\meta{ref}.last & \(\meta{last}\)\\
\meta{ref}.next & \(\meta{last}+1\)\\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{ref} = \meta{first}:\meta{last}}]
as well as variants \texttt{\meta{first}::\meta{length}},
\texttt{::\meta{length}:\meta{last}}
or \texttt{:\meta{last}::\meta{length}},
which are equivalent provided \(\meta{first}+\meta{length} = \meta{last}+1\).

For a range limited from both above and below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{overlay query} & \bfseries \textrm{resolution} 
\\\hline
\meta{ref}.1 & \(\meta{first}\)\\
\meta{ref}.2 & \(\meta{first}+1\) \\
\meta{ref}.\meta{i} & \(\meta{first} + \meta{i} - 1\bigr)\) \\
\meta{ref}.previous & \(\meta{first}-1\)\\
\meta{ref}.last & \(\meta{last}\)\\
\meta{ref}.next & \(\meta{last}+1\)\\
\meta{ref}.length & \(\meta{length}\)\\
\meta{ref}.range & \(\max(0,\meta{first})\) ''-'' \(\max(0,\meta{last})\)\\
\hline
\end{tabular}
\end{center}
Notice that the resolution of \texttt{\meta{ref}.range} is not an algebraic difference,
and negative integers do not make sense there while in \pkg{beamer} context.

In the frame example below, we use the \cs{BeanovesResolve} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:8, % or similarly A = 3::6, A = ::6:8 and A = :8::6
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesResolve[see](A.1)        == 3,
\BeanovesResolve[see](A.-1)       == 1,
\BeanovesResolve[see](A.previous) == 2,
\BeanovesResolve[see](A.last)     == 8,
\BeanovesResolve[see](A.next)     == 9,
\BeanovesResolve[see](A.length)   == 6,
\BeanovesResolve[see](A.range)    == 3-8,
\end{frame}
\end{tcblisting}
%
\end{description}
For example both \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been properly defined with a starting value and a length.
%
\subsection{Counters}
Each named overlay set defined has a dedicated value counter
which is some kind of integer variable that can be used and incremented.
A standalone \texttt{\meta{ref}} \emph{overlay query} is resolved into
the position of this value counter.
For each frame, this variable is initialized to the first available
resolution amongst \meta{value}, \texttt{\meta{name}.1},
\texttt{\meta{name}.first} or \texttt{\meta{name}.last}.
If none is available, the counter is initialized to 1.

Additionnaly, resolution rules are provided for dedicated \emph{overlay queries}:
\begin{description}
\item[\texttt{\meta{name}+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the value counter by \meta{integer}
and use the new position.
Here \meta{integer expression} is the longest character sequence with no space%
\footnote{The parser for algebraic expression is very rudimentary.}.
\item[\texttt{++\meta{name}},] advance the value counter for \meta{name} by 1 and use the new position.
\item[\texttt{\meta{name}++},] use the actual position
and advance the value counter for \meta{key} by 1.
\end{description}

For each named overlay set defined, we also have an implicit index counter always starting at 1,
its actual value is an integer denoted \meta{n} in the sequel.
The \texttt{\meta{name}.n} \emph{named index reference} is resolved into \texttt{\meta{name}.\meta{n}},
which in turn is resolved according to the preceding rules.
%

We have resolution rules as well for the \emph{named index references}:
\begin{description}
\item[\texttt{\meta{name}.n+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the implicit index counter associate to \meta{name} by \meta{integer} and use the resolution of \texttt{\meta{name}.n}.

Here again, \meta{integer expression} denotes the longest character sequence with no space.
\item[\texttt{\meta{name}.++n}, \texttt{++\meta{name}.n},] advance the implicit index counter associate to \meta{key} by 1 and use the resolution of \texttt{\meta{name}.n},
\item[\texttt{\meta{name}.n++},] use the resolution of \texttt{\meta{name}.n} and increment the implicit index counter associate to \meta{name} by 1.
\end{description}

In order to decrement a counter, one can increment with a negative value, no dedicated syntax is provided yet.

These counters are reset to their default value for each new frame, which is 1 for the \texttt{\meta{name}.n} counter, and whichever \texttt{\meta{name}.first} or \texttt{\meta{name}.last} is defined for the \texttt{\meta{name}} counter.
\subsection{Dotted paths}
\begin{description}
\item[\texttt{\meta{name}.\meta{i} = \meta{query}},]
All the preceding rules are overriden by this particular one and \texttt{\meta{name}.\meta{i}} resolves to the resolution of \meta{spec}. This allows to override the ...+\meta{i}-1 rule and replace for example a single integer with multiple ranges.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3,
    B = 3,
    B.3 = 0,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesResolve[see](A.1) == 3,
\BeanovesResolve[see](A.3) == 5,
\BeanovesResolve[see](B.1) == 3,
\BeanovesResolve[see](B.3) == 0,
\end{frame}
\end{tcblisting}
%
\item[\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_k} = \meta{spec}}]
When a dotted path has more than one component,
a \emph{named overlay reference} like |A.1.2| needs some well defined
resolution rule to avoid ambiguities.
To resolve one level of such a reference
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}},
we replace the longest \texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_k}}
where 0$≤$k$≤$n by its definition \texttt{\meta{name'}.\meta{c'_1}...\meta{c'_p}}
if any (the path can be empty). \pkg{beanoves} uses this one level resolution
as many times as possible, but no more than a predefined limit to catch
circular references that would lead to an infinite \TeX\ loop.
One final resolution occurs with the other rules above if possible
otherwise an error is raised.

For a \emph{named indexed reference} like
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}.n},
we must first resolve \texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}}
into \texttt{\meta{name'}} with an empty dotted path, then retrieve the value of \texttt{\meta{name'}.n} denoted as integer \meta{n'} and finally use the resolved 
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}.\meta{n'}}.
\end{description}
%
%
\subsection{Frame id}
Except for very special situations, the \emph{frame ids} can be left unspecified.
When no \emph{frame id} was explicitly provided,
\pkg{beanoves} uses the \emph{last frame id}. At the beginning of each frame,
the \emph{last frame id} is set to the \emph{frame id} of the current frame,
which is denoted \emph{current frame id} and defaults to |?|.
Then it gets updated after each named reference resolution.
For example, the first time |A.1| reference is resolved within a given frame,
it is first translated to \texttt{\meta{current frame id}!A.1},
but when used just after \texttt{Y!C.2}, for example, it becomes a shortcut to
\texttt{Y!A.1} because the \emph{last frame id} is then \texttt{Y}.

In order to set the \emph{frame id} of the current frame to \meta{frame id},
use the new \texttt{beanoves id} option of the \pkg{beamer} frame environment. 
\begin{function}{beanoves id}
  \begin{syntax}
    beanoves id=\meta{frame id},
  \end{syntax}
\end{function}
We can use the same \emph{frame id} for different frames to share named overlay sets. 
%
\section{\texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\meta{queries})}'. Each one is then evaluated and replaced by its resolved static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s from next table.
Sometimes, using \texttt{\meta{name}.range} is not allowed because
the resolution would be interpreted as an algebraic difference
instead of a \pkg{beamer} range.
If it is not possible, an error is raised.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{query} & \bfseries \textrm{resolution} & \bfseries \textrm{limitation}
\\\hline
\phantom{xxx}\meta{start expr} & \meta{start} & \\
\phantom{xxx}\meta{start expr}: & \meta{start} - & \textrm{no }\meta{name}.range \\
\phantom{xxx}\meta{start expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{name}.range \\
::\meta{length expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{name}.range \\
\phantom{::\meta{length expr}}:\meta{end expr} & \phantom{\meta{start}} - \meta{end} & \textrm{no }\meta{name}.range \\
\phantom{::\meta{length expr}}: & \phantom{\meta{start}} - & \\
\phantom{xx}\meta{start expr}:: & \meta{start} -  & \textrm{no }\meta{name}.range \\
\phantom{xx}\meta{start expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{name}.range \\
\phantom{xxx}:\meta{end expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{name}.range \\
\phantom{xxx:\meta{end expr}}:: & \phantom{\meta{start}} - & \\
\hline
\end{tabular}
\end{center}
Here \meta{start expr}, \meta{end expr} and \meta{length expr}
both denote algebraic expressions possibly involving parenthesis, named overlay references and counters.
As integers, they are respectively resolved into \meta{start}, \meta{end} and \meta{length}.

Notice that nesting \texttt{?(...)} query expressions is not supported.
\section{Support}
See \url{https://github.com/jlaurens/beanoves}.
One can report issues.
\end{documentation}
\DocInput{beanoves.dtx}
\begin{luacode}
local bnvs = require("./\jobname-test.lua")
tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
local ra = bnvs.check_variants("\jobname.sty")
tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
--[[
if ra then
  for _,v in ipairs(ra) do
    tex.print("\\verb|"..v.."|\\\\")
  end
end
]]
\end{luacode}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \NewDocumentEnvironment {BNVS/gobble} { +b } {} {}
% \begin{implementation}
% \begin{BNVS/gobble}
%<*package>
% \end{BNVS/gobble}
%
%\begin{BNVS/gobble}
%\begin{luacode}
%local bnvs = require("./\jobname-test.lua")
%tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
%local ra = bnvs.check_variants("\jobname-debug.sty")
%tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
%--[[
%if ra then
%  for _,v in ipairs(ra) do
%    tex.print("\\verb|"..v.."|\\\\")
%  end
%end
%]]
%\end{luacode}
%\end{BNVS/gobble}
%
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention, unused).
% \begin{BNVS/macrocode}
%    \begin{macrocode}
%<@@=bnvs>
%    \end{macrocode}
% \end{BNVS/macrocode}
% Reserved namespace:
% identifiers containing the case insensitive string |beanoves| or
% containing the case insensitive string |bnvs| delimited by two non characters.
%
% \subsection{Package declarations}
%
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  {beanoves}
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
%<*!final>
  {beanoves-debug}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  {2024/01/11}
  {1.0}
  {Named overlay specifications for beamer}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsection{Facility layer: definitions and naming}
% In order to make the code shorter and easier to read, we add a layer
% over \LaTeX3. The |c| and |v| argument specifiers take a slightly different meaning when
% used in a function which name contains with |bnvs| or |BNVS|.
% Where \LaTeX3 would transform |l__bnvs_ref_tl| into |\l__bnvs_ref_tl|,
% \pkg{bnvs} will directly transform |ref| into |\l__bnvs_ref_tl|.
% The type of the local variable used depends on the context and may be
% |seq| or |int| for example.
% There are however a pair of exceptions mentionned below.
% For a better reading experience,
% `|ref|' will generally stand for |\l__bnvs_ref_tl|,
% whereas `|path| sequence' will generally stand for |\l__bnvs_path_seq|.
% Other similar shortcuts are used as well. 
%
% Functions with |BNVS| in their names are management functions.
% They belong to a deeper layer and do not contain any logic specific
% to the \pkg{beanoves} package.
% \begin{function}{
%   \BNVS:c,
%   \BNVS_l:cn,
%   \BNVS_g:cn,
% }
% \begin{syntax}
% \cs{BNVS:c} \marg{cs core name}
% \cs{BNVS_l:cn} \marg{local variable core name} \marg{ type }
% \cs{BNVS_g:cn} \marg{global variable core name} \marg{ type }
% \end{syntax}
% These are naming functions.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS:c    #1    { __bnvs_#1     }
\cs_new:Npn \BNVS_l:cn #1 #2 { l__bnvs_#1_#2 }
\cs_new:Npn \BNVS_g:cn #1 #2 { g__bnvs_#1_#2 }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \BNVS_use_raw:c,
%   \BNVS_use_raw:Nc,
%   \BNVS_use_raw:nc,
%   \BNVS_use:c,
%   \BNVS_use:Nc,
%   \BNVS_use:nc,
% }
% \begin{syntax}
% \cs{BNVS_use_raw:c} \marg{cs name}
% \cs{BNVS_use_raw:Nc} \meta{function} \marg{cs name}
% \cs{BNVS_use_raw:nc} \marg{tokens} \marg{cs name}
% \cs{BNVS_use:c} \marg{cs core}
% \cs{BNVS_use:Nc} \meta{function} \marg{cs core}
% \cs{BNVS_use:nc} \marg{tokens} \marg{cs core}
% \end{syntax}
% \cs{BNVS_use_raw:c} is a wrapper over \cs{use:c}.
% possibly prepended with some code.
% It needs 3 expansion steps just like \cs{BNVS_use:c}.
% The other are used to expand |\use:c| enough before usage by
% \meta{function} or \meta{tokens}.
% The first argument of \meta{function} has type |N|.
% The next token after \meta{tokens} will have type |N| too.
% \meta{cs name} is a full cs name
% whereas \meta{cs core} will be prepended with the appropriate prefix.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:N #1 { #1 }
\cs_new:Npn \BNVS_use_raw:c #1 {
  \exp_last_unbraced:No
  \BNVS_use_raw:N { \cs:w #1 \cs_end: }
}
\cs_new:Npn \BNVS_use:c #1 {
  \BNVS_use_raw:c { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_use:c, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use:c { TEST:n } { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_tl { XX } { 
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_raw:NN #1 #2 {
  #1 #2
}
\cs_new:Npn \BNVS_use_raw:nN #1 #2 {
  #1 #2
}
\cs_new:Npn \BNVS_use_raw:Nc #1 #2 {
  \exp_last_unbraced:NNo
  \BNVS_use_raw:NN #1 { \cs:w #2 \cs_end: }
}
\cs_new:Npn \BNVS_use_raw:nc #1 #2 {
  \exp_last_unbraced:Nno
  \BNVS_use_raw:nN { #1 } { \cs:w #2 \cs_end: }
}
\cs_new:Npn \BNVS_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { \BNVS:c { #2 } }
}
\cs_new:Npn \BNVS_use:nc #1 #2 {
  \BNVS_use_raw:nc { #1 } { \BNVS:c { #2 } }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\cs_set_eq:NN \BNVS_use_raw_saved:N \BNVS_use_raw:N
\cs_set:Npn \BNVS_use_raw:N #1 {
  \cs_if_exist:NF #1 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #1~(c) }
  }
  #1
}
\cs_set_eq:NN \BNVS_use_raw_saved:NN \BNVS_use_raw:NN
\cs_set:Npn \BNVS_use_raw:NN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #2~(N) }
  }
  \BNVS_use_raw_saved:NN #1 #2
}
\cs_set_eq:NN \BNVS_use_raw_saved:nN \BNVS_use_raw:nN
\cs_set:Npn \BNVS_use_raw:nN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_fatal:x { Unknown~command~\token_to_str:N #2~(n) }
  }
  \BNVS_use_raw_saved:nN { #1 } #2
}

%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\BNVS_use_tl:Nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x { NO_WAY \token_to_str:N #1 }
%   }
% }
% \BNVS_tl_use:Nc \BNVS_Test:N { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\BNVS_tl_use:nc, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x {
%       ^^J=>\token_to_str:N #1
%       ^^J=>\tl_to_str:N #1
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:x {
%       ^^J=>\tl_to_str:N \l__bnvs_TEST_tl
%       ^^J=>\tl_to_str:n { #1 }
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\BNVS_use_raw:c, noigre}
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_Test: { SUCCESS }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A }
% \tl_clear:N \l__bnvs_TEST_tl
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use_raw:c { BNVS_Test: } }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A' }
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_fatal:x #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { FAILURE }
% }
% \cs_undefine:N \BNVS_Test:
% \BNVS_use_raw:c { BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { FAILURE } { B }
% \end{BNVS/test}
% \begin{BNVS/test}{:Nn=\BNVS_use:Nc{/:nc}, noigre}
% \BNVS_new:cpn { TEST: } { SUCCESS }
% \cs_if_exist:cF { \BNVS:c { TEST: } } {
%   \BNVS_fatal:x { Unknown~bnvs~command~TEST:~(ii-N) }
% }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \exp_args:No \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { E / \token_to_str:N #1 / }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \BNVS_set:cpn { TEST: } { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \cs_if_eq:NNF #1 \__bnvs_TEST: {
%     \test_fail:x { TEST / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:c { TEST: }
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_log:n #1 { }
\cs_generate_variant:Nn \BNVS_log:n { x }
\cs_new:Npn \BNVS_DEBUG_on: {
  \cs_set:Npn \BNVS_DEBUG_log:n { \BNVS_log:n }
}
\cs_new:Npn \BNVS_DEBUG_off: {
  \cs_set:Npn \BNVS_DEBUG_log:n { \use_none:n }
}
\BNVS_DEBUG_off:
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \BNVS_new:cpn,
%   \BNVS_set:cpn,
% }
% \cs{BNVS_new:cpn} is like \cs{cs_new:cpn} except that the name
% argument is tagged for \pkg{beanoves} package.
% Similarly for \cs{BNVS_set:cpn}.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new:cpn #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n {New=>#1}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \cs_new:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine:c #1 {
  \cs_undefine:c { \BNVS:c { #1 } }
}
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\BNVS_new:cpn, noigre}
% \BNVS_new:cpn { TEST: } { }
% \cs_if_exist:NF \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:c { TEST: }
% \cs_if_exist:NT \__bnvs_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_set:cpn #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n {BNVS_set:cpn=>#1}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \cs_set:cpn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_set:cpn, noigre}
% \BNVS_new:cpn { TEST:n } #1 { #1#1 }
% \cs_if_exist:NF \__bnvs_TEST:n {
%   \test_fail:n { NO_WAY/1 }
% }
% \tl_set:Nx \l__bnvs_TEST_A_tl { \__bnvs_TEST:n { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { XX } { 
%   \test_fail:n { NO_WAY/2 }
% }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_generate_variant:Nn \cs_generate_variant:Nn { c }
\cs_new:Npn \BNVS_generate_variant:cn #1 {
  \cs_generate_variant:cn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsection{logging}
%
% Utility messaging.
%
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
\msg_new:nnn { beanoves } { :nn } { #1~(#2) }
\BNVS_new:cpn { warning:n } {
  \msg_warning:nnn { beanoves } { :n }
}
\BNVS_generate_variant:cn { warning:n } { x }
\cs_new:Npn \BNVS_error:n {
  \msg_error:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_error:x {
  \msg_error:nnx { beanoves } { :n }
}
\cs_new:Npn \BNVS_fatal:n {
  \msg_fatal:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_fatal:x {
  \msg_fatal:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/gobble}
% Next are unexposed functions.
%<*!final>
\cs_new:Npn \BNVS_log_a:nn #1 #2 {
  \msg_term:nnn { beanoves } { :n } { #1~#2 }
}
\cs_generate_variant:Nn \BNVS_log_a:nn { xn }
\int_zero_new:N \l__BNVS_DEBUG_group_int
\cs_set:Npn \BNVS_log:n {
  \BNVS_log_a:xn
  { ▃▃ \prg_replicate:nn {\l__BNVS_DEBUG_group_int} {▁▃} \space }
}
%</!final>
% \end{BNVS/gobble}
%
% \subsection{Facility layer: Variables}
% \begin{function}{
%   \BNVS_N_new:c,
%   \BNVS_v_new:c,
% }
% \begin{syntax}
% \cs{BNVS_N_new:n} \marg{type}
% \end{syntax}
% Creates typed utility functions, see usage below.
% Undefined when no longer used.
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_N_new:c #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_new:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:c } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nc } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nc } }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1:c } ##1 {
    l \BNVS:c{ ##1 } \tl_if_empty:nF { ##1 } { _ } #1
  }
  \cs_new:cpn { BNVS_#1_new:c } ##1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { \use:c { BNVS_#1:c } { ##1 } } }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \use:c { #1_new:c } { \use:c { BNVS_#1:c } { ##1 } }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \cs_new:cpn { BNVS_#1_undefine:c } ##1 {
    \cs_undefine:c { \use:c { BNVS_#1:c } { ##1 } }  
  }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:c } ##1 {
    \use:c { \use:c { BNVS_#1:c } { ##1 } }
  }
  \cs_new:cpn { BNVS_#1_use:Nc } ##1 ##2 {
    \BNVS_use_raw:Nc
      ##1 { \use:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nc } ##1 ##2 {
    \BNVS_use_raw:nc
      { ##1 } { \use:c { BNVS_#1:c } { ##2 } }
  }
}
\cs_new:Npn \BNVS_v_new:c #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:Nv } }
\BNVS_log:x { New => \token_to_str:c { BNVS_#1_use:nv } }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_use:Nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NV ##1 }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
  \cs_new:cpn { BNVS_#1_use:nv } ##1 ##2 {
    \BNVS_use_raw:nc
      { \exp_args:NnV \use:n { ##1 } }
      { \BNVS_use_raw:c { BNVS_#1:c } { ##2 } }
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_tl_use:Nv{|:nv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_all:c #1 {
  \cs_undefine:c { BNVS_#1:c }
  \cs_undefine:c { BNVS_#1_new:c }
  \cs_undefine:c { BNVS_#1_use:c }
  \cs_undefine:c { BNVS_#1_use:nc }
  \cs_undefine:c { BNVS_#1_use:Nc }
  \cs_undefine:c { BNVS_#1_use:nv }
  \cs_undefine:c { BNVS_#1_use:Nv }
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_N_new:c { bool }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_bool:c, noigre}
% \exp_args:Nx \tl_if_eq:nnF { \BNVS_bool:c { TEST } } { l__bnvs_TEST_bool } {
%   \test_fail:x { TEST/\BNVS_bool:c { TEST } }
% }
% \end{BNVS/test}
% \begin{BNVS/test}{:Nn=\BNVS_bool_use:Nc{/:nc}, noigre}
% \bool_set_true:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NF #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \bool_set_false:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NT #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_N_new:c { int }
\BNVS_v_new:c { int }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_int_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \int_add:Nn #1 { 245 }
%   \int_compare:nNnF { #1 } = { 666 } {
%     \test_fail:x { TEST / \int_use:N #1 / }
%   }
% }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:Nc   \BNVS_Test:N   { TEST }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_N_new:c { tl }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_tl_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \assert_equal:nnn { #1 } { \l__bnvs_TEST_tl } { A }
% }
% \BNVS_tl_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_tl_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_v_new:c { tl }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_tl_use:nv, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \assert_equal_tl:vnn { TEST } { #1 } { A }
% }
% \BNVS_tl_use:Nv   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:nv { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_N_new:c { str }
\BNVS_v_new:c { str }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_str_use:nc{/:Nc}, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNF #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \str_set:Nn \l__bnvs_TEST_A_str { FAILURE }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNT #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A=B }
%   }
% }
% \BNVS_str_use:Nc   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nc { \BNVS_Test:N } { TEST_A }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_N_new:c { seq }
\BNVS_v_new:c { seq }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_seq_use:Nc{/:nc}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { 421 }
%   \seq_pop_left:NNTF #1 \l__bnvs_TEST_tl {
%     \tl_if_eq:NnF \l__bnvs_TEST_tl { SUCCESS } {
%       \test_fail:n { TEST/1/\tl_to_str:N #1 }
%     }
%   } {
%     \test_fail:n { TEST/2/\token_to_str:N #1 }
%   }
% }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:Nc   \BNVS_Test:N   { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\cs_undefine:N \BNVS_N_new:c
%    \end{macrocode}
% \begin{BNVS/gobble}
%</final>
% \end{BNVS/gobble}
% \begin{function}{
%   \BNVS_use:Ncn,
% }
% \begin{syntax}
% \cs{BNVS_use:Ncn} \meta{function} \marg{core name} \marg{type}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nc }   #1   { #2 }
}
\cs_new:Npn \BNVS_use:ncn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nc } { #1 } { #2 }
}
\cs_new:Npn \BNVS_use:Nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:Nv }   #1   { #2 }
}
\cs_new:Npn \BNVS_use:nvn #1 #2 #3 {
  \BNVS_use_raw:c { BNVS_#3_use:nv } { #1 } { #2 }
}
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:x { A / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Ncn   \BNVS_Test:N   { TEST_A } { tl }
% \BNVS_use:ncn { \BNVS_Test:N } { TEST_A } { tl }
% \end{BNVS/test}
% \begin{BNVS/test}{:Nn=\BNVS_use:Nvn{/:nvn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { A / \tl_to_str:n { #1 } }
%   }
% }
% \BNVS_use:Nvn   \BNVS_Test:n   { TEST_A } { tl }
% \BNVS_use:nvn { \BNVS_Test:n } { TEST_A } { tl }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Ncn   #1   { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:ncncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:ncn { #1 } { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:Nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:Nvn   #1   { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_use:nvncn #1 #2 #3 {
  \BNVS_use:ncn {
    \BNVS_use:nvn { #1 } { #2 } { #3 }
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_use:Ncncn{/:ncncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:NN #1 #2 {
%   \tl_if_eq:NNF #1 #2 {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Ncncn   \BNVS_Test:NN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_Test:NN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:ncncn { \BNVS_use_raw:c { BNVS_Test:NN } } { TEST_A } { tl } { TEST_B } { tl }
% \end{BNVS/test}
% \begin{BNVS/test}{:Nn=\BNVS_use:Nvncn{/:nvncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \cs_set:Npn \BNVS_Test:nN #1 #2 {
%   \tl_if_eq:NnF #2 { #1 } {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_use:Nvncn   \BNVS_Test:nN   { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_Test:nN } { TEST_A } { tl } { TEST_B } { tl }
% \BNVS_use:nvncn { \BNVS_use_raw:c { BNVS_Test:nN } } { TEST_A } { tl } { TEST_B } { tl }
% \cs_undefine:N \BNVS_Test:nN
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:Ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:Ncncn   #1   { #2 } { #3 } { #4 } { #5 }
  }
}
\cs_new:Npn \BNVS_use:ncncncn #1 #2 #3 #4 #5 {
  \BNVS_use:ncn {
    \BNVS_use:ncncn { #1 } { #2 } { #3 } { #4 } { #5 }
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_use:ncncncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:NNN #1 #2 #3 {
%   \tl_if_eq:NnF #1 { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:NnF #2 { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:NnF #3 { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_use:Ncncncn   \BNVS_Test:NNN   { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \BNVS_use:ncncncn { \BNVS_Test:NNN } { TEST_A } { tl } { TEST_B } { tl } { TEST_C } { tl }
% \end{BNVS/test}
% \begin{function}{
%   \BNVS_new_c:cn,
% }
% \begin{syntax}
% \cs{BNVS_new_c:nc} \marg{type} \marg{core name}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_c:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:c } {
    \BNVS_use_raw:c { BNVS_#1_use:nc } { \BNVS_use_raw:c { #1_#2:N } }
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_c:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \cs_if_exist:NT \tl_BNVS_TEST_A:N {
%   \test_fail:n { NAME~CONFLICT:\token_to_str:N \tl_BNVS_TEST_A:N }
% }
% \cs_set:Npn \tl_BNVS_TEST_A:N #1 {
%   \tl_if_eq:NnF #1 { SUCCESS } {
%     \test_fail:n { NO_WAY/1/\token_to_str:N #1 }
%   }
% }
% \BNVS_new_c:nc { tl } { BNVS_TEST_A }
% \cs_if_exist:NF \__bnvs_tl_BNVS_TEST_A:c {
%   \test_fail:n { NO_WAY/2 }
% }
% \__bnvs_tl_BNVS_TEST_A:c { TEST_A }
% \cs_undefine:N \tl_BNVS_TEST_A:N
% \cs_undefine:N \__bnvs_tl_TEST_A:c
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:nc #1 #2 {
  \BNVS_new:cpn { #1_#2:cn } ##1 {
    \BNVS_use:ncn { \BNVS_use_raw:c { #1_#2:Nn } } { ##1 } { #1 }
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_cn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_cn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \__bnvs_tl_TEST_A:cn
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cnn:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnn } ##1 {
    \BNVS_use:Ncn { #3 } { ##1 } { #1 }
  }
}
\cs_new:Npn \BNVS_new_cnn:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnn:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
\cs_new:Npn \BNVS_new_cnv:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnv } ##1 ##2 {
    \BNVS_tl_use:nv {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
\cs_new:Npn \BNVS_new_cnv:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnv:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
\cs_new:Npn \BNVS_new_cnx:ncN #1 #2 #3 {
  \BNVS_new:cpn { #2:cnx } ##1 ##2 {
    \exp_args:Nnx \use:n {
      \BNVS_use:Ncn #3 { ##1 } { #1 } {  ##2 }
    }
  }
}
\cs_new:Npn \BNVS_new_cnx:nc #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cnx:ncN { #1 } { #1_#2 }
  } { #1_#2:Nnn }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_cnn:nc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_if_exist:NT \tl_TEST_A:Nnn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:Nnn }
% }
% \cs_set:Npn \tl_TEST_A:Nnn #1 #2 #3 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y }
%   }
%   \tl_if_eq:nnF { #3 } { Z } {
%     \test_fail:n { Z }
%   }
% }
% \BNVS_new_cnn:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cnn {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cnn { TEST_A } { Y } { Z }
% \cs_undefine:N \tl_TEST_A:Nnn
% \cs_undefine:N \__bnvs_tl_TEST_A:cnn
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cc } ##1 ##2 {
    \BNVS_use:Ncncn #3 { ##1 } { #1 } { ##2 } { #4 }
  }
}
\cs_new:Npn \BNVS_new_cc:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cc:ncNn { #1 } { #1_#2 }
  } { #1_#2:NN }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cc:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cc }
}
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \BNVS_N_new:c { bnvs }
% \tl_new:N  \l__bnvs_TEST_A_bnvs
% \tl_set:Nn \l__bnvs_TEST_A_bnvs { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \tl_TEST_A:NN \l__bnvs_TEST_A_tl \l__bnvs_TEST_A_bnvs
% \BNVS_new_cc:ncn { tl } { TEST_A } { bnvs }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_A }
% \BNVS_undefine_all:c { bnvs }
% \cs_undefine:N \l__bnvs_TEST_A_bnvs
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cc:nc #1 #2 {
  \BNVS_new_cc:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_cc:ncn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \tl_set:Nn \l__bnvs_TEST_B_tl { 999 }
% \cs_if_exist:NT \tl_TEST_A:NN {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_TEST_A:NN }
% }
% \cs_set:Npn \tl_TEST_A:NN #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 }
%   }
%   \tl_if_eq:NnF #2 { 999 } {
%     \test_fail:n { 999 }
%   }
% }
% \BNVS_new_cc:nc { tl } { TEST_A }
% \cs_if_exist:NF \__bnvs_tl_TEST_A:cc {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_tl_TEST_A:cc { TEST_A } { TEST_B }
% \cs_undefine:N \tl_TEST_A:NN
% \BNVS_undefine_cc:nc { tl } { TEST_A }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cn } ##1 {
    \BNVS_use:Ncn #3 { ##1 } { #1 }
  }
}
\cs_new:Npn \BNVS_new_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new:cpn { #2:cv } ##1 ##2 {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 }
    } { ##2 } { #4 }
  }
}
\cs_new:Npn \BNVS_new_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:Nn }
}
\cs_new:Npn \BNVS_new_cv:nc #1 #2 {
  \BNVS_new_cv:ncn { #1 } { #2 } { #1 }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_cv:nc #1 #2 {
  \BNVS_undefine:c { #1_#2:cv }
}
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\BNVS_new_cv:ncn, noigre}
% \cs_if_exist:NT \tl_BNVS_TEST:Nn {
%   \test_fail:x { NAME~CONFLICT:~\token_to_str:N \tl_BNVS_TEST:Nn }
% }
% \cs_new:Npn \tl_BNVS_TEST:Nn { \tl_set:Nn }
% \tl_clear:N \l__bnvs_TEST_A_tl
% \tl_BNVS_TEST:Nn \l__bnvs_TEST_A_tl { SUCCESSA0 }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESSA0 } {
%   \test_fail:n { 0 }
% }
% \BNVS_new_cv:ncn { tl } { BNVS_TEST } { tl }
% \tl_clear:N \l__bnvs_TEST_A_tl
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESSA0 }
% \__bnvs_tl_BNVS_TEST:cv { TEST_A } { TEST_B }
% \__bnvs_tl_if_eq:cvF { TEST_A } { TEST_B } {
%   \test_fail:n { 0 }
% }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESSA0 } {
%   \test_fail:n { 0 }
% }
% \cs_undefine:N \tl_BNVS_TEST:Nn
% \BNVS_undefine_cv:nc { tl } { TEST }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_l_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_l:cn { #2 } { #3 } }
}
\cs_new:Npn \BNVS_l_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_l:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\BNVS_l_use:Ncn{/:ncn}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/l }
%   }
% }
% \BNVS_l_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_l_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_use:Ncn #1 #2 #3 {
  \BNVS_use_raw:Nc   #1   { \BNVS_g:cn { #2 } { #3 } }
}
\cs_new:Npn \BNVS_g_use:ncn #1 #2 #3 {
  \BNVS_use_raw:nc { #1 } { \BNVS_g:cn { #2 } { #3 } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_g_use:Ncn{/:ncn}, noigre}
% \tl_gset:Nn \g__bnvs_TEST_tl { 421 }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:NnF #1 { 421 } {
%     \test_fail:n { 421/g }
%   }
% }
% \BNVS_g_use:Ncn   \BNVS_Test:N   { TEST } { tl }
% \BNVS_g_use:ncn { \BNVS_Test:N } { TEST } { tl }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_g_prop_use:Nc #1 #2 {
  \BNVS_use_raw:Nc   #1   { \BNVS_g:cn { #2 } { prop } }
}
\cs_new:Npn \BNVS_g_prop_use:nc #1 #2 {
  \BNVS_use_raw:nc { #1 } { \BNVS_g:cn { #2 } { prop } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_g_prop_use:Nc{/:nc}, noigre}
% \prop_gput:Nnn \g__bnvs_TEST_prop { key } { value }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \prop_get:NnNTF #1 { key } \l__bnvs_TEST_tl {
%     \assert_equal_tl:vnn { TEST } { value } { TEST/1 }
%   } {
%     \test_fail:n { TEST/2 }
%   }
% }
% \BNVS_g_prop_use:Nc   \BNVS_Test:N   { TEST }
% \BNVS_g_prop_use:nc { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_exp_args:Nvvv #1 #2 #3 #4 {
  \BNVS_use:ncncncn { \exp_args:NVVV #1 }
    { #2 } { tl } { #3 } { tl } { #4 } { tl }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_exp_args:Nvvv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:nnF { #2 } { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:nnF { #3 } { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_exp_args:Nvvv \BNVS_Test:nnn { TEST_A } { TEST_B } { TEST_C }
% \end{BNVS/test}
% \begin{function}{
% \BNVS_new_conditional:cpnn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional:cpnn} \marg{core name} \meta{parameter} \marg{conditions} \marg{code}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_new_conditional:Npnn { c }
\cs_new:Npn \BNVS_new_conditional:cpnn #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_log:x {New => \token_to_str:c { \BNVS:c { #1 } } [TF?] }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_new_conditional:cpnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\cs_generate_variant:Nn \cs_split_function:N { c }
\cs_new:Npn \BNVS_undefine_conditional:c #1 {
  \BNVS_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \BNVS_undefine:c { #1##1 }
  }
}
\cs_new:Npn \BNVS_prg_undefine_conditional:c #1 {
  \cs_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \cs_undefine:c { #1##1 }
  }
}
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:N } \l__bnvs_TEST_A_tl }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:N#1 } \l__bnvs_TEST_A_tl }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_generate_conditional_variant:Nnn { c }
\cs_new:Npn \BNVS_generate_conditional_variant:cnn #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { Variant => #1[TF] }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_generate_conditional_variant:cnn { \BNVS:c { #1 } }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_conditional:cpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:cpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_generate_conditional_variant:cnn { TEST_A:N } c { p, T, F, TF }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:c { TEST_A_p:c } { l__bnvs_TEST_A_tl } }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:c { TEST_A:c#1 } { l__bnvs_TEST_A_tl } }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:c { TEST_A:N }
% \BNVS_undefine_conditional:c { TEST_A:c }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:cnn #1 #2 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vn:cNnn { #1 }
  } { #1:nn TF } { #2 }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_conditional_vn:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { S }
% \BNVS_new_conditional:cpnn { TEST:nn } #1 #2 { T, F, TF } {
%   \tl_if_eq:nnTF { #1 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vn:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { S } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { S } { }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { S }     { \test_fail:n { 3 } }
% \BNVS_use:c { TEST:vnTF } { TEST_A } { F } { \test_fail:n { 4 } } { }
% \BNVS_use:c { TEST:vnT  } { TEST_A } { F } { \test_fail:n { 5 } }
% \BNVS_use:c { TEST:vnF  } { TEST_A } { F }                        { }
% \BNVS_undefine_conditional:c { TEST:nn }
% \BNVS_undefine_conditional:c { TEST:Vn }
% \BNVS_undefine_conditional:c { TEST:vn }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vc:cNnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #2 { ##1 } { #3 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vc:cnn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNnn { #1 }
  } { #1:ncTF }
}
\cs_new:Npn \BNVS_new_conditional_vc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vc } ##1 ##2 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vc:cNn { #1 }
  } { #1:ncTF }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_conditional_vc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { SUCCESS }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vc#1 } { TEST_A } { TEST_B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 4 } }
% \BNVS_TEST:n {  F }                        { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { TEST:nc }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\BNVS_new_conditional_vc:cnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \BNVS_new_conditional:cpnn { TEST:n } #1 { TF } {
%   \tl_if_eq:nnTF { #1 } { SUCCESS } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional:cpnn { TEST:nc } #1 #2 { T, F, TF } {
%   \BNVS_use:c { #2 } { #1 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_new_conditional_vc:cnn { TEST } { tl } { T, F, TF }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { } { \test_fail:n { 1 } }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }     { \test_fail:n { 2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_use:c { TEST:vcTF } { TEST_A } { TEST:nTF } { \test_fail:n { 3 } } { }
% \BNVS_use:c { TEST:vcT  } { TEST_A } { TEST:nTF } { \test_fail:n { 4 } }
% \BNVS_use:c { TEST:vcF  } { TEST_A } { TEST:nTF }                        { }
% \BNVS_undefine_conditional:c { TEST:n  }
% \BNVS_undefine_conditional:c { TEST:nN }
% \BNVS_undefine_conditional:c { TEST:VN }
% \BNVS_undefine_conditional:c { TEST:vc }
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsubsection{Regex}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_regex_use:Nc #1 #2 {
  \BNVS_use_raw:Nc #1 { c \BNVS:c { #2 } _regex }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_match_if_once:Nn,
%   \__bnvs_match_if_once:Nv,
%   \__bnvs_match_if_once:nn,
%   \__bnvs_if_regex_split:cn,
% }
% \begin{syntax}
% \cs{__bnvs_match_if_once:NnTF} \meta{regex variable} \marg{expression}
% \marg{yes code} \marg{no code}
% \cs{__bnvs_match_if_once:nnTF} \marg{regex} \marg{expression}
% \marg{yes code} \marg{no code}
% \cs{__bnvs_if_regex_split:cncTF} \marg{regex core} \marg{expression} \meta{seq core} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_regex_split:cnTF} \marg{regex core} \marg{expression} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item \cs{regex_match_if_once:NnNTF} with the |match| sequence as N argument
% \item \cs{regex_match_if_once:nnNTF} with the |match| sequence as N argument
% \item \cs{regex_split:NnNTF} with the |split| sequence as last N argument
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_extract_once:Ncn } #1 #2 #3 { T, F, TF } {
  \BNVS_use:ncn {
    \regex_extract_once:NnNTF #1 { #3 }
  } { #2 } { seq } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { match_if_once:Nn } #1 #2 { T, F, TF } {
  \BNVS_use:ncn {
    \regex_extract_once:NnNTF #1 { #2 }
  } { match } { seq } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_extract_once:NcnTF, noigre}
% \BNVS_seq_new:c { A_TEST }
% \__bnvs_if_extract_once:NcnTF \c__bnvs_TEST_comma_regex { A_TEST } { , } {
%   \seq_pop_left:NNTF \l__bnvs_A_TEST_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_match_if_once:NnTF, noigre}
% \__bnvs_match_if_once:NnTF \c__bnvs_TEST_comma_regex { , } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_extract_once:Ncv } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_tl_use:nv {
      \regex_extract_once:NnNTF #1 
    } { #3 }
  } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { match_if_once:Nv } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_tl_use:nv {
      \regex_extract_once:NnNTF #1 
    } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_extract_once:NcvTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \__bnvs_if_extract_once:NcvTF \c__bnvs_TEST_comma_regex { A_TEST }{ TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_A_TEST_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_match_if_once:NvTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \__bnvs_match_if_once:NvTF \c__bnvs_TEST_comma_regex { TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { match_if_once:nn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \regex_extract_once:nnNTF { #1 } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_match_if_once:nnTF, noigre}
% \__bnvs_match_if_once:nnTF { A } { A } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { A } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_regex_split:cnc } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_regex_split:cn } #1 #2 { T, F, TF } {
  \BNVS_seq_use:nc {
    \BNVS_regex_use:Nc \regex_split:NnNTF { #1 } { #2 }
  } { split } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_regex_split:cnTF, noigre}
% \cs_set:Npn \BNVS_Test:nT #1 #2 {
%   \seq_pop_left:NNTF \l__bnvs_split_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { #1 } { #1/1 }
%     #2
%   } {
%     \test_fail:n { #1/2 }
%   }
% }
% \__bnvs_if_regex_split:cnTF { TEST_comma } { A,B,C } {
%   \BNVS_Test:nT { A } { \BNVS_Test:nT { B } { \BNVS_Test:nT { C } { } } }
% } {
%   \test_fail:n { A/3 }
% }
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsubsection{Token lists}
% \begin{function}{
%   \__bnvs_tl_clear:c,
%   \__bnvs_tl_use:c,
%   \__bnvs_tl_set_eq:cc,
%   \__bnvs_tl_set:cn,
%   \__bnvs_tl_set:cv,
%   \__bnvs_tl_set:cx,
%   \__bnvs_tl_put_left:cn,
%   \__bnvs_tl_put_right:cn,
%   \__bnvs_tl_put_right:cx,
%   \__bnvs_tl_put_right:cv,
% }
% \begin{syntax}
% \cs{__bnvs_tl_clear:c} \marg{core key tl}
% \cs{__bnvs_tl_use:c} \marg{core}
% \cs{__bnvs_tl_count:c} \marg{core}
% \cs{__bnvs_tl_set_eq:cc} \marg{lhs core name} \marg{rhs core name}
% \cs{__bnvs_tl_set:cn} \marg{core} \marg{tl}
% \cs{__bnvs_tl_set:cv} \marg{core} \marg{value core name}
% \cs{__bnvs_tl_put_left:cn} \marg{core} \marg{tl}
% \cs{__bnvs_tl_put_right:cn} \marg{core} \marg{tl}
% \cs{__bnvs_tl_put_right:cv} \marg{core} \marg{value core name}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_clear:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_use:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_set_eq:cc {l__bnvs_|\texttt{\meta{lhs core}}|_tl}||{l__bnvs_|\texttt{\meta{rhs core}}|_tl}|
% \item |\tl_set:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \item |\tl_set:cx {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_left:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \end{itemize}
% \end{function}
% \begin{function}{
%   \BNVS_new_conditional_vnc:cn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional_vnc:cn} \marg{core} \marg{conditions}
% \end{syntax}
% \meta{function} is the test function with signature |...:nncTF|.
% \meta{core}|:nncTF| is used for testing.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vnc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:Nv #2 { ##1 } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vnc:cNn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \BNVS_new_conditional_vnc:cn
% }
% \begin{syntax}
% \cs{BNVS_new_conditional_vnc:cn} \marg{core} \marg{conditions}
% \end{syntax}
% Forwards to |\BNVS_new_conditional_vnc:cNn| with |\|\meta{core}|:nncTF| as function argument. Used for testing.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvnc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvnc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvnc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvnc:cNn { #1 }
  } { #1:nnncTF }
}
\cs_new:Npn \BNVS_new_conditional_vvvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvvc } ##1 ##2 ##3 ##4 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:nv {
        \BNVS_tl_use:Nv #2 { ##1 }
      } { ##2 }
    } { ##3 } { ##4 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvvc:cNn { #1 }
  } { #1:nnncTF }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_new_conditional_vnc:cn, noigre}
% \BNVS_new_conditional:cpnn { TEST:nnc } #1 #2 #3 { T, F, TF } {
%   \BNVS_tl_use:Nc \tl_set:Nn { TEST_#3 } { #1 }
%   \BNVS_tl_use:Nc \tl_if_eq:NnTF { TEST_#3 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_use:c { TEST:nncTF } { A } { A } { B } { } { \test_fail:n { 0 } }
% \BNVS_use:c { TEST:nncTF } { A } { B } { B } { \test_fail:n { 1 } } { }
% \BNVS_new_conditional_vnc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_TEST:vncTF { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 2 } }
% \BNVS_use:c { TEST:vnc TF } { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 3 } }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:c { TEST:vnc#1 } { TEST_A } { SUCCESS } { B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { B/1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { B/2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { B/3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { B/4 } }
% \BNVS_TEST:n {  F }                          { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:c { BNVS_TEST:nnc }
% \BNVS_undefine_conditional:c { BNVS_TEST:vnc }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vvc:cNn #1 #2 #3 {
  \BNVS_new_conditional:cpnn { #1:vvc } ##1 ##2 ##3 { #3 } {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:Nv #2 { ##1 }
    } { ##2 } { ##3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vvc:cn #1 {
  \BNVS_use:nc {
    \BNVS_new_conditional_vvc:cNn { #1 }
  } { #1:nncTF }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_c:c {
  \BNVS_new_c:nc { tl }
}
\BNVS_new_tl_c:c { clear }
\BNVS_new_tl_c:c { use }
\BNVS_new_tl_c:c { count }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_tl_clear:c{|use:c|count:c}, noigre}
% \BNVS_tl_new:c { TEST_NCUC }
% \tl_set:Nn \l__bnvs_TEST_NCUC_tl { SUCCESS }
% \assert_size_equal:nnn { SUCCESS } { \__bnvs_tl_use:c { TEST_NCUC } } { 1 }
% \assert_size_equal:nnn { 7 } { \__bnvs_tl_count:c { TEST_NCUC } } { 2 }
% \__bnvs_tl_clear:c { TEST_NCUC }
% \assert_size_equal:nnn {   } { \__bnvs_tl_use:c   { TEST_NCUC } } { 3 }
% \assert_size_equal:nnn { 0 } { \__bnvs_tl_count:c { TEST_NCUC } } { 4 }
% \BNVS_tl_undefine:c { TEST_NCUC }
% \end{BNVS/test}
%    \begin{macrocode}

\BNVS_new:cpn { tl_set_eq:cc } #1 #2 {
  \BNVS_use:ncncn { \tl_set_eq:NN } { #1 } { tl } { #2 } { tl }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_tl_set_eq:cc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \__bnvs_tl_clear:c { TEST_B }
% \__bnvs_tl_set_eq:cc { TEST_B } { TEST_A }
% \tl_if_eq:NNF \l__bnvs_TEST_A_tl \l__bnvs_TEST_B_tl { \test_fail:n { 1 } }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_tl_cn:c {
  \BNVS_new_cn:nc { tl }
}
\cs_new:Npn \BNVS_new_tl_cv:c #1 {
  \BNVS_new_cv:ncn { tl } { #1 } { tl }
}
\BNVS_new_tl_cn:c { set }
\BNVS_new_tl_cv:c { set }
\BNVS_new:cpn { tl_set:cx } {
  \exp_args:Nnx \__bnvs_tl_set:cn
}
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_tl_set:cn{|:cv|:cx}, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } { \test_fail:x { cn/\l__bnvs_TEST_A_tl } }
% \tl_clear:N \l__bnvs_TEST_B_tl
% \__bnvs_tl_set:cx { TEST_B } { \l__bnvs_TEST_A_tl }
% \tl_if_eq:NnF \l__bnvs_TEST_B_tl { SUCCESS } { \test_fail:n { cx } }
% \tl_clear:N \l__bnvs_TEST_C_tl
% \__bnvs_tl_set:cv { TEST_C } { TEST_A }
% \tl_if_eq:NnF \l__bnvs_TEST_C_tl { SUCCESS } { \test_fail:n { cv } }
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_new_tl_cn:c { put_right }
\BNVS_new_tl_cv:c { put_right }
% \BNVS_generate_variant:cn { tl_put_right:cn } { cx }
\BNVS_new:cpn { tl_put_right:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_right:cn }
}
\BNVS_new_tl_cn:c { put_left }
\BNVS_new_tl_cv:c { put_left }
% \BNVS_generate_variant:cn { tl_put_left:cn } { cx }
\BNVS_new:cpn { tl_put_left:cx } {
  \exp_args:Nnnx \BNVS_use:c { tl_put_left:cn }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_tl_if_empty:c,
%   \__bnvs_tl_if_blank:v,
%   \__bnvs_tl_if_eq:cn,
% }
% \begin{syntax}
% \cs{__bnvs_tl_if_empty:cTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{__bnvs_tl_if_blank:vTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{__bnvs_tl_if_eq:cnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:cTF {l__bnvs_|\texttt{\meta{core}}|_tl}| \texttt{\marg{yes code} \marg{no code}}
% \item |\tl_if_eq:cnTF {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl} \marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_c:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2 } ##1 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_c:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_c:ncNn { #1 } { #1_#2:c }
  } { #1_#2:NTF }
}
\BNVS_new_conditional_c:ncn { tl } { if_empty } { p, T, F, TF }
\BNVS_new_conditional:cpnn { tl_if_blank:v } #1 { T, F, TF } {
  \BNVS_tl_use:Nv \tl_if_blank:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_tl_if_empty:c, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_empty:c#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_empty:cTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_tl_if_blank:v, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:cpn { TEST:n } #1 {
%   \BNVS_use_raw:c { __bnvs_tl_if_blank:v#1} { TEST_A }
% }
% \__bnvs_tl_if_empty:cTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use_raw:c { __bnvs_tl_if_blank:vTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \__bnvs_TEST:n { T  } { }
% \__bnvs_TEST:n {  F }     { \test_fail:n { 1/B } }
% \__bnvs_tl_set:cn { TEST_A } { SUCCESS }
% \__bnvs_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \__bnvs_TEST:n { T  } { \test_fail:n { 2/B } }
% \__bnvs_TEST:n {  F }                          { }
% \BNVS_undefine:c { TEST:n }
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cn } ##1 ##2 { #4 } {
    \BNVS_use:Ncn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_cn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cn:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cn:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:cv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Ncn #3 { ##1 } { #1 } 
    } { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_cv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_cv:ncNn { #1 } { #1_#2 }
  } { #1_#2:NnTF }
}
\BNVS_new_conditional_cv:ncn { tl } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_tl_if_eq:cn{|:cv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { A } { } { \test_fail:n { 1/A } }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { A } { } 
% \__bnvs_tl_if_eq:cnF  { TEST_A } { A }     { \test_fail:n { 1/B } }
% \__bnvs_tl_if_eq:cnTF { TEST_A } { B } { \test_fail:n { 2/A } } { }
% \__bnvs_tl_if_eq:cnT  { TEST_A } { B } { \test_fail:n { 2/B } }
% \__bnvs_tl_if_eq:cnF  { TEST_A } { B }                          { }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { } { \test_fail:n { 3/A } }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { } 
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }     { \test_fail:n { 3/B } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \__bnvs_tl_if_eq:cvTF { TEST_A } { TEST_B } { \test_fail:n { 4/A } } { }
% \__bnvs_tl_if_eq:cvT  { TEST_A } { TEST_B } { \test_fail:n { 4/B } }
% \__bnvs_tl_if_eq:cvF  { TEST_A } { TEST_B }                          { }
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsubsection{Strings}
% \begin{function}[TF]{
%   \__bnvs_str_if_eq:vn,
% }
% \begin{syntax}
% \cs{__bnvs_str_if_eq:vnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\str_if_eq:ccTF {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vn:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vn } ##1 ##2 { #4 } {
    \BNVS_use:Nvn #3 { ##1 } { #1 } { ##2 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vn:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vn:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vn:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_vv:ncNn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #2:vv } ##1 ##2 { #4 } {
    \BNVS_use:nvn {
      \BNVS_use:Nvn #3 { ##1 } { #1 }
    }  { ##2 } { #1 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \BNVS_new_conditional_vv:ncn #1 #2 {
  \BNVS_use_raw:nc {
    \BNVS_new_conditional_vv:ncNn { #1 } { #1_#2 }
  } { #1_#2:nnTF }
}
\BNVS_new_conditional_vv:ncn { str } { if_eq } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_str_if_eq:vn/:vv, noigre, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_str_if_eq:vn#1 } { TEST_A }
% }
% \BNVS_Test:n { TF } { SUCCESS } { } { \test_fail:n { 1/A } }
% \BNVS_Test:n { T  } { SUCCESS } { } 
% \BNVS_Test:n {  F } { SUCCESS }     { \test_fail:n { 1/B } }
% \BNVS_Test:n { TF } { FAILURE } { \test_fail:n { 2/A } } { }
% \BNVS_Test:n { T  } { FAILURE } { \test_fail:n { 2/B } }
% \BNVS_Test:n {  F } { FAILURE }                          { }
% \cs_set:Npn \BNVS_Test:n #1 { \BNVS_use_raw:c { __bnvs_str_if_eq:vv#1 } { TEST_A } }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \BNVS_Test:n { TF } { TEST_B } { } { \test_fail:n { 3/A } }
% \BNVS_Test:n {  T } { TEST_B } { }
% \BNVS_Test:n { F  } { TEST_B }     { \test_fail:n { 3/B } }
% \str_set:Nn \l__bnvs_TEST_B_str { FAILURE }
% \BNVS_Test:n { TF } { TEST_B } { \test_fail:n { 4/A } } { }
% \BNVS_Test:n { T  } { TEST_B } { \test_fail:n { 4/B } }
% \BNVS_Test:n {  F } { TEST_B }                          { }
% \cs_undefine:c { Test:n }
% \end{BNVS/test}
%    \begin{macrocode}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Sequences}
% \begin{function}{
%   \__bnvs_seq_count:c,
%   \__bnvs_seq_clear:c,
%   \__bnvs_seq_set_eq:cc,
%   \__bnvs_seq_use:cn,
%   \__bnvs_seq_item:cn,
%   \__bnvs_seq_remove_all:cn,
%   \__bnvs_seq_put_left:cv,
%   \__bnvs_seq_put_right:cn,
%   \__bnvs_seq_put_right:cv,
%   \__bnvs_seq_set_split:cnn,
%   \__bnvs_seq_set_split:cnv,
%   \__bnvs_seq_set_split:cnx,
%   \__bnvs_seq_pop_left:cc,
% }
% \begin{syntax}
% \cs{__bnvs_seq_new:c } \marg{core}
% \cs{__bnvs_seq_count:c } \marg{core}
% \cs{__bnvs_seq_clear:c } \marg{core}
% \cs{__bnvs_seq_set_eq:cc } \marg{core_1} \marg{core_2}
% \cs{__bnvs_seq_use:cn } \marg{core} \marg{separator}
% \cs{__bnvs_seq_item:cn } \marg{core} \marg{integer expression}
% \cs{__bnvs_seq_remove_all:cn } \marg{core} \marg{tl}
% \cs{__bnvs_seq_put_right:cn } \marg{seq core} \marg{tl}
% \cs{__bnvs_seq_put_right:cv } \marg{seq core} \marg{tl core}
% \cs{__bnvs_seq_set_split:cnn } \marg{seq core} \marg{tl} \marg{separator}
% \cs{__bnvs_seq_pop_left:cc } \marg{core_1} \marg{core_2}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\seq_set_eq:cc {l__bnvs_|\texttt{\meta{core_1}}|_seq} {l__bnvs_|\texttt{\meta{core_2}}|_seq}|
% \item |\seq_count:c {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_use:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{separator}}
% \item |\seq_item:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{integer expression}}
% \item |\seq_remove_all:cn {l__bnvs_|\texttt{\meta{core}}|_seq}|\texttt{\marg{tl}}
% \item |\__bnvs_seq_clear:c {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_put_right:cv {l__bnvs_|\texttt{\meta{seq core}}|_seq} {l__bnvs_|\texttt{\meta{tl core}}|_tl}|
% \item |\seq_set_split:cnn{l__bnvs_|\texttt{\meta{seq core}}|_seq}{l__bnvs_|\texttt{\meta{tl core}}|_tl}{|\texttt{\meta{tl}}|}|
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { seq } { count }
\BNVS_new_c:nc   { seq } { clear }
\BNVS_new_cn:nc  { seq } { use }
\BNVS_new_cn:nc  { seq } { item }
\BNVS_new_cn:nc  { seq } { remove_all }
\BNVS_new_cn:nc  { seq } { map_inline }
\BNVS_new_cc:nc  { seq } { set_eq }
\BNVS_new_cv:ncn { seq } { put_left  } { tl }
\BNVS_new_cn:ncn { seq } { put_right } { tl }
\BNVS_new_cv:ncn { seq } { put_right } { tl }
\BNVS_new_cnn:nc { seq } { set_split }
\BNVS_new_cnv:nc { seq } { set_split }
\BNVS_new_cnx:nc { seq } { set_split }
\BNVS_new_cc:ncn { seq } { pop_left  } { tl }
\BNVS_new_cc:ncn { seq } { pop_right } { tl }
%    \end{macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_seq{...}, noigre}
% \BNVS_seq_new:c { B_TEST }
% \__bnvs_seq_clear:c { A_TEST }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \assert_size_not_equal:nnn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { 0 }
% \__bnvs_seq_put_right:cv { A_TEST } { TEST_B }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 1 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { FAILURE } { 1 }
% \__bnvs_seq_put_left:cv { A_TEST } { TEST_A }
% \int_compare:nNnF { \__bnvs_seq_count:c { A_TEST } } = { 2 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \seq_use:Nn \l__bnvs_A_TEST_seq { , } } { SUCCESS , FAILURE } { 5 }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { A_TEST } { , } } { SUCCESS , FAILURE } { 6 }
% \__bnvs_seq_set_eq:cc { B_TEST } { A_TEST }
% \assert_size_equal:nnn { \__bnvs_seq_use:cn { B_TEST } { , } } { SUCCESS , FAILURE } { 7 }
% \BNVS_seq_undefine:c { A_TEST }
% \BNVS_seq_undefine:c { B_TEST }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_seq_split:cnn/pop_right:cc, noigre}
% \__bnvs_seq_clear:c { TEST }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 1 } } { A } { 1 }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 2 } } { B } { 2 }
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { B } { \test_fail:n { 3 } }
% \__bnvs_seq_pop_right:cc { TEST } { TEST }
% \__bnvs_tl_if_eq:cnF { TEST } { A } { \test_fail:n { 4 } }
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_seq_if_empty:c,
%   \__bnvs_seq_get_right:cc,
%   \__bnvs_seq_pop_left:cc,
%   \__bnvs_seq_pop_right:cc,
% }
% \begin{syntax}
% \cs{ __bnvs_seq_if_empty:cTF } \marg{seq core} \marg{yes code} \marg{no code}
% \cs{ __bnvs_seq_get_right:ccTF } \marg{seq core} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new_conditional_cc:ncnn #1 #2 #3 #4 {
  \BNVS_new_conditional:cpnn { #1_#2:cc } ##1 ##2 { #4 } {
    \BNVS_use:ncncn {
      \BNVS_use_raw:c { #1_#2:NNTF }
    } { ##1 } { #1 } { ##2 } { #3 } {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
\BNVS_new_conditional_c:ncn { seq } { if_empty } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { get_right } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_left  } { tl } { T, F, TF }
\BNVS_new_conditional_cc:ncnn
  { seq } { pop_right } { tl } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_seq_get_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:c { seq_get_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { B } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_seq_pop_left:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_left:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { A } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_seq_pop_right:ccTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_pop_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { C } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_seq_if_empty:cTF, noigre}
% \__bnvs_seq_clear:c { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \__bnvs_seq_set_split:cnn { TEST } { , } { A, B }
% \BNVS_Test:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 4 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsubsection{Integers}
% \begin{function}{
%   \__bnvs_int_new:c,
%   \__bnvs_int_use:c,
%   \__bnvs_int_zero:c,
%   \__bnvs_int_inc:c,
%   \__bnvs_int_decr:c,
%   \__bnvs_int_set:cn,
%   \__bnvs_int_set:cv
% }
% \begin{syntax}
% \cs{ __bnvs_int_new:c  } \marg{core}
% \cs{ __bnvs_int_use:c  } \marg{core}
% \cs{ __bnvs_int_incr:c } \marg{core}
% \cs{ __bnvs_int_decr:c } \marg{core}
% \cs{ __bnvs_int_set:cn } \marg{core} \marg{value}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\int_new:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_use:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_incr:c  {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_idecr:c {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_set:cn  {l__bnvs_|\texttt{\meta{core}}|_int}| \texttt{\meta{value}}
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_c:nc   { int } { new  }
\BNVS_new_c:nc   { int } { use  }
\BNVS_new_c:nc   { int } { zero }
\BNVS_new_c:nc   { int } { incr }
\BNVS_new_c:nc   { int } { decr }
\BNVS_new_cn:nc  { int } { set  }
\BNVS_new_cv:ncn { int } { set  } { int }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_int_new:c/use:c/set:cn, noigre}
% \BNVS_int_new:c  { A_TEST }
% \__bnvs_int_set:cn { A_TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { A_TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_set:cn { A_TEST } { 2 }
% \BNVS_Test:nn { 2 } { 2 }
% \cs_undefine:N \BNVS_Test:nn
% \BNVS_int_undefine:c { A_TEST }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_int_incr:c/decr:c, noigre}
% \__bnvs_int_set:cn { TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \__bnvs_int_incr:c { TEST }
% \BNVS_Test:nn { 2 } { 2 }
% \__bnvs_int_decr:c { TEST }
% \BNVS_Test:nn { 1 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_int_set:cv, noigre}
% \__bnvs_int_set:cn { TEST_A } { 421 }
% \__bnvs_int_set:cv { TEST_B } { TEST_A }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \__bnvs_int_use:c { TEST_B } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 421 } { 1 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsubsection{Prop}
% \begin{function}[TF]{
%   \__bnvs_if_prop_get:Nnc,
% }
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_prop_get:Nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_use:ncn {
    \prop_get:NnNTF #1 { #2 }
  } { #3 } { tl } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_prop_get:NncTF, noigre}
% \prop_clear:N \l__bnvs_TEST_prop
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_use_raw:c { __bnvs_if_prop_get:Nnc#1 }
%     \l__bnvs_TEST_prop { #2 } { TEST }
% }
% \BNVS_Test:nn { TF } { key } { \test_fail:n { A/1 } } { }
% \BNVS_Test:nn { T  } { key } { \test_fail:n { A/2 } }
% \BNVS_Test:nn {  F } { key }                        { }
% \prop_put:Nnn \l__bnvs_TEST_prop { key } { value }
% \cs_set:Npn \Test_a:nn #1 #2 {
%   \__bnvs_tl_if_eq:cnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:nn { TF } { key } { \Test_a:nn { value } { A/3 } } { \test_fail:n { B/3 } }
% \BNVS_Test:nn { T  } { key } { \Test_a:nn { value } { A/3 } }
% \BNVS_Test:nn {  F } { key }     { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \Test_a:nn
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \subsection{Debug facilities}
% Typesetting file |beanoves.dtx| creates both \pkg{beanoves}
% and \pkg{beanoves-debug} style files. The former is intended for everyday
% use whereas the latter contains supplemental debugging and testing
% facilities which are intentionally left undocumented.
% In particular, we have aliases for |\group_begin:| and |\group_end:|
% to allow the display of supplemental informations while debugging.
%
% \subsection{Debug messages}
% \begin{BNVS/gobble}
%<*!debug>
\cs_new:Npn \BeanovesDebugOn {
  \__bnvs_warning:x { Debugging~mode~requires~\jobname-debug.sty,~typeset~\jobname.dtx}
}
\cs_new:Npn \BeanovesDebugOff { \BeanovesDebugOn }
%</!debug>
%<*!final>
\cs_set_eq:NN \BeanovesDebugOn \BNVS_DEBUG_on:
\cs_set_eq:NN \BeanovesDebugOff \BNVS_DEBUG_off:
\cs_generate_variant:Nn \BNVS_DEBUG_log:n { x, V }
\cs_new:Npn \BNVS_DEBUG_b:nn #1 #2 {
  \BNVS_DEBUG_log:x { #1~#2 }
}
%</!final>
% \end{BNVS/gobble}
%
% \subsection{Variable facilities}
%
%
% \subsection{Testing facilities}
% \begin{BNVS/gobble}
% Next documentation is only in the source.
% In order to ensure that grouping is properly managed,
% we use dedicated commands to begin or end a group.
% In final mode, there is no added value.
% In debug mode, the depth is recorded and a label is possibly used.
%<*final>
\cs_set_eq:NN \BNVS_begin: \group_begin:
\cs_set_eq:NN \BNVS_end: \group_end:
%</final>
%<*!final>
\str_new:N \l__BNVS_DEBUG_group_str
\cs_new:Npn \BNVS_DEBUG_end_set:n #1 {
  \cs_set:Npn \BNVS_end: {
    \int_compare:nNnTF { #1 } > { \int_use:N \l__BNVS_DEBUG_group_int } {
      \BNVS_error:x {Internal~error:~too~many~group~end.}
    } {
      \int_compare:nNnT { #1 } < { \int_use:N \l__BNVS_DEBUG_group_int } {
        \BNVS_error:x {Internal~error:~missing~group~end.}
      }
    }
    \group_end:
    \str_if_empty:NTF \l__BNVS_DEBUG_group_str {
      \BNVS_DEBUG_log:x { Top~level }
    } {
      \BNVS_DEBUG_log:x
        { Back~to~\l__BNVS_DEBUG_group_str / \int_use:N \l__BNVS_DEBUG_group_int }
    }
  }
}
\cs_new:Npn \BNVS_begin: {
  \group_begin:
  \str_clear:N \l__BNVS_DEBUG_group_str
  \int_incr:N \l__BNVS_DEBUG_group_int
  \exp_args:Nx \BNVS_DEBUG_end_set:n
    { \int_use:N \l__BNVS_DEBUG_group_int }
}
\cs_new:Npn \BNVS_DEBUG_end_set:nn #1 #2 {
  \str_set:Nn \l__BNVS_DEBUG_group_str { #2 }
  \cs_set:Npn \BNVS_end: {
    \str_if_eq:VnF \l__BNVS_DEBUG_group_str { #2 } {
      \BNVS_error:x
        { Wrong~grouping~\l__BNVS_DEBUG_group_str!=#2 }
    }
    \int_compare:nNnTF { #1 } > { \int_use:N \l__BNVS_DEBUG_group_int } {
      \BNVS_error:n {Internal~error:~too~many~group~end.}
    } {
      \int_compare:nNnT { #1 } < { \int_use:N \l__BNVS_DEBUG_group_int } {
        \BNVS_error:n {Internal~error:~missing~group~end.}
      }
    }
    \BNVS_DEBUG_log:x {END~#2/\int_use:N \l__BNVS_DEBUG_group_int}
    \group_end:
    \str_if_empty:NTF \l__BNVS_DEBUG_group_str {
      \BNVS_DEBUG_log:x { Top~level }
    } {
      \BNVS_DEBUG_log:x
        { Back~to~\l__BNVS_DEBUG_group_str / \int_use:N \l__BNVS_DEBUG_group_int }
    }
  }
}
\cs_set:Npn \BNVS_DEBUG_begin:n #1 {
  \BNVS_begin:
  \BNVS_DEBUG_log:x {BEGIN~#1/\int_use:N \l__BNVS_DEBUG_group_int}
  \str_set:Nx \l__BNVS_DEBUG_group_str { #1 }
  \exp_args:Nxx
  \BNVS_DEBUG_end_set:nn { \int_use:N \l__BNVS_DEBUG_group_int } { #1 }
}
\cs_set:Npn \BNVS_DEBUG_end:n #1 {
  \str_if_eq:VnF \l__BNVS_DEBUG_group_str { #1 } {
    \BNVS_error:x
      { Wrong~grouping~\l__BNVS_DEBUG_group_str!=#1 }
  }
  \BNVS_end:
}
\cs_set_eq:NN \BNVS_end: \group_end:
\bool_new:N \l__bnvs_TEST_ignore_bool
\bool_set_false:N \l__bnvs_TEST_ignore_bool
\cs_new:Npn \BNVS_DEBUG_log:nn #1 {
  \exp_args:Nx
  \BNVS_DEBUG_b:nn
  { ▄▄ \prg_replicate:nn {\l__BNVS_DEBUG_group_int + 1} {#1} }
}
\cs_generate_variant:Nn \BNVS_DEBUG_log:nn { nx, nV }
\ProvideDocumentEnvironment {BNVS/failure} {} {} {}
\bool_new:N \l__bnvs_TEST_bool
\tl_new:N \g__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_banner_tl
\tl_new:N \l__bnvs_TEST_done_tl
\tl_clear:N \l__bnvs_TEST_done_tl
\tl_new:N \l__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_A_tl
\tl_new:N \l__bnvs_TEST_B_tl
\tl_new:N \l__bnvs_TEST_C_tl
\str_new:N \l__bnvs_TEST_str
\str_new:N \l__bnvs_TEST_A_str
\str_new:N \l__bnvs_TEST_B_str
\seq_new:N \l__bnvs_TEST_seq
\seq_new:N \l__bnvs_TEST_A_seq
\seq_new:N \l__bnvs_TEST_B_seq
\int_new:N \l__bnvs_TEST_int
\int_new:N \l__bnvs_TEST_group_int
\prop_new:N \l__bnvs_TEST_prop
\prop_new:N \g__bnvs_TEST_prop
\regex_const:Nn \c__bnvs_TEST_comma_regex { , }
\NewDocumentEnvironment{BNVS/test} {} {
  \color{red}\bfseries\ExplSyntaxOn
  \debug_on:n { check-declarations }
  \__bnvs_gclear_all:
  \int_gset:Nn \g__bnvs_call_int { 128 }
  \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
  \__bnvs_provide_off:
  \BNVS_DEBUG_log_set:cnnc { if_resolve_query:ncTF } { QUERY } { ? } { ans }
  \BNVS_TEST_BEGIN:n
} {
  \assert_equal:xxn {
    \int_use:N \l__BNVS_DEBUG_group_int
  } {
    \int_use:N \l__bnvs_TEST_group_int
  } { Bad~group~nesting }
  \tl_use:N \l__bnvs_TEST_done_tl
  \__bnvs_gclear:
  \ExplSyntaxOff\ignorespacesafterend
}
\keys_define:nn { BNVS/test } {
  banner  .code:n = \tl_set:Nn \l__bnvs_TEST_banner_tl { #1 },
  :N      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:N #1
  },
  :Nn     .code:n = \exp_args:NNo \tl_set:No \l__bnvs_TEST_banner_tl { 
    \exp_last_unbraced:No \token_to_str:N { \use_i:nn #1 }
    \use_ii:nn #1
  },
  :c      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { #1 }
  },
  :cn     .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \use_i:nn #1 } \use_ii:nn #1
  },
  bnvs:c  .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { \use_i:nn #1 } }
  },
  bnvs:cn .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS:c { \use_i:nn #1 } } \use_ii:nn #1
  },
  debug  .code:n = \BNVS_DEBUG_on:,
  reset  .code:n = \reset:n { #1 },
  ignore .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { \BNVS_use_raw:c { c_#1_bool } },
  ignore .default:n = true,
%  ignore .code:n = {}, % comment this line to ignore tests
  noigre .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { !(\BNVS_use_raw:c { c_#1_bool }) },
  noigre .default:n = false,
  noigre .code:n = {}, % comment this line to ignore no tests
}
\int_new:N \l__bnvs_TEST_A_int
\int_new:N \l__bnvs_TEST_B_int
\cs_new:Npn \BNVS_TEST_BEGIN:n #1 {
  \cs_set:Npn \reset:n ##1 {
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \tl_if_empty:nF { ##1 } {
      \__bnvs_gclear:
      \__bnvs_n_gclear:
      \__bnvs_v_gclear:
      \__bnvs_cache_gclear:
    }
    \Beanoves { FIRST = 220+2, LENGTH = 440+5, LAST = 660+6 }
    \BNVS_end:
    \__bnvs_provide_off:
  }
  \cs_set:Npn \reset_X: {
    \reset:n { YES }
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \Beanoves {
      X1  = FIRST,
      X2  = LAST-LENGTH+1,
      A1  = FIRST:,
      A2  = LAST-LENGTH+1:,
      AA1 = FIRST::,
      AA2 = LAST-LENGTH+1::,
      Z1  = :LAST,
      Z2  = :FIRST+LENGTH-1,
      AL11 = FIRST::LENGTH,
      AL12 = FIRST::LAST-FIRST+1,
      AL21 = LAST-LENGTH+1::LENGTH,
      AL22 = LAST-LENGTH+1::LAST-FIRST+1,
      AZ11 = FIRST:LAST,
      AZ12 = FIRST:FIRST+LENGTH-1,
      AZ21 = LAST-LENGTH+1:LAST,
      AZ22 = LAST-LENGTH+1:FIRST+LENGTH-1,
      LZ11 = ::LENGTH:LAST,
      LZ12 = ::LENGTH:FIRST+LENGTH-1,
      LZ21 = ::LAST-FIRST+1:LAST,
      LZ22 = ::LAST-FIRST+1:FIRST+LENGTH-1,
      ZL11 = :LAST::LENGTH,
      ZL12 = :LAST::LAST-FIRST+1,
      ZL21 = :FIRST+LENGTH-1::LENGTH,
      ZL22 = :FIRST+LENGTH-1::LAST-FIRST+1,
    }
    \BNVS_end:
  }
  \tl_if_empty:nF { #1 } { \keys_set_known:nn {BNVS/test} {#1} }
  \bool_if:NTF \l__bnvs_TEST_ignore_bool {
    \tl_clear:N \l__bnvs_TEST_done_tl
    \RenewDocumentEnvironment{BNVS/test}{+b}{
      \BNVS_set:cpn { end_test: } {
        \BNVS_set:cpn { end_test: } { }
        \end{BNVS/test}
      }
    } {
      \__bnvs_end_test:
    }
    \begin{BNVS/test}
  } {
    \cs_set:Npn \banner:n ##1 {
      \__bnvs_call_greset:
      \BNVS_log_a:xn { ▶︎▶︎▶︎▶︎▶︎~TEST~##1~/~line:~\the\inputlineno} {}
    }
    \RenewDocumentEnvironment{BNVS/failure}{}
      {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
         \setlength{\itemindent}{0pt}%
         \setlength{\leftmargin}{0pt}%
         \setlength{\labelwidth}{0pt}%
         \addtolength{\topsep}{-0.5\parskip}%
         \listparindent \parindent
         \setlength{\parsep}{\parskip}}}
      {\end{list}}  
% Utilities
    \cs_set_eq:NN \test_extract:nnnn \BNVS_TEST_extract:nnnn
    \cs_set_eq:NN \test_extract:Nnnn \BNVS_TEST_extract:Nnnn
    \cs_set_eq:NN \test_split:Nnnn \BNVS_TEST_split:Nnnn
	   \cs_set_eq:NN \assert_equal:nnn \BNVS_ASSERT_equal:nnn
    \cs_set_eq:NN \assert_equal:xnn \BNVS_ASSERT_equal:xnn
    \cs_set_eq:NN \assert_equal:xxn \BNVS_ASSERT_equal:xxn
	   \cs_set_eq:NN \assert_size_equal:nnn \BNVS_ASSERT_size_equal:nnn
	   \cs_set_eq:NN \assert_size_not_equal:nnn \BNVS_ASSERT_size_not_equal:nnn
    \cs_set_eq:NN \assert_equal_tl:vnn \BNVS_ASSERT_equal_tl:vnn
    \cs_set_eq:NN \test_fail:n \BNVS_TEST_fail:n
    \cs_set_eq:NN \test_fail:x \BNVS_TEST_fail:x
    \cs_set:Npn \assert_equal_ans:nn {
      \assert_equal_tl:vnn { ans }
    }
    \cs_set:Npn \preflight:n ##1 {
      \banner:n { ##1 }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \preflight:nn ##1 ##2 {
      \banner:n { ##2~/~##1 }
      \tl_if_empty:nF { ##1 } {
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \preflight:nnn ##1 ##2 ##3 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2~/~##3~/ }
      } {
        \banner:n { ##2~/~X=##1->##2~/ }
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__BNVS_DEBUG_group_int
      \__bnvs_tl_clear:c { ans }
    }
    \cs_set:Npn \postflight: {
      \assert_equal:xxn {
        \int_use:N \l__BNVS_DEBUG_group_int
      } {
        \int_use:N \l__bnvs_TEST_group_int
      } { Bad~group~nesting }
      \BNVS_end:
    }
    \cs_set:Npn \flight:nT ##1 ##2 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:n { ##1 }
        ##2
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnT ##1 ##2 ##3 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nn { ##1 } { ##2 }
        ##3
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnnT ##1 ##2 ##3 ##4 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nnn { ##1 } { ##2 } { ##3 }
        ##4
        \postflight:
      }
    }
    \cs_set:Npn \Test_resolve_x_path:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_if_resolve_kip_x_path:TF {
          \BNVS_ASSERT_equal_tl:vnn {id } { ?! } { ##6-id }
          \BNVS_ASSERT_equal_tl:vnn { id } { ?! } { ##6-id }
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_FQ_name_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \__bnvs_seq_use:cn { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
        \__bnvs_gclear:
      }
    }
    \cs_set:Npn \Test_if_resolve_path_n:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \__bnvs_gclear_all:
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_if_resolve_kip_n_path:TF {
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_FQ_name_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \__bnvs_seq_use:cn { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
% Utilities
    \cs_set:Npn \Test_generic_ncTF:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        \__bnvs_int_set:cv { TEST_A } { DEBUG_group }
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-TRUE }
        } {
          \test_fail:x { ##5-FALSE(\token_to_str:N ##1)}
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__BNVS_DEBUG_group_int } {
          \test_fail:n { ##5~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_ncTF:Nnnnn { c }
    \cs_set:Npn \Test_what_action_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_ncTF:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
%   Usage \Test_generic_X_ncTF:Nnnn \__bnvs_if_append_previous::ncTF {X=123} {122} {label}
    \cs_set:Npn \Test_generic_X_ncTF:Nnnn ##1 ##2 {
      \Test_generic_ncTF:Nnnnn ##1 { ##2 } {}
    }
    \cs_generate_variant:Nn \Test_generic_X_ncTF:Nnnn { c }
    \cs_set:Npn \Test_what_action_X_ncTF:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \cs_if_exist:cTF { __bnvs_##1_##2:ncTF } {
        \BNVS_use:Nc
        \Test_generic_X_ncTF:Nnnn { ##1_##2:ncTF } { ##3 } { ##4 } { ##5 }
      } {
        \test_fail:x { ##5-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##2 } { ##6 } {
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
          \assert_equal_ans:nn { ##5 } { ##6-TRUE }
        } {
          \test_fail:n { ##6-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_generic_X_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        ##1 { ?!X } { ##3 } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-X-TRUE }
        } {
          \test_fail:n { ##5-X-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_X_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_X_nncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF { __bnvs_##1_##2:nnNTF } {
        \Test_generic_X_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:nnNTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_X:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnnT { ##2 } { ##5 } { ##2~/~##3 } {
        \group_begin:
        \__bnvs_if_resolve_value:ncTF { ?!X } { a } {
          \group_end:
          ##1 { ?!X } { ##3 } { ans } {
            \assert_equal_ans:nn { ##4 } { ##5-b }
          } {
            \test_fail:x { ##5-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##5-d(if_resolve_value:ncTF) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_X:Nnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_X_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_check_value_X:cnnnn { __bnvs_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\__bnvs_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnnT { ##2 } { ##6 } { ##2~/~##4 } {
        \group_begin:
        \exp_args:Nx
        \__bnvs_if_resolve_value:ncTF { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { a } {
          \group_end:
          \exp_args:Nx
          ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
            \assert_equal_ans:nn { ##5 } { ##6-b }
          } {
            \test_fail:n { ##6-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##6-d(if_resolve_value:ncTF-2) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_nncTF:nnnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_check_value_nncTF:cnnnnn { __bnvs_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\__bnvs_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_what_resolve_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:nnnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:nnnnn { ##1 } { append }
    }
    \cs_set:Npn \Test_what_resolve_ncTF:nnnnn ##1 {
      \Test_what_action_ncTF:nnnnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_ncTF:nnnnn ##1 {
      \Test_what_action_ncTF:nnnnnn { ##1 } { append }
    }
% General
    \cs_set:Npn \Test_if_resolve_index_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { append }
    }
    \cs_set:Npn \Test_if_resolve_index:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { index } { append }
    }
    \cs_set:Npn \Test_if_resolve_range:nnn {
      \Test_what_action_X_ncTF:nnnnn { range } { resolve }
    }
    \cs_set:Npn \Test_if_append_range:nnn {
      \Test_what_action_X_ncTF:nnnnn { range } { append }
    }
% n index
    \cs_set:Npn \Test_n_get:nnnn {
      \Test_generic_ncTF:Nnnnn \__bnvs_n_get:ncTF
    }
    \cs_set:Npn \Test_n_get_X:nnn {
      \Test_generic_X_ncTF:Nnnn \__bnvs_n_get:ncTF
    }
    \cs_set:Npn \Test_if_resolve_n:nnnn {
      \Test_what_action_ncTF:nnnnnn { n } { resolve }
    }
    \cs_set:Npn \Test_if_append_n:nnnn {
      \Test_what_action_ncTF:nnnnnn { n } { append }
    }
    \cs_set:Npn \Test_resolve_n_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n } { resolve }
    }
    \cs_set:Npn \Test_n_append_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n } { append }
    }
    \cs_set:Npn \Test_if_resolve_n_index_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_if_append_n_index_X:nnn {
      \Test_what_action_X_ncTF:nnnnn { n_index } { append }
    }
    \cs_set:Npn \Test_if_resolve_n_index:nnnn {
      \Test_what_action_ncTF:nnnnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_if_append_n_index:nnnn {
      \Test_what_action_ncTF:nnnnnn { n_index } { append }
    }
    \cs_set:Npn \Test_if_resolve_n_incr:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_incr } { resolve }
    }
    \cs_set:Npn \Test_if_append_n_incr:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_incr } { append }
    }
    \cs_set:Npn \Test_if_resolve_n_post:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_post } { resolve }
    }
    \cs_set:Npn \Test_if_append_n_post:nnnnn {
      \Test_what_action_nncTF:nnnnnnn { n_post } { append }
    }
% v
    \cs_set:Npn \Test_if_resolve_v_incr:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_incr } { resolve }
    }
    \cs_set:Npn \Test_if_append_v_incr:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_incr } { append }
    }
    \cs_set:Npn \Test_if_resolve_v_post:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_post } { resolve }
    }
    \cs_set:Npn \Test_if_append_v_post:nnnnn {
      \Test_what_action_check_value_nncTF:nnnnnnn { v_post } { append }
    }
% query
    \cs_set:Npn \Test_if_append:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { append }
    }
    \cs_set:Npn \Test_if_resolve:nnnn {
      \Test_what_action_ncTF:nnnnnn { if } { resolve }
    }
    \cs_set:Npn \Test_regex:nnnn ##1 {
      \bool_if:NTF \l__bnvs_TEST_ignore_bool {
        \use_none:nnn
      } {
        \tl_if_exist:cTF { c__bnvs_##1_regex } {
          \BNVS_TEST_extract:cnnn { c__bnvs_##1_regex }
        } {
          \test_fail:n { Bad~name:~##1}
          \use_none:nnn
        }
      }
    }
    \cs_set:Npn \Test_query:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \__bnvs_tl_clear:c { TEST_A }
        \__bnvs_if_resolve_query:ncTF { ##2 } { TEST_A } {
          \assert_equal_tl:vnn { TEST_A } { ##3 } {
            Test~\cs{__bnvs_if_resolve_query:nc}:~##4-a
          }
        } {
          \test_fail:n { ##4-CALL }
        }
      }
    }
    \cs_set:Npn \Test_resolve:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \BeanovesResolve[in=\l__bnvs_ans_tl]{ ##2 }
        \assert_equal_ans:nn { ##3 } { ##4 }
      }
    }
    \BNVS_log_a:nn {▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎} {}
    \BNVS_log_a:xn {TEST~\l__bnvs_TEST_banner_tl\space file:~\BeanovesCurrentTestFile, line:~\the\inputlineno} {}
    \tl_set:Nn \l__bnvs_TEST_done_tl {
      \BNVS_log_a:xn { TEST~\l__bnvs_TEST_banner_tl...~DONE} {}
      \BNVS_log_a:nn {◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀} {}
    }
  }
}
\cs_new:Npn \BeanovesCurrentTestFile {
  \tl_if_empty:VF \CurrentFilePath { \CurrentFilePath / }
  \CurrentFile
}
\cs_set:Npn \BNVS_TEST_extract:nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \tl_if_empty:nT { #3 } {
    \__bnvs_match_if_once:nnT { #1 } { #2 } {
      \test_fail:n { #4-a }
    }
  } {
    \__bnvs_match_if_once:nnTF { #1 } { #2 } {
      \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { match } , }
      \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
      \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
        \__bnvs_tl_if_empty:cTF { b } {
          \seq_put_left:Nn \l__bnvs_match_seq { #2 }
        } {
          \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
        }
      }
      \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { split } , }
      \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
    } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_set:Npn \BNVS_TEST_extract:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_extract_once:NnNTF #1 { #2 } \l__bnvs_match_seq {
    \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { match } , }
    \seq_set_from_clist:Nn \l__bnvs_match_seq { #3 }
    \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
      \__bnvs_tl_if_empty:cTF { b } {
        \seq_put_left:Nn \l__bnvs_match_seq { #2 }
      } {
        \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
      }
    }
    \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { match } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn
  \BNVS_TEST_extract:Nnnn { cnnn }
\cs_set:Npn \BNVS_TEST_split:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_split:NnNTF #1 { #2 } \l__bnvs_split_seq {
    \tl_set:Nx \l__bnvs_a_tl { \__bnvs_seq_use:cn { split } , }
    \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
    \tl_set:Nx \l__bnvs_b_tl { \__bnvs_seq_use:cn { split } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn \msg_error:nnnn { nnnx }
\cs_set:Npn \BNVS_ASSERT_equal:nnn #1 #2 #3 {
  \tl_if_eq:nnF { #1 } { #2 } {
    \msg_error:nnnx { beanoves } { :nn } { FAILED~`#1'!=`#2' } { \BeanovesCurrentTestFile :\the\inputlineno :#3}
    \begin{BNVS/failure}
    \item FAILURE~`#1'!=`#2'~(\BeanovesCurrentTestFile :\the\inputlineno)
    \item #3
    \end{BNVS/failure}
  }
}
\box_new:N \l__bnvs_TEST_A_box
\box_new:N \l__bnvs_TEST_B_box
\cs_set:Npn \BNVS_ASSERT_size_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{BNVS/failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{BNVS/failure}
    }
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_ASSERT_size_not_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{BNVS/failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{BNVS/failure}
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_TEST_fail:n #1 {
  \msg_error:nnnx { beanoves } { :nn } { TEST~FAILED } { \BeanovesCurrentTestFile :\the\inputlineno :#1~(\int_use:N \g__bnvs_call_int)}
  \begin{BNVS/failure}
  \item FAILURE~unexpected~branch~(\BeanovesCurrentTestFile :\the\inputlineno)
  \item #1
  \end{BNVS/failure}
}
\cs_generate_variant:Nn \BNVS_ASSERT_equal:nnn { x, xx }
\cs_set:Npn \BNVS_ASSERT_equal_tl:vnn {
  \BNVS_tl_use:Nv \BNVS_ASSERT_equal:nnn
}
\cs_generate_variant:Nn \BNVS_TEST_fail:n { x }
\cs_new:Npn \BNVS_DEBUG_log_f:c #1 {
  \BNVS_DEBUG_log:x { \token_to_str:c { \BNVS:c { #1 } } }
}
\cs_new:Npn \BNVS_DEBUG_log_f:ncn #1 #2 #3 {
  \BNVS_DEBUG_log:x { #1 \token_to_str:c { \BNVS:c { #2 } } #3 }
}
\cs_new:Npn \BNVS_DEBUG_log_tl:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_tl_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_int:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_int_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_int_use:Nv \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nc #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_to_str:n { #1 }
    -> / \tl_to_str:n { #2 } /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { v }
\cs_new:Npn \BNVS_DEBUG_log_tl:nc #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_if_empty:nF { #1 } { #1 -> }
    \BNVS_tl_use:Nc \token_to_str:N  { #2 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #2 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_tl:c #1 {
  \BNVS_DEBUG_log:x {
    \BNVS_tl_use:Nc \token_to_str:N { #1 }
    -> / \BNVS_tl_use:Nv \tl_to_str:n { #1 } /
  }
}

\cs_new:Npn \BNVS_DEBUG_log_arg:nn #1 #2 {
  \BNVS_DEBUG_log:x { \tl_to_str:n { #1 } -> / \tl_to_str:n { #2 } / }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnnn #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnc #1 {
  \BNVS_DEBUG_log_f:c { #1 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:ncn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:cnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:ncn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_cs:nN #1 #2 {
  \BNVS_DEBUG_log:x { \tl_to_str:n { #1 } == \token_to_str:N #2 }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:N #1 {
  \BNVS_DEBUG_log:x {
    \token_to_str:N #1 => / \seq_count:N #1 / \seq_use:Nn #1 . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nN #1 #2 {
  \BNVS_DEBUG_log:x {
    \tl_to_str:n { #1 } => / \seq_count:N #2 / \seq_use:Nn #2 . /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { x }
\cs_new:Npn \BNVS_DEBUG_log_seq:xc #1 #2 {
  \BNVS_DEBUG_log:x {
    #1
    => / \seq_count:c { l__bnvs_#2_seq }
       / \seq_use:cn { l__bnvs_#2_seq } . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:c #1 {
  \BNVS_DEBUG_log:x {
    \token_to_str:c { l__bnvs_#1_seq }
    => / \seq_count:c { l__bnvs_#1_seq }
       / \seq_use:cn { l__bnvs_#1_seq } . /
  }
}
\tl_new:N \BNVS_DEBUG_tl
\cs_new:Npn \BNVS_DEBUG_log_cs_set:cpn #1 {
  \tl_set:Nn \BNVS_DEBUG_tl { #1 }
  \tl_replace_once:Nnn \BNVS_DEBUG_tl { : } { _ }
  \cs_set:cpn { BNVS_DEBUG_log_ \BNVS_DEBUG_tl :nn }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cn #1 #2 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    #2
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnn #1 #2 #3 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nn { #2 } { #3 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnc #1 #2 #3 #4 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnc { #2 } { #3 } { IN } { #4 }
    \cs_if_exist:cT { l__bnvs_#4_tl } {
      \BNVS_DEBUG_log_tl:c { #4 }
    }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnn #1 #2 #3 #4 #5 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnn { #2 } { #3 } { #4 } { #5 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnnc #1 #2 #3 #4 #5 #6 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnc { #2 } { #3 } { #4 } { #5 } { IN } { #6 }
  }
}
\cs_new:Npn \BNVS_DEBUG_log_set:cnnnnnnc #1 #2 #3 #4 #5 #6 #7 #8 {
  \BNVS_DEBUG_log_cs_set:cpn { #1 } ##1 ##2 {
    \BNVS_DEBUG_log_f:ncn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnnc { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { IN } { #8 }
  }
}
%</!final>
% \end{BNVS/gobble}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% The number of variables used has not been optimized,
% nor the \TeX\ groups used.
% Optimization often goes against readability.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_id_last_tl
\tl_set:Nn \l__bnvs_id_last_tl { ?! }
\tl_new:N \l__bnvs_a_tl
\tl_new:N \l__bnvs_b_tl
\tl_new:N \l__bnvs_c_tl
\tl_new:N \l__bnvs_V_tl
\tl_new:N \l__bnvs_A_tl
\tl_new:N \l__bnvs_L_tl
\tl_new:N \l__bnvs_Z_tl
\tl_new:N \l__bnvs_ans_tl
\tl_new:N \l__bnvs_Q_name_tl
\tl_new:N \l__bnvs_FQ_name_tl
\tl_new:N \l__bnvs_key_tl
\tl_new:N \l__bnvs_key_base_tl
\tl_new:N \l__bnvs_ref_tl
\tl_new:N \l__bnvs_ref_base_tl
\tl_new:N \l__bnvs_id_tl
\tl_new:N \l__bnvs_n_tl
\tl_new:N \l__bnvs_path_tl
\tl_new:N \l__bnvs_group_tl
\tl_new:N \l__bnvs_scan_tl
\tl_new:N \l__bnvs_query_tl
\tl_new:N \l__bnvs_token_tl
\tl_new:N \l__bnvs_root_tl
\tl_new:N \l__bnvs_n_incr_tl
\tl_new:N \l__bnvs_incr_tl
\tl_new:N \l__bnvs_post_tl
\tl_new:N \l__bnvs_suffix_tl
\int_new:N \g__bnvs_call_int
\int_new:N \l__bnvs_int
\int_new:N \l__bnvs_i_int
\seq_new:N \g__bnvs_def_seq
\seq_new:N \l__bnvs_a_seq
\seq_new:N \l__bnvs_b_seq
\seq_new:N \l__bnvs_ans_seq
\seq_new:N \l__bnvs_match_seq
\seq_new:N \l__bnvs_split_seq
\seq_new:N \l__bnvs_path_seq
\seq_new:N \l__bnvs_path_base_seq
\seq_new:N \l__bnvs_query_seq
\seq_new:N \l__bnvs_token_seq
\bool_new:N \l__bnvs_in_frame_bool
\bool_set_false:N \l__bnvs_in_frame_bool
\bool_new:N \l__bnvs_parse_bool
%    \end{macrocode}
% \end{BNVS/macrocode}
% In order to implement the provide feature, we
% add getters and setters
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\bool_new:N \l__bnvs_provide_bool
\BNVS_new:cpn { provide_on: } {
  \bool_set_true:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { PROVIDE...ON }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { provide_off: } {
  \bool_set_false:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { PROVIDE...OFF }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\__bnvs_provide_off:
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{\__bnvs_if_provide: }
% \begin{syntax}
% \cs{__bnvs_if_provide:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% Execute \meta{yes code} when in provide mode (see |\Beanoves*{...}|), \meta{no code} otherwise.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_provide: } { p, T, F, TF } {
  \bool_if:NTF \l__bnvs_provide_bool {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \subsection{Infinite loop management}
% Unending recursivity is managed here.
% \begin{variable} {\g__bnvs_call_int}
% Some functions calls, as well as some loop bodies, decrement this counter.
% When this counter reaches 0, an error is raised or
% a computation is aborted.
% \end{variable}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\int_const:Nn \c__bnvs_max_call_int { 2048 }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{\__bnvs_call_greset:}
% \begin{syntax}
% \cs{__bnvs_call_greset:}
% \end{syntax}
% Reset globally the call stack counter to its maximum value.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_set:Npn  \__bnvs_call_greset: {
  \int_gset:Nn \g__bnvs_call_int { \c__bnvs_max_call_int }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{function}
% \begin{function}[TF]{\__bnvs_if_call:}
% \begin{syntax}
% \cs{__bnvs_call_do:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% Decrement the \cs{g__bnvs_call_int} counter globally and
% execute \meta{yes code} if we have not reached 0,
% \meta{no code} otherwise.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_call: } { T, F, TF } {
  \int_gdecr:N \g__bnvs_call_int
  \int_compare:nNnTF \g__bnvs_call_int > 0 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{function}
%
% \subsection{Overlay specification}
% \subsection{Basic functions}
% \begin{variable} {\g__bnvs_prop}
% \meta{key}--\meta{integer spec} property list to store the named overlay sets.
% The keys are constructed from fully qualified names denoted as \meta{FQ name}.
% \begin{description}
% \item [\texttt{\meta{FQ name}/V}] for the value
% \item [\texttt{\meta{FQ name}/A}] for the first index
% \item [\texttt{\meta{FQ name}/L}] for the length when provided
% \item [\texttt{\meta{FQ name}/Z}] for the last index when provided
% \end{description}
% The implementation is private, in particular, keys may change in future versions. They are exposed here for informational purposes only.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_prop
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{variable}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_prop {
      \BNVS_DEBUG_log:n { ##1 -> ##2 }
    }
  }
  \BNVS_DEBUG_log_cache_gprop:n {#1}
  \BNVS_DEBUG_log_v_gprop:n {#1}
  \BNVS_DEBUG_log_n_gprop:n {#1}
}
\NewDocumentCommand\BeanovesLogGProp {O{20}} { \BNVS_DEBUG_log_gprop:n {#1} }
%</!final>
% \end{BNVS/gobble}
% \begin{function}{
%   \__bnvs_gput:nnn,
%   \__bnvs_gput:nvn,
%   \__bnvs_gput:nnv,
%   \__bnvs_item:nn,
%   \__bnvs_gremove:nn,
%   \__bnvs_gclear:n,
%   \__bnvs_gclear:v,
%   \__bnvs_gclear:,
% }
% \begin{syntax}
% \cs{__bnvs_gput:nnn} \marg{subkey} \marg{FQ name} \marg{integer  spec}
% \cs{__bnvs_item:nn} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_gremove:nn} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_gclear:n} \marg{FQ name}
% \cs{__bnvs_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% This is a wrapper over \LaTeX3\ eponym functions.
% The key used in |\g__bnvs_prop| is \texttt{\meta{FQ name}/\meta{subkey}}.
% In practice, \texttt{\meta{subkey}} is one of \texttt{V}, \texttt{A}, \texttt{L}, \texttt{Z}.
% |fq| means ``fully qualified''.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gput:nnn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { gput:nnn } #1 #2 #3 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
\BNVS_DEBUG_log_f:cnnnnnn { gput:nnn }
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_new:cpn { gput:nvn } #1 {
  \BNVS_tl_use:nv {
    \__bnvs_gput:nnn { #1 }
  }
}
\BNVS_new:cpn { gput:nnv } #1 #2 {
  \BNVS_tl_use:nv {
    \__bnvs_gput:nnn { #1 } { #2 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_prop { #2 / #1 }
}
\BNVS_new:cpn { gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_prop { #2 / #1 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { gremove:nn } { SUBKEY } { #1 } { KEY } { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L } {
    \__bnvs_gremove:nn { ##1 } { #1 }
  }
  \__bnvs_cache_gclear:n { #1 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnn { gclear:nn } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { gclear: } {
  \prop_gclear:N \g__bnvs_prop
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { gclear:nn }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\BNVS_generate_variant:cn { gclear:n } { V }
\BNVS_new:cpn { gclear:v } {
   \BNVS_tl_use:Nc \__bnvs_gclear:V
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_gput:nnn{|item:nn|gremove:nn}, noigre}
% \__bnvs_gput:nnn { subkey } { key } { value }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \prop_item:Nn \g__bnvs_prop { key / subkey } } 
%   { value }
%   { \test_fail:n { A } }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \__bnvs_item:nn { subkey } { key } } 
%   { value }
%   { \test_fail:n { B } }
% \__bnvs_gremove:nn {subkey} {key}
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \__bnvs_item:nn { subkey } { key } } 
%   { }
%   { \test_fail:n { C } }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_gclear:/n/v, noigre}
% \__bnvs_gput:nnn { A } { key_1 } { value_1 }
% \__bnvs_gput:nnn { A } { key_2 } { value_2 }
% \__bnvs_gput:nnn { A } { key_3 } { value_3 }
% \cs_set:Npn \BNVS_Test:nnTF #1 #2 {
%   \exp_args:Nx
%   \tl_if_eq:nnTF
%     { \prop_item:Nn \g__bnvs_prop { key_#1 / A } } 
%     { #2 }
% }
% \cs_set:Npn \Test_in:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { value_#1 }
%     { }
%     { \test_fail:n { IN_#1/#2 } }
% }
% \cs_set:Npn \Test_out:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { }
%     { }
%     { \test_fail:n { OUT_#1/#2 } }
% }
% \Test_in:nn { 1 } { A }
% \Test_in:nn { 2 } { B }
% \Test_in:nn { 3 } { C }
% \__bnvs_gclear:n { key_1 }
% \Test_out:nn { 1 } { D }
% \Test_in:nn { 2 } { E }
% \Test_in:nn { 3 } { F }
% \__bnvs_tl_set:cn { TEST_A } { key_2 }
% \__bnvs_gclear:v { TEST_A }
% \Test_out:nn { 1 } { G }
% \Test_out:nn { 2 } { H }
% \Test_in:nn { 3 } { I }
% \__bnvs_gclear:
% \Test_out:nn { 1 } { J }
% \Test_out:nn { 2 } { K }
% \Test_out:nn { 3 } { L }
% \cs_undefine:N \BNVS_Test:nnTF
% \cs_undefine:N \Test_in:nn
% \cs_undefine:N \Test_out:nn
% \end{BNVS/test}
%
% \begin{function}[pTF]{
%   \__bnvs_if_in:nn,
%   \__bnvs_if_in:n,
% }
% \begin{syntax}
% \cs{__bnvs_if_in_p:nn} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_if_in:nnTF} \marg{subkey} \marg{FQ name} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_in_p:n} \marg{FQ name}
% \cs{__bnvs_if_in:nTF} \marg{FQ name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{FQ name}/\meta{subkey}}, it makes the code more concise and readable.
% The version with no \meta{subkey} is the or combination for keys
% |V|, |A| and |Z|.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:nn } #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \__bnvs_if_in_p:nn V { #1 }
    || \__bnvs_if_in_p:nn A { #1 }
    || \__bnvs_if_in_p:nn Z { #1 }
  } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_in:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_in:nTF { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_in:nnTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_if_in:nn#1 } { subkey } { key }
% }
% \cs_set:Npn \BNVS_Test:TF {
%   \bool_if:nTF { \__bnvs_if_in_p:nn { subkey } { key } }
% }
% \BNVS_Test:TF       { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { TF } { \test_fail:n { A/2 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/3 } }
% \BNVS_Test:n {  F }                        { }
% \__bnvs_gput:nnn { subkey } { key } { value }
% \prop_if_in:NnF \g__bnvs_prop { key/subkey } { \test_fail:n { B } }
% \bool_if:nF { \prop_if_in_p:Nn \g__bnvs_prop { key/subkey } } { \test_fail:n { BB } }
% \BNVS_Test:TF       { } { \test_fail:n { B/1 } }

% \BNVS_Test:n { TF } { } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { B/3 } }
% \cs_undefine:N \BNVS_Test:TF
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{function}{
%   \__bnvs_gprovide:nnnT,
% }
% \begin{syntax}
% \cs{__bnvs_gprovide:nnnT} \marg{subkey} \marg{FQ name} \marg{value} \marg{yes precode}
% \end{syntax}
% Execute \meta{yes precode} before providing.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gprovide:nnnT } #1 #2 #3 #4 {
  \prop_if_in:NnF \g__bnvs_prop { #2 / #1 } {
    #4
    \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnn { gprovide:nnnT } 
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_gprovide:nnnT, noigre}
% \__bnvs_gclear:
% \__bnvs_if_in:nnT { subkey } { key } { \test_fail:n { A } }
% \__bnvs_gprovide:nnnT { subkey } { key } { value } { }
% \__bnvs_if_in:nnF { subkey } { key } { \test_fail:n { B } }
% \__bnvs_gprovide:nnnT { subkey } { key } { value } {
%   \test_fail:n { C }
% }
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{function}[TF]{\__bnvs_if_get:nnc}
% \begin{syntax}
% \cs{__bnvs_if_get:nncTF} \marg{subkey} \marg{FQ name} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl core} variable is undefined, on resolution only.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_get:nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_prop { #2 / #1 }
  } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnnc { if_get:nncTF } { ...TRUE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnnnnc { if_get:nncTF } { ...FALSE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:c=\BNVS:c{if_get:nncTF}, noigre}
% \__bnvs_gclear:
% \__bnvs_tl_clear:c { TEST }
% \__bnvs_if_get:nncTF { subkey } { key } { TEST } { \test_fail:n { A/1 } } { }
% \__bnvs_tl_clear:c { TEST }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use_raw:c { __bnvs_if_get:nnc#1 } { subkey } { key } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/2 } }
% \BNVS_Test:n {  F }                          { }
% \__bnvs_gput:nnn { subkey } { key } { value }
% \cs_new:Npn \TestT:n #1 {
%   \__bnvs_tl_if_eq:cnF { TEST } { value } { \test_fail:n { #1 } }
% }
% \BNVS_Test:n { TF } { \TestT:n { B/1 } } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { \TestT:n { B/3 } }
% \BNVS_Test:n {  F }                      { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_get:nvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_if_get:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \__bnvs_gput:nnn X { A } { B }
% \BNVS_Test:xxn { \__bnvs_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \__bnvs_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} || \__bnvs_if_in_p:nn X {A} } TF } { T } { 11 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_if_get:nncF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_if_get:nncT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{BNVS/test}
%
% \subsection{Functions with cache}
% \begin{variable} {\g__bnvs_cache_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges.
% \begin{description}
% \item [\texttt{\meta{FQ name}/V}] for the cached static value of the value
% \item [\texttt{\meta{FQ name}/A}] for the cached static value of the first index
% \item [\texttt{\meta{FQ name}/L}] for the cached static value of the length
% \item [\texttt{\meta{FQ name}/Z}] for the cached static value of the last index
% \item [\texttt{\meta{FQ name}/P}] for the cached static value of the previous index
% \item [\texttt{\meta{FQ name}/N}] for the cached static value of the next index
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_cache_prop
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{variable}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_cache_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_cache_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_cache_prop {
      \BNVS_DEBUG_log:n { c: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogCProp {O{20}} { \BNVS_DEBUG_log_cache_gprop:n {#1} }
%</!final>
% \end{BNVS/gobble}
% \begin{function}{
%   \__bnvs_cache_gput:nnn,
%   \__bnvs_cache_gput:nnv,
%   \__bnvs_cache_gput:nvn,
%   \__bnvs_cache_item:nn,
%   \__bnvs_cache_gremove:nn,
%   \__bnvs_cache_gclear:n,
%   \__bnvs_cache_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_cache_gput:nnn} \marg{subkey} \marg{FQ name} \marg{value}
% \cs{__bnvs_cache_item:nn} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_cache_gremove:nn} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_cache_gclear:n} \marg{FQ name}
% \cs{__bnvs_cache_gclear:}
% \end{syntax}
% Wrapper over the functions above for \texttt{\meta{FQ name}/\meta{subkey}}.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { cache_gput:nnn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { cache_gput:nnn } #1 #2 #3 {
\BNVS_DEBUG_log_f:c { cache_gput:nnn }
\BNVS_DEBUG_log_arg:nn { SUBKEY } { #1 }
\BNVS_DEBUG_log_arg:nn { KEY } { #2 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #3 }
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 } { #3 }
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \__bnvs_cache_gput:nnn { nV, nnV }
\BNVS_new:cpn { cache_gput:nvn } #1 {
  \BNVS_tl_use:nc {
    \__bnvs_cache_gput:nVn { #1 }
  }
}
\BNVS_new:cpn { cache_gput:nnv } #1 #2 {
  \BNVS_tl_use:nc {
    \__bnvs_cache_gput:nnV { #1 } { #2 }
  }
}
\BNVS_new:cpn { cache_item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:cpn { cache_gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:cpn { cache_gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L, P, N } {
    \prop_gremove:Nn \g__bnvs_cache_prop { #1 / ##1 }
  }
}
\BNVS_new:cpn { cache_gclear: } {
  \prop_gclear:N \g__bnvs_cache_prop
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { cache_gclear: }
\BNVS_DEBUG_log_gprop:n { }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[pTF]{
%   \__bnvs_cache_if_in:nn,
% }
% \begin{syntax}
% \cs{__bnvs_cache_if_in_p:n} \marg{subkey} \marg{FQ name}
% \cs{__bnvs_cache_if_in:nTF} \marg{subkey} \marg{FQ name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{subkey}/\meta{FQ name}}, it makes the code more concise and readable.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_cache_if_in:nn #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_cache_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_cache_if_get:nnc
% }
% \begin{syntax}
% \cs{__bnvs_cache_if_get:nncTF} \marg{subkey} \marg{FQ name} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl core} variable is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { cache_if_get:nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_cache_prop { #2 / #1 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=cache_(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \__bnvs_cache_gput:nnn X { A } { B }
% \BNVS_Test:xxn { \__bnvs_cache_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \__bnvs_cache_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \__bnvs_cache_if_in_p:nn X {B} || \__bnvs_cache_if_in_p:nn X {A} } TF } { T } { 11 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_cache_if_get:nncF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_cache_if_get:nncT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{BNVS/test}
%
% \subsubsection{Implicit value counter}
% The implicit value counter is local to the current frame.
% It is defined at the global level because changes made
% at any depth must be made at the frame depth.
% If the frame were a closure, this counter would belong to that closure.
% When used for the first time, it either defaults to the first index or last index.
% \begin{variable} {\g__bnvs_v_prop}
% \meta{key}--\meta{value} property list to store the contents or the named value counters.
% The keys are qualified names \meta{id}!\meta{short name} denoted as
% \meta{Q name}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_v_prop
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{variable}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_v_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_v_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_v_prop {
      \BNVS_DEBUG_log:n { v: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogVProp {O{20}} { \BNVS_DEBUG_log_v_gprop:n {#1} }
%</!final>
% \end{BNVS/gobble}
% \begin{function}{
%   \__bnvs_v_gput:nn,
%   \__bnvs_v_gput:nV,
%   \__bnvs_v_gput:Vn,
%   \__bnvs_v_item:n,
%   \__bnvs_v_gremove:n,
%   \__bnvs_v_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_v_gput:nn} \marg{Q name} \marg{value}
% \cs{__bnvs_v_item:n} \marg{Q name}
% \cs{__bnvs_v_gremove:n} \marg{Q name}
% \cs{__bnvs_v_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_gput:nn } {
  \prop_gput:Nnn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_new:cpn { v_gput:nv } #1 {
  \BNVS_tl_use:nv {
    \__bnvs_v_gput:nn { #1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_item:n } #1 {
  \prop_item:Nn \g__bnvs_v_prop { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { v_gremove:n } {
  \prop_gremove:Nn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { v_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_v_prop { #1 }
\BNVS_DEBUG_log_f:cnn { v_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_new:cpn { v_gclear: } {
  \prop_gclear:N \g__bnvs_v_prop
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { v_gclear:n }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[pTF]{
%   \__bnvs_v_if_in:n
% }
% \begin{syntax}
% \cs{__bnvs_v_if_in_p:n} \marg{Q name}
% \cs{__bnvs_v_if_in:nTF} \marg{Q name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{key}} value counter.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_if_in:n } #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_v_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_v_if_get:nc,
% }
% \begin{syntax}
% \cs{__bnvs_v_if_get:ncTF} \marg{Q name} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl core} variable is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_if_get:nc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:nc {
    \prop_get:NnNTF \g__bnvs_v_prop { #1 }
  } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { v_if_get:ncTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { v_if_get:ncTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{cn={\BNVS:c{v_gput:nn}}{|get}, noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } { #3 }
% }
% \__bnvs_v_gput:nn { A } { B }
% \BNVS_Test:xxn { \__bnvs_v_item:n {A} } { B } { 1 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_v_if_get:ncF {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_v_if_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \cs_undefine:N \BNVS_Test:xxn
% \end{BNVS/test}
%
% \begin{function}[TF]{
%   \__bnvs_v_if_greset:nn,
%   \__bnvs_v_if_greset:vn,
%   \__bnvs_if_greset_all:nn,
%   \__bnvs_if_greset_all:vn
% }
% \begin{syntax}
% \cs{__bnvs_v_if_greset:nnTF} \marg{Q name} \marg{initial value} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_greset_all:nnTF} \marg{Q name} \marg{initial value} \marg{yes code} \marg{no code}
% \end{syntax}
% The key must include the frame id.
% Reset the value counter to the given \meta{initial value}.
% The |..._all| variant also cleans the cached values.
% If the \meta{Q name} is known, \meta{yes code} is executed,
% otherwise \meta{no code} is executed.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_if_greset:nn } #1 #2 { T, F, TF } {
  \__bnvs_v_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { v_if_greset:nnTF } { }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_v_gremove:n { #1 }
    \tl_if_empty:nF { #2 } {
      \__bnvs_v_gput:nn { #1 } { #2 }
    }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { v_if_greset:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_v_if_greset:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_greset_all:nn } #1 #2 { T, F, TF } {
  \__bnvs_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { if_greset_all:nnTF } { KEY } { #1 } { VALUE } { #2 }
    \BNVS_DEBUG_begin:n { if_greset_all:nn }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \clist_map_inline:nn { V, A, Z, L } {
      \__bnvs_if_get:nncT { ##1 } { #1 } { a } {
        \__bnvs_quark_if_nil:cT { a } {
          \__bnvs_cache_if_get:nncTF { ##1 } { #1 } { a } {
            \__bnvs_gput:nnv { ##1 } { #1 } { a }
          } {
            \__bnvs_gput:nnn { ##1 } { #1 } { 1 }
          }
        }
      }
    }
    \BNVS_end:
    \__bnvs_cache_gclear:n { #1 }
    \__bnvs_v_if_greset:nnT { #1 } { #2 } {}
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_greset_all:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_greset_all:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}{\__bnvs_gclear_all:n, \__bnvs_gclear_all:}
% \begin{syntax}
% \cs{__bnvs_gclear_all:n} \marg{FQ name}
% \cs{__bnvs_gclear_all:}
% \end{syntax}
% Convenient shortcuts to clear all the storage, for the given fully qualified name in the first case.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { gclear_all: } {
  \__bnvs_gclear:
  \__bnvs_cache_gclear:
  \__bnvs_n_gclear:
  \__bnvs_v_gclear:
}
\BNVS_new:cpn { gclear_all:n } #1 {
  \__bnvs_gclear:n { #1 }
  \__bnvs_cache_gclear:n { #1 }
  \__bnvs_n_gremove:n { #1 }
  \__bnvs_v_gremove:n { #1 }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Implicit index counter}
% The implicit index counter is also local to the current frame.
% It is defined at the global level because changes made
% at any depth must be made at the frame depth.
% When used for the first time, it defaults to 1.
% \begin{variable} {\g__bnvs_n_prop}
% \meta{key}--\meta{value} property list to store the contents of the named index counters.
% The keys are qualified names \meta{id}!\meta{short name}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_n_prop
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{variable}
% \begin{BNVS/gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_n_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_n_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_n_prop {
      \BNVS_DEBUG_log:n { n: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogNProp {O{20}} { \BNVS_DEBUG_log_n_gprop:n {#1} }
%</!final>
% \end{BNVS/gobble}
% \begin{function}{
%   \__bnvs_n_gput:nn,
%   \__bnvs_n_gput:nv,
%   \__bnvs_n_gput:vn,
%   \__bnvs_n_gprovide:nn,
%   \__bnvs_n_item:n,
%   \__bnvs_n_gremove:n,
%   \__bnvs_n_gremove:v,
%   \__bnvs_n_gclear:
% }
% \begin{syntax}
% \cs{__bnvs_n_gput:nn} \marg{Q name} \marg{value}
% \cs{__bnvs_n_item:n} \marg{Q name}
% \cs{__bnvs_n_gremove:n} \marg{Q name}
% \cs{__bnvs_n_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { n_gput:nn } {
  \prop_gput:Nnn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { n_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { n_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \__bnvs_n_gput:nn { nV }
\BNVS_new:cpn { n_gput:nv } #1 {
  \BNVS_tl_use:nc {
    \__bnvs_n_gput:nV { #1 }
  }
}
\BNVS_new:cpn { n_gprovide:nn } #1 #2 {
  \prop_if_in:NnF \g__bnvs_n_prop { #1 } {
    \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnn { n_gprovide:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\BNVS_new:cpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_new:cpn { n_gremove:n } {
  \prop_gremove:Nn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { n_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_n_prop { #1 }
\BNVS_DEBUG_log_f:cnn { n_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
\BNVS_generate_variant:cn { n_gremove:n } { V }
\BNVS_new:cpn { n_gremove:v } {
  \BNVS_tl_use:nc {
    \__bnvs_n_gremove:V
  }
}
\BNVS_new:cpn { n_gclear: } {
  \prop_gclear:N \g__bnvs_n_prop
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:c { n_gclear: }
\BNVS_DEBUG_log_gprop:n { }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_n_gremove:n { V }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[pTF]{\__bnvs_n_if_in:n}
% \begin{syntax}
% \cs{__bnvs_n_if_in_p:nn} \marg{Q name}
% \cs{__bnvs_n_if_in:nTF} \marg{Q name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{Q name}} value counter.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_n_if_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_n_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{\__bnvs_n_get:nc}
% \begin{syntax}
% \cs{__bnvs_n_get:ncTF} \marg{Q name} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl core} variable is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_n_get:nc #1 #2 { T, F, TF } {
  \__bnvs_if_prop_get:NncTF \g__bnvs_n_prop { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { n_get:ncTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:cnnnc { n_get:ncTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=n_(gput|gremove|gclear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } {#3}
% }
% \__bnvs_n_gput:nn { A } { B }
% \BNVS_Test:xxn { \__bnvs_n_item:n {A} } { B } { 1 }
% \__bnvs_tl_clear:c { b }
% \__bnvs_n_get:ncF {A} { b } {
%   \test_fail:n { 13 }
% }
% \__bnvs_n_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{BNVS/test}
%
% \subsubsection{Regular expressions}
%
% \begin{variable}{\c__bnvs_key_regex}
% This regular expressioin is used for both short names and dot path components.
% The short name of an overlay set consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_key_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=key_regex, noigre}
% \Test_regex:nnnn { key } {A} {A} {1}
% \Test_regex:nnnn { key } {_A1} {_A1} {2}
% \end{BNVS/test}
% \end{variable}
% \begin{variable}{\c__bnvs_id_regex}
% The frame identifier consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_id_regex {
  (?: \ur{c__bnvs_key_regex} | [?] )? !
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=id_regex, noigre}
% \Test_regex:nnnn { id } {!} {!} {1}
% \Test_regex:nnnn { id } {_A1!} {_A1!} {2}
% \Test_regex:nnnn { id } {?!} {?!} {2}
% \end{BNVS/test}
% \end{variable}
% \begin{variable}{\c__bnvs_path_regex}
% A sequence of \texttt{.\meta{positive integer}} or \texttt{.\meta{short name}} items representing a path.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_path_regex {
  (?: \. \ur{c__bnvs_key_regex} | \. [-+]? \d+ )*
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=path_regex, noigre}
% \Test_regex:nnnn { path } {} {} {1}
% \Test_regex:nnnn { path } {.1} {.1} {2}
% \Test_regex:nnnn { path } {.1.2} {.1.2} {3}
% \Test_regex:nnnn { path } {.1.-2} {.1.-2} {4}
% \Test_regex:nnnn { path } {.-1} {.-1} {5}
% \Test_regex:nnnn { path } {.-1.2} {.-1.2} {6}
% \Test_regex:nnnn { path } {.-1.-2} {.-1.-2} {7}
% \Test_regex:nnnn { path } {.1.n} {.1.n} {2'}
% \Test_regex:nnnn { path } {.1.2.n} {.1.2.n} {3'}
% \Test_regex:nnnn { path } {.1.-2.n} {.1.-2.n} {4'}
% \Test_regex:nnnn { path } {.-1.n} {.-1.n} {5'}
% \Test_regex:nnnn { path } {.-1.2.n} {.-1.2.n} {6'}
% \Test_regex:nnnn { path } {.-1.-2.n} {.-1.-2.n} {7'}
% \Test_regex:nnnn { path } {.n.1} {.n.1} {2''}
% \Test_regex:nnnn { path } {.1.n.2} {.1.n.2} {3''}
% \Test_regex:nnnn { path } {.1.n.-2} {.1.n.-2} {4''}
% \Test_regex:nnnn { path } {.n.-1} {.n.-1} {5''}
% \Test_regex:nnnn { path } {.-1.n.2} {.-1.n.2} {6''}
% \Test_regex:nnnn { path } {.-1.n.-2} {.-1.n.-2} {7''}
% \end{BNVS/test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_A_FQ_name_Z_regex}
% A fully qualified name is the qualified name of an overlay set
% possibly followed by a dotted path.
% Matches the whole string.
% \end{variable}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_FQ_name_Z_regex {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{myList}
% \item[1:] The range name including the frame \meta{id} and exclamation mark if any
% \item[2:] frame \meta{id} including the exclamation mark
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? ) \ur{c__bnvs_key_regex} )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item[3:] the path, if any.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_regex} ) \Z
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{myList}
% \begin{BNVS/test}{:N=\c__bnvs_A_FQ_name_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_FQ_name_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1, {},{}} {2}
% \BNVS_Test:nnn {A.1} {A, {}, .1} {3}
% \BNVS_Test:nnn {_A1.1} {_A1, {}, .1} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1, {}, .1.2} {5}
% \BNVS_Test:nnn {?!A} {?!A, ?!, {}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!, {}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A, ?!, .1} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1, ?!, .1} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1, ?!, .1.2} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A, {}, .1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1, {}, .1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1, {}, .1.2.n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A, ?!, .1.n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1, ?!, .1.n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1, ?!, .1.2.n} {5'-?!}
% \end{BNVS/test}
%
% \begin{variable}{\c__bnvs_A_FQ_name_n_Z_regex}
% A key is the name of an overlay set possibly followed by a dotted path.
% Matches the whole string.
% Catch the ending \texttt{.n}.
% \end{variable}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_FQ_name_n_Z_regex {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{itemize}
% \item[1:] The full match
% \item[2:] The fully qualified name including the frame \meta{id} and exclamation mark if any, the dotted path but excluding the trailing \texttt{.n} (this is |\c__bnvs_path_regex| with a trailing |?|).
% \item[3:] frame \meta{id} including the exclamation mark
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? )
  \ur{c__bnvs_key_regex}
  (?: \. \ur{c__bnvs_key_regex} | \. [-+]? \d+ )*? )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item[4:] the last \texttt{.n} component if any.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  ( \. n )? \Z
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{itemize}
% \begin{BNVS/test}{banner=A_FQ_name_n_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_FQ_name_n_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1,{},{}} {2}
% \BNVS_Test:nnn {A.1} {A.1,{},{}} {3}
% \BNVS_Test:nnn {_A1.1} {_A1.1,{},{}} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1.1.2,{},{}} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2,{},{.n}} {6}
% \BNVS_Test:nnn {?!A} {?!A, ?!,{}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!,{}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A.1, ?!,{}} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1.1, ?!,{}} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1.1.2, ?!,{}} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A.1, {}, .n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1.1, {}, .n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2, {}, .n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A.1, ?!, .n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1.1, ?!, .n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1.1.2, ?!, .n} {5'-?!}
% \BNVS_Test:nnn {?!_A1.1.n.2.n} {?!_A1.1.n.2, ?!, .n} {5''-?!}
% \end{BNVS/test}
%
% \begin{variable}{\c__bnvs_colons_regex}
% For ranges defined by a colon syntax.
% One catching group for more than one colon.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_colons_regex { :(:+)? }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=colons_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn {
%   \BNVS_TEST_split:Nnnn \c__bnvs_colons_regex
% }
% \BNVS_Test:nnn { A:C } {{A},{},{C}} {1}
% \BNVS_Test:nnn { A::C } {{A},{:},{C}} {2}
% \BNVS_Test:nnn { A:::C } {{A},{::},{C}} {3}
% \BNVS_Test:nnn { :B::C } {{},{},{B},{:},{C}} {4}
% \end{BNVS/test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 9 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{BNVS/macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \+\+
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{myList}
%   \item 1: \meta{qualified name} of an overlay set
%   \item 2: \meta{id} of a an overlay set including the exclamation mark 
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_key_regex} )
%    \end{macrocode}
% \end{BNVS/macrocode}
%   \item 3: optionally followed by a dotted path
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:Nn=\c__bnvs_split_regex{/:}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{}} { 1|2|3-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ++ABC } {} {{ABC},{},{}} {a'}
% \BNVS_Test:nnnn { ++ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b'}
% \BNVS_Test:nnnn { ++?!ABC } {} {{?!ABC},{?!},{}} {c'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~X~ } {++?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e'}
% \end{BNVS/test}
%   \item 4: \meta{key} of a slide range
%   \item 5: \meta{id} of a slide range including the exclamation mark
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    | ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_key_regex} )
%    \end{macrocode}
% \end{BNVS/macrocode}
%   \item 6: optionally followed by a dotted path
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:Nn=\c__bnvs_split_regex{/:}, noigre, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{}} { 4|5|6-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2~X~ } {?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e}
% \BNVS_Test:nnnn { ABC.3.N.n~~ } {} {{ABC},{},{.3.N.n}} {f}
% \end{BNVS/test}
% We continue with other expressions
%   \item 7: the \meta{++n} attribute
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      (?: \.(\+)\+n
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\c__bnvs_split_regex/.++n, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{+},{},{} } { 7-#4~(.++n) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC.++n } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2.++n~~ } {}  {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC.++n } {}  {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~X~ } { ?!ABC.1.2.++n~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{BNVS/test}
%   \item 8: the poor man integer expression after `|+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      |  \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner={\token_to_str:N\c__bnvs_split_regex/+=}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { `+='~#4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{} } { 8-#4~(+=) } 
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl { #3, {}, #4 }
% }
% \BNVS_Test:nnnnn { ABC += 421 } {} {{ABC}, {}, {}} {421} {1}
% \BNVS_Test:nnnnn { ABC += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {2}
% \BNVS_Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {3}
% \BNVS_Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {4}
% \BNVS_Test:nnnnn { ?!ABC += 421 } {} {{?!ABC}, {?!}, {}} {421} {5}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {6}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1~X } {?!ABC += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {7}
% \BNVS_Test:nnnnn { ?!ABC += (P.1+1)~~^^A(
% ) } {?!ABC += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {8}
% \end{BNVS/test}
%   \item 9: the post increment
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      | (\+)\+
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:Nn=\c__bnvs_split_regex{/:...++}, noigre}
% \BNVS_set:cpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{+}} { 9-#4~(...++) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \__bnvs_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC++ } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2++~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC++ } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2++~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2++~X~ } {?!ABC.1.2++~} {{?!ABC},{?!},{.1.2}} {e}
% \end{BNVS/test}
% \end{myList}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    )?
  ) \s*
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\c__bnvs_split_regex/split, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%     { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},/2 } { split-#3 }
% }
% \BNVS_Test:nnn { ++A }     {{A},{},{}} { 1-a }
% \BNVS_Test:nnn { ++?!A }   {{?!A},{?!},{}} { 1-b }
% \BNVS_Test:nnn { ++A.3 }   {{A},{},{.3}} { 1-c }
% \BNVS_Test:nnn { ++?!A.3 } {{?!A},{?!},{.3}} { 1-d }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,{},{},{},#2,/2 } { split-#3 }
% }
% \BNVS_Test:nnn { A.++n }   {{A},{},{},{+},{},{}} { 2-a' }
% \BNVS_Test:nnn { ?!A.++n } {{?!A},{?!},{},{+},{},{}} { 2-b' }
% \BNVS_Test:nnn { A.3.++n } {{A},{},{.3},{+},{},{}} { 2-c' }
% \BNVS_Test:nnn {?!A.3.++n} {{?!A},{?!},{.3},{+},{},{}} { 2-d' }
% \BNVS_Test:nnn { A }   {{A},{},{},{},{},{}} { 2-a }
% \BNVS_Test:nnn { A.n } {{A},{},{.n},{},{},{}} { 2-b }
% \BNVS_Test:nnn { ?!A } {{?!A},{?!},{},{},{},{}} { 2-c }
% \BNVS_Test:nnn { ?!A.n } {{?!A},{?!},{.n},{},{},{}} { 2-d }
% \BNVS_Test:nnn { A.3 } {{A},{},{.3},{},{},{}} { 2-e }
% \BNVS_Test:nnn { A.3.n } {{A},{},{.3.n},{},{},{}} { 2-f }
% \BNVS_Test:nnn { A.N.3.n } {{A},{},{.N.3.n},{},{},{}} { 2-f' }
% \BNVS_Test:nnn { ?!A.3 } {{?!A},{?!},{.3},{},{},{}} { 2-g }
% \BNVS_Test:nnn { ?!A.3.n } {{?!A},{?!},{.3.n},{},{},{}} { 2-h }
% \BNVS_Test:nnn { A++ }   {{A},{},{},{},{},{+}} { 3-a }
% \BNVS_Test:nnn { A.n++ }   {{A},{},{.n},{},{},{+}} { 3-b }
% \BNVS_Test:nnn { ?!A++ } {{?!A},{?!},{},{},{},{+}} { 3-c }
% \BNVS_Test:nnn { ?!A.n++ } {{?!A},{?!},{.n},{},{},{+}} { 3-d }
% \BNVS_Test:nnn { A.3++ } {{A},{},{.3},{},{},{+}} { 3-e }
% \BNVS_Test:nnn { A.3.n++ } {{A},{},{.3.n},{},{},{+}} { 3-f }
% \BNVS_Test:nnn { ?!A.3++ } {{?!A},{?!},{.3},{},{},{+}} { 3-g }
% \BNVS_Test:nnn { ?!A.3.n++ } {{?!A},{?!},{.3.n},{},{},{+}} { 3-h }
% \BNVS_Test:nnn { A.length } {{A},{},{.length},{},{},{}} { 4-a }
% \BNVS_Test:nnn { A.3.length } {{A},{},{.3.length},{},{},{}} { 4-b }
% \BNVS_Test:nnn { ?!A.length } {{?!A},{?!},{.length},{},{},{}} { 4-c }
% \BNVS_Test:nnn { ?!A.3.length } {{?!A},{?!},{.3.length},{},{},{}} { 4-d }
% \BNVS_Test:nnn { A.last } {{A},{},{.last},{},{},{}} { 5-a }
% \BNVS_Test:nnn { ?!A.last } {{?!A},{?!},{.last},{},{},{}} { 5-b }
% \BNVS_Test:nnn { A.3.last } {{A},{},{.3.last},{},{},{}} { 5-c }
% \BNVS_Test:nnn { ?!A.3.last } {{?!A},{?!},{.3.last},{},{},{}} { 5-d }
% \BNVS_Test:nnn { A.previous } {{A},{},{.previous},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.previous } {{?!A},{?!},{.previous},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.previous } {{A},{},{.3.previous},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.previous } {{?!A},{?!},{.3.previous},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.next } {{A},{},{.next},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.next } {{?!A},{?!},{.next},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.next } {{A},{},{.3.next},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.next } {{?!A},{?!},{.3.next},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.range } {{A},{},{.range},{},{},{}} { 7-a }
% \BNVS_Test:nnn { ?!A.range } {{?!A},{?!},{.range},{},{},{}} { 7-b }
% \BNVS_Test:nnn { A.3.range } {{A},{},{.3.range},{},{},{}} { 7-c }
% \BNVS_Test:nnn { ?!A.3.range } {{?!A},{?!},{.3.range},{},{},{}} { 7-d }
% \end{BNVS/test}
% \end{variable}
%
% \subsubsection{\pkg{beamer.cls} interface}
% Work in progress.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\RequirePackage{keyval}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l__bnvs_id_last_tl { #1 ! }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_KEY} {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/before}{
  \__bnvs_n_gclear:
  \__bnvs_v_gclear:
  \bool_set_true:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_BEFORE} {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/after}{
  \bool_set_false:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_AFTER} {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Defining named slide ranges}
%
% \begin{function}[TF]{\__bnvs_range_if_set:cccn}
%   \begin{syntax}
%     \cs{__bnvs_range_if_set:cccnTF} \marg{core first}  \marg{core end} \marg{core length} \marg{tl} \marg{yes code} \marg{no code}
%   \end{syntax}
% Parse \meta{tl} as a range according to \cs{c__bnvs_colons_regex} and set the variables accordingly.
% \meta{tl} is expected to only contain colons and integers.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { split_if_pop_left:c } #1 { T, F, TF } {
  \__bnvs_seq_pop_left:ccTF { split } { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { split_if_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #1 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { split_if_pop_left:cTF } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVV }
\BNVS_new_conditional:cpnn { range_if_set:cccn } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { range_if_set:cccnTF } {
  \BNVS_DEBUG_log_tl:c { #1 }
  \BNVS_DEBUG_log_tl:c { #2 }
  \BNVS_DEBUG_log_tl:c { #3 }
  \BNVS_DEBUG_log_arg:nn { IN } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_range_set_cccnTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { range_if_set:cccn }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { a }
  \__bnvs_tl_clear:c { b }
  \__bnvs_tl_clear:c { c }
  \__bnvs_if_regex_split:cnTF { colons } { #4 } {
    \__bnvs_seq_pop_left:ccT { split } { a } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% |a| may contain the \meta{start}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \__bnvs_seq_pop_left:ccT { split } { b } {
        \__bnvs_tl_if_empty:cTF { b } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% This is a one colon range.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \__bnvs_split_if_pop_left:cTF { b } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% |b| may contain the \meta{end}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
            \__bnvs_seq_pop_left:ccT { split } { c } {
              \__bnvs_tl_if_empty:cTF { c } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% A |::| was expected:
% \begin{BNVS/macrocode}
%    \begin{macrocode}
                \BNVS_error:n { Invalid~range~expression(1):~#4 }
              } {
                \int_compare:nNnT { \__bnvs_tl_count:c { c } } > { 1 } {
                  \BNVS_error:n { Invalid~range~expression(2):~#4 }
                }
                \__bnvs_split_if_pop_left:cTF { c } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \cs{l__bnvs_c_tl} may contain the \meta{length}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
                  \__bnvs_seq_if_empty:cF { split } {
                    \BNVS_error:n { Invalid~range~expression(3):~#4 }
                  }
                } {
                  \BNVS_error:n { Internal~error }
                }
              }
            } 
          } {
          }
        } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% This is a two colon range component.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \int_compare:nNnT { \__bnvs_tl_count:c { b } } > { 1 } {
            \BNVS_error:n { Invalid~range~expression(4):~#4 }
          }
          \__bnvs_seq_pop_left:ccT { split } { c } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% |c| contains the \meta{length}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
            \__bnvs_split_if_pop_left:cTF { b } {
              \__bnvs_tl_if_empty:cTF { b } {
                \__bnvs_seq_pop_left:cc { split } { b }
%    \end{macrocode}
% \end{BNVS/macrocode}
% |b| may contain the \meta{end}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
                \__bnvs_seq_if_empty:cF { split } {
                  \BNVS_error:n { Invalid~range~expression(5):~#4 }
                }
              } {
                \BNVS_error:n { Invalid~range~expression(6):~#4 }
              }
            } {
              \__bnvs_tl_clear:c { b }
            }
          }
        }
      }
    }
%    \end{macrocode}
% \end{BNVS/macrocode}
% Providing both the \meta{start}, \meta{length} and \meta{end} of a range
% is not allowed, even if they happen to be consistent.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \cs_set:Npn \BNVS_next: { }
    \__bnvs_tl_if_empty:cT { a } {
      \__bnvs_tl_if_empty:cT { b } {
        \__bnvs_tl_if_empty:cT { c } {
          \cs_set:Npn \BNVS_next: {
            \BNVS_error:n { Invalid~range~expression(7):~#3 }
          }
        }
      }
    }
    \BNVS_next:
    \cs_set:Npn \BNVS:nnn ##1 ##2 ##3 {
      \BNVS_end:
      \__bnvs_tl_set:cn { #1 } { ##1 }
      \__bnvs_tl_set:cn { #2 } { ##2 }
      \__bnvs_tl_set:cn { #3 } { ##3 }
    }
    \BNVS_exp_args:Nvvv \BNVS:nnn { a } { b } { c }
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_range_set_cccnTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_range_if_set:cccnTF, noigre}
% \__bnvs_range_if_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_tl_clear:c { a }
%   \__bnvs_tl_clear:c { b }
%   \__bnvs_tl_clear:c { c }
%   \BNVS_use:c { range_if_set:cccn#1 } { a } { b } { c } { #2 }
% }
% \BNVS_Test:nn { TF } { } { \test_fail:n { A } } { }
% \BNVS_Test:nn { T  } { } { \test_fail:n { A } }
% \BNVS_Test:nn {  F } { }                          { }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \__bnvs_tl_if_eq:cnTF { a } { #1 } {
%     \__bnvs_tl_if_eq:cnTF { b } { #2 } {
%       \__bnvs_tl_if_eq:cnF { c } { #3 } {
%         \test_fail:n { #4/c }
%       }
%     } {
%       \test_fail:n { #4/b }
%     }
%   } {
%     \test_fail:n { #4/a }
%   }
% }
% \BNVS_Test:nnnn { } { } { } { X }
% \__bnvs_range_if_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \BNVS_Test:nn { TF } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } } { \test_fail:n { B/a } }
% \BNVS_Test:nn { T  } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } }
% \BNVS_Test:nn {  F } { 1:2 }     { \test_fail:n { #4/a } }
% \BNVS_Test:nn { TF } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } } { \test_fail:n { C/a } }
% \BNVS_Test:nn { T  } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn {  F } { 1::3 }     { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn { TF } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } } { \test_fail:n { D/a } }
% \BNVS_Test:nn { T  } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } }
% \BNVS_Test:nn {  F } { :2::3 }     { \test_fail:n { #4/a } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \BNVS_Test:nnnn
% \end{BNVS/test}
% \end{BNVS/macrocode}
%
% \begin{function}{
%   \__bnvs_range:nnnn,
%   \__bnvs_range:nvvv,
% }
%   \begin{syntax}
%     \cs{__bnvs_range:nnnn} \marg{key} \marg{start} \marg{end} \marg{length}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { range:nnnn } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { range:nnnn } { KEY } { #1 }
\BNVS_DEBUG_log_range_nnnn:nn { } { ... }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_provide:TF {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { ...PROVIDE... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_in:nnTF A { #1 } {
      \use_none:nnn
    } {
      \__bnvs_if_in:nnTF Z { #1 } {
        \use_none:nnn
      } {
        \__bnvs_if_in:nnTF L { #1 } {
          \use_none:nnn
        } {
          \__bnvs_do_range:nnnn { #1 }
        }
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { .../DO~RANGE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_do_range:nnnn { #1 }
  }
}
\BNVS_new:cpn { range:nvvv } #1 #2 #3 #4 {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:nv {
      \BNVS_tl_use:nv {
        \BNVS_use:c { range:nnnn } { #1 }
      } { #2 }
    } { #3 }
  } { #4 }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}{
%   \__bnvs_parse_record:n,
%   \__bnvs_parse_record:v,
%   \__bnvs_parse_record:nn,
%   \__bnvs_parse_record:xn,
%   \__bnvs_parse_record:vn,
%   \__bnvs_n_parse_record:n,
%   \__bnvs_n_parse_record:v,
%   \__bnvs_n_parse_record:nn,
%   \__bnvs_n_parse_record:xn,
%   \__bnvs_n_parse_record:vn
% }
%   \begin{syntax}
%     \cs{__bnvs_parse_record:n} \marg{Q?F name}
%     \cs{__bnvs_parse_record:nn} \marg{Q?F name} \marg{value}
%     \cs{__bnvs_n_parse_record:n} \marg{Q?F name}
%     \cs{__bnvs_n_parse_record:nn} \marg{Q?F name} \marg{value}
%   \end{syntax}
% Auxiliary function for \cs{__bnvs_parse:n} and \cs{__bnvs_parse:nn} below.
% If \meta{value} does not correspond to a range,
% the \texttt{V} key is used.
% The \texttt{_n} variant concerns the index counter.
% This is a bottleneck.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_record:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { parse_record_n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_record_n:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_provide:TF {
    \__bnvs_gprovide:nnnT V { #1 } { 1 } {
      \__bnvs_gclear:n { #1 }
    }
  } {
    \__bnvs_gclear:n { #1 }
    \__bnvs_gput:nnn V { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_n:nn { ... } { ...END }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_parse_record:n { V }
\BNVS_new:cpn { parse_record:v } {
  \BNVS_tl_use:nc {
    \__bnvs_parse_record:V
  }
}
\BNVS_new:cpn { parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn { parse_record:nn }
  { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_record_nn:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_range_if_set:cccnTF { a } { b } { c } { #2 } {
    \__bnvs_range:nvvv { #1 } { a } { b } { c }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...RANGE... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  } {
    \__bnvs_if_provide:TF {
      \__bnvs_gprovide:nnnT V { #1 } { #2 } {
        \__bnvs_gclear_all:n { #1 }
      }
    } {
      \__bnvs_gclear_all:n { #1 }
      \__bnvs_gput:nnn V { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...VALUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \__bnvs_parse_record:nn { x, V }
\BNVS_new:cpn { parse_record:vn } {
  \BNVS_tl_use:nc {
    \__bnvs_parse_record:Vn
  }
}
\BNVS_new:cpn { n_parse_record:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { n_parse_record:n } { KEY } { #1 }
\BNVS_DEBUG_log_n_parse_record_n:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \bool_if:NTF \l__bnvs_n_provide_bool {
    \__bnvs_n_gprovide:nn
  } {
    \__bnvs_n_gput:nn
  }
  { #1 } { 1 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_n:nn { ... } { }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_n_parse_record:n { V }
\BNVS_new:cpn { n_parse_record:v } {
  \BNVS_tl_use:nc {
    \__bnvs_n_parse_record:V
  }
}
\BNVS_new:cpn { n_parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn
  { n_parse_record:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_n_parse_record_nn:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_range_if_set:cccnTF { a } { b } { c } { #2 } {
    \BNVS_error:n { Unexpected~range:~#2 }
  } {
    \__bnvs_if_provide:TF {
      \__bnvs_n_gprovide:nn { #1 } { #2 }
    } {
      \__bnvs_n_gput:nn { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_nn:nn { ... } { ...DONE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \__bnvs_n_parse_record:nn { x, V }
\BNVS_new:cpn { n_parse_record:vn } {
  \BNVS_tl_use:Nc \__bnvs_n_parse_record:Vn
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{BNVS/test}{:N=\__bnvs_n_parse_record:nn, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \banner:n { #1 }
%   \assert_equal:xxn {\__bnvs_n_item:n {X} } {#1} {a}
% }
% \__bnvs_provide_on:
% \__bnvs_n_parse_record:nn {X} {A}
% \BNVS_DEBUG_log:n { 111 }
% {
%   \cs_set:Npn \BNVS_error:n #1 {
%     \cs_set:Npn \test_fail:n ##1 { }
%   }
%   \BNVS_DEBUG_log:n { 111 }
%   \__bnvs_n_parse_record:nn {X} {A::C}
% }
% \end{BNVS/test}
%
% \begin{function}[TF]{
%   \__bnvs_if_id_name_n_get:n,
%   \__bnvs_if_id_name_n_get:v,
% }
% \begin{syntax}
% \cs{__bnvs_id_name_n_set:nTF} \marg{ref} \marg{yes code} \marg{no code}
% \end{syntax}
% If \meta{ref} is a fully qualified name,
% put the frame id it defines into |id|
% and the fully qualified name into |key|,
% then execute \meta{yes code}.
% The |n| |tl| variable is empty except when \meta{ref} ends with \texttt{.n}.
% Otherwise execute \meta{no code}.
% If \meta{ref} is only a qualified name,
% put it in |key|, prepended with |id_last|,
% and set |id| to this value as well.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { id_name_n_end_export: } {
  \cs_set:Npn \BNVS:nnn ##1 ##2 ##3 {
    \BNVS_end:
    \__bnvs_tl_set:cn { id } { ##1 }
    \__bnvs_tl_set:cn { key } { ##2 }
    \__bnvs_tl_set:cn { n } { ##3 }
  }
  \__bnvs_tl_if_empty:cTF { id } {
    \BNVS_exp_args:Nvvv
    \BNVS:nnn { id_last } { key } { n }
    \__bnvs_tl_put_left:cv { key } { id_last }
  } {
    \BNVS_exp_args:Nvvv
    \BNVS:nnn { id } { key } { n }
    \__bnvs_tl_set:cv { id_last } { id }
  }
}
\BNVS_new_conditional:cpnn { if_id_name_n_get:n } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { if_id_name_n_get:n } { 
  \BNVS_DEBUG_log_arg:nn { IN } { #1 }
  \BNVS_DEBUG_tl:c { key }
  \BNVS_DEBUG_tl:c { id }
  \BNVS_DEBUG_tl:c { n }
  \BNVS_DEBUG_tl:c { id_last }
}
  \BNVS_DEBUG_begin:n { if_id_name_n_get:n }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NnTF \c__bnvs_A_FQ_name_n_Z_regex { #1 } {
    \__bnvs_if_match_pop_left:cTF { key } {
      \__bnvs_if_match_pop_left:cTF { key } {
        \__bnvs_if_match_pop_left:cTF { id } {
          \__bnvs_if_match_pop_left:cTF { n } {
            \__bnvs_id_name_n_end_export:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_id_name_n_get_n:nn { } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_end:
            \BNVS_error:n { LOGICALLY_UNREACHABLE_A_FQ_name_n_Z/n }
            \prg_return_false:
          }
        } {
          \BNVS_end:
          \BNVS_error:n { LOGICALLY_UNREACHABLE_A_FQ_name_n_Z/id }
          \prg_return_false:
        }
      } {
        \BNVS_end:
        \BNVS_error:n { LOGICALLY_UNREACHABLE_A_FQ_name_n_Z/name }
        \prg_return_false:
      }      
    } {
      \BNVS_end:
      \BNVS_error:n { LOGICALLY_UNREACHABLE_A_FQ_name_n_Z/n }
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_id_name_n_get_n:nn { } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_id_name_n_get:v } #1 { T, F, TF } {
  \BNVS_tl_use:nv { \BNVS_use:c { if_id_name_n_get:nTF } } { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_id_name_n_get:nTF, noigre, noigre}
% \__bnvs_match_if_once:NnTF \c__bnvs_A_FQ_name_n_Z_regex { ?!X } { } { }
% \__bnvs_if_id_name_n_get:nTF { ?!X } { } { }
% \cs_set:Npn \BNVS_Test:nnnnnn #1 #2 #3 #4 #5 #6 {
%   \banner:n { #6 }
%   \tl_if_empty:nTF { #2 } {
%     \__bnvs_if_id_name_n_get:nT { #1 } {
%       \test_fail:n { FAIL }
%     }
%   } {
%     \__bnvs_if_id_name_n_get:nTF { #1 } {
%       \assert_equal_tl:vnn { key } { #2 } { #6-name }
%       \assert_equal_tl:vnn { id } { #3 } { #6-id }
%       \assert_equal_tl:vnn { n } { #4 } { #6-n }
%       \assert_equal_tl:vnn { id_last } { #5 } { #6-last }
%     } {
%       \test_fail:n { FAIL(bis) }
%     }
%   }
% }
% \BNVS_Test:nnnnnn { X    } { ?!X  } { ?! }  { } { ?! } { 1 }
% \BNVS_Test:nnnnnn { X.1  } { ?!X.1 } { ?! } { } { ?! } { 2 }
% \BNVS_Test:nnnnnn { F!X  } { F!X } { F!  } { } { F! } { 3 }
% \BNVS_Test:nnnnnn { X    } { F!X } { F!  } { } { F! } { 4 }
% \BNVS_Test:nnnnnn { X!X  } { X!X } { X!  } { } { X! } { 5 }
% \BNVS_Test:nnnnnn { Y!X.1 } { Y!X.1 } { Y! } { } { Y! } { 6 }
% \BNVS_Test:nnnnnn { Y!X.n } { Y!X } { Y! } { .n } { Y! } { 7 }
% \BNVS_Test:nnnnnn { Y!X.1.n } { Y!X.1 } { Y! } { .n } { Y! } { 8 }
% \BNVS_Test:nnnnnn { ?!!X.1 } { } { } { } { } { 9 }
% \cs_undefine:N \BNVS_Test:nnnnnn
% \end{BNVS/test}
%
% \begin{function}{\__bnvs_parse:n, \__bnvs_parse:nn}
%   \begin{syntax}
%     \cs{__bnvs_parse:n} \marg{F/Q name}
%     \cs{__bnvs_parse:nn} \marg{F/Q name} \marg{definition}
%   \end{syntax}
% Auxiliary functions called within a group by |\keyval_parse:nnn|.
% \meta{F/Q name} is the overlay (eventually fully) qualified name, 
% including eventually a dotted path and a frame identifier,
% \meta{definition} is the corresponding definition.
% \begin{variable}{\l__bnvs_match_seq}
% Local storage for the match result.
% \end{variable}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { parse:n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_n:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \peek_remove_spaces:n {
    \peek_catcode:NTF \c_group_begin_token {
      \__bnvs_tl_if_empty:cTF { root } {
        \BNVS_error:n { Unexpected~list~at~top~level. }
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
        \BNVS_DEBUG_begin:n { parse:n }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_int_incr:c { i }
        \__bnvs_tl_put_right:cx { root } { \__bnvs_int_use:c { i } . }
        \cs_set:Npn \bnvs:w ####1 ####2 \s_stop {
          \regex_match:nnT { \S* } { ####2 } {
            \BNVS_error:n { Unexpected~####2 }
          }
          \keyval_parse:nnn {
            \__bnvs_parse:n
          } {
            \__bnvs_parse:nn
          } { ####1 }
          \BNVS_end:
        }
        \bnvs:w #1 \s_stop
      }
    } {
      \__bnvs_tl_if_empty:cTF { root } {
        \__bnvs_if_id_name_n_get:nTF { #1 } {
          \__bnvs_tl_if_empty:cTF { n } {
            \__bnvs_parse_record:v
          } {
            \__bnvs_n_parse_record:v
          }
          { key }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...COMPLETE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        } {
          \BNVS_error:n { Unexpected~key:~#1 }
        }
      } {
        \__bnvs_int_incr:c { i }
        \__bnvs_tl_if_empty:cTF { n } {
          \__bnvs_parse_record:xn
        } {
          \__bnvs_n_parse_record:xn
        } {
          \__bnvs_tl_use:c { root } \__bnvs_int_use:c { i }
        } { #1 }
      }
    }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...DONE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_parse:n, noigre}
% \__bnvs_provide_off:
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn V { ?!#1 } } { #2 } { #1 }
% }
% \__bnvs_parse_record:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \__bnvs_gclear:n { ?!X }
% \__bnvs_parse:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \__bnvs_gput:nnn V { ?!Y } { 2 }
% \BNVS_Test:nn { Y } { 2 }
% \__bnvs_parse:n { ?!Y }
% \BNVS_Test:nn { Y } { 1 }
% \__bnvs_gput:nnn V { ?!Z } { 2 }
% \BNVS_Test:nn { Z } { 2 }
% \__bnvs_provide_on:
% \__bnvs_parse:n { ?!Z }
% \BNVS_Test:nn { Z } { 2 }
% \end{BNVS/test}
%
%    \begin{macrocode}
\BNVS_new:cpn { do_range:nnnn } #1 #2 #3 #4 {
    \__bnvs_gclear_all:n { #1 }
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_range:nnnn, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn A {#1} } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } {#8~A }
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn Z {#1} } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } {#8~Z }
%   \BNVS_ASSERT_equal:xxn { \__bnvs_item:nn L {#1} } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } {#8~L }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \__bnvs_provide_off:
%   \__bnvs_range:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \__bnvs_provide_on:
%   \__bnvs_range:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \__bnvs_range:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \__bnvs_range:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \__bnvs_range:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \__bnvs_range:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:c=range:nvvv, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \assert_equal:xxn { \__bnvs_item:nn A { #1 } } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } { #8/A }
%   \assert_equal:xxn { \__bnvs_item:nn Z { #1 } } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } { #8/Z }
%   \assert_equal:xxn { \__bnvs_item:nn L { #1 } } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } { #8/L }
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \__bnvs_tl_set:cn { TEST_A } { #2 }
%   \__bnvs_tl_set:cn { TEST_B } { #3 }
%   \__bnvs_tl_set:cn { TEST_C } { #4 }
%   \__bnvs_range:nvvv  { #1 } { TEST_A } { TEST_B } { TEST_C }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \__bnvs_provide_off:
%   \BNVS_Test:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \__bnvs_provide_on:
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \BNVS_Test:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \BNVS_Test:nnnnnnn
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { do_range:nnnn } {
  \BNVS_DEBUG_log_arg:nn { KEY } { #1 }
  \BNVS_DEBUG_log_arg:nn { FIRST } { #2 }
  \BNVS_DEBUG_log_arg:nn { LAST } { #3 }
  \BNVS_DEBUG_log_arg:nn { LENGTH } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_do_range_nnnn:nn {  } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #4 } {
    \tl_if_empty:nTF { #2 } {
      \tl_if_empty:nTF { #3 } {
        \BNVS_error:n { Not~a~range:~:~#1 }
      } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn V { #1 } { \q_nil }
      }
    } {
      \__bnvs_gput:nnn A { #1 } { #2 }
      \__bnvs_gput:nnn V { #1 } { \q_nil }
      \tl_if_empty:nF { #3 } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn L { #1 } { \q_nil }
      }
    }
  } {
    \tl_if_empty:nTF { #2 } {
      \__bnvs_gput:nnn L { #1 } { #4 }
      \tl_if_empty:nF { #3 } {
        \__bnvs_gput:nnn Z { #1 } { #3 }
        \__bnvs_gput:nnn A { #1 } { \q_nil }
        \__bnvs_gput:nnn V { #1 } { \q_nil }
      }
    } {
      \__bnvs_gput:nnn A { #1 } { #2 }
      \__bnvs_gput:nnn L { #1 } { #4 }
      \__bnvs_gput:nnn Z { #1 } { \q_nil }
      \__bnvs_gput:nnn V { #1 } { \q_nil }
    }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_do_range_nnnn:nn { ... } { ...DONE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
\cs_new:Npn \BNVS_exp_args:NNcv #1 #2 #3 #4 {
  \BNVS_tl_use:nc { \exp_args:NNnV #1 #2 { #3 } }
    { #4 }
}
%    \end{macrocode}
% \begin{BNVS/test}{:N=\BNVS_exp_args:NNcv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \cs_set:Npn \BNVS_Test:cnn  #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { #2 } {
%     \test_fail:n { #3 }
%   }
% }
% \BNVS_exp_args:NNcv \relax \BNVS_Test:cnn { A } { TEST_A } { A }
% \cs_undefine:N \BNVS_Test:cnn
% \end{BNVS/test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_set:cv #1 {
  \BNVS_tl_use:nv {
    \BNVS_end: \__bnvs_tl_set:cn { #1 }
  }
}
\cs_new:Npn \BNVS_tl_set_after:ncv #1 #2 {
  \BNVS_tl_use:nv {
    #1 \__bnvs_tl_set:cn { #2 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse:nn } #1 #2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnn { parse:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_nn:nn { } { ... }
  \BNVS_DEBUG_begin:n { parse:nn }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { a } { #1 }
%    \end{macrocode}
% \end{BNVS/macrocode}
% We prepend the argument with |root|, in case we are recursive.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_tl_put_left:cv { a } { root }
  \__bnvs_if_id_name_n_get:vTF { a } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \regex_match:nnTF { \S } { #2 } {
      \peek_remove_spaces:n {
        \peek_catcode:NTF \c_group_begin_token {
%    \end{macrocode}
% \end{BNVS/macrocode}
% The value is a comma separated list,
% we warn about an unexpected \texttt{.n} suffix, if any.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \__bnvs_tl_if_empty:cF { n } {
\__bnvs_warning:n { Ignoring~unexpected~suffix~.n:~#1 }
          }
%    \end{macrocode}
% \end{BNVS/macrocode}
% We go recursive opening a new \TeX\ group.
% The |root| contains the common part that will prefix the subkeys.
% \begin{BNVS/test}{bnvs:cn={parse:nn}{/list}, noigre}
%   \__bnvs_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_if_get:nncF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%     }
%   }
%   \__bnvs_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_if_get:nncT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%     }
%   }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
% \begin{BNVS/gobble}
%<*!final>
          \BNVS_DEBUG_begin:n { parse:nn(2) }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_gput:nvn V { key } { \q_nil }
          \__bnvs_tl_set:cv { root } { key }
          \__bnvs_tl_put_right:cn { root } { . }
          \__bnvs_int_set:cn { i } { 0 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...GO~RECURSIVE... }
\BNVS_DEBUG_log_tl:c { root }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \cs_set:Npn \BNVS:w ##1 ##2 \s_stop {
            \regex_match:nnT { \S } { ##2 } {
              \BNVS_error:n { Unexpected~value~#2 }
            }
            \keyval_parse:nnn {
              \__bnvs_parse:n
            } {
              \__bnvs_parse:nn
            } { ##1 }
            \BNVS_end:
          }
          \BNVS:w
        } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Next character is not a group begin token.
% \begin{BNVS/test}{bnvs:cn={parse:nn}{/KEY=VALUE}, noigre}
% \__bnvs_parse:nn { X } { FIRST: }
% \__bnvs_if_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \__bnvs_parse:nn { X } { FIRST::LENGTH }
% \__bnvs_if_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \BNVS_DEBUG_log_gprop:n { 100 }
% \__bnvs_if_get:nncTF L { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LENGTH } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/L }
% }
% \__bnvs_parse:nn { X } { FIRST:LAST }
% \__bnvs_if_get:nncTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \__bnvs_if_get:nncTF Z { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LAST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/Z }
% }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \__bnvs_tl_if_empty:cTF { n } {
            \__bnvs_parse_record:vn
          } {
            \__bnvs_n_parse_record:vn
          }
          { key } { #2 }
          \use_none_delimit_by_s_stop:w
        }
      }
      #2 \s_stop
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Empty value given: remove the reference.
% \begin{BNVS/test}{bnvs:cn={parse:nn}{/empty~value}, noigre}
%   \__bnvs_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_if_get:nncF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%    }
%  }
%   \__bnvs_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \__bnvs_tl_set:cn { a } { ?!X/#1 }
%     \__bnvs_if_get:nncT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%    }
%  }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/1... }
\BNVS_DEBUG_log_tl:c { key }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_tl_if_empty:cTF { n } {
        \__bnvs_gclear:v
      } {
        \__bnvs_n_gremove:v
      }
      { key }
    }
  } {
    \BNVS_error:n { Invalid~key:~#2 }
  }
%    \end{macrocode}
% \end{BNVS/macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/2... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \BNVS_end_tl_set:cv { id_last } { id_last }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\__bnvs_parse_prepare:N, noigre}
% \__bnvs_tl_set:cn { a } {A[B]C}
% \__bnvs_parse_prepare:N \l__bnvs_a_tl
% \assert_equal:xxn { \tl_to_str:V \l__bnvs_a_tl } { \tl_to_str:n { A {{B}} C } } {1}
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { parse_prepare:N } #1 {
  \tl_set:Nx #1 #1
  \bool_set_false:N \l__bnvs_parse_bool
  \bool_do_until:Nn \l__bnvs_parse_bool {
    \tl_if_in:NnTF #1 {%---[
    ]} {
      \regex_replace_all:nnNF { \[ ([^\]%---)
      ]*%---[(
      ) \] } { { { \1 } } } #1 {
        \bool_set_true:N \l__bnvs_parse_bool
      }
    } {
      \bool_set_true:N \l__bnvs_parse_bool
    }
  }
  \tl_if_in:NnTF #1 {%---[
  ]} {
    \BNVS_error:n { Unbalanced~%---[
    ]}
  } {
    \tl_if_in:NnT #1 { [%---]
    } {
      \BNVS_error:n { Unbalanced~[ %---]
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{
%   bnvs:cn={parse:nn}{/+\token_to_str:N\__bnvs_item:n}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \__bnvs_provide_off:
%   \banner:n { #5 }
%   \__bnvs_parse:nn {X} {#1}
%   \assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a}
%   \assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#3} {#5-c}
%   \assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#4} {#5-b}
%   \__bnvs_provide_on:
%   \clist_map_inline:nn {D, D:E, D::F, :E::F} {
%     \__bnvs_parse:nn {X} { ##1 }
%     \assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a(##1)}
%     \assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#3} {#5-c(##1)}
%     \assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#4} {#5-b(##1)}
%  }
% }
% \BNVS_Test:nnnnn {A:   } {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B  } {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C } {A} { \exp_not:N \q_nil } {C} {3}
% \BNVS_Test:nnnnn {:B::C} { \exp_not:N \q_nil } {B} {C} {4}
% \end{BNVS/test}
% \begin{BNVS/test}{
%   bnvs:cn={parse:nn}{+\cs{__bnvs_item:n}}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_parse:nn {X.1.2} {#1}
%   \assert_equal:xxn {\__bnvs_item:nn A {?!X.1.2} } {#2} {#5-A}
%   \assert_equal:xxn {\__bnvs_item:nn Z {?!X.1.2} } {#3} {#5-Z}
%   \assert_equal:xxn {\__bnvs_item:nn L {?!X.1.2} } {#4} {#5-L}
% }
% \BNVS_Test:nnnnn {A:} {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B} {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C} {A} { \exp_not:N \q_nil } {C} {3}
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:cn={parse:n}{/:nn}, noigre}
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_if_in:nnTF A {?!X.#5} {
%     \assert_equal:xxn {\__bnvs_item:nn A {?!X.#5} } {#1} {#4-a}
%     \assert_equal:xxn {\__bnvs_item:nn Z {?!X.#5} } {#2} {#4-b}
%     \assert_equal:xxn {\__bnvs_item:nn L {?!X.#5} } {#3} {#4-c}
%   } {
%     \__bnvs_if_in:nnTF V {?!X.#5} {
%       \assert_equal:xxn {\__bnvs_item:nn V {?!X.#5} } {#1} {#4-v}
%     } {
%       \test_fail:n {#4-F}
%     }
%   }
% }
% \__bnvs_parse:nn {X.3} {::C:B}
% \__bnvs_parse:nn {X.3} {{A:,A:B,A::C,:B::C,::C:B, D}}
% \BNVS_Test:nnnnn {A} {} {} {4-1} {3.1}
% \BNVS_Test:nnnnn {A} {B} { \exp_not:N \q_nil } {4-2} {3.2}
% \BNVS_Test:nnnnn {A} { \exp_not:N \q_nil } {C} {4-3} {3.3}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-4} {3.4}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-5} {3.5}
% \BNVS_Test:nnnnn {D} {} {} {4-6} {3.6}
% \cs_undefine:N \BNVS_Test:nnnnn
% \end{BNVS/test}
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key–value list}
%   \end{syntax}
%   The keys are the slide overlay references.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{key–value} items are parsed by \cs{__bnvs_parse:nn}.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_put_right:cv #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_v_gput:nv #1 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_v_gput:nn { #1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { \token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_arg:nn { IN } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{BNVS/macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \seq_gput_right:Nn \g__bnvs_def_seq { #2 }
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% At the top level, clear everything.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \__bnvs_gclear:
    }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { Beanoves }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_tl_clear:c { root }
    \__bnvs_int_zero:c { i }
    \__bnvs_tl_set:cn { a } { #2 }
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% At the top level, use the global definitions.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \seq_if_empty:NF \g__bnvs_def_seq {
        \__bnvs_tl_put_left:cx { a } {
          \seq_use:Nn \g__bnvs_def_seq , ,
        }
      }
    }
    \__bnvs_parse_prepare:N \l__bnvs_a_tl
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ...\token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \IfBooleanTF {#1} {
      \__bnvs_provide_on:
    } {
      \__bnvs_provide_off:
    }
    \BNVS_tl_use:nv {
      \keyval_parse:nnn { \__bnvs_parse:n } { \__bnvs_parse:nn }
    } { a }
    \BNVS_end_tl_set:cv { id_last } { id_last }
    \ignorespaces
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\__bnvs@frame, \__bnvs@masterdecode}
% \begin{syntax}
% \cs{__bnvs@frame} \marg{overlay specification}
% \cs{__bnvs@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} reads it.
% \begin{variable}{\l__bnvs_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% 
% Save the original macros \cs{beamer@frame} and
% \cs{beamer@masterdecode} then override them
% to properly preprocess the argument.
% We start by defining the overloads.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\makeatletter
\cs_set:Npn \__bnvs@frame < #1 > {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
%<*!final>
  \BNVS_DEBUG_begin:n { bnvs@frame }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_resolve:nc { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { bnvs@frame:~#1 }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_saved@frame <
  } { ans } >
}
\cs_set:Npn \__bnvs@masterdecode #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
%<*!final>
  \BNVS_DEBUG_begin:n { bnvs@masterdecode }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { ans }
  \__bnvs_scan:nNc { #1 } \__bnvs_resolve:nc { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { bnvs@masterdecode:~#1 }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_saved@masterdecode
  } { ans }
}
\cs_new:Npn \BeanovesOff {
  \cs_set_eq:NN \beamer@frame \__bnvs_saved@frame 
  \cs_set_eq:NN \beamer@masterdecode \__bnvs_saved@masterdecode
}
\cs_new:Npn \BeanovesOn {
  \cs_set_eq:NN \beamer@frame \__bnvs@frame
  \cs_set_eq:NN \beamer@masterdecode \__bnvs@masterdecode
}
\AddToHook{begindocument/before}{
  \cs_if_exist:NTF \beamer@frame {
    \cs_set_eq:NN \__bnvs_saved@frame \beamer@frame
    \cs_set_eq:NN \__bnvs_saved@masterdecode \beamer@masterdecode
  } {
    \cs_set:Npn \__bnvs_saved@frame < #1 > {
      \BNVS_error:n {Missing~package~beamer}
    }
    \cs_set:Npn \__bnvs_saved@masterdecode < #1 > {
      \BNVS_error:n {Missing~package~beamer}
    }
  }
  \BeanovesOn
}
\makeatother
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{\__bnvs_scan:nNc}
% \begin{syntax}
% \cs{__bnvs_scan:nNc} \marg{overlay query} \meta{eval} \meta{tl core}
% \end{syntax}
% Scan the \meta{overlay query} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from the \meta{resolve} function, which is \cs{__bnvs_resolve:nc}.
% A group is created to use local variables:
% \begin{variable}{\l__bnvs_ans_tl}
% The token list that will be appended to \meta{tl variable} on return.
% \end{variable}
% \begin{variable}{\l__bnvs_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l__bnvs_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l__bnvs_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l__bnvs_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
% Next are helpers.
% \begin{function}{
%   \__bnvs_scan_question:T
% }
% \begin{syntax}
% \cs{__bnvs_scan_question:T} \marg{code}
% \end{syntax}
% At top level state, scan the tokens of the
% \meta{named overlay expression} looking for a `|?|' character.
% If a `|?(...)|' is found, then the \meta{code} is executed.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { scan_question:T } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_question:T } { }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccT { token } { token } {
    \__bnvs_tl_if_eq:cnTF { token } { ? } {
      \__bnvs_scan_require_open:
      #1
    } {
      \__bnvs_tl_put_right:cv { ans } { token }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}    }
    }
    \__bnvs_scan_question:T { #1 }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \__bnvs_scan_require_open:
% }
% \begin{syntax}
% \cs{__bnvs_scan_require_open:}
% \end{syntax}
% We just found a `|?|',
% we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
% \end{function}
%    \begin{macrocode}
\BNVS_new:cpn { scan_require_open: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_require_open: } { }
%</!final>
% \end{BNVS/gobble}
% Get next token.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \tl_if_eq:NnTF \l__bnvs_token_tl { ( %)
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Set the parenthesis depth to 1 (on first passage).
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_int_set:cn { } { 1 }
%    \end{macrocode}
% \end{BNVS/macrocode}
% Record the forthcomming content in
% the \cs{l__bnvs_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_tl_clear:c { query }
        \__bnvs_scan_require_close:
      } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Ignore this token and loop.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_scan_require_open:
      }
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% End reached but no opening parenthesis found, raise.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \BNVS_fatal:x {Missing~'('%---)
      ~after~a~? }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \__bnvs_scan_require_close:
% }
% \begin{syntax}
% \cs{__bnvs_scan_require_close:}
% \end{syntax}
% We found a `|?(|', we record the forthcomming content in the |query| variable,
% up to the next balancing `|)|`.
% \end{function}
%    \begin{macrocode}
\BNVS_new:cpn { scan_require_close: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { scan_require_close: } { }
%</!final>
% \end{BNVS/gobble}
% Get next token.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_seq_pop_left:ccTF { token } { token } {
    \__bnvs_tl_if_eq:cnTF { token } { ( %---)
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to |query|,
% then scan again for a^^A---(
% |)|.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \__bnvs_int_incr:c { }
      \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_scan_require_close:
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% This is not a `|(|'.^^A---)
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \__bnvs_tl_if_eq:cnTF { token } { %(---
        )
      } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% We found a balancing ^^A(---
% `|)|', we decrement and test the depth.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_int_decr:c { }
        \int_compare:nNnTF { \__bnvs_int_use:c { } } = 0 {
%    \end{macrocode}
% \end{BNVS/macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to |ans|
% and look for the next |?|.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to |query| because it is not yet the
% end of sequence marker.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_scan_require_close:
        }
      } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to |query|
% and look for a balancing^^A(---
% |)|.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_tl_put_right:cv { query } { token }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_scan_require_close:
      }
    }
  } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Above ends the code for Not a  `|(|'. ^^A---)
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and terminate.
% As recovery we feed |query| with the missing ^^A(---
% `|)|'.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \BNVS_error:x { Missing~%(---
      `)' }
    \__bnvs_tl_put_right:cx { query } {
      \prg_replicate:nn { \l__bnvs_int } {%(---
      )}
    }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{bnvs:c={scan:nNc}, noigre}
% \cs_set:Npn \BNVS_TEST_resolve:nc #1 #2 {
%   \__bnvs_tl_put_right:cn { #2 } { !(#1) }
% }resolve_in
% \__bnvs_tl_clear:c { a }
% \__bnvs_scan:nNc {1+1} \BNVS_TEST_resolve:nc { a }
% \__bnvs_scan:nNc {?(A)} \BNVS_TEST_resolve:nc { a }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \banner:n { Test:~scan/#3/#1/}
%   \__bnvs_tl_clear:c { a }
%   \__bnvs_scan:nNc { #1 } \BNVS_TEST_resolve:nc { a }
%   \assert_equal_tl:vnn { a } { #2 } { #3 }
% }
% \BNVS_Test:nnn {} {} {1}
% \BNVS_Test:nnn {1+1} {1+1} {2}
% \BNVS_Test:nnn {1?(+)1} {1!(+)1} {3}
% \BNVS_Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \cs_undefine:N \BNVS_TEST_resolve:nc
% \cs_undefine:N \BNVS_Test:nnn
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { scan:nNc } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { scan:nNc } {
  \BNVS_DEBUG_log_arg:nn { WHAT } { #1 }
  \BNVS_DEBUG_log_cs:nN { CMD } #2
  \BNVS_DEBUG_log_arg:nc { IN } { #3 }
}
\BNVS_DEBUG_log_scan_nNc:nn { } { ... }
  \BNVS_DEBUG_begin:n { scan:nNc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_set:cpn { fatal:x } ##1 {
    \msg_fatal:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \BNVS_set:cpn { error:x } ##1 {
    \msg_error:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \__bnvs_tl_set:cn { scan } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_seq_clear:c { token }
%    \end{macrocode}
% \end{BNVS/macrocode}
% Explode the \meta{named overlay expression} into a list of individual tokens:
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \regex_split:nnN { } { #1 } \l__bnvs_token_seq
%    \end{macrocode}
% \end{BNVS/macrocode}
% Run the top level loop to scan for a `|?|' character:
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_scan_question:T {
    \BNVS_tl_use:Nv #2 { query } { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { query }
\BNVS_DEBUG_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  }
  \BNVS_end_tl_put_right:cv { #3 } { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_scan_nNc:nn { ... } { ...DONE }
\BNVS_DEBUG_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Resolution}
%
% Given a name, a frame id and an integer path,
% we resolve any intermediate standalone reference.
% For example, with |A=B| and |B=C|, |A| is resolved in |C|.
% But with |A=B+1| and |B=C|, |A| is not resolved in |C+1|.
% With |A=B:D| and |B=C|, |A| is not resolved in |C:D| as well.
%
% \begin{function}[TF]{
%   \__bnvs_if_kip:ccc
% }
% \begin{syntax}
% \cs{__bnvs_if_kip:cccTF} \marg{key} \marg{id} \marg{path} \marg{yes code} \marg{no code}
% \end{syntax}
% Auxiliary function. On input,
% the \meta{key} tl variable contains a set name whereas
% the \meta{id} tl variable contains a frame id.
% If \meta{key} tl variable contents is a recorded key, on return,
% \meta{key} tl variable contains the resolved name,
% \meta{id} tl variable contains the used frame id,
% \meta{path} seq variable is prepended with new dotted path components,
% \meta{yes code} is executed, otherwise \meta{no code} is executed.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVx }
\quark_new:N \q__bnvs
\BNVS_new:cpn { end_kip_export_seq:nnnccc } #1 #2 #3 #4 #5 #6 {
  \BNVS_end:
  \tl_if_empty:nTF { #2 } {
    \__bnvs_tl_set:cn { #4 } { #1 }
    \__bnvs_tl_put_left:cv { #4 } { #5 }
  } {
    \__bnvs_tl_set:cn { #4 } { #1 }
    \__bnvs_tl_set:cn { #5 } { #2 }
  }
  \__bnvs_seq_set_split:cnn { #6 } { \q__bnvs } { #3 }
  \__bnvs_seq_remove_all:cn { #6 } { }
}
\BNVS_new:cpn { end_kip_export:ccc } {
  \exp_args:Nnnx \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_end_kip_export_seq:nnnccc { key }
  } { id } {
    \__bnvs_seq_use:cn { path } { \q__bnvs }
  }
}
\BNVS_new_conditional:cpnn { if_match_pop_kip: } { T, F, TF } {
  \__bnvs_if_match_pop_left:cTF { key } {
    \__bnvs_if_match_pop_left:cTF { key } {
      \__bnvs_if_match_pop_left:cTF { id } {
        \__bnvs_if_match_pop_left:cTF { path } {
          \__bnvs_seq_set_split:cnv { path } { . } { path }
          \__bnvs_seq_remove_all:cn { path } { }
          \prg_return_true:
        } {
          \prg_return_false:
        }
      } {
        \prg_return_false:
      }
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_kip:ccc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { if_kip:ccc } {
  \BNVS_DEBUG_log_tl:c  { #1 }
  \BNVS_DEBUG_log_tl:c  { #2 }
  \BNVS_DEBUG_log_seq:c { #3 }
}
\BNVS_DEBUG_log_kip_ccc:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_kip:ccc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_match_if_once:NvTF \c__bnvs_A_FQ_name_Z_regex { #1 }  {
%    \end{macrocode}
% \end{BNVS/macrocode}
% This is a correct key, update the path sequence accordingly.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \__bnvs_if_match_pop_kip:TF {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn { } {...ID...}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_end_kip_export:ccc { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...TRUE}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...UNREACHABLE}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_kip_ccc:nn {...} {...FALSE/NOT~A~KEY}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_kip_n_path:,
%   \__bnvs_if_resolve_kip_x_path:,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_kip_n_path:TF} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_resolve_kip_x_path:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% \marg{yes code} will be executed once resolution has occurred,
% \marg{no code} otherwise.
% The |key| and |id| variables as well as the |path| sequence
% are meant to contain proper information on input and on output as well.
% On input, |\l__bnvs_key_tl| contains a slide range name, 
% |\l__bnvs_id_tl| contains a frame id and
% |\l__bnvs_path_seq| contains the components of an integer path, possibly empty.
% On return, the variable |\l__bnvs_key_tl| contains the resolved range name,
% |\l__bnvs_id_tl| contains the frame id used and
% |\l__bnvs_path_seq| contains the sequence of integer path components that could not be resolved.
%
% To resolve one level of a named one slide specification like
% \meta{name}.\meta{i_1}...\meta{i_n},
% we replace the shortest \meta{name}.\meta{i_1}...\meta{i_k}
% where 0$≤$k$≤$n by its definition \meta{name'}.\meta{j_1}...\meta{j_p}
% if any. The \cs{__bnvs_resolve_?:NNNTF} function uses this one level resolution
% as many times as possible, but no more than a predefined limit to catch
% circular references that would lead to an infinite loop.
%
% \begin{enumerate}
% \item If |\l__bnvs_key_tl| content is the name of an unlimited range,
% and the first item of this range is exactly another name range with
% eventually a heading frame identifier or a trailing integer path,
% then |\l__bnvs_key_tl| is replaced by this name, the |\l__bnvs_id_tl|
% and |\l__bnvs_id_tl| are updates accordingly and
% the \meta{path seq var} is prepended with the integer path.
% \item If \meta{path seq var} is not empty,
% append to the right of |\l__bnvs_key_tl| after a separating dot,
% all its left elements but the last one and loop.
% Otherwise return.
%
% In the |_n| variant, the resolution is driven only when there is a non empty
% dotted path.
%
% In the |_x| variant, the resolution is driven one step further:
% if \meta{path seq var} is empty, \meta{name tl var} can contain anything,
% including an integer for example.
% \end{enumerate}
% \end{function}
% \begin{function}{
%   \__bnvs_if_resolve_kip_x_path:TFF
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_kip_x_path:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{BNVS/test}{bnvs:c={if_resolve_kip_n_path:TF}, noigre}
% \Test_if_resolve_path_n:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_if_resolve_path_n:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_if_resolve_path_n:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \Test_if_resolve_path_n:nnnnnn { X=Y,Y } { X } { } { X } { } { 1B }
% \Test_if_resolve_path_n:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \Test_if_resolve_path_n:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_if_resolve_path_n:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_if_resolve_path_n:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \Test_if_resolve_path_n:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_if_resolve_path_n:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B }
% \Test_if_resolve_path_n:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C }
% \Test_if_resolve_path_n:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D }
% \Test_if_resolve_path_n:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H }
% \Test_if_resolve_path_n:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2 }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_if_resolve_path_n:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L }
% \Test_if_resolve_path_n:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A }
% \Test_if_resolve_path_n:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A' }
% \end{BNVS/test}
%
% \begin{BNVS/test}{bnvs:c={if_resolve_kip_x_path:TF}, noigre}
% \Test_resolve_x_path:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y=12 } { X } { 1 } { 12 } { } { 1C' }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y=123 } { X } { 1.2 } { 123 } { } { 2C }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y.2 = 1234 } { X } { 1.2 } { 1234 } { } { 3C }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y.3=12 } { X } { 1.2.3 } { 12 } { } { 5C }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 6C }
% \Test_resolve_x_path:nnnnnn { X=Y, Y.1.2.3.4=Z, Z = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7A }
% \Test_resolve_x_path:nnnnnn { X=Y, Y.1.2.3=Z, Z.4 = 123 } { X } { 1.2.3.4 } { 123 } { } { 7B }
% \Test_resolve_x_path:nnnnnn { X=Y, Y.1.2=Z, Z.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 7C }
% \Test_resolve_x_path:nnnnnn { X=Y, Y.1=Z, Z.2.3.4 = 234} { X } { 1.2.3.4 } { 234 } { } { 7D }
% \Test_resolve_x_path:nnnnnn { X=Y, Y=Z,Z.1.2.3.4 = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7D }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7E }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y.2.3=Z, Z.4=4 } { X } { 1.2.3.4 } { 4 } { } { 7F }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y.2=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7G }
% \Test_resolve_x_path:nnnnnn { X.1=Y, Y=Z, Z.2.3.4 = 234 } { X } { 1.2.3.4 } { 234 } { } { 7H }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7I1 }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { 123 } { } { 7I2 }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y.3=Z, Z.4 = 4, } { X } { 1.2.3.4 } { 4 } { } { 7J }
% \Test_resolve_x_path:nnnnnn { X.1.2=Y, Y=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7K }
% \Test_resolve_x_path:nnnnnn { X.1.2.3=Y, X.1.2=Z, Y.4=4 } { X } { 1.2.3.4 } { 4 } { } { 8A }
% \Test_resolve_x_path:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Z } { } { 9A }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_x_path:TFF } #1 #2 {
  \__bnvs_if_resolve_kip_x_path:TF {
    \__bnvs_seq_if_empty:cTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_a_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_kip_export: } {
  \exp_args:Nnnx
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_end_kip_export_seq:nnnccc { key }
  } { id } {
    \__bnvs_seq_use:cn { path } { \q__bnvs }
  } { key } { id } { path }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { seq_merge:cc } #1 #2 {
  \__bnvs_seq_if_empty:cF { #2 } {
    \__bnvs_seq_set_split:cnx { #1 } { \q__bnvs } {
      \__bnvs_seq_use:cn { #1 } { \q__bnvs }
      \exp_not:n { \q__bnvs }
      \__bnvs_seq_use:cn { #2 } { \q__bnvs } 
    }
    \__bnvs_seq_remove_all:cn { #1 } { }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_x_path:nFF } #1 #2 #3 {
  \__bnvs_if_get:nvcTF #1 { a } { b } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_x_path_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_kip:cccTF { b } { id } { path } {
      \__bnvs_tl_set_eq:cc { key } { b }
      \__bnvs_seq_merge:cc { path } { b }
      \__bnvs_seq_clear:c { b }
      \__bnvs_seq_set_eq:cc { a } { path }
      \__bnvs_if_resolve_kip_x_path_loop_or_end_return:
    } {
      \__bnvs_seq_if_empty:cTF { b } {
        \__bnvs_tl_set_eq:cc { key } { b }
        \__bnvs_seq_clear:c { path }
        \__bnvs_seq_clear:c { a }
        \__bnvs_if_resolve_kip_x_path_loop_or_end_return:
      } {
        #2
      }
    }
  } {
    #3
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_x_path_VAL_loop_or_end_return:F } #1 {
  \__bnvs_if_resolve_kip_x_path:nFF V { #1 } {
    \__bnvs_if_resolve_kip_x_path:nFF A { #1 } {
      \__bnvs_if_resolve_kip_x_path:nFF L { #1 } { #1 }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_x_path_end_return_true: } {
  \__bnvs_seq_pop_left:ccTF { path } { a } {
    \__bnvs_seq_if_empty:cTF { path } {
      \__bnvs_tl_clear:c { b }
      \__bnvs_index_can:vTF { key } {
        \__bnvs_index_append:vvcTF { key } { a } { b } {
          \__bnvs_tl_set:cv { key } { b }
        } {
          \__bnvs_tl_set:cv { key } { a }
        }
      } {
        \__bnvs_tl_set:cv { key } { a }
      }
    } {
      \BNVS_error:x { Path~too~long~.\BNVS_tl_use:c { a }
        .\__bnvs_seq_use:cn { path } . }
    }
  } {
    \__bnvs_if_resolve_value:vcT { key } { key } {}
  }
  \__bnvs_end_kip_export:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_x_path_TF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_kip_x_path: } { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { if_resolve_kip_x_path:TF } {
  \BNVS_DEBUG_log_tl:c { key }
  \BNVS_DEBUG_log_tl:c { id }
  \BNVS_DEBUG_log_seq:c { path }
}
\BNVS_DEBUG_log_if_resolve_kip_x_path_TF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_resolve_kip_x_path: }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_seq_set_eq:cc { a } { path }
  \__bnvs_seq_clear:c { b }
  \__bnvs_if_resolve_kip_x_path_loop_or_end_return:
}
\BNVS_new:cpn { if_resolve_kip_x_path_loop_or_end_return: } {
  \__bnvs_if_call:TF {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_x_path_TF:nn { ... }  { ...LOOP... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_tl_set_eq:cc { a } { key }
    \__bnvs_seq_if_empty:cTF { a } {
      \__bnvs_if_resolve_kip_x_path_VAL_loop_or_end_return:F {
        \__bnvs_if_resolve_kip_x_path_end_return_true:
      }
    } {
      \__bnvs_tl_put_right:cx { a } { . \__bnvs_seq_use:cn { a } . }
      \__bnvs_if_resolve_kip_x_path_VAL_loop_or_end_return:F {
        \__bnvs_seq_pop_right:ccT { a } { c } {
          \__bnvs_seq_put_left:cv { b } { c }
        }
        \__bnvs_if_resolve_kip_x_path_loop_or_end_return:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_x_path_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% 
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_n_path_or_end_return:nF } #1 #2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_get:nvcTF { #1 } { a } { b } {
    \__bnvs_if_kip:cccTF { b } { id } { path } {
      \__bnvs_tl_set_eq:cc { key } { b }
      \__bnvs_seq_merge:cc { path } { b }
      \__bnvs_seq_set_eq:cc { a } { path }
      \__bnvs_seq_clear:c { b }
      \__bnvs_if_resolve_kip_n_path_loop_or_end_return:
    } {
      \__bnvs_seq_pop_right:ccTF { a } { c } {
        \__bnvs_seq_put_left:cv { b } { c }
        \__bnvs_if_resolve_kip_n_path_loop_or_end_return:
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...Unknown~key... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_if_resolve_kip_n_path_end_return_true:
      }
    }
  } {
    #2
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_n_path_VAL_loop_or_end_return: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...VAL... }
\BNVS_DEBUG_log_tl:c { b }
\BNVS_DEBUG_log_seq:c { b }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_kip_n_path_or_end_return:nF V {
    \__bnvs_if_resolve_kip_n_path_or_end_return:nF A {
      \__bnvs_if_resolve_kip_n_path_or_end_return:nF L {
        \__bnvs_seq_pop_right:ccTF { a } { c } {
          \__bnvs_seq_put_left:cv { b } { c }
          \__bnvs_if_resolve_kip_n_path_loop_or_end_return:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...Unknown~key... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_if_resolve_kip_n_path_end_return_true:
        }
      }
    }
  }
}
\BNVS_new:cpn { if_resolve_kip_n_path_end_return_false: } {
  \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_false:
}
\BNVS_new:cpn { if_resolve_kip_n_path_end_return_true: } {
  \__bnvs_end_kip_export:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
% \end{BNVS/macrocode}

% \begin{function}{
%   \__bnvs_if_resolve_kip_n_path_loop_or_end_return:
% }
% Loop to resolve the path.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_n_path_loop_or_end_return: } {
  \__bnvs_if_call:TF {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...LOOP... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_tl_set_eq:cc { a } { key }
    \__bnvs_seq_if_empty:cTF { a } {
      \__bnvs_seq_if_empty:cTF { b } {
        \__bnvs_if_resolve_kip_n_path_end_return_true:
      } {
        \__bnvs_if_resolve_kip_n_path_VAL_loop_or_end_return:
      }
    } {
      \__bnvs_tl_put_right:cx { a } { . \__bnvs_seq_use:cn { a } . }
      \__bnvs_if_resolve_kip_n_path_VAL_loop_or_end_return:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   __bnvs_if_resolve_kip_n_path:
% }
% This is the entry point to resolve the path.
% Local variables:
% \begin{itemize}
% \item \cs{...key_tl}, \cs{...id_tl}, \cs{...path_seq}
% contain the resolution.
% \item |...a_tl| contains the name with a partial index path currently resolved.
% \item \cs{...a_seq} contains the dotted path components to be resolved.
% It equals \cs{...path_seq} at the beginning 
% \item \cs{...b_seq} is used as well.
% Initially empty.
% \end{itemize}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_kip_n_path: } { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cn { if_resolve_kip_n_path:TF } {
  \BNVS_DEBUG_tl:c { key }
  \BNVS_DEBUG_tl:c { id   }
  \BNVS_DEBUG_log_seq:c { path }
}
\BNVS_DEBUG_log_if_resolve_kip_n_path_TF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_resolve_kip_n_path: }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_seq_set_eq:cc { a } { path }
  \__bnvs_seq_clear:c { b }
  \__bnvs_if_resolve_kip_n_path_loop_or_end_return:
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Evaluation bricks}
% We start by helpers.
% \begin{function}{
%  \__bnvs_round_ans:n,
%  \__bnvs_round:c,
%  \__bnvs_round_ans:
%}
% \begin{syntax}
% \cs{__bnvs_round:c} \meta{tl core name}
% \cs{__bnvs_round_ans:}
% \cs{__bnvs_round_ans:n} \marg{expression}
% \end{syntax}
% The first function replaces the variable content
% with its rounded floating point evaluation.
% The second function replaces |ans| tl variable content
% with its rounded floating point evaluation.
% The last function appends to the |ans| tl variable
% the rounded floating point evaluation of the argument.
% \end{function}
% \begin{BNVS/test}{bnvs:c={round_ans:n}, noigre}
% \banner:n {1}
% \__bnvs_tl_clear:c { ans }
% \__bnvs_round_ans:n {11+(1)-111}
% \assert_equal_tl:vnn { ans } { -99 } { 1 }
% \__bnvs_round_ans:n { }
% \assert_equal_tl:vnn { ans } { -990 } { 2 }
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:c=round:c, noigre}
% \banner:n {1}
% \__bnvs_tl_set:cn { a } {11+(1)-111}
% \__bnvs_round:c { a }
% \assert_equal:xxn { \l__bnvs_a_tl } { -99 } { 1 }
% \__bnvs_tl_clear:c { a }
% \__bnvs_round:c { a }
% \assert_equal_tl:vnn { a } { 0 } { 2 }
% \__bnvs_tl_set:cn { ans } {11+(1)-111}
% \__bnvs_round_ans:
% \assert_equal_tl:vnn { ans } { -99 } { 3 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round_ans:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { round_ans:n } { }
\BNVS_DEBUG_log_arg:nn { IN } { #1 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #1 } {
    \__bnvs_tl_put_right:cn { ans } { 0 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { EMPTY }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  } {
    \__bnvs_tl_put_right:cx { ans } { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_tl:nc { OUT } { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:N } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { round:N } { }
\BNVS_DEBUG_log:x { \token_to_str:N #1 -> / \tl_to_str:V #1 / }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF #1 {
    \tl_set:Nn #1 { 0 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { EMPTY }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  } {
    \tl_set:Nx #1 { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { OUT -> / \tl_to_str:V #1 / }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { round:c } {
  \BNVS_tl_use:Nc \__bnvs_round:N
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \BNVS_end_return_false:
%   \BNVS_end_return_false:x
% }
% \begin{syntax}
% \cs{__bnvs_end_return_false:}
% \cs{__bnvs_end_return_false:x} \marg{message}
% \end{syntax}
% End a group and calls \cs{prg_return_false:}.
% The message is for debugging only.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false: {
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false:x #1 {
  \BNVS_error:x { #1 }
  \BNVS_end_return_false:
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_value:nc,
%   \__bnvs_if_resolve_value:vc,
%   \__bnvs_if_append_value:nc,
%   \__bnvs_if_append_value:xc,
%   \__bnvs_if_append_value:vc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_value:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_value:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the content of the \meta{key} value counter
% into the \meta{tl variable} or
% append this value to the right of the variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% Inside the \meta{no code} branch,
% the content of the \meta{tl variable} is undefined.
% Implementation detail: we return the first in the cache for subkey V
% and in the general prop for subkey V.
% Once we have found a value, we feed the previous items
% such that the next search stops at the first item.
% The cache contains an integer which is the computed value from the general prop.
% A group is created while appending but not while resolving.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_value_return:nnnT } #1 #2 #3 #4 {
  \__bnvs_tl_if_empty:cTF { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { ... } { ...FALSE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  } {
    \__bnvs_cache_gput:nnv V { #2 } { #3 }
    #4
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { ... } { ...TRUE/#1 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_nil:c } #1 { T, F, TF } {
  \BNVS_tl_use:Nc \quark_if_nil:NTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { quark_if_no_value:c } #1 { T, F, TF } {
  \BNVS_tl_use:Nc \quark_if_no_value:NTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_value:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_value:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF V { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nncTF V { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% We can retrieve the value from either the first or last index.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_gput:nnn V { #1 } { \q_no_value }
        \__bnvs_if_resolve_first:ncTF { #1 } { #2 } {
          \__bnvs_if_resolve_value_return:nnnT A { #1 } { #2 } {
            \__bnvs_gput:nnn V { #1 } { \q_nil }
          }
        } {
          \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
            \__bnvs_if_resolve_value_return:nnnT Z { #1 } { #2 } {
              \__bnvs_gput:nnn V { #1 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { ... } { ...FALSE/#1 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn V { #1 } { \q_nil }
            \prg_return_false:
          }
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Possible recursive call.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_if_resolve_value_return:nnnT V { #1 } { #2 } {
              \__bnvs_gput:nnn V { #1 } { \q_nil }
            }
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_value_ncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn V { #1 } { \q_nil }
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BeanovesLogGProp
\BNVS_DEBUG_log_f:ncn { ... } { if_resolve_value:ncTF } { ...FALSE/RESOLVE }
\BNVS_DEBUG_log_arg:nnnc { UNKNOWN~KEY } { #1 } { IN } { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_value:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_resolve_value:ncTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_put_right:vc } #1 #2 {
  \BNVS_tl_use:nv {
    \BNVS_end:
    \__bnvs_tl_put_right:cn { #2 }
  } { #1 }
}
\BNVS_new_conditional:cpnn { if_append_value:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_value:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_value_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_value:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_value:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_value_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_value_ncTF:nn { ... } { ...TRUE(FAILED) }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_value } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{bnvs:c=if_append_value:ncTF, noigre}
% \Test_what_append_X_ncTF:nnnn { value } { 222 } { 222 } { 1 }
% \reset:n { YES }
% \BNVS_DEBUG_log_gprop:n { }
% \BNVS_DEBUG_tl:c { ans }
% \__bnvs_if_resolve:ncF { FIRST } { ans } {
%   \assert_equal_ans{ ans }
% \Test_what_append_X_:nn { 222 } { NO~WAY }
% }
% \__bnvs_tl_clear:c ncTF:nnnn { value } { FIRST } { 222 } { 2 }
% \cs_new:Npn \BNVS_Test:nn #1 #2 {
%   \__bnvs_if_resolve_value:ncTF { X } { ans } {
%     \assert_equal_tl:vnn { ans } { #1 } { #2/A }
%     \__bnvs_cache_if_get:nncTF V { X } { ans } {
%       \assert_equal_tl:vnn { ans } { #1 } { #2/B }
%     } {
%       \test_fail:n { #2/C }
%     } 
%   } {
%     \test_fail:n { #2/D }
%   }
% }
% \__bnvs_gput:nnn V { X } { 421 }
% \BNVS_Test:nn { 421 } { 1 }
% \__bnvs_gclear_all:n { X }
% \__bnvs_gput:nnn A { X } { 422 }
% \__bnvs_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 422 } { 2 }
% \__bnvs_gclear_all:n { X }
% \__bnvs_gput:nnn Z { X } { 423 }
% \__bnvs_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 423 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_first:nc,
%   \__bnvs_if_resolve_first:xc,
%   \__bnvs_if_resolve_first:vc,
%   \__bnvs_if_append_first:nc,
%   \__bnvs_if_append_first:xc,
%   \__bnvs_if_append_first:vc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_first:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_first:ncTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the first index of the \meta{key} slide range
% into the \meta{tl variable} or
% append the first index of the \meta{key} slide range
% to the \meta{tl variable}.
% If no resolution occurs the content of the
% \meta{tl variable} is undefined in the first case
% and unmodified in the second.
% Cache the result.
% Execute \meta{yes code} when there is a \meta{first}, \meta{no code} otherwise.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_first:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_first:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF A { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_resolve_first:ncTF/C, noigre}
% \__bnvs_cache_gput:nnn A { X } { 421 }
% \__bnvs_if_resolve_first:ncTF { X } { ans } {
%   \assert_equal_ans:nn { 421 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nncTF A { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn A { #1 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS/macrocode}
% The first index must be computed separately from the length and the last index.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
          \__bnvs_tl_put_right:cn { #2 } { - }
          \__bnvs_if_append_length:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { + 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_tl_if_empty:cTF { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
              \__bnvs_gput:nnn A { #1 } { \q_nil }
              \prg_return_false:
            } {
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_resolve_first:ncTF/q_nil-ZL, noigre}
% \__bnvs_gput:nnn A { X } { \q_nil }
% \__bnvs_gput:nnn Z { X } { 666 }
% \__bnvs_gput:nnn L { X } { 445 }
% \__bnvs_if_resolve_first:ncTF { X } { ans } {
%   \assert_equal_ans:nn { 222 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
              \__bnvs_gput:nnn A { #1 } { \q_nil }
              \__bnvs_cache_gput:nnv A { #1 } { #2 }
              \prg_return_true:
            }
          } {
            \BNVS_error:n {
Unavailable~length~for~#1~(\token_to_str:N\__bnvs_if_resolve_first:ncTF/2) }
            \__bnvs_gput:nnn A { #1 } { \q_nil }
            \prg_return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\token_to_str:N\__bnvs_if_resolve_first:ncTF/1) }
          \__bnvs_gput:nnn A { #1 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { a } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv A { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BeanovesLogGProp
\BNVS_DEBUG_log_if_resolve_first_ncTF:nn { ... } { ...FALSE/C^^J Unknown~KEY = / #1 / A / }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_first } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_first:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_first:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_first_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_first:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_first:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_first_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_first_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_append_first:ncTF, noigre}
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1 }
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1' }
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4' }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5 }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5' }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6 }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6' }
% \end{BNVS/test}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_last:nc,
%   \__bnvs_if_append_last:nc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_last:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_last:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the last index of the fully qualified \meta{key} range
% into or to the right of the right of the \meta{tl variable}, when possible.
% Execute \meta{yes code} when a last index was given,
% \meta{no code} otherwise.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_last:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_last:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF Z { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  }  {
    \__bnvs_if_get:nncTF Z { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn Z { #1 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS/macrocode}
% The last index must be computed separately from the start and the length.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...A+L... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_first:ncTF { #1 } { #2 } {          
          \__bnvs_tl_put_right:cn { #2 } { + }
          \__bnvs_if_append_length:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { - 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_cache_gput:nnv Z { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \__bnvs_gput:nnn Z { #1 } { \q_nil }
            \prg_return_true:
          } {
            \BNVS_error:x {
 Unavailable~length~for~#1~(\token_to_str:N \__bnvs_if_resolve_last:ncTF/1) }
            \__bnvs_gput:nnn Z { #1 } { \q_nil }
            \prg_return_false:
          }
        } {
          \BNVS_error:x {
Unavailable~first~for~#1~(\token_to_str:N \__bnvs_if_resolve_last:ncTF/1) }
          \__bnvs_gput:nnn Z { #1 } { \q_nil }
          \prg_return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv Z { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...TRUE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_last_ncTF:nn { ... } { ...FALSE/B }
\BNVS_DEBUG_log_tl:c { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_last } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_last:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_last:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_last_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_last:ncTF }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_last_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_last_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_last } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{banner=last, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 1 }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 2 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 3 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 4 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 5 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 6 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 11 }
% \end{BNVS/test}
% \begin{function}[TF]{\__bnvs_if_resolve_length:nc, \__bnvs_if_append_length:nc}
% \begin{syntax}
% \cs{__bnvs_if_resolve_length:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_length:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the length of the \meta{key} slide range into \meta{tl variable},
% or append the length of the \meta{key} slide range to \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{length}, \meta{no code} otherwise.
% \end{function}
% \begin{BNVS/test}{bnvs:c=append_length:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { length } { ::445 } { 445 } { 1 }
% \Test_what_append_X_ncTF:nnnn { length } { ::445 } { 445 } { 2 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH } { 445 } { 3 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH } { 445 } { 4 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST::LENGTH } { 445 } { 5 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST::LENGTH } { 445 } { 6 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH:LAST } { 445 } { 7 }
% \Test_what_append_X_ncTF:nnnn { length } { ::LENGTH:LAST } { 445 } { 8 }
% \Test_what_append_X_ncTF:nnnn { length } { :LAST::LENGTH } { 445 } { 9 }
% \Test_what_append_X_ncTF:nnnn { length } { :LAST::LENGTH } { 445 } { 10 }
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:c=if_resolve:ncTF, noigre}
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { A }
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:c=if_append:ncTF, noigre}
% \Test_if_append:nnnn { 222:666 } { X.last } { 666 } { A }
% \Test_if_append:nnnn { 222:666 } { X.1 } { 222 } { B }
% \Test_if_append:nnnn { 222:666 } { X.last - X.1 } { 444 } { C }
% \Test_if_append:nnnn { 222:666 } { X.last - (X.1) } { 444 } { D }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 0 } { A2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 0 } { B2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 0 } { C2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 0 } { D2i }
% \reset:n { Y }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 666 } { A2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 222 } { B2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 444 } { C2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 444 } { D2 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST:LAST } { 445 } { 11 }
% \Test_what_append_X_ncTF:nnnn { length } { FIRST:LAST } { 445 } { 12 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_length:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_length:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF L { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_get:nncTF L { #1 } { #2 } {
      \__bnvs_quark_if_nil:cTF { #2 } {
        \__bnvs_gput:nnn L { #1 } { \q_no_value }
%    \end{macrocode}
% \end{BNVS/macrocode}
% The length must be computed separately from the start and the last index.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
          \__bnvs_tl_put_right:cn { #2 } { - }
          \__bnvs_if_append_first:ncTF { #1 } { #2 } {
            \__bnvs_tl_put_right:cn { #2 } { + 1 }
            \__bnvs_round:c { #2 }
            \__bnvs_gput:nnn L { #1 } { \q_nil }
            \__bnvs_cache_gput:nnv L { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_error:n {
Unavailable~first~for~#1~(\__bnvs_if_resolve_length:ncTF/2) }
            \return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\__bnvs_if_resolve_length:ncTF/1) }
          \return_false:
        }
      } {
        \__bnvs_quark_if_no_value:cTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \__bnvs_if_resolve:vcTF { #2 } { #2 } {
            \__bnvs_cache_gput:nnv L { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_length_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_length } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_length:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_length:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_length_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_length:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_length:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_length_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_length_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_length } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_range:nc,
%   \__bnvs_if_append_range:nc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_range:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_range:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the range of the \meta{key} slide range into the \meta{tl variable}
% or append this range to the \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{range}, \meta{no code} otherwise, in that latter case
% the content the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_range:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_range:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_range_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_range:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_first:ncTF { #1 } { a } {
    \BNVS_tl_use:Nv \int_compare:nNnT { a } < 0 {
      \__bnvs_tl_set:cn { a } { 0 }
    }
    \__bnvs_if_resolve_last:ncTF { #1 } { b } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Limited from above and below.
% \begin{BNVS/test}{bnvs:cn={if_append_range:ncTF}{A-Z}, noigre}
% \Test_if_append_range:nnn { 222:666 } { 222-666 } { 3 }
% \Test_if_append_range:nnn { 222::445 } { 222-666 } { 4 }
% \Test_if_append_range:nnn { ::445:666 } { 222-666 } { 5 }
% \Test_if_append_range:nnn { :666::445 } { 222-666 } { 6 }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST:LAST } { 222-666 } { 3 }
% ^^A\Test_if_append_range:nnn { FIRST::LENGTH } { 222-666 } { 4 }
% \Test_if_append_range:nnn { ::LENGTH:LAST } { 222-666 } { 5 }
% \Test_if_append_range:nnn { :LAST::LENGTH } { 222-666 } { 6 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_right:cn { a } { - }
      \__bnvs_tl_put_right:cv { a } { b }
      \BNVS_end_tl_put_right:cv { #2 } { a }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_ncTF:nn { ... } { ...TRUE/A-Z }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Limited from below.
% \begin{BNVS/test}{:N=\__bnvs_if_append_range:ncTF/A-, noigre}
% \reset:n { Y }
% \Test_if_append_range:nnn { 222 } { 222- } { 1 }
% \Test_if_append_range:nnn { 222: } { 222- } { 1' }
% \Test_if_append_range:nnn { 222:: } { 222- } { 1'' }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST } { 222- } { 1 }
% \Test_if_append_range:nnn { FIRST: } { 222- } { 1' }
% \Test_if_append_range:nnn { FIRST:: } { 222- } { 1'' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \BNVS_end_tl_put_right:cv { #2 } { a }
      \__bnvs_tl_put_right:cn { #2 } { - }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_ncTF:nn { ... } { ...TRUE/A- }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_if_resolve_last:ncTF { #1 } { b } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Limited from above.
% \begin{BNVS/test}{:N=\__bnvs_if_append_range:ncTF/-Z, noigre}
% \reset:n { Y }
% \Test_if_append_range:nnn { :666 } { -666 } { 1 }
% \reset:n { Y }
% \Test_if_append_range:nnn { :LAST } { -666 } { 1' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
      \__bnvs_tl_put_left:cn { b } { - }
      \BNVS_end_tl_put_right:cv { #2 } { b }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_ncTF:nn { ... } { ...TRUE/-Z }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_if_resolve_value:ncTF { #1 } { b } {
      \BNVS_tl_use:Nv \int_compare:nNnT { b } < 0 {
        \__bnvs_tl_set:cn { b } { 0 }
      }
%    \end{macrocode}
% \end{BNVS/macrocode}
% Unlimited range.
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_range:ncTF{/:-}, noigre}
% \reset:n { Y }
% \Test_if_append_range:nnn { 222 } { 222- } { 1 }
% \reset:n { Y }
% \Test_if_append_range:nnn { FIRST } { 222- } { 1' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \BNVS_end_tl_put_right:cv { #2 } { b }
        \__bnvs_tl_put_right:cn { #2 } { - }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_ncTF:nn { ... } { ...TRUE/V }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_range_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_end:
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_range } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_range:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_range_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_range_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_tl_clear:c { #2 }
  \__bnvs_if_append_range:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_range_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_range_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  } 
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_range } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_previous:nc,
%   \__bnvs_if_append_previous::nc
% }
% \begin{syntax}
% \cs{__bnvs_if_append_previous::ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to the variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{BNVS/test}{:N=\__bnvs_if_append_previous::ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { previous } { 222: } { 221 } { 2 }
% \Test_what_append_X_ncTF:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5' }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6 }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6' }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_if_append_previous::ncTF, noigre}
% \reset:n { Y }
% \Beanoves { X = :LAST::LENGTH }
% \Test_what_append_X_ncTF:nnnn { last } { } { 666 } { A }
% \Test_what_append_X_ncTF:nnnn { length } { } { 445 } { B }
% \Test_what_append_X_ncTF:nnnn { first } { } { 222 } { C }
% \Test_what_append_X_ncTF:nnnn { previous } {  } { 221 } { 7 }
% \Test_what_append_X_ncTF:nnnn { previous } { :LAST+1::LENGTH } { 222 } { 7' }
% \Beanoves {X=:LAST}
% \__bnvs_tl_clear:c { a }
% \__bnvs_if_append_previous::ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \__bnvs_tl_clear:c { a }
% \__bnvs_if_append_previous::ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_previous:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_previous:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_previous_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF P { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_resolve_first:ncTF { #1 } { #2 } {
      \__bnvs_tl_put_right:cn { #2 } { -1 }
      \__bnvs_round:c { #2 }
      \__bnvs_cache_gput:nnv P { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_previous_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_previous } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_previous::nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_previous:_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_previous:_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_previous::nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_previous:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_previous:_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_previous:_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_previous: } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_next:nc,
%   \__bnvs_if_append_next:nc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_next:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_next:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to this variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% \end{function}
% \begin{BNVS/test}{:N=\__bnvs_if_append_next:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 1 }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 2 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 3 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 4 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 5 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 6 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 7 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 8 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 9 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 10 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_next:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_next:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_resolve_next_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_cache_if_get:nncTF N { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_next_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
      \__bnvs_tl_put_right:cn { #2 } { +1 }
      \__bnvs_round:c { #2 }
      \__bnvs_cache_gput:nnv N { #1 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_next_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_next_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { resolve_next } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_next:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_next:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_next_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_next:ncTF }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_next:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_next_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_next_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_next } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_v:nc,
%   \__bnvs_if_append_v:nc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_v:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_v:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the value of the \meta{key} overlay set
% into the \meta{tl variable} or
% append this value to the right of this variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only. 
% \end{function}
% \begin{BNVS/test}{:N=\__bnvs_if_resolve_v:ncTF, noigre}
% \reset:n { Y }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_v:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_resolve_v_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_v_if_get:ncTF { #1 } { #2 } {
    \__bnvs_quark_if_no_value:cTF { #2 } {
      \BNVS_fatal:n {Circular~definition:~#1}
      \prg_return_false:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_v_ncTF:nn { ... } { ...TRUE/ALREADY }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \__bnvs_v_gput:nn { #1 } { \q_no_value }
    \__bnvs_if_resolve_value:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_resolve_v:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_resolve_ncTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_DEBUG_log_gprop:n { 100 }
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_if_append_v:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { v } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_v_ncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_v_gput:nv { #1 } { #2 }
      \prg_return_true:
    } {
      \__bnvs_if_resolve_first:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_v_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_v_gput:nv { #1 } { #2 }
        \prg_return_true:
      } {
        \__bnvs_if_resolve_last:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_v_ncTF:nn { ... } { ...TRUE/Z }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_v_gput:nv { #1 } { #2 }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_v_ncTF:nn { ... } { ...FALSE/Z }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_v_gremove:n { #1 }
          \prg_return_false:
        }
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_resolve_v } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_v:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_v:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_v_append_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_v:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:N=\__bnvs_if_append_value:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_if_append_value:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_ncTF:nnnnn { value } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{BNVS/test}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { v_append } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_index_can:n,
%   \__bnvs_index_can:v,
%   \__bnvs_if_resolve_index:nnc,
%   \__bnvs_if_resolve_index:vvc,
%   \__bnvs_index_append:nnc,
%   \__bnvs_index_append:vvc
% }
% \begin{syntax}
% \cs{__bnvs_index_can:nTF} \marg{key} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_resolve_index:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_index_append:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index associated to the \meta{key} and \meta{integer} slide range
% into the \meta{tl variable} or
% append this index to the right of this variable.
% When \meta{integer} is 1, this is the first index,
% when \meta{integer} is 2, this is the second index, and so on.
% When \meta{integer} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% The computation may fail when too many recursion calls are made.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \__bnvs_if_in_p:nn V { #1 }
    || \__bnvs_if_in_p:nn A { #1 }
    || \__bnvs_if_in_p:nn Z { #1 }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnn { index_can:nTF } { KEY } { #1 }
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...TRUE}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...FALSE}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_can:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_index_can:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_index:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \exp_args:Nx \__bnvs_if_resolve_value:ncTF { #1.#2 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
  } {
    \__bnvs_if_resolve_first:ncTF { #1 } { #3 } {
      \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			\__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { ... } { ...TRUE/FIRST }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
%    \end{macrocode}
% \end{BNVS/macrocode}
% Limited overlay set.
% \begin{BNVS/test}{bnvs:c=if_resolve_index:nncTF, noigre}
% \Test_if_resolve_index:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_if_resolve_index:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_if_resolve_index:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_if_resolve_index:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_if_resolve_index:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \cs_undefine:N \BNVS_Test:n
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    } {
      \__bnvs_if_resolve_last:ncTF { #1 } { #3 } {
        \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			  \__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { ... } { ...TRUE/LAST }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_if_resolve_value:ncTF { #1 } { #3 } {
          \__bnvs_tl_put_right:cn { #3 } { + #2 - 1 }
   			    \__bnvs_round:c { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_index_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \prg_return_false:
        }
      }
  }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:nvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \__bnvs_if_resolve_index:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_index:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_if_resolve_index:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { index_append:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_index_append_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { index_append:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_index:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
%    \end{macrocode}
% \begin{BNVS/test}{:N=\__bnvs_index_append:nncTF, noigre}
% \Test_index_append:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_index_append:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_index_append:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_index_append:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{BNVS/test}
%    \begin{macrocode}
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { index_append:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:nv {
    \BNVS_tl_use:Nv \__bnvs_index_append:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \subsubsection{Index counter}
% \begin{function}[TF]{\__bnvs_if_resolve_n:nc,\__bnvs_if_append_n:nc, \__bnvs_if_append_n:Vc}
% \begin{syntax}
% \cs{__bnvs_if_resolve_n:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluate the n counter associated to the \marg{key} overlay set
% into \meta{tl variable}.
% Initialize this counter to 1 on the first use.
% \meta{no code} is never executed.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_n:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_resolve_n_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_n_get:ncF { #1 } { #2 } {
    \__bnvs_tl_set:cn { #2 } { 1 }
    \__bnvs_n_gput:nn { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_resolve_n_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_n:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_append_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { n_append } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_append_n:ncTF, noigre}
% \Test_n_append_X:nnn { 1 } { 1 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 123 }
% \Test_n_append_X:nnn { } { 123 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_append_n:nnnn { } { ?!#1 } { 1 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{BNVS/test}
%
% \begin{function}[TF]{
%  \__bnvs_if_resolve_n_index:nc,
%  \__bnvs_if_append_n_index:nc,
%  \__bnvs_if_resolve_n_index:nnc,
%  \__bnvs_if_append_n_index:nnc,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_n_index:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_n_index:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_resolve_n_index:nncTF} \marg{key} \marg{base key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_n_index:nncTF} \marg{key} \marg{base key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index for the value of the n counter associated to the
% \marg{key} overlay set into the \meta{tl variable} or
% append this value the right of this variable.
% Initialize this counter to 1 on the first use.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined on resolution only.
% \end{function}
% \begin{BNVS/test}{:N=\__bnvs_if_resolve_n_index:ncTF, noigre}
% \reset:n { YES }
% \Test_if_resolve_n_index_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_if_resolve_n_index_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_n_index:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { 445 }
%   \Test_if_resolve_n_index:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_resolve_n_index:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { -443 }
%   \Test_if_resolve_n_index:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{BNVS/test}
% \begin{BNVS/test}{:N=\__bnvs_if_append_n_index:ncTF, noigre}
% \reset:n { YES }
% \Test_if_append_n_index_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_if_append_n_index_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_append_n_index:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { 445 }
%   \Test_if_append_n_index:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_if_append_n_index:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \__bnvs_n_gput:nn { ?!#1 } { -443 }
%   \Test_if_append_n_index:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_index:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_n_index:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_n_index_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:ncTF { #1 } { #2 } {
    \__bnvs_if_resolve_index:nvcTF { #1 } { #2 } { #2 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_index:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_n_index:nncTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:ncTF { #1 } { #3 } {
    \__bnvs_tl_put_left:cn { #3 } { #2. }
    \__bnvs_if_resolve:vcTF { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_index_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_index:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append_n_index:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_n_index_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_index:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_index:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_ncTF:nn { } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_ncTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_index:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_append_n_index:nncTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_index:nncTF }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_index:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_index_nncTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_vc:cn { if_append_n_index } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_append_n_index } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\__bnvs_if_append_n_index:ncTF, noigre}
% \reset:n { YES }
% \Test_if_append_n_index_X:nnn { FIRST } { 222 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_n_append_X:nnn { } { 445 } { 2 }
% \Test_if_append_n_index_X:nnn { } { 666 } { 1 }
% \end{BNVS/test}
%
% \subsubsection{Value counter}
% \begin{function} [TF] {
%   \__bnvs_if_resolve_v_incr:nnc,
%   \__bnvs_if_append_v_incr:nnc,
%   \__bnvs_if_append_v_incr:VnN,
%   \__bnvs_if_append_v_incr:VVN
% }
% \begin{syntax}
% \cs{__bnvs_if_append_v_incr:nnTF}  \marg{key} \marg{offset} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_resolve_v_incr:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_v_incr:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Increment the value counter position accordingly.
% When requested, put the result in the \meta{tl variable}.
% In the second version, the result will lay within the declared range.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v_incr:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_v_incr_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #2 } { #3 } {
    \BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
      \__bnvs_if_resolve_v:ncTF { #1 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_v_incr:nncTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_incr:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_v_incr:nncTF{/:2}, noigre}
% \reset:n { Y }
% \__bnvs_if_resolve_v_incr:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_false:
      }
    } {
      \__bnvs_tl_put_right:cn { #3 } { + }
      \__bnvs_if_append_v:ncTF { #1 } { #3 } {
        \__bnvs_round:c { #3 }
        \__bnvs_v_gput:nv { #1 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_v_incr:nncTF{/:3}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_incr:nncTF { ?!X } { 444 } { ans } {
%   \assert_equal_ans:nn { 666 } { 3 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_incr_nncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { if_resolve_v_incr } { T, F, TF }
\BNVS_new_conditional:cpnn { if_append_v_incr:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_append_v_incr_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_v_incr_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_v_incr:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v_incr:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_incr_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_v_incr:nncTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_incr:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_incr_nncTF:nn { } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_v_incr:nncTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_incr:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } { 2 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { if_append_v_incr } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_append_v_incr } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_v_post:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_v_post:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_v_post_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v:ncTF { #1 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve_v_post:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve:ncTF { #2 } { a } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { a } = 0 {
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_v_post:nncTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_post:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \__bnvs_tl_put_right:cn { a } { + }
        \__bnvs_tl_put_right:cv { a } { #3 }
        \__bnvs_round:c { a }
        \BNVS_end_v_gput:nv { #1 } { a }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_v_post:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_if_resolve_v_post:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 2222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_true:
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_v_post:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \end{BNVS/test}
%    \begin{macrocode}
      \BNVS_end:
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_v_post_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_v_post:nncTF}{/:2}, noigre}
% \reset:n { Y }
% \__bnvs_if_resolve_v_post:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
      \prg_return_false:
  }
}
\BNVS_new_conditional_vvc:cn { if_resolve_v_post } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_v_post:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_append_v_post:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_v_post_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_v_post:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_v_post:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_post_nncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_append_v_post:nncTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_post:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
%   \__bnvs_tl_set:cn { ans } { 2 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_v_post_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_v_post:nncTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_post:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 2 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { 2' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  }
}
\BNVS_new_conditional_vnc:cn { if_append_v_post } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_append_v_post } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{bnvs:cn={if_append_v_post:nncTF}{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 9 }
% \__bnvs_if_append_v_post:nncTF { ?!X } { 8000 } { ans } {
%   \assert_equal_ans:nn { 9222 } { A }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { A' }
%   } {
%     \test_fail:n { NO_WAY-A' }
%   }
% } {
%   \test_fail:n { NO_WAY-A }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 9 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_if_append_v_post:vncTF { a } { 8000 }  { ans } {
%   \assert_equal_ans:nn { 9222 } { B }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { B' }
%   } {
%     \test_fail:n { NO_WAY-B' }
%   }
% } {
%   \test_fail:n { NO_WAY-B }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_if_append_v_post:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C' }
%   } {
%     \test_fail:n { NO_WAY-C' }
%   }
% } {
%   \test_fail:n { NO_WAY-C }
% }
% \end{BNVS/test}
% \begin{function} [TF] {
%   \__bnvs_if_resolve_n_incr:nnnc,
%   \__bnvs_if_resolve_n_incr:vvnc,
%   \__bnvs_if_resolve_n_incr:nnc,
%   \__bnvs_if_resolve_n_incr:vvc,
%   \__bnvs_if_append_n_incr:nnnc,
%   \__bnvs_if_append_n_incr:nnc,
%   \__bnvs_if_append_n_incr:vnc,
%   \__bnvs_if_append_n_incr:vvc,
%   \__bnvs_if_resolve_n_post:nnc,
%   \__bnvs_if_append_n_post:nnc
%   }
% \begin{syntax}
% \cs{__bnvs_if_resolve_n_incr:nncTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_resolve_n_incr:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_n_incr:nnncTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_n_incr:nncTF} \marg{key} \marg{offset} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Increment the implicit n counter accordingly.
% When requested, put the resulting index in the variable with \meta{tl core name}.
% \end{function}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nnc}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves{ X = 123 }
% \__bnvs_if_resolve_n:ncTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 1 } { A }
% } {
%   \test_fail:n { NO_WAY }
% }
% \__bnvs_if_resolve_n_index:ncTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 123 } { B }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Beanoves{ X = 123 }
% \__bnvs_if_resolve_n_incr:nncTF { ?!X } { 123 } { ans } {
%   \assert_equal_ans:nn { 246 } { C }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Test_if_append_n_incr:nnnnn { 123 } {} { 123 } { 246 } { 1 }
% \Test_n_get:nnnn {} {} { 124 } { 2 }
% \Test_if_append_n_incr:nnnnn { 123 } {} { 500+40+3 } { 666 } { 3 }
% \reset:n { YES }
% \Test_if_append_n_incr:nnnnn { FIRST } {} { LENGTH-1 } { 666 } { 4 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_incr:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnnnc { if_resolve_n_incr:nnncTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #3 } { #4 } {
			\BNVS_tl_use:Nv \int_compare:nNnTF { #4 } = 0 {
      \__bnvs_if_resolve_n:ncTF { #1 } { #4 } {
        \__bnvs_if_resolve_index:nvcTF { #1 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nnncTF { ?!X } { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nnncT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \__bnvs_tl_put_right:cn { #4 } { + }
      \__bnvs_if_append_n:ncTF { #1 } { #4 } {
        \__bnvs_round:c { #4 }
        \__bnvs_n_gput:nv { #1 } { #4 }
        \__bnvs_if_resolve_index:nvcTF { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nnncTF { ?!X } { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nnncT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bvs:cn={if_resolve_n_incr:nnncTF}{/:5}, noigre}
% \reset:n{ YES }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nnncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nnncTF}{/:6}, noigre}
% \reset:n{ YES }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_incr:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_n_incr_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #2 } { #3 } {
			\BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
      \__bnvs_if_resolve_n:ncTF { #1 } { #3 } {
        \__bnvs_if_resolve_index:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \__bnvs_tl_put_right:cn { #3 } { + }
      \__bnvs_if_append_n:ncTF { #1 } { #3 } {
        \__bnvs_round:c { #3 }
        \__bnvs_n_gput:nv { #1 } { #3 }
        \__bnvs_if_resolve_index:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve_n_incr:nncTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_incr:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_incr:nncTF{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_incr:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_incr:nncTF{/:5}, noigre}
% \reset:n{ YES }
% \end{BNVS/test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_incr_nncTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_incr:nncTF{/:6}, noigre}
% \reset:n{ YES }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { if_resolve_n_incr } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_resolve_n_incr } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_incr:nnnc } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnnnc { if_append_n_incr:nnncTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_incr:nnnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_incr:nnncTF { #1 } { #2 } { #3 } { #4 }{
    \BNVS_end_tl_put_right:cv { #4 } { #4 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_append_n_incr:nnncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_append_n_incr:nnncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nnncT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnc:cn { if_append_n_incr } { T, F, TF }
\BNVS_new_conditional_vvvc:cn { if_append_n_incr } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_incr:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_append_n_incr:nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_n_incr_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_incr:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_incr:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_append_n_incr:nncTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_incr_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_append_n_incr:nncTF}{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_incr:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { if_append_n_incr } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_append_n_incr } { T, F, TF }
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:cn={if_append_n_incr:nncTF}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_if_append_n_incr:vncTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_if_append_n_incr:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{function} [TF] {
%   \__bnvs_if_resolve_v_post:nnc,
%   \__bnvs_if_resolve_v_post:vvc,
%   \__bnvs_if_append_v_post:nnc,
%   \__bnvs_if_append_v_post:vnN,
%   \__bnvs_if_append_v_post:vvN
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_v_post:nncTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{__bnvs_if_append_v_post:nncTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Resolve the value of the free counter for the given \meta{key} into
% the \meta{tl variable} then increment this free counter position
% accordingly.
% The append version, appends the value to the right of the \meta{tl variable}.
% The content of the \meta{tl variable} is undefined
% while in the \marg{no code} branch and on resolution only.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_n_post:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_resolve_n_post_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n:ncTF { #1 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve_n_post:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve:ncTF { #2 } { #3 } {
      \BNVS_tl_use:Nv \int_compare:nNnTF { #3 } = 0 {
        \BNVS_end:
        \__bnvs_if_resolve_index:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_n_post:nncTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_post:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
%   \__bnvs_if_resolve_n_index:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
        \__bnvs_tl_put_right:cn { #3 } { + }
        \__bnvs_if_append_n:ncTF { #1 } { #3 } {
          \__bnvs_round:c { #3 }
          \__bnvs_n_gput:nv { #1 } { #3 }
          \BNVS_end:
          \__bnvs_if_resolve_index:nvcTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_n_post:nncTF{/:2}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_if_resolve_n_post:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 222 } {2-A}
%   \__bnvs_if_resolve_n_index:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_n_post:nncTF{/:22'}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
            \prg_return_false:
          }
        } {
          \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_post:nncTF{/:3}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nncT { ?! } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
          \prg_return_false:
        }
      }
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_post:nncTF{/:4}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_n_post_nncTF:nn { ... } { ...FALSE/D }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_resolve_n_post:nncTF{/:5}, noigre}
% \reset:n{ YES }
% \__bnvs_if_resolve_n_post:nncT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/5-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append_n_post:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnnnc { if_append_n_post_nncTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_if_append_n_post_nncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append_n_post:nnc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_n_post:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:cv { #3 } { #3 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_post_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_n_post:nncTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_post:nncTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
%   \__bnvs_if_resolve_n_index:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_n_post:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {2-A}
%   \__bnvs_if_resolve_n_index:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_n_post_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_n_post:nncTF{/:2}, noigre}
% \reset:n{ YES }
% \__bnvs_if_append_n_post:nncT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \reset:n{ YES }
% \__bnvs_if_append_n_post:nncT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{BNVS/test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnc:cn { if_append_n_post } { T, F, TF }
\BNVS_new_conditional_vvc:cn { if_append_n_post } { T, F, TF }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:Nn=\__bnvs_if_append_v_post:nncTF{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_if_append_v_post:nncTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { A-1 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { A-2 }
%   } {
%     \test_fail:n { NO_WAY-A-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-A-4 }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_if_append_v_post:vncTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 2222 } { B-1 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { B-2 }
%   } {
%     \test_fail:n { NO_WAY-B-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-B-4 }
% }
% \Beanoves { X=FIRST}
% \__bnvs_tl_set:cn { ans } { 2 }
% \__bnvs_tl_set:cn { a } { ?!X }
% \__bnvs_tl_set:cn { b } { 2000 }
% \__bnvs_if_append_v_post:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C-1 }
%   \__bnvs_if_resolve_v:ncTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C-2 }
%   } {
%     \test_fail:n { NO_WAY-C-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-C-4 }
% }
% \end{BNVS/test}
%
% \subsubsection{Evaluation}
%
% \begin{function}{\__bnvs_round_ans:}
% \begin{syntax}
% \cs{__bnvs_rslv_round:}
% \end{syntax}
% Helper function to round the |\l__bnvs_ans_tl| variable.
% For ranges only, this will be set to |\prg_do_nothing|
% because we do not want to interpret the |-| sign as a minus operator.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { round_ans: } {
  \__bnvs_round:c { ans }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \subsubsection{ Functions for the resolution }
% They manily start with |\__bnvs_if_resolve_|
%
% \begin{function}{\__bnvs_if_resolve_end_return_false:n}
% \begin{syntax}
% \cs{__bnvs_if_resolve_end_return_false:n} \marg{message}
% \end{syntax}
% Close one \TeX\ group, display a message and return false.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}{
%   \__bnvs_if_resolve_path_n:TFF,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_path_n:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_path_n:TFF } #1 #2 {
  \__bnvs_if_resolve_kip_n_path:TF {
    \__bnvs_seq_if_empty:cTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function} {
%   \__bnvs_if_resolve_path_n:T
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_path_n:T} \marg{yes code}
% \end{syntax}
% Resolve the path and execute \meta{yes code} on success.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...#1 }
    \BNVS_DEBUG_end:n { if_resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_path_n:T } #1 {
  \__bnvs_if_resolve_path_n:TFF {
    #1
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Unknown~dotted~path
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { resolve_x:T } #1 {
  \__bnvs_if_resolve_kip_x_path:TFF {
    #1
  } {
    \__bnvs_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \__bnvs_if_resolve_end_return_false:n { Unknown~dotted~path }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_path_suffix:n,
% }
% \begin{syntax}
% \cs{__bnvs_if_path_suffix:nTF} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% If the last item of |\l__bnvs_path_seq| is \meta{suffix},
% then execute \meta{yes code} otherwise execute \meta{no code}.
% The suffix is |n| in the second case.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_path_pop_right_n:c } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:c=if_path_pop_right_n:cTF, noigre}
% \__bnvs_seq_clear:c { path }
% \__bnvs_if_path_pop_right_n:cTF { a } {
%   \test_fail:n { NO~WAY/1 }
% } {
% }
% \__bnvs_seq_set_split:cnn { path } { . } { 1.2.3 }
% \__bnvs_seq_set_split:cnn { path } { . } { n }
%   \__bnvs_if_path_pop_right_n:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/2 }
% }
% \__bnvs_seq_set_split:cnn { path } { . } { 1.2.3.n }
% \__bnvs_if_path_pop_right_n:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/3 }
% }
% \end{BNVS/test}
%    \begin{macrocode}
  \__bnvs_seq_pop_right:ccTF { path } { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}{
%   \__bnvs_if_resolve_pop_kip:TTF,
%   \__bnvs_if_resolve_return_or_pop_complete_white:T,
%   \__bnvs_if_resolve_pop_complete_black:T,
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_pop_kip:TTF} \marg{blank code} \marg{black code} \marg{end code}
% \cs{__bnvs_if_resolve_return_or_pop_complete_white:T} \marg{blank code}
% \cs{__bnvs_if_resolve_pop_complete_black:T} \marg{black code}
% \end{syntax}
% For |\__bnvs_if_resolve_pop_kip:TTF|.
% If the |split| sequence is empty, execute \meta{end code}.
% Otherwise pops the 3 heading items of the
% |split| sequence into the three |tl| variables |key|, |id|, |path|.
% If |key| is blank then execute \meta{blank code}, otherwise execute
% \meta{black code}.
%
% For |\__bnvs_if_resolve_return_or_pop_complete_white:T|: pops the three heading items of
% the |split| sequence into the three variables
% |n_incr|, |incr|, |post|.
% Then execute \meta{blank code}.
%
% For |\__bnvs_if_resolve_pop_complete_black:T|: pops the six heading items of
% the |split| sequence then execute \meta{blank code}.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_kip_complete: } {
  \__bnvs_tl_if_blank:vT { id } {
    \__bnvs_tl_put_left:cv { key } { id_last }
    \__bnvs_tl_set:cv { id } { id_last }
  }
  \__bnvs_tl_if_blank:vTF { path } {
    \__bnvs_seq_clear:c { path }
  } {
    \__bnvs_seq_set_split:cnv { path } { . } { path }
    \__bnvs_seq_remove_all:cn { path } { }
  }
  \__bnvs_tl_set_eq:cc { key_base } { key }
  \__bnvs_seq_set_eq:cc { path_base } { path }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...COMPLETE... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_kip:TTF } #1 #2 #3 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...POP... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_split_if_pop_left:cTF { key } {
    \__bnvs_split_if_pop_left:cTF { id } {
      \__bnvs_split_if_pop_left:cTF { path } {
        \__bnvs_tl_if_blank:vTF { key } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% The first 3 capture groups are empty,
% and the 3 next ones are expected to contain the expected information.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
          #1
        } {
          \__bnvs_if_resolve_pop_kip_complete:
          #2
        }
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/2 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/1 }
    }
  } { #3 }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}{
%   \__bnvs_if_resolve_pop_complete:nNT
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_pop_kip:FFTF} \marg{empty key code} \marg{no id code} \marg{yes code} \marg{no capture code}
% \cs{__bnvs_if_resolve_pop_complete:nNT} \marg{tl} \meta{tl var} \marg{yes code}
% \end{syntax}
% \meta{tl} and \meta{tl var} are the arguments of the \cs{__bnvs_if_resolve:nc} conditionals.
% conditional variants.
%
% \cs{__bnvs_if_resolve_pop_kip:FFTF} locally
% sets the |key|, |id| and |path| |tl| variables
% to the 3 heading items of the split sequence,
% which correspond to the 3 eponym capture groups.
% If no capture group is available, \meta{no capture code} is executed.
% If the capture group for the key is empty, then \meta{empty key code} is executed.
% If there is no capture group for the id, then \meta{no id code} is executed.
% Otherwise \meta{yes code} is executed.
%
% \cs{__bnvs_rslv_pop_end:T} locally
% sets the three |tl| variables |n_incr|, |incr| and |post|
% to the three heading items of the split sequence,
% which correspond to the last 3 eponym capture groups.
% \end{function}
% \begin{BNVS/test}{bnvs:c=if_resolve_pop_kip:TTF, noigre}
% \cs_set:Npn \BNVS_DEBUG_log_if_resolve_ncTF:nn #1 #2 {}
% \cs_set:Npn \__bnvs_end_unreachable_return_false:n #1 {
%   \__bnvs_tl_set:cn { ans } { #1 }
% }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 #4 #5 #6 {
%   \__bnvs_tl_clear:c { ans  }
%   \__bnvs_tl_clear:c { key  }
%   \__bnvs_tl_clear:c { id   }
%   \__bnvs_tl_clear:c { path }
%   \__bnvs_seq_set_split:cnn { split } { . } { #1 }
%   \__bnvs_seq_pop_left:cc { split } { a }
%   \__bnvs_if_resolve_pop_kip:TTF {
%     \__bnvs_tl_set:cn { ans } { FIRST  }
%   } {
%     \__bnvs_tl_set:cn { ans } { SECOND }
%   } {
%     \__bnvs_tl_set:cn { ans } { THIRD  }
%   }
%   \assert_equal_ans:nn { #2 } { #6/ans }
%   \assert_equal_tl:vnn { key  } { #3 } { #6/key  }
%   \assert_equal_tl:vnn { id   } { #4 } { #6/id   }
%   \assert_equal_tl:vnn { path } { #5 } { #6/path }
% }
% \BNVS_Test:nnn { .  .2.3 } { FIRST  } {   } { 2 } { 3 } { 1 }
% \BNVS_Test:nnn { . 1.2.3 } { SECOND } { 1 } { 2 } { 3 } { 2 }
% \BNVS_Test:nnn {         } { THIRD  } {   } {  } {  } { 3 }
% \BNVS_Test:nnn { . 1     } { if_resolve_pop_kip:TTF/1 } { 1 } { } { } { 4 }
% \BNVS_Test:nnn { . 1.2   } { if_resolve_pop_kip:TTF/2 } { 1 } { 2 } { } { 5 }
% \cs_undefine:N \BNVS_Test:nnn
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_return_or_pop_complete_white:T } #1 {
  \__bnvs_split_if_pop_left:cTF { n_incr } {
    \__bnvs_split_if_pop_left:cTF { incr } {
      \__bnvs_split_if_pop_left:cTF { post } {
        #1
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_return_or_pop_complete_white:T/3 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_return_or_pop_complete_white:T/2 }
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_return_or_pop_complete_white:T/1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_pop_complete_black:T } #1 {
  \__bnvs_split_if_pop_left:cTF { a } {
    \__bnvs_split_if_pop_left:cTF { a } {
      \__bnvs_split_if_pop_left:cTF { a } {
        \__bnvs_split_if_pop_left:cTF { a } {
          \__bnvs_split_if_pop_left:cTF { a } {
            \__bnvs_split_if_pop_left:cTF { a } {
              #1
            } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/6 }
            }
          } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/5 }
          }
        } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/4 }
        }
      } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/3 }
      }
    } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/2 }
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/1 }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve:nc,
%   \__bnvs_if_resolve:vc,
%   \__bnvs_if_append:nc,
%   \__bnvs_if_append:vc,
%   \__bnvs_if_append:xc
% }
% \begin{syntax}
% \cs{__bnvs_if_append:ncTF} \marg{expression} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluates the \meta{expression},
% replacing all the named overlay specifications by their static
% counterpart then put the rounded result in \meta{tl variable} when resolving or to
% the right of the \meta{tl variable} when appending.
% Executed within a group.
% Heavily used by \cs{__bnvs_if_resolve_query:nc}, where \meta{integer expression}
% was initially enclosed inside `|?(...)|'.
% Local variables: 
% \begin{variable}{\l__bnvs_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l__bnvs_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l__bnvs_split_int }
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_int_new:c { split }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{variable}{\l__bnvs_key_tl}
%    Storage for |split| sequence items that represent names.
% \end{variable}
% \begin{variable}{\l__bnvs_path_tl}
%    Storage for |split| sequence items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% Open a main \TeX\ group to define local functions and variables,
% sometimes another grouping level is used.
% The main \TeX\ group is closed in the various \cs{...end_return...} functions.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_kip_x_path_or_end_return_false:nT } #1 #2 {
  \__bnvs_if_resolve_kip_x_path:TFF {
    #2
  } {
    \BNVS_end_return_false:x { Too~many~dotted~components:~#1 }
  } {
    \BNVS_end_return_false:x { Unknown~dotted~path:~#1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_append:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_ncTF:nn { } { ... }
  \BNVS_DEBUG_begin:n { if_append:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve:ncTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:cv { #2 } { #2 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_unreachable_return_false:n } #1 {
  \BNVS_error:x { UNREACHABLE/#1 }
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_call:TF {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_begin:n { if_resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_set:cpn { if_resolve_warning:n } ##1 {
      \__bnvs_warning:n { #1:~##1 }
      \BNVS_set:cpn { if_resolve_warning:n } {
        \use_none:n
      }
    }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ... }
%</!final>
% \end{BNVS/gobble}
% \end{BNVS/macrocode}
% This \TeX\ group will be closed just before returning.
% Implementation:
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_regex_split:cnTF { split } { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...SPLIT... }
\BNVS_DEBUG_log_seq:c { split }
%</!final>
% \end{BNVS/gobble}
% \end{BNVS/macrocode}
% The leftmost item is not a special item: we start feeding |\l__bnvs_ans_tl| with it.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
      \BNVS_set:cpn { if_resolve_end_return_true: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Normal and unique end of the loop.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
        \__bnvs_if_resolve_round_ans:
        \BNVS_tl_set_after:ncv {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
          \BNVS_DEBUG_end:n { if_resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        } { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
      \BNVS_set:cpn { if_resolve_round_ans: } { \__bnvs_round_ans: }
      \__bnvs_tl_clear:c { ans }
      \__bnvs_if_resolve_loop_or_end_return:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { } { ...TRUE/DIRECT }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_tl_clear:c { ans }
      \__bnvs_round_ans:n { #1 }
      \BNVS_tl_set_after:ncv {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
          \BNVS_DEBUG_end:n { if_resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
      } { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:     
    }
  } {
    \BNVS_error:n { TOO_MANY_NESTED_CALLS/Resolution }
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_append:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_append:ncTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:cpnn { if_resolve:vc } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Nv \__bnvs_if_resolve:ncTF { #1 } { #2 } {
    \prg_return_true:     
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% Next functions are helpers for the \cs{__bnvs_if_resolve:nc} conditional variants.
% When present, their two first arguments \meta{tl} and \meta{tl var}
% are exactly the ones given to the variants.
%
% \begin{function}{
%   \__bnvs_if_resolve_loop_or_end_return:
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_loop_or_end_return:}
% \end{syntax}
% May call itself at the end.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...LOOP... }
\BNVS_DEBUG_log_seq:c { split }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_split_if_pop_left:cTF { a } {
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_if_resolve_pop_kip:TTF {
      \__bnvs_if_resolve_pop_kip:TTF {
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/3 }
      } {
        \__bnvs_if_resolve_return_or_pop_complete_white:T {
          \__bnvs_tl_if_blank:vTF { n_incr } {
            \__bnvs_tl_if_blank:vTF { incr } {
              \__bnvs_tl_if_blank:vTF { post } {
                \__bnvs_if_resolve_value_loop_or_end_return_true:F {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Only the dotted path, branch according to the last component.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
                  \__bnvs_seq_pop_right:ccTF { path } { a } {
                    \BNVS_tl_use:Nv \str_case:nnF { a } {
{ n         } { \BNVS_use:c { if_resolve_loop_or_end_return[.n]: } }
{ length    } { \BNVS_use:c { if_resolve_loop_or_end_return[.length]: } }
{ last      } { \BNVS_use:c { if_resolve_loop_or_end_return[.last]:  } }
{ range     } { \BNVS_use:c { if_resolve_loop_or_end_return[.range]: } }
{ previous  } { \BNVS_use:c { if_resolve_loop_or_end_return[.previous]: } }
{ next      } { \BNVS_use:c { if_resolve_loop_or_end_return[.next]:  } }
{ reset     } { \BNVS_use:c { if_resolve_loop_or_end_return[.reset]: } }
{ reset_all } { \BNVS_use:c { if_resolve_loop_or_end_return[.reset_all]: } }
                    } {
\BNVS_use:c { if_resolve_loop_or_end_return[...<integer>]: }
                    }
                  } {
\BNVS_use:c { if_resolve_loop_or_end_return[...]: }
                  }
                }
              } {
\BNVS_use:c { if_resolve_loop_or_end_return[...++]: }
              }
            } {
              \__bnvs_if_path_suffix:nTF { n } {
\BNVS_use:c { if_resolve_loop_or_end_return[...n+=...]: }
              } {
\BNVS_use:c { if_resolve_loop_or_end_return[...+=...]: }
              }
            }
          } {
\BNVS_use:c { if_resolve_loop_or_end_return[...++n]: }
          }
        }
      } {
% split sequence empty
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/2 }
      }
    } {
      \__bnvs_if_resolve_pop_complete_black:T {
        \__bnvs_if_path_suffix:nTF { n } {
\BNVS_use:c { if_resolve_loop_or_end_return[++...n]: }
        } {
\BNVS_use:c { if_resolve_loop_or_end_return[++...]: }
        }
      }
    } {
      \__bnvs_if_resolve_end_return_true:
    }
  } {
\__bnvs_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { if_resolve_value_loop_or_end_return_true:F } #1 {
  \__bnvs_tl_set:cx { a } {
    \BNVS_tl_use:c { key } \BNVS_tl_use:c { path }
  }
  \__bnvs_if_resolve_v:vcTF { a } { a } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(v) }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_tl_put_right:cv { ans } { a }
    \__bnvs_if_resolve_loop_or_end_return:
  } {
    \__bnvs_if_resolve_value:vcTF { a } { a } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...TRUE/DIRECT(V) }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_tl_put_right:cv { ans } { a }
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      #1
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { end_return_error:n } #1 {
      \BNVS_error:n { #1 }
      \BNVS_end:
      \prg_return_false:
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.n]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{myList}
% \item Case \texttt{...n}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...n }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_if_resolve:nnnn { FIRST+1 } { X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { LENGTH-1 } { X.n } { 444 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.n } { 666 } { 1-d }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_tl:c { path }
\BNVS_DEBUG_log_seq:c { path }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_resolve_base_n:
    \__bnvs_if_append_n_index:vvcTF { key } { key_base } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...n }
\BNVS_DEBUG_log_tl:c { b }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_end_return_error:n {
        Undefined~dotted~path
      }
    }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
%
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_path_suffix:n } #1 { T, F, TF } {
  \__bnvs_seq_get_right:ccTF { path } { a } {
    \__bnvs_tl_if_eq:cnTF { a } { #1 } {
      \__bnvs_seq_pop_right:ccT { path } { a } { }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.length]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...length}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...length }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/length}, noigre}
% \Test_if_resolve:nnnn { 222::445 } { X.length } { 445 } { 1 }
% \Test_if_resolve:nnnn { 222:666 } { X.length } { 445 } { 2 }
% \Test_if_resolve:nnnn { ::445:666 } { X.length } { 445 } { 3 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length } { 445 } { 4 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length } { 445 } { 5 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length } { 445 } { 6 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222::445 } { X.length+X.length } { 890 } { 1' }
% \Test_if_resolve:nnnn { 222:666 } { X.length+X.length } { 890 } { 2' }
% \Test_if_resolve:nnnn { ::445:666 } { X.length+X.length } { 890 } { 3' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length+X.length } { 890 } { 4' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length+X.length } { 890 } { 5' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length+X.length } { 890 } { 6' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_length:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../length }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~length }
    } 
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.last]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...last}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...last }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.last}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.last } { 666 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.last } { 666 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last } { 666 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last } { 666 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last } { 666 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last } { 666 } { 8 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :666 } { X.last / 2 } { 333 } { 1' }
% \Test_if_resolve:nnnn { 222::445 } { X.last / 2 } { 333 } { 2' }
% \Test_if_resolve:nnnn { 222:666 } { X.last / 2 } { 333 } { 3' }
% \Test_if_resolve:nnnn { ::445:666 } { X.last / 2 } { 333 } { 4' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last / 2 } { 333 } { 5' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last / 2 } { 333 } { 6' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last / 2 } { 333 } { 7' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last / 2 } { 333 } { 8' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_last:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../last }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \BNVS_end_return_false:x { NO~last }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.range]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...range}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...range }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.range}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_if_resolve:nnnn { 222: } { X.range } { 222- } { 1' }
% \Test_if_resolve:nnnn { 222:: } { X.range } { 222- } { 1'' }
% \Test_if_resolve:nnnn { :666 } { X.range } { -666 } { 2 }
% \Test_if_resolve:nnnn { 222::445 } { X.range } { 222-666 } { 3 }
% \Test_if_resolve:nnnn { 222:666 } { X.range } { 222-666 } { 4 }
% \Test_if_resolve:nnnn { ::445:666 } { X.range } { 222-666 } { 5 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_if_resolve:nnnn { FIRST: } { X.range } { 222- } { 6' }
% \Test_if_resolve:nnnn { FIRST:: } { X.range } { 222- } { 6'' }
% \Test_if_resolve:nnnn { :LAST } { X.range } { -666 } { 7 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.range } { 222-666 } { 8 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.range } { 222-666 } { 9 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.range } { 222-666 } { 10 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_range:vcTF { key } { ans } {
      \BNVS_set:cpn { if_resolve_round_ans: } { \prg_do_nothing: }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../range }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~range }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.previous]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...previous}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...previous }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.previous}, noigre}
% \Test_if_resolve:nnnn { 222: } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::' } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.previous } { 221 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.previous } { 221 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5 }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5' }
% \Test_if_resolve:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.previous } { 221 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.previous } { 221 } { 8 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_previous::vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../previous }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~previous }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.next]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...next}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...next }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.next}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.next } { 667 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.next } { 667 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.next } { 667 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { X.next } { 667 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.next } { 667 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.next } { 667 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.next } { 667 } { 8 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_next:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../next }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~next }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.reset]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...reset}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...reset }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.reset}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-3 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_v_if_greset:vnT { key } { } { }
    \__bnvs_if_append_value:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../reset }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[.reset_all]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...reset\_all}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...reset_all }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/.reset_all}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-3 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { c-1 }
% \Test_if_resolve:nnnn { } { LAST+=333 } { 999 } { c-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { c-3 }
% \Test_if_resolve:nnnn { } { X } { 666 } { c-4 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_greset_all:vnT { key } { } { }
    \__bnvs_if_append_value:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../reset }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...<integer>]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...\meta{integer}}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...<integer> }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/Counter/.<integer>}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.1 } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X.1 } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X.1 } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X.1 } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X.1 } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X.1 } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.1 } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X.1 } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X.1 } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.1 } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.1 } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X.1 } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.1 } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X.1 } { 666 } { 1-d' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_index_append:vvcTF { key } { a } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../<integer> }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~integer }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/Counter/...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X } { 666 } { 1-d' }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_value:vcTF { key } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~value }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...++]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...++}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...++ }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_path_suffix:nTF { reset } {
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...reset++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...reset++ }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve_path_n:T {
      \__bnvs_v_if_greset:vnT { key } { } { }
      \__bnvs_if_append_v_post:vncTF { key } { 1 }  { ans } {
        \__bnvs_if_resolve_loop_or_end_return:
      } {
        \__bnvs_if_resolve_end_return_false:n { NO~post }
      }
    }
  } {
    \__bnvs_if_path_suffix:nTF { reset_all } {
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...reset_all++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{BNVS/test}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...reset_all++ }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_path_n:T {
        \__bnvs_if_greset_all:vnT { key } { } { }
        \__bnvs_if_append_v_post:vncTF { key } { 1 }  { ans } {
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { NO~post }
        }
      }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...++ }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_path_n:T {
        \__bnvs_if_append_v_post:vncTF { key } { 1 }  { ans } {
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { NO~post }
        }
      }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...n+=...]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{....n+=\meta{integer}}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...n+=... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...n+=...}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.n += 444 } { 666 } { B }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { C }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { D }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { E }
% \Test_if_resolve:nnnn { } { X.n += (LENGTH - 1) } { 666 } { F }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { G }
% \Test_if_resolve:nnnn { } { X.n += (-(LENGTH-1)) } { 222 } { H }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { I }
% \Test_if_resolve:nnnn { } { X.n += LENGTH - 1 } { 666 } { J }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { K }
% \Test_if_resolve:nnnn { } { X.n += -444~4 } { 2224 } { L }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_resolve_base_n:
    \__bnvs_if_append_n_incr:vvvcTF { key } { key_base }  { incr }  { ans } {
%    \begin{macrocode}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...n+=... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n {
        NO~n~incrementation
      }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[...+=...]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{A+=\meta{integer}}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...+=... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...+=...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_if_resolve:nnnn { } { FIRST } { 222 } { B }
% \Test_if_resolve:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 8 }
% \Test_if_resolve:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 10 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 12 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 16 }
% \Test_if_resolve:nnnn { } { X } { 667 } { 13 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_if_append_v_incr:vvcTF { key }  { incr }  { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...+=... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n {
        NO~incremented~value
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_base_n: } {
  \__bnvs_seq_if_empty:cF { path_base } {
    \__bnvs_seq_pop_right:cc { path_base } { a }
    \__bnvs_seq_if_empty:cF { path_base } {
      \__bnvs_tl_put_right:cx { key_base } {
        . \__bnvs_seq_use:cn { path_base } { . }
      }
    }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...BASE~n... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_base: } {
  \__bnvs_seq_if_empty:cF { path_base } {
    \__bnvs_tl_put_right:cx { key_base } {
      . \__bnvs_seq_use:cn { path_base } { . }
    }
  }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { ...BASE... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
\BNVS_DEBUG_log_seq:xc { \BNVS_tl_use:c { path } } { path }
\BNVS_DEBUG_log_tl:c { key_base }
\BNVS_DEBUG_log_seq:c { path_base }
\BNVS_DEBUG_log_tl:c { ans }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_loop_or_end_return[...++n]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{...++n}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~...++n }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/...++n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.++n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.++n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { X.3.N.++n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_resolve_base:
    \__bnvs_if_append_n_incr:vvncTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../...++n }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~...++n }
    }
  }
}
\BNVS_set:cpn { if_resolve_loop_or_end_return[++...n]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{++...n}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:x { ▃▃▃▃▃~CASE~++...n }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:cn={if_resolve:ncTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{BNVS/test}
% \begin{BNVS/test}{bnvs:cn={if_append:ncTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_append:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_append:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_append:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_append:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve_path_n:T {
    \__bnvs_resolve_base_n:
    \__bnvs_if_append_n_incr:vvncTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...n }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \__bnvs_if_resolve_loop_or_end_return:
    } {
      \__bnvs_if_resolve_end_return_false:n { NO~++...n }
    }
  }
}
\BNVS_new:cpn { if_resolve_loop_or_end_return[++...]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item Case \texttt{++...}.
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log:n { ▃▃▃▃▃~CASE~++... }
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_path_suffix:nTF { reset } {
    \__bnvs_if_resolve_path_n:T {
      \__bnvs_if_append_v_incr:vncTF { key } { 1 } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...reset }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \__bnvs_v_if_greset:vnT { key } { } { }
        \__bnvs_if_resolve_loop_or_end_return:
      } {
        \__bnvs_v_if_greset:vnT { key } { } { }
        \__bnvs_if_resolve_end_return_false:n { No~increment }
      }
    }
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{BNVS/test}
%    \begin{macrocode}
  } {
    \__bnvs_if_path_suffix:nTF { reset_all } {
      \__bnvs_if_resolve_path_n:T {
        \__bnvs_if_append_v_incr:vncTF { key } { 1 } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++...reset_all }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_if_greset_all:vnT { key } { } { }
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_greset_all:vnT { key } { } { }
          \__bnvs_if_resolve_end_return_false:n { No~increment }
        }
      }
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset_all}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{BNVS/test}
%    \begin{macrocode}
    } {
      \__bnvs_if_resolve_path_n:T {
        \__bnvs_if_append_v_incr:vncTF { key } { 1 } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_ncTF:nn { ... } { .../++... }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
          \__bnvs_if_resolve_loop_or_end_return:
        } {
          \__bnvs_if_resolve_end_return_false:n { No~increment }
        }
      }
    }
%    \end{macrocode}
% \begin{BNVS/test}{bnvs:c={if_resolve_loop_or_end_return[++...]:}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N } { 112 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N } { 112 } { 4-b }
% \Test_if_resolve:nnnn { } { B } { 112 } { 5-b }
% \end{BNVS/test}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{myList}
%
% \begin{function}[TF]{
%   \__bnvs_if_resolve_query:nc
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_query:ncTF} \marg{overlay query} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of |\l__bnvs_ans_tl|.
% Ranges are supported with the colon syntax.
% This is executed within a local \TeX\ group managed by the caller.
% Below are local variables and constants.
% \begin{variable}{\l__bnvs_V_tl}
% Storage for a single value out of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_A_tl}
% Storage for the first component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_Z_tl}
% Storage for the last component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_L_tl}
% Storage for the length component of a range.
% \end{variable}
% \begin{variable}{\c__bnvs_A_cln_Z_regex}
% Used to parse named overlay specifications.
% V, A:Z, A::L on one side, :Z, :Z::L and ::L:Z on the other sides.
% Next are the capture groups. The first one is for the whole match.
% \end{variable}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{myList}
% \item 2 $\to$ V
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    ( [^:]+? )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item 3, 4, 5 $\to$ A : Z? or A :: L?
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    | (?: ( [^:]+? ) \s* : (?: \s* ( [^:]*? ) | : \s* ( [^:]*? ) ) )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item 6, 7 $\to$ ::(L:Z)?
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    | (?: :: \s* (?: ( [^:]+? ) \s* : \s* ( [^:]+? ) )? )
%    \end{macrocode}
% \end{BNVS/macrocode}
% \item 8, 9 $\to$ :(Z::L)?
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    | (?: : \s* (?: ( [^:]+? ) \s* :: \s* ( [^:]*? ) )? )
  )
  \s* \Z
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{myList}
% \begin{BNVS/test}{:N=\c__bnvs_A_cln_Z_regex, noigre}
% \Test_regex:nnnn { A_cln_Z } {V           } {{},{V},{ },{ },{ },{ },{ },{ },{ }} {1}
% \Test_regex:nnnn { A_cln_Z } {VV          } {{},{VV},{ },{ },{ },{ },{ },{ },{ }} {1a}
% \Test_regex:nnnn { A_cln_Z } {A:Z         } {{},{ },{A},{Z},{ },{ },{ },{ },{ }} {2}
% \Test_regex:nnnn { A_cln_Z } {AA:ZZ       } {{},{ },{AA},{ZZ},{ },{ },{ },{ },{ }} {2a}
% \Test_regex:nnnn { A_cln_Z } {~AA:ZZ      } {{},{ },{AA},{ZZ},{ },{ },{ },{ },{ }} {2b}
% \Test_regex:nnnn { A_cln_Z } {A:          } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3}
% \Test_regex:nnnn { A_cln_Z } {~A:         } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3a}
% \Test_regex:nnnn { A_cln_Z } {~AA:        } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {3b}
% \Test_regex:nnnn { A_cln_Z } {A::L        } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4}
% \Test_regex:nnnn { A_cln_Z } {~A::L       } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4a}
% \Test_regex:nnnn { A_cln_Z } {~AA::L      } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4b}
% \Test_regex:nnnn { A_cln_Z } {~AA~::L     } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4d}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~L    } {{},{ },{AA},{ },{L},{ },{ },{ },{ }} {4e}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~LL   } {{},{ },{AA},{ },{LL},{ },{ },{ },{ }} {4f}
% \Test_regex:nnnn { A_cln_Z } {A::         } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5}
% \Test_regex:nnnn { A_cln_Z } {~A::        } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5a}
% \Test_regex:nnnn { A_cln_Z } {~AA::       } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5b}
% \Test_regex:nnnn { A_cln_Z } {~AA~::      } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5d}
% \Test_regex:nnnn { A_cln_Z } {~AA~::~     } {{},{ },{AA},{ },{ },{ },{ },{ },{ }} {5e}
% \Test_regex:nnnn { A_cln_Z } {::L:Z       } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6}
% \Test_regex:nnnn { A_cln_Z } {~::L:Z      } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6a}
% \Test_regex:nnnn { A_cln_Z } {~::~L:Z     } {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6b}
% \Test_regex:nnnn { A_cln_Z } {~::~LL:Z    } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6c}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:Z   } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6e}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:~Z  } {{},{ },{ },{ },{ },{LL},{Z},{ },{ }} {6f}
% \Test_regex:nnnn { A_cln_Z } {~::~LL~:~ZZ} {{},{ },{ },{ },{ },{LL},{ZZ},{ },{ }} {6g}
% \Test_regex:nnnn { A_cln_Z } {::          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7}
% \Test_regex:nnnn { A_cln_Z } {~::         } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7a}
% \Test_regex:nnnn { A_cln_Z } {~::~        } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7b}
% \Test_regex:nnnn { A_cln_Z } {:Z::L       } {{},{ },{ },{ },{ },{ },{ },{Z},{L}} {8}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::L      } {{},{ },{ },{ },{ },{ },{ },{ZZ},{L}} {8a}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::LL     } {{},{ },{ },{ },{ },{ },{ },{ZZ},{LL}} {8b}
%\Test_regex:nnnn { A_cln_Z } {:Z::         } {{},{ },{ },{ },{ },{ },{ },{Z},{ }} {9}
% \Test_regex:nnnn { A_cln_Z } {:ZZ::       } {{},{ },{ },{ },{ },{ },{ },{ZZ},{ }} {9a}
% \Test_regex:nnnn { A_cln_Z } {:           } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10}
% \Test_regex:nnnn { A_cln_Z } {~:          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10a}
% \Test_regex:nnnn { A_cln_Z } {:~          } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10b}
% \Test_regex:nnnn { A_cln_Z } {~:~         } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10c}
% \end{BNVS/test}
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_set:cpn { resolve_query_end_return_true: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_end_return_false: } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
\BNVS_new:cpn { if_resolve_query_return_false:n } #1 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve_query_error_return_false:n } #1 {
  \BNVS_error:x { #1 }
  \__bnvs_if_resolve_query_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_resolve_query_return_unreachable: } {
  \__bnvs_resolve_query_error_return_false:n { UNREACHABLE }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { if_blank:cTF } #1 {
  \BNVS_tl_use:Nc \tl_if_blank:VTF { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_match_pop_left:c } #1 { T, F, TF } {
  \BNVS_tl_use:nc {
    \BNVS_seq_use:Nc \seq_pop_left:NNTF { match }
  } { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { if_match_pop_left:cTF } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #1 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_f:ncn { } { if_match_pop_left:cTF } { ...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_set:cpn { if_match_pop_left:cT } #1 #2 {
  \BNVS_use:c { if_match_pop_left:cTF }
    { #1 } { #2 } { \__bnvs_if_resolve_query_return_unreachable: }
}
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/test}{bnvs:c={if_match_pop_left:cTF}, noigre}
% \__bnvs_seq_clear:c { match }
% \__bnvs_seq_put_right:cn { match } { SUCCESS }
% \__bnvs_if_match_pop_left:cTF { A } {
%   \__bnvs_tl_if_eq:cnF { A } { SUCCESS } {
%     \test_fail:n { A/1 }
%   }
% } {
%   \test_fail:n { A/2 }
% }
% \end{BNVS/test}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
%   \__bnvs_if_resolve_query_branch:
% }
% \begin{syntax}
% \cs{__bnvs_if_resolve_query_branch:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% Called by |\__bnvs_if_resolve_query:ncTF| that just filled |\l__bnvs_match_seq| after the |c__bnvs_A_cln_Z_regex|.
% Puts the proper items of |\l__bnvs_match_seq| into the variables
% |\l__bnvs_V_tl|, |\l__bnvs_A_tl|, |\l__bnvs_Z_tl|, |\l__bnvs_L_tl|
% then branches accordingly on one of the returning 
% |\__bnvs_if_resolve_query_return[|\meta{description}|]:| functions.
% All these functions properly set the |\l__bnvs_ans_tl| variable and they end with either
% |\prg_return_true:| or |\prg_return_false:|.
% This is used only once but is not inlined for readability.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_query_branch: } { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...MATCH~BRANCH... }
%</!final>
% \end{BNVS/gobble}
% At start, we ignore the whole match.
%    \begin{macrocode}
  \__bnvs_if_match_pop_left:cT V {
    \__bnvs_if_match_pop_left:cT V {
      \__bnvs_if_blank:cTF V {
        \__bnvs_if_match_pop_left:cT A {
          \__bnvs_if_match_pop_left:cT Z {
            \__bnvs_if_match_pop_left:cT L {
              \__bnvs_if_blank:cTF A {
                \__bnvs_if_match_pop_left:cT L {
                  \__bnvs_if_match_pop_left:cT Z {
                    \__bnvs_if_blank:cTF L {
                      \__bnvs_if_match_pop_left:cT Z {
                        \__bnvs_if_match_pop_left:cT L {
                          \__bnvs_if_blank:cTF L {
                            \BNVS_use:c { if_resolve_query_return[:Z]: }
                          } {
                            \BNVS_use:c { if_resolve_query_return[:Z::L]: }
                          }
                        }
                      }
                    } {
                      \__bnvs_if_blank:cTF Z {
\__bnvs_resolve_query_error_return_false:n { Missing~first~or~last }
                      } {
                        \BNVS_use:c { if_resolve_query_return[:Z::L]: }
                      }
                    }
                  }
                }
              } {
                \__bnvs_if_blank:cTF Z {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { if_resolve_query_return[A:]: }
                  } {
                    \BNVS_use:c { if_resolve_query_return[A::L]: }
                  }
                } {
                  \__bnvs_if_blank:cTF L {
                    \BNVS_use:c { if_resolve_query_return[A:Z]: }
                  } {
%    \end{macrocode}
% Logically unreachable code, the regular expression does not match this.
%    \begin{macrocode}
                    \__bnvs_if_resolve_query_return_unreachable:
                  }
                }
              }
            }
          }
        }
      } {
        \BNVS_use:c { if_resolve_query_return[V]: }
      }
    }
  }
}
\BNVS_new:cpn { if_resolve_query_return[V]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} Single value
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[V]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { V } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[V]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { V } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[V]...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[V]...FALSE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new:cpn { if_resolve_query_return[A:Z]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:\meta{last}} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[A:Z]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \__bnvs_if_append:vcTF { Z } { ans } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...TRUE }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new:cpn { if_resolve_query_return[A::L]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}::\meta{length}} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[A::L]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { A } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { A }
      \__bnvs_tl_put_right:cn { ans } { -1 }
      \__bnvs_round_ans:
      \__bnvs_tl_put_left:cn { ans } { - }
      \__bnvs_tl_put_left:cv { ans } { A }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { if_resolve_query_return[A:]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:} and \texttt{\meta{first}::} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[A:]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { A } { LAST - LENGTH + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[A:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222- } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { A } { ans } {
    \__bnvs_tl_put_right:cn { ans } { - }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { if_resolve_query_return[:Z::L]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{:\meta{last}::\meta{length}} or \texttt{::\meta{length}:\meta{last}} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[:Z::L]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \__bnvs_tl_set:cn { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:Z::L]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_if_resolve:vcTF { Z } { Z } {
    \__bnvs_if_resolve:vcTF { L } { ans } {
      \__bnvs_tl_put_left:cn  { ans } { 1-}
      \__bnvs_tl_put_right:cn { ans } { + }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \__bnvs_round_ans:
      \__bnvs_tl_put_right:cn { ans } { - }
      \__bnvs_tl_put_right:cv { ans } { Z }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
\BNVS_new:cpn { if_resolve_query_return[:]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[:]:}, noigre}
% \reset:n { Y }
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { - } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \prg_return_true:
}
\BNVS_new:cpn { if_resolve_query_return[:Z]: } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% \emoji{left-speech-bubble} \texttt{:\meta{last}} range
% \begin{BNVS/test}{bnvs:c={if_resolve_query_return[:Z]:}, noigre}
% \reset:n { Y }
% \__bnvs_tl_set:cn { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:cpnn { TEST: } { TF } {
%   \BNVS_use:c { if_resolve_query_return[:Z]: }
% }
% \__bnvs_TEST:TF {
%   \assert_equal_ans:nn { -666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \__bnvs_TEST:TF
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_tl_set:cn { ans } { - }
  \__bnvs_if_append:vcTF { Z } { ans } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{function}[TF]{
% \__bnvs_if_resolve_query:nc
%}
% \begin{syntax}
% \cs{__bnvs_if_resolve_query:ncTF} \marg{query} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Evaluate only one query.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:cpnn { if_resolve_query:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { if_resolve_query:ncTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { } { ... }
\BNVS_set:cpn { error:n } ##1 {
  \BNVS_error:n { #1 / ##1 }
}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \__bnvs_call_greset:
  \__bnvs_match_if_once:NnTF \c__bnvs_A_cln_Z_regex { #1 } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...MATCH... }
\BNVS_DEBUG_log_seq:c { match }
    \BNVS_DEBUG_begin:n { if_resolve_query:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_if_resolve_query_branch:TF {
      \BNVS_tl_set_after:ncv {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
        \BNVS_DEBUG_end:n { if_resolve_query:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
      } { #2 } { ans }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #2 }
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_query_ncTF:nn { ... } { ...FALSE }
    \BNVS_DEBUG_end:n { if_resolve_query:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \end{BNVS/macrocode}
% Error
% \begin{BNVS/macrocode}
%    \begin{macrocode}
    \BNVS_error:n { Syntax~error:~#1 }
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_end:n { if_resolve_query:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{bnvs:c={if_resolve_query:ncTF}, noigre}
% \Test_query:nnnn { 100 } { 1 } { 1 } { 1 }
% \Test_query:nnnn { } { 1+1 } { 2 } { 2 }
% \Test_query:nnnn { } { X.1 } { 100 } { 3a }
% \Test_query:nnnn { } { X.11 } { 110 } { 3b }
% \Test_query:nnnn { } { X.1+X.11 } { 210 } { 3c }
% \Test_query:nnnn { } { X.111 } { 210 } { 4a }
% \Test_query:nnnn { } { X.1:X.111 } { 100-210 } { 4b }
% \Test_query:nnnn { } { X.1::111 } { 100-210 } { 5 }
% \Test_query:nnnn { 4 } { X.1 } { 4 } { 6 }
% \Test_query:nnnn { } { X.0 } { 3 } { 7 }
% \Test_query:nnnn { } { X.-1 } { 2 } { 8 }
% \Test_query:nnnn { } { X.-2 } { 1 } { 9 }
% \Test_query:nnnn { } { X.-3 } { 0 } { 10 }
% \end{BNVS/test}
%
% \begin{function}{
%   \__bnvs_resolve:nc
% }
% \begin{syntax}
% \cs{__bnvs_resolve:nc} \marg{overlay query list} \marg{core tl name}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated \meta{overlay query list},
% replacing all the individual named overlay specifications and integer expressions
% by their static counterparts by calling \cs{__bnvs_if_resolve_query:nc},
% then append the result to the right of the \meta{core tl name} variable .
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l__bnvs_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l__bnvs_ans_seq}
% Storage for the evaluated result.
% \end{variable}
% \begin{variable}{\c__bnvs_comma_regex}
% Used to parse slide range overlay specifications.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{BNVS/macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\BNVS_new:cpn { resolve:nc } #1 #2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_log_set:cnnc { resolve:nc } { IN } { #1 } { #2 }
\BNVS_DEBUG_log_resolve_nc:nn { } { ... }
  \BNVS_DEBUG_begin:n { resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
% \end{BNVS/macrocode}
% Local variables cleared
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_seq_clear:c { ans }
%    \end{macrocode}
% \end{BNVS/macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{first}::\meta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \regex_split:NnN \c__bnvs_comma_regex { #1 } \l__bnvs_query_seq
%    \end{macrocode}
% \end{BNVS/macrocode}
% Then each component is evaluated and the result is stored in \cs{l__bnvs_ans_seq}
% that we justed cleared above.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \__bnvs_seq_map_inline:cn { query } {
    \__bnvs_tl_clear:c { ans }
    \__bnvs_if_resolve_query:ncTF { ##1 } { ans } {
      \__bnvs_seq_put_right:cv { ans } { ans }
    } {
      \seq_map_break:n {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_on:
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_error:n { Circular/Undefined~dependency~in~#1}
      }
    }
  }
%    \end{macrocode}
% \end{BNVS/macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to the tl variable.
% \begin{BNVS/macrocode}
%    \begin{macrocode}
  \typeout{*****~AFTER~Circular/Undefined}
  \exp_args:Nnx
  \use:n {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
    \BNVS_DEBUG_end:n { resolve:nc }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    \__bnvs_tl_put_right:cn { #2 }
  } { \__bnvs_seq_use:cn { ans } , }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{bnvs:c={resolve:nc}, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BNVS_DEBUG_log_tl:c { ans }
% \__bnvs_tl_clear:c { ans }
% \__bnvs_resolve:nc {X.1} { ans }
% \assert_equal_ans:nn { 222 } { 1 }
% \end{BNVS/test}
%
% \begin{function}{\BeanovesResolve}
%   \begin{syntax}
%     \cs{BeanovesResolve} \oarg{setup} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{__bnvs_resolve:nc}
% within a group. \cs{...ans_tl} is used locally to store the result.
%
% The optional \meta{setup} is a key--value list. The value for \texttt{in:N} key is the |tl| variable where the evaluation is stored.
% If the |see| key is provided, the result is typeset.
% \end{function}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesResolve { O{} m } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \BNVS_DEBUG_begin:n { BeanovesResolve }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \keys_define:nn { BeanovesResolve } {
    in:N .tl_set:N = \l__bnvs_resolve_in_tl,
    in:N .initial:n = { },
    see .bool_set:N = \l__bnvs_resolve_see_bool,
    see .default:n = true,
    see .initial:n = false,
  }
  \keys_set:nn { BeanovesResolve } { #1 }
  \__bnvs_tl_clear:c { ans }
  \__bnvs_resolve:nc { #2 } { ans }
  \typein{Press<enter>~to~continue}
  \__bnvs_tl_if_empty:cTF { resolve_in } {
    \bool_if:nTF { \l__bnvs_resolve_see_bool } {
      \BNVS_tl_use:Nv \BNVS_end: { ans }
    } {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
  \BNVS_DEBUG_end:n { BeanovesResolve }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
  \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
    }
  } {
    \bool_if:nTF { \l__bnvs_resolve_see_bool } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
        \BNVS_DEBUG_end:n { BeanovesResolve }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \tl_set:Nn ##1 { ##2 }
        ##2
      }
      \BNVS_tl_use:nv {
        \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_resolve_in_tl
      } { ans }
    } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
%    \end{macrocode}
% \begin{BNVS/gobble}
%<*!final>
        \BNVS_DEBUG_end:n { BeanovesResolve }
%</!final>
%<*!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \BNVS_end:
%    \end{macrocode}
% \begin{BNVS/gobble}
%</!debug>
% \end{BNVS/gobble}
%    \begin{macrocode}
        \tl_set:Nn ##1 { ##2 }
      }
      \BNVS_tl_use:nv {
        \exp_last_unbraced:NV \BNVS_end:Nn \l__bnvs_resolve_in_tl
      } { ans }
    }
  }
}
%    \end{macrocode}
% \end{BNVS/macrocode}
% \begin{BNVS/test}{:N=\BeanovesResolve, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BeanovesResolve[in:N=\l__bnvs_TEST_A_tl]{X.2}
% \assert_equal_tl:vnn { TEST_A } { 223 } { 1 }
% \end{BNVS/test}
%
% \subsubsection{Reseting counters}
% \begin{function}{\BeanovesReset, \BeanovesReset*}
%   \begin{syntax}
%     \cs{BeanovesReset} \oarg{first value} \marg{ref}
%     \cs{BeanovesReset}* \oarg{first value} \marg{ref}
%   \end{syntax}
% Forwards to \cs{__bnvs_v_if_greset:nnF} or \cs{__bnvs_if_greset_all:nnF} when starred.
% \end{function}
% \begin{BNVS/test}{:N=\BeanovesReset, noigre}
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { value }{ FIRST } { 222 } { 1 }
% \Test_if_append_v_incr:nnnnn { } { ?!X } { 123 } { 345 } { 1 }
% \BeanovesReset{X}
% \Test_what_append_X_ncTF:nnnn { value }{ } { 222 } { 1 }
% \end{BNVS/test}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesReset { s O{} m } {
  \__bnvs_if_id_name_n_get:nTF { #3 } {
    \BNVS_tl_use:nv {
      \IfBooleanTF { #1 } {
        \__bnvs_if_greset_all:nnF
      } {
        \__bnvs_v_if_greset:nnF
      }
    } { key } { #2 } {
%      \__bnvs_warning:n { Unknown~name:~#3 }
    }
  } {
    \__bnvs_warning:n { Bad~name:~#3 }
  }
  \ignorespaces
}
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{BNVS/gobble}
%<*!final>
\BNVS_DEBUG_off:
%</!final>
% \end{BNVS/gobble}
% \begin{BNVS/macrocode}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \end{BNVS/macrocode}
%
% \begin{BNVS/gobble}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{BNVS/gobble}
%
% \begin{BNVS/test}{banner=misc, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \banner:n { #1 => #2}
%   \__bnvs_if_resolve:ncTF { #1 } { ans } {
%     \assert_equal_ans:nn { #2 } { A }
%   } {
%     \test_fail:n { B }
%   }
% }
% \Beanoves {
%   Air      = 1 : Gannet.last,
%   Chameleo = Air.2::1,
%   Gannet   = Chameleo.next::1,
%   Water    = Air.next : Picasso.last,
%   Octopus  = Water.2::1,
%   Starfish = Octopus.next::1,
%   StickyStarfish = Starfish.1::1,
%   Picasso = Starfish.next::1,
%   PicassoTrans = 1 : Picasso.previous,
%   Summary  = Water.next::1,
% }
% \BNVS_Test:nn { Chameleo.previous } {1}
% \BNVS_Test:nn { Gannet.previous } {2}
% \BNVS_Test:nn { Water.previous } {3}
% \BNVS_Test:nn { Octopus.previous } {4}
% \BNVS_Test:nn { Starfish.previous } {5}
% \BNVS_Test:nn { PicassoTrans.range } {1-6}
% \BNVS_Test:nn { Air.range } {1-3}
% \BNVS_Test:nn { Chameleo.1 } {2}
% \BNVS_Test:nn { Gannet.1 } {3}
% \BNVS_Test:nn { Water.range } {4-7}
% \BNVS_Test:nn { Octopus.1 } {5}
% \BNVS_Test:nn { Starfish.1 } {6}
% \BNVS_Test:nn { Picasso.range } {7-7}
% \BNVS_Test:nn { Summary.range } {8-8}
% \BNVS_Test:nn { Picasso.1 } {7}
% \BNVS_Test:nn { Air.last } {3}
% \BNVS_Test:nn { StickyStarfish.range } {6-6}
% \cs_undefine:N \BNVS_Test:nn
% \end{BNVS/test}
%
% \end{implementation}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
% \begin{BNVS/gobble}
%<*internal>
% \end{BNVS/gobble}
\iffalse
% \begin{BNVS/gobble}
%</internal>
% \end{BNVS/gobble}
%<*test-lua>
local Command = {}
Command.__index = Command

function Command:clear()
  self.all__ = {}
  self.by_name__ = {}
  self.output__ = {}
end

Command:clear()

function Command:output(message)
  if message == true then
    self.output__ = {}
  elseif message then
    self.output__[#self.output__+1] = message
  end
  return self.output__
end

function Command:already(name, signature) --> Command?
  if signature then
    name = name..":"..signature
  end
  return self.by_name__[name]
end

function Command:base_signature(name) --> String, String?
  local pattern = "^([a-zA-Z_@]*):([NncVvoxefpwDTF]*)"
  local base, signature = name:match(pattern)
  if base then
    return base, signature
  end
  return name
end

function Command:make(name, signature) --> Command?
  -- self:output("name: "..name..", signature: "..(signature or "")..", "..(name:find("bnvs") and "OK" or "KO"))
  if not name:find("bnvs") then
    return nil
  end
  if name:find("q__") then
    return nil
  end
  if name:find("DEBUG") then
    return nil
  end
  if name:len()<7 then
    return nil
  end
  if signature then
    name = name..":"..signature
  end
  local o = self.by_name__[name]
  if o then
    return o
  end
  local base, signature = self:base_signature(name)
  o = {
    name = name,
    base = base,
    signature = signature,
  }
  setmetatable(o, self)
  table.insert(self.all__, o)
  self.by_name__[name] = o
  if name:match("^c__") then
    o.is_constant = true
  elseif name:match("^[lg]__") then
    o.is_variable = true
  else
    o.is_function = true
  end
  return o
end

function iter (a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function Command:sorted()
  table.sort(self.all__, function(l, r) return l.name < r.name end)
  return iter, self.all__, 0
end

function Command:sorted_functions()
  local t = {}
  for _,cmd in self:sorted() do
    if cmd.is_function then
      t[#t+1] = cmd
    end
  end
  return iter, t, 0
end

function Command:parse_all(s)
  local n = 0
  local pattern = "%f[\\]"..--
[[\([a-zA-Z_@:]+)]]
  for name in string.gmatch (s, pattern) do
    if not self:already(name) and self:make(name) then
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs commands parsed")
end

function Command:parse_set_eq(s)
  local n = 0
  local pattern = "\\cs_set_eq:NN%s*"..
"\\([a-zA-Z_@:]+)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command copy")
end

function Command:parse_action(s, action)
  local n = 0
  local pattern = "\\cs_"..action..":Np?n%s+"..
"\\([a-zA-Z_@:]*)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." command definition "..action)
end

function Command:parse_BNVS_action(s, action)
  local n = 0
  local pattern = "\\BNVS_"..action..":cpn%s*{"..
"%s*([a-zA-Z_@:]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_"..name
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command definition "..action)
end

function Command:parse_BNVS_new_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_"..signature..":ncn?%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, name in string.gmatch (s, pattern) do
    name = "__bnvs_"..module.."_"..name
    local cmd = self:make(name..":"..signature)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new definition "..signature)
end

function Command:parse_BNVS_new_tl_signed(s, signature)
  local n = 0
  local pattern = "\\BNVS_new_tl_"..signature..":c?%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_tl_"..name..":"..signature
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new tl definition "..signature)
end

function Command:complete_variant(variant, signature) --> String
  if #variant < #signature then
    local ans = {}
    for i=1,#signature do
      ans[#ans+1] = signature:sub(i, i)
    end
    for i=1,#variant do
      ans[i] = variant:sub(i, i)
    end
    return table.concat(ans)
  end
  return variant
end

function Command:parse_generate_variant(s)
  local n = 0
  local pattern = "\\cs_generate_variant:Nn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_BNVS_generate_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_variant:cn%s*"..
"{%s*"..
"([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    core = "__bnvs_"..core
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_new_conditional(s)
  local n = 0
  local pattern = "\\prg_new_conditional:Npnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"[^{"..--}
"]*{([pTF,%s]-)}"
  for core, conditionals in string.gmatch (s, pattern) do
    local from = self:already(core)
    if from then
      from.is_conditional_core = true
    end
    local base, signature = self:base_signature(core)
    for c in conditionals:gmatch("([pTF]+)") do
      local name = c == "p" and (signature and base.."_p:"..signature or core.."_p") or core..c
      local generated = self:make(name)
      if generated then
        generated.is_defined = true
        generated.conditional_core = core
        n = n+1
      end
    end
  end
  self:output("-> "..n.." bnvs conditionals created")
end

function Command:parse_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\prg_generate_conditional_variant:Nnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_generate_conditional_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_conditional_variant:cnn%s*"..
"{%s*([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}%s*"..
"{([pTF,%s]-)}"
  for name, variants, conditionals in string.gmatch (s, pattern) do
    local base, signature = self:base_signature(name)
    base = "__bnvs_"..base
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        local vv = self:complete_variant(v, signature)
        for c in conditionals:gmatch("([pTF]+)") do
          local name = c == "p" and base.."_p:"..vv or base..":"..vv..c
          local generated = self:already(name)
          if generated then
            generated.is_defined = true
            generated.is_TF = c == "TF"
            n = n+1
          else
            generated = self:make(name)
            if generated then
              generated.is_defined = true
              generated.is_TF = c == "TF"
              generated.is_unused_conditional = true
              n = n+1
            end
          end
        end
      end
    else
      self:output("INCONSISTENCY, No signature: "..name)
    end
  end
  self:output("-> "..n.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." "..signature.." bnvs conditional variants generated")
end

function Command:parse_BNVS_new_conditional_nc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_([a-z]*):ncn?%s*{%s*"..
"([a-z]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for signature, module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs ncn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_cc:ncnn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":cc"..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":ncn*%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_tl(s, signature, is_tl)
  is_tl = is_tl == nil and false or is_tl
  local n = 0
  local pattern = "BNVS_new_conditional_tl_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  local prefix = is_tl and "__bnvs_tl_" or "__bnvs_"
  for base in string.gmatch (s, pattern) do
    for _,c in ipairs({"T", "F", "TF"}) do
      local name = prefix..base..":"..signature..c
  self:output("-> "..name)
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_cpnn(s)
  local n = 0
  local pattern = "BNVS_new_conditional:cpnn%s*{%s*"..
"([a-zA-Z_@]*):([a-zA-Z_@]*)%s*}[^{"..--}
"]*{%s*"..
"([pTF,%s]*)%s*}"
  local pattern_pTF = "([pTF]+)"
  for base, signature, pTFs in string.gmatch(s, pattern) do
    for pTF in string.gmatch(pTFs, pattern_pTF) do
      local name = "__bnvs_"..base
      if pTF == "p" then
        name = name.."_p:"..signature
      else
        name = name..":"..signature..pTF
      end
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = pTF == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = pTF == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs raw conditional variants generated")
end

function Command:check_unused_variants()
  self:output("-> check for unused variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused variants...DONE")
end

function Command:check_unused_conditional_variants(skip)
  if skip then
    return
  end
  self:output("-> check for unused conditional variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused_conditional then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused conditional variants...DONE")
end

function Command:check_undefined()
  self:output("-> check for undefined...")
  for _,cmd in self:sorted_functions() do
    if not cmd.is_defined and not cmd.is_conditional_core then
      if cmd.name:len() > 7 then
        self:output("!!!! "..cmd.name)
      end
    end
  end
  self:output("-> check for undefined...DONE")
end

function Command:check_variants(s) --> [String]
  self:clear()
  self:parse_all(s)
  self:parse_set_eq(s)
  self:parse_action(s,"new")
  self:parse_action(s,"set")
  self:parse_BNVS_action(s,"new")
  self:parse_BNVS_action(s,"set")
  self:parse_generate_variant(s)
  self:parse_BNVS_generate_variant(s)
  self:parse_new_conditional(s)
  self:parse_BNVS_new_signed(s, "c")
  self:parse_BNVS_new_signed(s, "cc")
  self:parse_BNVS_new_signed(s, "cn")
  self:parse_BNVS_new_signed(s, "cv")
  self:parse_BNVS_new_signed(s, "cnn")
  self:parse_BNVS_new_signed(s, "cnv")
  self:parse_BNVS_new_signed(s, "cnx")
  self:parse_BNVS_new_tl_signed(s, "c")
  self:parse_BNVS_new_tl_signed(s, "cn")
  self:parse_BNVS_new_tl_signed(s, "cv")
  self:parse_BNVS_new_conditional_cpnn(s)
  self:parse_BNVS_new_conditional_signed(s, "c")
  self:parse_BNVS_new_conditional_signed(s, "nc")
  self:parse_BNVS_new_conditional_signed(s, "cc")
  self:parse_BNVS_new_conditional_signed(s, "cn")
  self:parse_BNVS_new_conditional_signed(s, "cnn")
  self:parse_BNVS_new_conditional_signed(s, "cnv")
  self:parse_BNVS_new_conditional_signed(s, "cnx")
  self:parse_BNVS_new_conditional_tl(s, "cn", true)
  self:parse_BNVS_new_conditional_tl(s, "cv", true)
  self:parse_BNVS_new_conditional_tl(s, "vnc", false)
  self:parse_BNVS_new_conditional_tl(s, "vvc", false)
  self:parse_BNVS_new_conditional(s, "Nn")
  self:parse_BNVS_new_conditional(s, "Nv")
  self:parse_BNVS_new_conditional(s, "nn")
  self:parse_BNVS_new_conditional(s, "c")
  self:parse_BNVS_new_conditional(s, "cc")
  self:parse_BNVS_new_conditional(s, "cv")
  self:parse_BNVS_new_conditional(s, "vc")
  self:parse_BNVS_new_conditional(s, "vnc")
  self:parse_BNVS_new_conditional(s, "vvc")
  self:parse_BNVS_new_conditional(s, "vvnc")
  self:parse_BNVS_new_conditional(s, "vvvc")
  self:parse_generate_conditional_variant(s)
  self:parse_BNVS_generate_conditional_variant(s)
  self:check_unused_variants()
  self:check_unused_conditional_variants(true)
  self:check_undefined()
  return self:output()
end
local function check_variants (path) --> string?
  local file = io.open(path, "r")
  if file == nil then
    return nil
  end
  local s = file:read("a")
  file:close()
  local ra1 = Command:check_variants([[
\BNVS_set:cpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:cnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
\cs_generate_variant:Nn \__bnvs_v_gput:nn { nV }
\bnvs_TEST_A:n
\bnvs_TEST_B:nn
\cs_set:Npn \bnvs_TEST_B:nn {}
\cs_new:Npn \bnvs_C:nn {}
\BNVS_new_conditional:cpnn { if_get:nnc } #1 #2 #3 { p, T, F, TF } {}
\_generate_conditional_variant:Nnn
  \__bnvs_if_get:nnc {nV} { p, T, F, TF }
]])
  local ra2 = Command:check_variants(s)
  for _,v in ipairs(ra2) do
    ra1[#ra1+1] = v
  end
  return ra2
end
return {
  __INFO__ = "beanoves dedicated table for DEBUGGING",
  check_variants  = check_variants,
  Command__ = Command,
}
%</test-lua>
%<*internal>
\fi
% \begin{BNVS/gobble}
%</internal>
% \end{BNVS/gobble}
