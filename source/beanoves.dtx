% \iffalse meta-comment
% !TEX program  = LuaLaTeX
% !TEX encoding = UTF-8
%
%% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2022 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of multiple time lines in |beamer| documents.
Time lines are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay specifications

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf,
                                beanoves.sty and
                                beanoves-debug.sty.

\endpostamble
\generate{
  \file{\jobname-debug.sty}{\from{\jobname.dtx}{package,debug}}
}
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package,gubed,tset}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% ! TeX proot = ...
\PassOptionsToPackage{enable-debug}{expl3}
\documentclass{l3doc}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\tcbuselibrary{minted}
\RequirePackage{beanoves-debug}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specifications with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{\jobname-debug.sty}
\date{\fileversion \qquad \filedate}
\NewDocumentEnvironment{bnvs.macrocode}{}{
 \setlength{\topsep}{0.4em plus 0.15 em minus 0.15 em}
  \begin{trivlist}
  \setlist[trivlist]{nosep}
  \item\vspace{-\baselineskip}
}{
  \end{trivlist}
}
\begin{document}
\maketitle
\changes{v1.0}{2009/10/06}{First public release}
\begin{abstract}
This package allows the management of multiple slide number lists in |beamer| documents.
Slide number lists are very handy both during edition and to manage complex and variable \pkg{beamer} overlay specifications.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{TODO}
This section will be removed.
\begin{itemize}
\item Overlay sets instead of slide ranges
\item bounded and unbounded ranges
\begin{itemize}
\item \texttt{A=1}, \texttt{A.\meta{integer}} can take any value.
\item \texttt{A=1:}, 1<=\texttt{A.\meta{integer}}.
\item \texttt{A=::1}, \texttt{A.\meta{integer}}<=1.
\item \texttt{A=1::10}, 1<=\texttt{A.\meta{integer}}<=10.
\end{itemize}
\item revisit \texttt{A = [...]} to allow explicit keys
\end{itemize}

\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanoves}
\begin{document}
\Beanoves {
      A = 1:2,
      B = A.next:3,
      C = B.next,
    }
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.1)-?(B.last)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2::B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.next)-> {From slide 3}\\
\visible<?(B.3::B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare named overlay sets.
On line 5, we declare an overlay set named `A', which is a range starting at slide 1 and with length 2.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1 because 1 is the first index of the overlay set named A.
On line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.next)} stands for 3.
%
On line 6, we declare a second overlay set named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last slide number is 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide number after slide range `B' is 6
which is also the start of the third slide range
due to line 7.
\section{Named overlay sets}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn
according to overlay specifications. The main overlay sets is a range of integers
covering all the slide numbers, from one to the total amount of slides.
In general, an overlay set is a range of positive integers identified by a unique name.
The main practical interest is that such sets may be defined relative to one another, we can even have lists of overlay sets.
Finally, we can use these lists to build and organize \pkg{beamer} overlay
specifications logically.
\subsection{Named overlay reference}
|A.1|, |C.2| are \emph{named overlay references} as well as |A| and |Y!C.2|.
More precisely, they are string identifiers, each one representing
a static integer to be used in \pkg{beamer} overlay specifications.
They can take one of the next forms.
\begin{description}
\item[\texttt{\meta{short name}}]: like |A| and |C|,
\item[\texttt{\meta{frame id}|!|\meta{short name}}]: denoted by \emph{qualified names}, like |X!A| and |Y!C|.
\item[\texttt{\meta{short name}\meta{integer path}}]:
  denoted by \emph{full names} like |A.1| and |C.2|,
\item[\texttt{\meta{frame id}|!|\meta{short name}\meta{dotted path}}]:
  denoted by \emph{qualified full names} like |X!A.1| and |Y!C.2|.
\end{description}
The \emph{short names} and \emph{frame ids} are alphanumerical case sensitive
identifiers, with possible underscores but no space nor leading digit.
Unicode symbols above \texttt{U+00A0} are allowed if the underlying \TeX\ engine
supports it. Identifiers consisting only of lowercase letters are reserved by the package.

The \emph{dotted path} is a string
\texttt{.\meta{component_1}.\meta{component_2}....\meta{component_n}},
where each \meta{component_i} denotes either an integer, eventually signed,
or a \meta{short name}. The \emph{dotted path} can be empty for which \texttt{n} is 0.

The mapping from \emph{named overlay references} to integers is defined
at the global \TeX\ level because either we can
include only a subset of one frame slides
or we can share the same overlay sets between different frames.
Hence the \emph{frame id} due to the need to possibly target a particular frame.

\subsection{Defining named overlay sets}
In order to define \emph{named overlay sets}s, we can either execute the next |\Beanoves| command  before a \pkg{beamer} frame environment, or use the |beanoves| option of this environment.
The value of the |beanoves| option is similar to the argument of the |\Beanoves| commands, but the latter takes precedence on the former.
This behaviour may be useful to input the very same source code into different frames and have different combinations of slides.
%
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{
    \phantom{xx}\meta{named ref_1}=\meta{range spec_1},
    \phantom{xx}\meta{named ref_2}=\meta{range spec_2},
    \phantom{xx}...,
    \phantom{xx}\meta{named ref_n}=\meta{range spec_n},
    \}
  \end{syntax}
\end{function}
\begin{function}{\Beanoves}
  \begin{syntax}
    \cs{Beanoves}\{
    \phantom{xx}\meta{named ref_1}=\meta{range spec_1},
    \phantom{xx}\meta{named ref_2}=\meta{range spec_2},
    \phantom{xx}...,
    \phantom{xx}\meta{named ref_n}=\meta{range spec_n},
    \}
  \end{syntax}
\end{function}
Each key \meta{named ref_i} is a \emph{named overlay reference}.
When the same key is used multiple times, only the last one is taken into account.
Possible values for \meta{range spec_i} are the \emph{slide range specifiers} \meta{first},
\meta{first}:\meta{length}, \meta{first}::\meta{last}, :\meta{length}::\meta{last}
where \meta{first}, \meta{length} and \meta{last} are either empty
or algebraic expression possibly involving any \emph{named overlay reference}
defined above. At least one of \meta{first} or \meta{last} must be provided.

When performed at the document level, the \cs{Beanoves} command starts by cleaning 
what was set previous calls. When performed inside \LaTeX\ environments,
each call cumulates with the previous.
Notice that the argument of this function can contain macros: they will be exhaustively expanded.

Also possible values are \emph{slide list specifiers} which
are comma separated lists of \emph{slide range specifiers}
and \emph{slide list specifier} between square brackets.
The definition
\\[0.2ex]
\hphantom{xx}\meta{named ref}|=[|\meta{range spec_1}|,|\meta{range spec_2}|,...,|\meta{range spec_n}|]|,
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\meta{named ref}|.1=|\meta{range spec_1}|,|
\\\hphantom{xx}\meta{named ref}|.2=|\meta{range spec_2}|,|
\\\hphantom{xx}|...,|
\\\hphantom{xx}\meta{named ref}|.|\textit{n}|=|\meta{range spec_n}.
\\[0.2ex]
The rules above can apply individually to each
\\[0.2ex]
\hphantom{xx}\meta{named ref}|.|\rlap{\textit{i}}\phantom{|i|}|=|\meta{range spec_i}.
\\[0.2ex]
Moreover we can go deeper: the definition
\\[0.2ex]
\hphantom{xx}\meta{named ref}|=[[|\meta{range spec_{1.1}}|,| \meta{range spec_{1.2}}|],[[|\meta{range spec_{2.1}}|,| \meta{range spec_{2.2}}|]]|
\\[0.2ex]
happens to be a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\meta{named ref}|.1.1=|\meta{range spec_{1.1}}|,|
\\\hphantom{xx}\meta{named ref}|.1.2=|\meta{range spec_{1.2}}|,|
\\\hphantom{xx}\meta{named ref}|.2.1=|\meta{range spec_{2.1}}|,|
\\\hphantom{xx}\meta{named ref}|.2.2=|\meta{range spec_{2.2}}
\\[0.2ex]
and so on.
%
\section{Named overlay resolution}
Turning a \emph{named overlay reference} into the static integer it represents,
as in \texttt{<?(A.1)>} above,
to feed \pkg{beamer} with is denoted \emph{named overlay resolution} or simply \emph{resolution}. This section is devoted to \emph{resolution rules} depending
on the definition of the named overlay set.
Here \meta{i} denotes an integer whereas \meta{first}, \meta{length} and \meta{last} stand for integers, or integer valued expressions.
%
\subsection{\ttfamily \meta{name} = \meta{first}}
For an unlimited range
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{name}.1 & \(\meta{first}\)\\
\meta{name}.2 & \(\meta{first}+1\) \\
\meta{name}.\meta{i} & \(\meta{first}+ \meta{i} - 1\) \\
\hline
\end{tabular}
\end{center}
\subsection{\ttfamily \meta{name}.\meta{i} = \meta{range spec}}
All the default rules above and below are overriden by this particular one and \texttt{\meta{name}.\meta{i}} resolves to the resolution of \meta{range spec}.

In the frame example below, we use the \cs{BeanovesEval} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3,
    A.3 = 0,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval(A.1) == 3,
\BeanovesEval(A.2) == 4,
\BeanovesEval(A.-1)== 1,
\BeanovesEval(A.3) == 0,
\end{frame}
\end{tcblisting}
%
\subsection{\ttfamily \meta{name} = \meta{first}:}
For a range limited from below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{name}.1 & \(\meta{first}\)\\
\meta{name}.2 & \(\meta{first}+1\) \\
\meta{name}.\meta{i} & \(\max(\meta{first}, \meta{first} + \meta{i} - 1)\) \\
\meta{name}.previous & \(\meta{first}-1\)\\
\hline
\end{tabular}
\end{center}
The same applies to {\ttfamily \meta{name} = \meta{first}::}.
\subsection{\ttfamily \meta{name} = ::\meta{last}}
For a range limited from above:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{name}.1 & \(\meta{last}\)\\
\meta{name}.0 & \(\meta{last}-1\) \\
\meta{name}.\meta{i} & \(\min(\meta{last}, \meta{last} + \meta{i} - 1)\) \\
\meta{name}.next & \(\meta{last}+1\)\\
\hline
\end{tabular}
\end{center}
\subsection{\ttfamily \meta{name} = \meta{first}::\meta{last}}
For a range limited from both above and below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{name}.1 & \(\meta{first}\)\\
\meta{name}.2 & \(\meta{first}+1\) \\
\meta{name}.\meta{i} & \(\min\bigl(\meta{last}, \max(\meta{first}, \meta{first} + \meta{i} - 1)\bigr)\) \\
\meta{name}.previous & \(\meta{first}-1\)\\
\meta{name}.last & \(\meta{last}\)\\
\meta{name}.next & \(\meta{last}+1\)\\
\meta{name}.length & \(\meta{last}-\meta{first}+1\)\\
\meta{name}.range & \(\meta{first}\) ''-'' \(\meta{last}\)\\
\hline
\end{tabular}
\end{center}
For example
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:6, % or equivalently A = 3::8, A = :6::8 and A = ::8:6
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval(A.1)        == 3,
\BeanovesEval(A.-1)       == 3,
\BeanovesEval(A.previous) == 2,
\BeanovesEval(A.last)     == 8,
\BeanovesEval(A.next)     == 9,
\BeanovesEval(A.length)   == 6,
\BeanovesEval(A.range)    == 3-8,
\end{frame}
\end{tcblisting}
a variation 
\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3::-1
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval(A.1)        == -1,
\BeanovesEval(A.-1)       == -1,
\BeanovesEval(A.previous) == -2,
\BeanovesEval(A.last)     == -1,
\BeanovesEval(A.next)     == 0,
\BeanovesEval(A.length)   == -5,
\BeanovesEval(A.range)    == 0-0,
\end{frame}
\end{tcblisting}

The same applies to
{\ttfamily \meta{name} = \meta{first}:\meta{length}}
for which \meta{last} is \(\meta{first}+\meta{length}-1\) as well as
{\ttfamily \meta{name} = :\meta{length}::\meta{last}}
or {\ttfamily \meta{name} = ::\meta{last}:\meta{length}},
for which \meta{first} is \(\meta{last}-\meta{length}+1\).
\subsection{Bounded ranges}
When the slide range has been given a length or an end,
like in the frame example below,
the resolution of \texttt{\meta{name}.\meta{integer}} becomes
the range integer in the range which is closest to \texttt{i+ \meta{integer} - 1}. 
%
\subsection{Named overlay lists}
After the definition
\\[0.2ex]
\hphantom{xx}\meta{named ref}|=[|\meta{range spec_1}|,|\meta{range spec_2}|,...,|\meta{range spec_n}|]|
\\[0.2ex]
the rules of the previous section apply recursively to each individual
declaration
\\[0.2ex]\hphantom{xx}\meta{named ref}|.|\rlap{\textit{i}}\hphantom{|i|}|=|\meta{range spec_i}.
%
\subsection{Counters}
For each name overlay set defined, we have an implicit index counter starting at 1,
its actual value is an integer denoted \meta{n}.
The \texttt{\meta{name}.n} \emph{named counter reference} is resolved into \texttt{\meta{name}.\meta{n}},
which in turn is resolved according to the preceding rules.
%

Each named overlay set defined also has a dedicated value counter
which is some kind of variable that can be used and incremented.
A simple \texttt{\meta{name}} reference is resolved into
the position of this counter, which is the value of the counter bounded from below by the lowest value of the range and from above by the largest value of the range.
For unbounded ranges, these values may be infinite.

Additionnaly, resolution rules are provided for the \emph{named index references}:
\begin{description}
\item[\ttfamily\meta{name}.n+=\meta{integer expression}]: resolve \meta{integer expression} into \meta{integer}, advance the implicit index counter associate to \meta{name} by \meta{integer} and use the resolution of \texttt{\meta{name}.n}.

Here \meta{integer expression} denotes the longest character sequence with no space%
\footnote{The parser for algebraic expression is very rudimentary.}.
\item[\ttfamily\meta{name}.++n]: advance the implicit index counter associate to \meta{name} by 1 and use the resolution of \texttt{\meta{name}.n},
\item[\ttfamily\meta{name}.n++]: use the resolution of \texttt{\meta{name}.n} and increment the implicit index counter associate to \meta{name} by 1.
\end{description}

We have resolution rules as well for the \emph{named value references}:
\begin{description}
\item[\ttfamily\meta{name}+=\meta{integer expression}]: resolve \meta{integer expression} into \meta{integer}, advance the value counter by \meta{integer}
and use the new position.
Here again, \meta{integer expression} is the longest character sequence with no space.
\item[\ttfamily++\meta{name}]: advance the value counter for \meta{name} by 1 and use the new position.
\item[\ttfamily\meta{name}++]: use the actual position
and advance the value counter for \meta{name} by 1.
\end{description}
For example both \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been properly defined with a starting value and a length.

In order to decrement a counter, one can increment with a negative value, no dedicated syntax is provided yet.
\subsection{Frame id}
Except for very special situations, the \emph{frame ids} can be left unspecified.
When no \emph{frame id} was explicitly provided,
\pkg{beanoves} uses the \emph{last frame id}. At the beginning of each frame,
the \emph{last frame id} is set to the \emph{frame id} of the current frame,
which is denoted \emph{current frame id} and defaults to |?|.
Then it gets updated after each named reference resolution.
For example, the first time |A.1| reference is resolved within a given frame,
it is first translated to \texttt{\meta{current frame id}!A.1},
but when used just after \texttt{Y!C.2}, it becomes a shortcut to
\texttt{Y!A.1} because the \emph{last frame id} was then \texttt{Y}.

In order to set the \emph{frame id} of the current frame to \meta{frame id},
use the new \texttt{beanoves id} option of the \pkg{beamer} frame environment. 
\begin{function}{beanoves id}
  \begin{syntax}
    beanoves id=\meta{frame id},
  \end{syntax}
\end{function}
%
\subsection{Deeper dotted paths}
When a dotted path has more than one component,
a \emph{named overlay reference} like |A.1.2| needs some well defined
resolution rule to avoid ambiguity.
To resolve one level of such a reference
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}},
we replace the longest \texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_k}}
where 0$≤$k$≤$n by its definition \texttt{\meta{name'}.\meta{c'_1}...\meta{c'_p}}
if any (the path can be empty). \pkg{beanoves} uses this one level resolution
as many times as possible, but no more than a predefined limit to catch
circular reference that would lead to an infinite \TeX\ loop.
One final resolution occurs with rules above if possible or an error is raised.

For a \emph{named indexed reference} like
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}.n},
we must first resolve \texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}}
into \texttt{\meta{name'}} with an empty dotted path, then retrieve the value of \texttt{\meta{name'}.n} denoted as \meta{n'} and finally use the resolved 
\texttt{\meta{name}.\meta{c_1}.\meta{c_2}...\meta{c_n}.\meta{n'}}.
%
\section{\texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\meta{queries})}'. Each one is then evaluated and replaced by its resolved static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s of next table.
Sometimes, using \texttt{\meta{name}.range} is not allowed as it would lead to
an algebraic difference instead of a range.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{query} & \bfseries \textrm{resolution} & \bfseries \textrm{limitation}
\\\hline
\phantom{xx}\meta{first expr} & \meta{first} & \\
\phantom{xx}\meta{first expr}: & \meta{first} - & \textrm{no }\meta{name}.range \\
\phantom{xx}\meta{first expr}:\meta{length expr} & \meta{first} - \meta{last} & \textrm{no }\meta{name}.range \\
\phantom{xx}::\meta{end expr}:\meta{length expr} & \meta{first} - \meta{last}  & \textrm{no }\meta{name}.range \\
\phantom{:\meta{length expr}}: & \phantom{\meta{first}} - & \\
\phantom{xx}\meta{first expr}:: & \meta{first} - & \textrm{no }\meta{name}.range \\
\phantom{::\meta{first expr}}::\meta{end expr} & \phantom{\meta{first}} - \meta{last}  & \textrm{no }\meta{name}.range \\
\phantom{xx}\meta{first expr}::\meta{end expr} & \meta{first} - \meta{last}  & \textrm{no }\meta{name}.range \\
:\meta{length expr}::\meta{end expr} & \meta{first} - \meta{last}  & \textrm{no }\meta{name}.range \\
\phantom{:\meta{length expr}}:: & \phantom{\meta{first}} - & \\
\hline
\end{tabular}
\end{center}
Here \meta{first expr}, \meta{length expr} and \meta{end expr}
both denote algebraic expressions possibly involving named slide references and counters.
As integers, they are respectively resolved into \meta{first}, \meta{length} and \meta{last}.

Notice that nesting \texttt{?(...)} query expressions is not supported.
\end{documentation}
\ExplSyntaxOn
\bool_set_true:N \l__bnvs_test_ignore_bool
\ExplSyntaxOff
\DocInput{beanoves.dtx}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
%
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse_m:Nnn}/{KEY=VALUE}, debug,
% ]
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST:LENGTH }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_get:nnNTF L { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { LENGTH } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/L }
%  }
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST::LAST }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_get:nnNTF Z { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { LAST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/Z }
%  }
% \end{bnvs.test}
% \begin{implementation}
% \NewDocumentEnvironment {bnvs.gobble} { +b } {} {}
%    \begin{bnvs.gobble}
%<*package>
%    \end{bnvs.gobble}
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%<@@=bnvs>
%    \end{macrocode}
% \end{bnvs.macrocode}
% Reserved namespace:
% identifiers containing the case insensitive string |beanoves| or
% the string |bnvs| delimited by two non characters.
% Not all the variables or functions names used by this package
% follow this convention, but in that case the global macro level is not polluted.
%
% \subsection{Package declarations}
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!debug>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {beanoves}
%    \end{macrocode}
% \begin{bnvs.gobble}
%</!debug>
%<*!gubed>
  {beanoves-debug}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {2022/10/28}
  {1.0}
  {Named overlay specifications for beamer}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsection{logging}
%
% Utility message.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
\msg_new:nnn { beanoves } { :nn } { #1~(#2) }
\cs_new:Npn \__bnvs_error:n {
  \msg_error:nnn { beanoves } { :n }
}
\cs_new:Npn \__bnvs_error:x {
  \msg_error:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsection{Debugging and testing facilities}
% Typesetting file |beanoves.dtx| creates both \pkg{beanoves}
% and \pkg{beanoves-debug} style files. The former is intended for everyday
% use whereas the latter contains supplemental debugging and testing
% facilities which are intentionally left undocumented. 
% \begin{bnvs.gobble}
%<*!gubed>
\cs_set:Npn \__bnvs_log_gprop: {
  \prop_map_inline:Nn \g__bnvs_prop {
    \__bnvs_DEBUG:n { ##1 -> ##2 }
  }
  \prop_map_inline:Nn \g__bnvs_n_prop {
    \__bnvs_DEBUG:n { n:##1 -> ##2 }
  }
}
\NewDocumentCommand\BeanovesLogGProp {} { \__bnvs_log_gprop: }
\cs_set:Npn \__bnvs_log_n_gprop: {
  \prop_map_inline:Nn \g__bnvs_n_prop {
    \__bnvs_DEBUG:n { n: ##1 -> ##2 }
  }
}
\NewDocumentCommand\BeanovesLogNProp {} { \__bnvs_log_n_gprop: }
\cs_set:Npn \__bnvs_DEBUG_a:nn #1 #2 {
  \msg_term:nnn { beanoves } { :n } { #1~#2 }
}
\cs_generate_variant:Nn \__bnvs_DEBUG_a:nn { xn }
\cs_new:Npn \__bnvs_DEBUG_on: {
  \cs_set:Npn \__bnvs_DEBUG:n {
    \__bnvs_DEBUG_a:xn
    { ▃▃ \prg_replicate:nn {\l__bnvs_group_int} {▁▃} \space }
  }
}
\cs_new:Npn \__bnvs_DEBUG_off: {
  \cs_set_eq:NN \__bnvs_DEBUG:n \use_none:n
}
\__bnvs_DEBUG_off:
\cs_generate_variant:Nn \__bnvs_DEBUG:n { x, V }
\int_zero_new:N \l__bnvs_group_int
\cs_set:Npn \__bnvs_group_begin: {
  \group_begin:
  \int_incr:N \l__bnvs_group_int
}
\cs_set_eq:NN \__bnvs_group_end: \group_end:
\cs_new:Npn \__bnvs_DEBUG_b:nn #1 #2 {
  \__bnvs_DEBUG:x { #1~#2 }
}
\bool_new:N \l__bnvs_test_ignore_bool
\bool_set_false:N \l__bnvs_test_ignore_bool
\cs_new:Npn \__bnvs_DEBUG:nn #1 {
  \exp_args:Nx
  \__bnvs_DEBUG_b:nn
  { ▄▄ \prg_replicate:nn {\l__bnvs_group_int + 1} {#1} }
}
\cs_generate_variant:Nn \__bnvs_DEBUG:nn { nx, nV }
%</!gubed>
%<*!debug>
\cs_set_eq:NN \__bnvs_group_begin: \group_begin:
%</!debug>
%<*!gubed>
\ProvideDocumentEnvironment {beanoves.failure} {} {} {}
\tl_new:N \l__bnvs_test_done_tl
\NewDocumentEnvironment{bnvs.test} {} {
  \color{red}\bfseries\ExplSyntaxOn
  \debug_on:n { check-declarations }
  \__bnvs_gclear:
  \int_gset:Nn \g__bnvs_call_int { 128 }
  \__bnvs_test:
} {
  \__bnvs_gclear:\ExplSyntaxOff\ignorespacesafterend
}
\keys_define:nn { bnvs.test } {
  banner .tl_set:N = \l__bnvs_banner_tl,
  debug .code:n = \__bnvs_DEBUG_on:,
  reset .code:n = \reset:n { #1 },
  ignore .bool_set:N = \l__bnvs_test_ignore_bool,
  ignore .default:n = true,
}
\NewDocumentCommand \__bnvs_test: { o } {
  \cs_set:Npn \reset:n ##1 {
    \__bnvs_DEBUG:x {A}
    \__bnvs_group_begin:
    \__bnvs_DEBUG:x {B}
%    \__bnvs_DEBUG_off:
    \tl_if_empty:nF { ##1 } {
      \prop_gclear:N \g__bnvs_prop
      \prop_gclear:N \g__bnvs_n_prop
    }
    \Beanoves { FIRST = 222, LENGTH = 445, LAST = 666 }
    \__bnvs_group_end:
    \__bnvs_DEBUG:x {C}
  }
  \IfValueT { #1 } { \keys_set_known:nn {bnvs.test} {#1} }
  \bool_if:NTF \l__bnvs_test_ignore_bool {
    \tl_clear:N \l__bnvs_test_done_tl
    \RenewDocumentEnvironment{bnvs.test}{+b}{
      \cs_set:Npn \end: {
        \cs_set:Npn \end: { }
        \end{bnvs.test}
      }
    } {
      \end:
    }
    \begin{bnvs.test}
  } {
    \cs_set:Npn \banner:n ##1 {
      \__bnvs_call_greset:
      \__bnvs_DEBUG_a:xn { ▶︎▶︎▶︎▶︎▶︎~TEST~##1~/~line:~\the\inputlineno} {}
    }
    \RenewDocumentEnvironment{beanoves.failure}{}
      {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
         \setlength{\itemindent}{0pt}%
         \setlength{\leftmargin}{0pt}%
         \setlength{\labelwidth}{0pt}%
         \addtolength{\topsep}{-0.5\parskip}%
         \listparindent \parindent
         \setlength{\parsep}{\parskip}}}
      {\end{list}}  
    \cs_set_eq:NN \test_extract:nnnn \__bnvs_test_extract:nnnn
    \cs_set_eq:NN \test_extract:Nnnn \__bnvs_test_extract:Nnnn
    \cs_set_eq:NN \test_split:Nnnn \__bnvs_test_split:Nnnn
    \cs_set_eq:NN \assert_equal:nnn \__bnvs_assert_equal:nnn
    \cs_set_eq:NN \test_fail:n \__bnvs_test_fail:n
    \cs_generate_variant:Nn \assert_equal:nnn { xxn }
    \cs_set:Npn \preflight:n ##1 {
      \banner:n { ##1 }
      \__bnvs_group_begin:
      \tl_clear:N \l__bnvs_ans_tl
    }
    \cs_set:Npn \preflight:nn ##1 ##2 {
      \banner:n { ##2~/~##1 }
      \tl_if_empty:nF { ##1 } {
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \__bnvs_log_gprop:
      }
      \__bnvs_group_begin:
      \tl_clear:N \l__bnvs_ans_tl
    }
    \cs_set:Npn \preflight:nnn ##1 ##2 ##3 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2~/~##3~/ }
      } {
        \banner:n { ##2~/~X=##1=>##2~/ }
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \__bnvs_log_gprop:
      }
      \__bnvs_group_begin:
      \tl_clear:N \l__bnvs_ans_tl
    }
    \cs_set:Npn \postflight: {
      \__bnvs_group_end:
    }
    \cs_set:Npn \flight:nT ##1 ##2 {
      \bool_if:NF \l__bnvs_test_ignore_bool {
        \preflight:n { ##1 }
        ##2
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnT ##1 ##2 ##3 {
      \bool_if:NF \l__bnvs_test_ignore_bool {
        \preflight:nn { ##1 } { ##2 }
        ##3
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnnT ##1 ##2 ##3 ##4 {
      \bool_if:NF \l__bnvs_test_ignore_bool {
        \preflight:nnn { ##1 } { ##2 } { ##3 }
        ##4
        \postflight:
      }
    }
    \cs_set:Npn \Test_resolve_x:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_set:Nx \l__bnvs_name_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_resolve_x:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
          \assert_equal:xxn { \l__bnvs_id_tl } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_name_tl {
            \assert_equal:xxn { \l__bnvs_name_tl } { ?!##4 } { ##6-name }
          } {
            \assert_equal:xxn { \l__bnvs_name_tl } { ##4 } { ##6-target }
          }
          \assert_equal:xxn { \seq_use:Nn \l__bnvs_path_seq . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
        \__bnvs_gclear:
      }
    }
    \cs_set:Npn \Test_resolve_n:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_set:Nx \l__bnvs_name_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_resolve_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
          \assert_equal:xxn { \l__bnvs_id_tl } { ?! } { ##6-id }
          \assert_equal:xxn { \l__bnvs_name_tl } { ?!##4 } { ##6-name }
          \assert_equal:xxn { \seq_use:Nn \l__bnvs_path_seq . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
    \cs_set:Npn \Test_resolve_pm_x:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_set:Nx \l__bnvs_name_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_resolve_pm_x:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
          \assert_equal:xxn { \l__bnvs_id_tl } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_name_tl {
            \assert_equal:xxn { \l__bnvs_name_tl } { ?!##4 } { ##6-name }
          } {
            \assert_equal:xxn { \l__bnvs_name_tl } { ##4 } { ##6-target }
          }
          \assert_equal:xxn { \seq_use:Nn \l__bnvs_path_seq . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
        \__bnvs_gclear:
      }
    }
    \cs_set:Npn \Test_resolve_pm_n:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_set:Nx \l__bnvs_name_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \__bnvs_resolve_pm_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
          \assert_equal:xxn { \l__bnvs_id_tl } { ?! } { ##6-id }
          \assert_equal:xxn { \l__bnvs_name_tl } { ?!##4 } { ##6-name }
          \assert_equal:xxn { \seq_use:Nn \l__bnvs_path_seq . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
    \cs_set:Npn \Test_raw:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##2 } { ##4 } {
        \cs_if_exist:cTF { __bnvs_raw_##1:nNTF } {
          \use:c { __bnvs_raw_##1:nNTF } { ?!X } \l__bnvs_ans_tl {
            \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-b }
          } {
            \test_fail:n { ##4-a }
          }
        } {
          \test_fail:n { ##4-BAD~##1 }
        }
      }
    }
    \cs_set:Npn \Test:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##2 } { ##4 } {
        \cs_if_exist:cTF { __bnvs_if_##1:nNTF } {
          \use:c { __bnvs_if_##1:nNTF } { ?!X } \l__bnvs_ans_tl {
            \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
            \tl_clear:N \l__bnvs_ans_tl
            \cs_if_exist:cTF { __bnvs_##1:nN } {
              \use:c { __bnvs_##1:nN } { ?!X } \l__bnvs_ans_tl
              \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-b }
            } {
              \test_fail:n { ##4-BAD~##1 }
            }
          } {
            \test_fail:n { ##4-c }
          }
        } {
          \cs_if_exist:cTF { __bnvs_##1:nNTF } {
            \use:c { __bnvs_##1:nNTF } { ?!X } \l__bnvs_ans_tl {
              \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
              \tl_clear:N \l__bnvs_ans_tl
              \cs_if_exist:cTF { __bnvs_##1:nN } {
                \use:c { __bnvs_##1:nN } { ?!X } \l__bnvs_ans_tl
                \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-b }
              } {
                \test_fail:n { ##4-BAD~##1 }
              }
            } {
              \test_fail:n { ##4-c }
            }
          } {
            \test_fail:n { ##4-BAD~##1 }
          }
        }
      }
    }
    \cs_set:Npn \Test_index:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \__bnvs_if_index:nnNTF { ?!X } { ##2 } \l__bnvs_ans_tl {
          \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
        } {
          \test_fail:n { ##4-b }
        }
      }
    }
    \cs_set:Npn \Test_raw_first:nnn {
      \Test_generic:Nnnn \__bnvs_raw_first:nNTF
    }
    \cs_set:Npn \Test_generic:Nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##2 } { ##4 } {
        ##1 { ?!X } \l__bnvs_ans_tl {
          \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-b }
        } {
          \test_fail:n { ##4-a }
        }
      }
    }
    \cs_set:Npn \Test_free_counter:nnn {
      \Test_generic:Nnnn \__bnvs_if_free_counter:nNTF
    }
    \cs_set:Npn \Test_counter:nnn {
      \Test_generic:Nnnn \__bnvs_if_counter:nNTF
    }
    \cs_set:Npn \Test_n_counter:nnn {
      \Test_generic:Nnnn \__bnvs_if_n_counter:nNTF
    }
    \cs_set:Npn \Test_n_counter:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \__bnvs_if_n_counter:nNTF { ##2 } \l__bnvs_ans_tl {
          \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
        } {
          \test_fail:n { ##4-b }
        }
      }
    }
    \cs_set:Npn \Test_n_index:nnn {
      \Test_generic:Nnnn \__bnvs_if_n_index:nNTF
    }
    \cs_set:Npn \Test_n:nnn {
      \Test_generic:Nnnn \__bnvs_n_get:nNTF
    }
    \cs_set:Npn \Test_generic:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnnT { ##2 } { ##5 } { ##2~/~##3 } {
        \__bnvs_if_free_counter:nNTF { ?!X } \l__bnvs_ans_tl {
          \tl_clear:N \l__bnvs_ans_tl
          ##1 { ?!X } { ##3 } \l__bnvs_ans_tl {
            \assert_equal:xxn { \l__bnvs_ans_tl } { ##4 } { ##5-b }
          } {
            \test_fail:n { ##5-c }
          }
        } {
          \test_fail:n { ##5-d }
        }
      }
    }
    \cs_set:Npn \Test_incr:nnnn {
      \Test_generic:Nnnnn \__bnvs_if_incr:nnNTF
    }
    \cs_set:Npn \Test_n_incr:nnnn {
      \Test_generic:Nnnnn \__bnvs_if_n_incr:nnNTF
    }
    \cs_set:Npn \Test_post:nnnn {
      \Test_generic:Nnnnn \__bnvs_if_post:nnNTF
    }
    \cs_set:Npn \Test_range:nnn {
      \Test_generic:Nnnn \__bnvs_if_range:nNTF
    }
    \cs_set:Npn \Test_append:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 }  { ##2==##3 } {
        \__bnvs_if_append:nNTF { ##2 } \l__bnvs_ans_tl {
          \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
        } {
          \test_fail:n { ##4-b }
        }
      }
    }
    \cs_set:Npn \Test_append_pm:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 }  { ##2==##3 } {
        \__bnvs_if_append_pm:nNTF { ##2 } \l__bnvs_ans_tl {
          \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4-a }
        } {
          \test_fail:n { ##4-b }
        }
      }
    }
    \cs_set:Npn \Test_regex:nnnn ##1 {
      \bool_if:NTF \l__bnvs_test_ignore_bool {
        \use_none:nnn
      } {
        \tl_if_exist:cTF { c__bnvs_##1_regex } {
          \__bnvs_test_extract:cnnn { c__bnvs_##1_regex }
        } {
          \test_fail:n { Bad~name:~##1}
          \use_none:nnn
        }
      }
    }
    \cs_set:Npn \Test_query:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \tl_clear:N \l_tmpa_tl
        \tl_set:Nn \l_tmpb_tl { FAILURE }
        \__bnvs_if_eval_query:nNTF { ##2 } \l_tmpa_tl {
          \assert_equal:xxn { \l_tmpa_tl } { ##3 } {
            Test~\cs{__bnvs_eval_query:nN}:~##4-a
          }
        } {
          \test_fail:n { ##4-CALL }
        }
      }
    }
    \cs_set:Npn \Test_eval:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \BeanovesEval[\l__bnvs_ans_tl]{ ##2 }
        \assert_equal:xxn { \l__bnvs_ans_tl } { ##3 } { ##4 }
      }
    }
    \__bnvs_DEBUG_a:nn {▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎} {}
    \__bnvs_DEBUG_a:xn {TEST~\l__bnvs_banner_tl\space file:~\BeanovesCurrentTestFile, line:~\the\inputlineno} {}
    \tl_set:Nn \l__bnvs_test_done_tl {
  \__bnvs_DEBUG_a:xn { TEST~\l__bnvs_banner_tl...~DONE} {}
  \__bnvs_DEBUG_a:nn {◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀} {}
}
  }
}

\cs_new:Npn \BeanovesCurrentTestFile {
  \tl_if_empty:VF \CurrentFilePath { \CurrentFilePath / }
  \CurrentFile
}






\NewDocumentEnvironment{bnvs.test.expl}{o} {
  \__bnvs_DEBUG_off:
  \tl_set:Nn \l__bnvs_banner_tl { ? }
  \IfValueT {#1} { \keys_set_known:nn {bnvs.test} {#1} }
} {  \ignorespacesafterend }
\cs_set:Npn \__bnvs_test_extract:nnnn #1 #2 #3 #4 {
  \__bnvs_group_begin:
  \tl_if_empty:nT { #3 } {
    \regex_extract_once:nnNT { #1 } { #2 } \l__bnvs_match_seq {
      \test_fail:n { #4-a }
    }
  } {
    \regex_extract_once:nnNTF { #1 } { #2 } \l__bnvs_match_seq {
      \tl_set:Nx \l__bnvs_a_tl { \seq_use:Nn \l__bnvs_match_seq , }
      \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
      \tl_set:Nx \l__bnvs_b_tl { \seq_use:Nn \l__bnvs_split_seq , }
      \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
    } {
      \test_fail:n { #4-a }
    }
  }
  \__bnvs_group_end:
}
\cs_set:Npn \__bnvs_test_extract:Nnnn #1 #2 #3 #4 {
  \__bnvs_group_begin:
  \regex_extract_once:NnNTF #1 { #2 } \l__bnvs_match_seq {
    \tl_set:Nx \l__bnvs_a_tl { \seq_use:Nn \l__bnvs_match_seq , }
    \seq_set_from_clist:Nn \l__bnvs_match_seq { #3 }
    \tl_set:Nx \l__bnvs_b_tl { \seq_use:Nn \l__bnvs_match_seq , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \__bnvs_group_end:
}
\cs_generate_variant:Nn
  \__bnvs_test_extract:Nnnn { cnnn }
\cs_set:Npn \__bnvs_test_split:Nnnn #1 #2 #3 #4 {
  \__bnvs_group_begin:
  \regex_split:NnNTF #1 { #2 } \l__bnvs_split_seq {
    \tl_set:Nx \l__bnvs_a_tl { \seq_use:Nn \l__bnvs_split_seq , }
    \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
    \tl_set:Nx \l__bnvs_b_tl { \seq_use:Nn \l__bnvs_split_seq , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \__bnvs_group_end:
}
\cs_generate_variant:Nn \msg_error:nnnn { nnnx }
\cs_set:Npn \__bnvs_assert_equal:nnn #1 #2 #3 {
  \tl_if_eq:nnF { #1 } { #2 } {
    \msg_error:nnnx { beanoves } { :nn } { FAILED~`#1'!=`#2' } { \BeanovesCurrentTestFile :\the\inputlineno :#3}
    \begin{beanoves.failure}
    \item FAILURE~`#1'!=`#2'~(\BeanovesCurrentTestFile :\the\inputlineno)
    \item #3
    \end{beanoves.failure}
  }
}
\cs_set:Npn \__bnvs_test_fail:n #1 {
  \msg_error:nnnx { beanoves } { :nn } { TEST~FAILED } { \BeanovesCurrentTestFile :\the\inputlineno :#1~(\int_use:N \g__bnvs_call_int)}
  \begin{beanoves.failure}
  \item FAILURE~unexpected~branch~(\BeanovesCurrentTestFile :\the\inputlineno)
  \item #1
  \end{beanoves.failure}
}
\cs_generate_variant:Nn \__bnvs_assert_equal:nnn { xxn }
%</!gubed>
% \end{bnvs.gobble}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% In that case, variables need not follow exactly the \LaTeX3\ naming convention:
% we do not specialize with the module name.
% On execution, next initialization instructions declare the variables as side effect.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_id_last_tl
\tl_set:Nn \l__bnvs_id_last_tl { ?! }
\tl_new:N \l__bnvs_a_tl
\tl_new:N \l__bnvs_b_tl
\tl_new:N \l__bnvs_c_tl
\tl_new:N \l__bnvs_id_tl
\tl_new:N \l__bnvs_ans_tl
\tl_new:N \l__bnvs_name_tl
\tl_new:N \l__bnvs_path_tl
\tl_new:N \l__bnvs_group_tl
\tl_new:N \l__bnvs_query_tl
\tl_new:N \l__bnvs_token_tl
\tl_new:N \l__bnvs_root_tl
\int_new:N \g__bnvs_call_int
\int_new:N \l__bnvs_int
\seq_new:N \g__bnvs_def_seq
\seq_new:N \l__bnvs_a_seq
\seq_new:N \l__bnvs_b_seq
\seq_new:N \l__bnvs_ans_seq
\seq_new:N \l__bnvs_match_seq
\seq_new:N \l__bnvs_split_seq
\seq_new:N \l__bnvs_path_seq
\seq_new:N \l__bnvs_query_seq
\seq_new:N \l__bnvs_token_seq
\bool_new:N \l__bnvs_no_counter_bool
\bool_new:N \l__bnvs_no_range_bool
\bool_new:N \l__bnvs_in_frame_bool
\bool_set_false:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsection{Infinite loop management}
% Unending recursivity is managed here.
% \begin{variable} {\g__bnvs_call_int}
% Some functions calls, as well as some loop bodies, decrement this counter.
% When this counter reaches 0, an error is raised or
% a computation is aborted.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\int_const:Nn \c__bnvs_max_call_int { 2048 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_call_greset:}
% \begin{syntax}
% \cs{__bnvs_call_greset:}
% \end{syntax}
% Reset globally the call stack counter to its maximum value.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
	\cs_set:Npn  \__bnvs_call_greset: {
  \int_gset:Nn \g__bnvs_call_int { \c__bnvs_max_call_int }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
% \begin{function}[TF]{\__bnvs_call:}
% \begin{syntax}
% \cs{__bnvs_call_do:TF} \marg{ true code } \marg{ false code }
% \end{syntax}
% Decrement the \cs{g__bnvs_call_int} counter globally and
% execute \meta{ true code } if we have not reached 0,
% \meta{ false code } otherwise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn  \__bnvs_call: { T, F, TF } {
  \int_gdecr:N \g__bnvs_call_int
  \int_compare:nNnTF \g__bnvs_call_int > 0 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
% 
%
% \subsection{Overlay specification}
% \subsubsection{In slide range definitions}
% \begin{variable} {\g__bnvs_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% The basic keys are, assuming \meta{id}!\meta{name} is a fully qualified overlay set name,
% \begin{description}
% \item [\texttt{\meta{id}!\meta{name}/A}] for the first index
% \item [\texttt{\meta{id}!\meta{name}/*}] non empty if the first index is also a minimum,
% \item [\texttt{\meta{id}!\meta{name}/L}] for the length when provided
% \item [\texttt{\meta{id}!\meta{name}/Z}] for the last index when provided
% \item [\texttt{\meta{id}!\meta{name}/C}] for the counter value, when used
% \item [\texttt{\meta{id}!\meta{name}/C0}] for initial value of the counter (when reset)
% \item [\texttt{\meta{id}!\meta{name}/n}] for the implicit index counter, when used.
% \end{description}
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges. They are characterized by a `|//|'.
% \begin{description}
% \item [\texttt{\meta{id}!\meta{name}//A}] for the cached static value of the first index
% \item [\texttt{\meta{id}!\meta{name}//Z}] for the cached static value of the last index
% \item [\texttt{\meta{id}!\meta{name}//L}] for the cached static value of the length
% \item [\texttt{\meta{id}!\meta{name}//P}] for the cached static value of the previous index
% \item [\texttt{\meta{id}!\meta{name}//N}] for the cached static value of the next index
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \subsection{Basic functions}
% \begin{function}{\__bnvs_gput:nnn,\__bnvs_gput:nVn,\__bnvs_gprovide:nnn,\__bnvs_gprovide:nVn,\__bnvs_item:nn,\__bnvs_gremove:nn,\__bnvs_gclear:n, \__bnvs_gclear:}
% \begin{syntax}
% \cs{__bnvs_gput:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{__bnvs_gprovide:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{__bnvs_item:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_get:nnN} \marg{subkey} \marg{key} \meta{tl variable}
% \cs{__bnvs_gremove:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_clear:n} \marg{key}
% \cs{__bnvs_clear:}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% This is a wrapper over \LaTeX3\ eponym functions,
% except \cs{__bnvs_gprovide:nn} which meaning is straightforward.
% The key argument is \texttt{\meta{key}/\meta{subkey}}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_gput:nnn #1 #2 #3 {
  \prop_gput:Nnn \g__bnvs_prop { #1 / #2 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string \__bnvs_gput:nnn }
\__bnvs_DEBUG:x { SUBKEY = / \tl_to_str:n { #1 } }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #3 } }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_new:Npn \__bnvs_gprovide:nnn #1 #2 #3 {
  \prop_if_in:NnF \g__bnvs_prop { #2 / #1 } {
    \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {\string\__bnvs_gprovide:nnn}
\__bnvs_DEBUG:x { SUBKEY = / \tl_to_str:n { #1 } }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #3 } }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_new:Npn \__bnvs_item:nn #1 #2 {
  \prop_item:Nn \g__bnvs_n_prop { #2 / #1 }
}
\cs_new:Npn \__bnvs_gremove:nn  #1 #2 {
  \prop_gremove:Nn \g__bnvs_prop { #2 / #1 }
}
\cs_new:Npn \__bnvs_gclear:n #1 {
  \__bnvs_gremove:nn {} { #1 }
  \clist_map_inline:nn { A, *, L, Z, C, C0, n } {
    \__bnvs_gremove:nn { ##1 } { #1 }
  }
  \__bnvs_gclear_cache:n { #1 }
}
\cs_new:Npn \__bnvs_gclear: {
  \prop_gclear:N \g__bnvs_prop
}
\cs_generate_variant:Nn \__bnvs_gput:nnn { nVn }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
% \begin{function}[pTF]{\__bnvs_if_in:nn,\__bnvs_if_in:nV}
% \begin{syntax}
% \cs{__bnvs_if_in_p:n} \marg{subkey} \marg{key}
% \cs{__bnvs_if_in:nTF} \marg{subkey} \marg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{subkey}/\meta{key}}, it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_in:nn #1 #2 { p, T, F, TF } {
  \__bnvs_if_in:nTF { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn \__bnvs_if_in:nn {nV} { p, T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_get:nnN}
% \begin{syntax}
% \cs{__bnvs_get:nnNTF} \marg{key} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{true code} when the item is found, \meta{false code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_get:nnN #1 #2 #3 { p, T, F, TF } {
  \prop_get:NnNTF \g__bnvs_prop { #2 / #1 } #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_get:nnNTF...TRUE }
\__bnvs_DEBUG:x { SUBKEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { \string #3 = / \tl_to_str:V #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_get:nnNTF...FALSE }
\__bnvs_DEBUG:x { SUBKEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { \string #3 = / \tl_to_str:V #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn \__bnvs_get:nnN {nV} { p, T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=(put|remove|clear|...):nn...]
% \cs_set:Npn \Test:xxn #1 #2 #3 {
%     \__bnvs_assert_equal:xxn { #1 } { #2 } {\cs{__bnvs_g(put|remove|clear|...):nn}~#3}
%   }
% \__bnvs_gput:nnn X { A } { B }
% \Test:xxn { \__bnvs_item:nn X {A} } { B } { 1 }
% \Test:xxn { \__bnvs_if_in:nnTF X {A} TF } { T } { 3 }
% \Test:xxn { \__bnvs_if_in:nnTF X {B} TF } { F } { 4 }
% \Test:xxn { \__bnvs_if_in:nnT X {A} T } { T } { 5 }
% \Test:xxn { \__bnvs_if_in:nnT X {B} T } { } { 6 }
% \Test:xxn { \__bnvs_if_in:nnF X {A} F } { } { 7 }
% \Test:xxn { \__bnvs_if_in:nnF X {B} F } { F } { 8 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {A} } TF } { T } { 9 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} } TF } { F } { 10 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} || \__bnvs_if_in_p:nn X {A} } TF } { T } { 11 }
% \tl_clear:N \l__bnvs_b_tl
% \__bnvs_get:nnNF X {A} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \__bnvs_get:nnNT X {B} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsection{Functions with cache}
% \begin{function}{\__bnvs_gput_cache:nnn,\__bnvs_gput_cache:nnV,\__bnvs_gremove_cache:nn,\__bnvs_gclear_cache:n}
% \begin{syntax}
% \cs{__bnvs_gput_cache:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{__bnvs_gremove_cache:nn} \marg{subkey} \marg{key}
% \cs{__bnvs_clear_cache:n} \marg{key}
% \end{syntax}
% Wrapper over the functions above for \texttt{\meta{key}/\meta{subkey}}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_gput_cache:nnn #1 {
  \__bnvs_gput:nnn { / #1 }
}
\cs_new:Npn \__bnvs_gremove_cache:nn  #1 {
  \__bnvs_gremove:nn { / #1 }
}
\cs_new:Npn \__bnvs_gclear_cache:n #1 {
  \clist_map_inline:nn { {}, A, L, Z, P, N } {
    \__bnvs_gremove_cache:nn { ##1 } { #1 }
  }
}
\cs_generate_variant:Nn \__bnvs_gput_cache:nnn { nnV }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
% \begin{function}[pTF]{\__bnvs_if_in_cache:nn,\__bnvs_if_in_cache:nV}
% \begin{syntax}
% \cs{__bnvs_if_in_cache_p:n} \marg{subkey} \marg{key}
% \cs{__bnvs_if_in_cache:nTF} \marg{subkey} \marg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{subkey}/\meta{key}}, it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_in_cache:nn #1 #2 { p, T, F, TF } {
  \__bnvs_if_in:nnTF { / #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_in_cache:nn {nV} { p, T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_get_cache:nnN}
% \begin{syntax}
% \cs{__bnvs_get_cache:nnNTF} \marg{subkey} \marg{key} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{true code} when the item is found, \meta{false code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_get_cache:nnN #1 #2 #3 { p, T, F, TF } {
  \__bnvs_get:nnNTF { / #1 } { #2 } #3 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_get_cache:nnN {nV} { p, T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=(put|remove|clear|...):nn...]
% \cs_set:Npn \Test:xxn #1 #2 #3 {
%     \__bnvs_assert_equal:xxn { #1 } { #2 } {\cs{__bnvs_g(put|remove|clear|...):nn}~#3}
%   }
% \__bnvs_gput:nnn X { A } { B }
% \Test:xxn { \__bnvs_item:nn X {A} } { B } { 1 }
% \Test:xxn { \__bnvs_if_in:nnTF X {A} TF } { T } { 3 }
% \Test:xxn { \__bnvs_if_in:nnTF X {B} TF } { F } { 4 }
% \Test:xxn { \__bnvs_if_in:nnT X {A} T } { T } { 5 }
% \Test:xxn { \__bnvs_if_in:nnT X {B} T } { } { 6 }
% \Test:xxn { \__bnvs_if_in:nnF X {A} F } { } { 7 }
% \Test:xxn { \__bnvs_if_in:nnF X {B} F } { F } { 8 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {A} } TF } { T } { 9 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} } TF } { F } { 10 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_in_p:nn X {B} || \__bnvs_if_in_p:nn X {A} } TF } { T } { 11 }
% \tl_clear:N \l__bnvs_b_tl
% \__bnvs_get:nnNF X {A} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \__bnvs_get:nnNT X {B} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsubsection{Implicit index counter}
% The implicit index counter is local to the current frame.
% When used for the first time, it defaults to 1.
% \begin{variable} {\g__bnvs_n_prop}
% \meta{key}--\meta{value} property list to store the named slide lists.
% The keys are \meta{id}!\meta{name}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_n_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{function}{\__bnvs_n_gput:nn,\__bnvs_n_gput:VV,\__bnvs_n_gput:nV,\__bnvs_n_gput:Vn,\__bnvs_n_gprovide:nn,\__bnvs_n_gprovide:nV,\__bnvs_n_item:n,\__bnvs_n_get:nN,\__bnvs_n_get:VN,\__bnvs_n_gremove:n,\__bnvs_n_gclear:}
% \begin{syntax}
% \cs{__bnvs_n_gput:nn} \marg{key} \marg{value}
% \cs{__bnvs_n_gprovide:nn} \marg{key} \marg{value}
% \cs{__bnvs_n_item:n} \marg{key}
% \cs{__bnvs_n_get:nN} \marg{key} \meta{tl variable}
% \cs{__bnvs_n_gremove:n} \marg{key}
% \cs{__bnvs_n_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 eponym functions,
% except \cs{__bnvs_n_gprovide:nn} which meaning is straightforward.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_n_gput:nn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_n_gput:nn...}
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #2 } / }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_n_gput:nn}
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #2 } / }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_new:Npn \__bnvs_n_gprovide:nn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {\string\__bnvs_n_gprovide:nn/key:#1/value:#2/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prop_if_in:NnF \g__bnvs_n_prop { #1 } {
    \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
  }
}
\cs_new:Npn \__bnvs_n_item:n {
  \prop_item:Nn \g__bnvs_n_prop
}
\cs_new:Npn \__bnvs_n_get:nN {
  \prop_get:NnN \g__bnvs_n_prop
}
\cs_new:Npn \__bnvs_n_gremove:n {
  \prop_gremove:Nn \g__bnvs_n_prop
}
\cs_new:Npn \__bnvs_n_gclear: {
  \prop_gclear:N \g__bnvs_n_prop
}
\cs_new:Npn \__bnvs_n_gclear:n #1 {
  \prop_gclear:N \g__bnvs_n_prop
}
\cs_generate_variant:Nn \__bnvs_n_gput:nn { nV, Vn, VV }
\cs_generate_variant:Nn \__bnvs_n_gprovide:nn { nV }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[pTF]{\__bnvs_if_n_in:n,\__bnvs_if_n_in:V}
% \begin{syntax}
% \cs{__bnvs_if_n_in_p:n} \marg{key}
% \cs{__bnvs_if_n_in:nTF} \marg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to test for the existence of some key, it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_n_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_n_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn \__bnvs_if_n_in:n {V} { p, T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_n_get:nN}
% \begin{syntax}
% \cs{__bnvs_n_get:nNTF} \marg{key} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{true code} when the item is found, \meta{false code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_n_get:nN #1 #2 { T, F, TF } {
  \prop_get:NnNTF \g__bnvs_n_prop { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_n_get:nNTF\space TRUE/
  #1/\string#2:#2/
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_n_get:nNTF\space FALSE/#1/\string#2/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_n_get:nN { VN } { T, F, TF }

%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=n_(gput|gremove|gclear|...):nn...]
% \cs_set:Npn \Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } {__bnvs_n_(gput|gremove|gclear|...):nn~#3}
% }
% \__bnvs_n_gput:nn { A } { B }
% \__bnvs_log_n_gprop:
% \Test:xxn { \__bnvs_n_item:n {A} } { B } { 1 }
% \Test:xxn { \__bnvs_if_n_in:nTF {A} TF } { T } { 3 }
% \Test:xxn { \__bnvs_if_n_in:nTF {B} TF } { F } { 4 }
% \Test:xxn { \__bnvs_if_n_in:nT {A} T } { T } { 5 }
% \Test:xxn { \__bnvs_if_n_in:nT {B} T } { } { 6 }
% \Test:xxn { \__bnvs_if_n_in:nF {A} F } { } { 7 }
% \Test:xxn { \__bnvs_if_n_in:nF {B} F } { F } { 8 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_n_in_p:n {A} } TF } { T } { 9 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_n_in_p:n {B} } TF } { F } { 10 }
% \Test:xxn { \bool_if:nTF { \__bnvs_if_n_in_p:n {B} || \__bnvs_if_n_in_p:n {A} } TF } { T } { 11 }
% \tl_clear:N \l__bnvs_b_tl
% \__bnvs_n_get:nNF {A} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \__bnvs_n_get:nNT {B} \l__bnvs_b_tl {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsubsection{Regular expressions}
%
% \begin{variable}{\c__bnvs_name_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_name_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=name_regex]
% \Test_regex:nnnn { name } {A} {A} {1}
% \Test_regex:nnnn { name } {_A1} {_A1} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_id_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_id_regex {
  (?: \ur{c__bnvs_name_regex} | [?] )? !
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=id_regex]
% \Test_regex:nnnn { id } {!} {!} {1}
% \Test_regex:nnnn { id } {_A1!} {_A1!} {2}
% \Test_regex:nnnn { id } {?!} {?!} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_path_regex, \c__bnvs_path_pm_regex}
% A sequence of \texttt{.\meta{positive integer}} items representing a path.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_path_regex {
  (?: \. [-+]? \d+ )*
}
\regex_const:Nn \c__bnvs_path_pm_regex {
  (?: \. \ur{c__bnvs_name_regex} | \. [-+]? \d+ )*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=path_regex]
% \Test_regex:nnnn { path } {} {} {1}
% \Test_regex:nnnn { path } {.1} {.1} {2}
% \Test_regex:nnnn { path } {.1.2} {.1.2} {3}
% \Test_regex:nnnn { path } {.1.-2} {.1.-2} {4}
% \Test_regex:nnnn { path } {.-1} {.-1} {5}
% \Test_regex:nnnn { path } {.-1.2} {.-1.2} {6}
% \Test_regex:nnnn { path } {.-1.-2} {.-1.-2} {7}
% \end{bnvs.test}
% \begin{bnvs.test}[banner=path_pm_regex]
% \Test_regex:nnnn { path_pm } {} {} {1}
% \Test_regex:nnnn { path_pm } {.1} {.1} {2}
% \Test_regex:nnnn { path_pm } {.1.2} {.1.2} {3}
% \Test_regex:nnnn { path_pm } {.1.-2} {.1.-2} {4}
% \Test_regex:nnnn { path_pm } {.-1} {.-1} {5}
% \Test_regex:nnnn { path_pm } {.-1.2} {.-1.2} {6}
% \Test_regex:nnnn { path_pm } {.-1.-2} {.-1.-2} {7}
% \Test_regex:nnnn { path_pm } {.1.n} {.1.n} {2'}
% \Test_regex:nnnn { path_pm } {.1.2.n} {.1.2.n} {3'}
% \Test_regex:nnnn { path_pm } {.1.-2.n} {.1.-2.n} {4'}
% \Test_regex:nnnn { path_pm } {.-1.n} {.-1.n} {5'}
% \Test_regex:nnnn { path_pm } {.-1.2.n} {.-1.2.n} {6'}
% \Test_regex:nnnn { path_pm } {.-1.-2.n} {.-1.-2.n} {7'}
% \Test_regex:nnnn { path_pm } {.n.1} {.n.1} {2''}
% \Test_regex:nnnn { path_pm } {.1.n.2} {.1.n.2} {3''}
% \Test_regex:nnnn { path_pm } {.1.n.-2} {.1.n.-2} {4''}
% \Test_regex:nnnn { path_pm } {.n.-1} {.n.-1} {5''}
% \Test_regex:nnnn { path_pm } {.-1.n.2} {.-1.n.2} {6''}
% \Test_regex:nnnn { path_pm } {.-1.n.-2} {.-1.n.-2} {7''}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_key_regex, \c__bnvs_A_key_Z_regex,\c__bnvs_key_pm_regex, \c__bnvs_A_key_pm_Z_regex}
% A key is the name of a slide range possibly followed by positive integer attributes
% using a dot syntax.
% The `|A_key_Z|' variant matches the whole string.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_key_regex {
  \ur{c__bnvs_id_regex} ?
  \ur{c__bnvs_name_regex}
  \ur{c__bnvs_path_regex}
}
\regex_const:Nn \c__bnvs_key_pm_regex {
  \ur{c__bnvs_id_regex} ?
  \ur{c__bnvs_name_regex}
  \ur{c__bnvs_path_pm_regex}
}
\regex_const:Nn \c__bnvs_A_key_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{itemize}
% \item[2:] slide \meta{id}
% \item[3:] question mark, when \meta{id} is empty
% \item[4:] The range name
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[5:] the path, if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_regex} ) \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{itemize}
% \begin{bnvs.test}[banner=key_regex]
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_extract:Nnnn \c__bnvs_key_regex
% }
% \Test:nnn {A} {A} {1}
% \Test:nnn {_A1} {_A1} {2}
% \Test:nnn {A.1} {A.1} {3}
% \Test:nnn {_A1.1} {_A1.1} {4}
% \Test:nnn {_A1.1.2} {_A1.1.2} {5}
% \Test:nnn {(_A1.1.2)} {_A1.1.2} {6}
% \Test:nnn {X!A} {X!A} {1-a}
% \Test:nnn {X!_A1} {X!_A1} {2-a}
% \Test:nnn {X!A.1} {X!A.1} {3-a}
% \Test:nnn {X!_A1.1} {X!_A1.1} {4-a}
% \Test:nnn {X!_A1.1.2} {X!_A1.1.2} {5-a}
% \Test:nnn {(X!_A1.1.2)} {X!_A1.1.2} {6-a}
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_extract:Nnnn \c__bnvs_A_key_Z_regex
% }
% \Test:nnn {A} {A, A,{},{}} {1}
% \Test:nnn {_A1} {_A1, _A1, {},{}} {2}
% \Test:nnn {A.1} {A.1, A, {}, .1} {3}
% \Test:nnn {_A1.1} {_A1.1, _A1, {}, .1} {4}
% \Test:nnn {_A1.1.2} {_A1.1.2, _A1, {}, .1.2} {5}
% \Test:nnn {?!A} {?!A, ?!A, ?!, {}} {1-?!}
% \Test:nnn {?!_A1} {?!_A1, ?!_A1, ?!, {}} {2-?!}
% \Test:nnn {?!A.1} {?!A.1, ?!A, ?!, .1} {3-?!}
% \Test:nnn {?!_A1.1} {?!_A1.1, ?!_A1, ?!, .1} {4-?!}
% \Test:nnn {?!_A1.1.2} {?!_A1.1.2, ?!_A1, ?!, .1.2} {5-?!}
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_key_pm_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{itemize}
% \item[2:] slide \meta{id}
% \item[3:] question mark, when \meta{id} is empty
% \item[4:] The range name
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[5:] the path, if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_pm_regex} ) \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{itemize}
% \begin{bnvs.test}[banner=key_regex_pm]
% \cs_set:Npn \Test:nn  #1 {
%   \__bnvs_test_extract:Nnnn \c__bnvs_key_pm_regex { #1 } { #1 }
% }
% \Test:nn {A} {1}
% \Test:nn {_A1} {2}
% \Test:nn {A.1} {3}
% \Test:nn {_A1.1} {4}
% \Test:nn {_A1.1.2} {5}
% \Test:nn {X!A} {1-a}
% \Test:nn {X!_A1} {2-a}
% \Test:nn {X!A.1} {3-a}
% \Test:nn {X!_A1.1} {4-a}
% \Test:nn {X!_A1.1.2} {5-a}
% \Test:nn {A.n} {1'}
% \Test:nn {_A1.n} {2'}
% \Test:nn {A.1.n} {3'}
% \Test:nn {_A1.1.n} {4'}
% \Test:nn {_A1.1.2.n} {5'}
% \Test:nn {X!A.n} {1'-a}
% \Test:nn {X!_A1.n} {2'-a}
% \Test:nn {X!A.1.n} {3'-a}
% \Test:nn {X!_A1.1.n} {4'-a}
% \Test:nn {X!_A1.1.2.n} {5'-a}
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_extract:Nnnn \c__bnvs_key_pm_regex
% }
% \Test:nnn {(_A1.1.2)} {_A1.1.2} {6}
% \Test:nnn {(X!_A1.1.2)} {X!_A1.1.2} {6-a}
% \Test:nnn {(_A1.1.2.n)} {_A1.1.2.n} {6'}
% \Test:nnn {(X!_A1.1.2.n)} {X!_A1.1.2.n} {6'-a}
% \cs_set:Npn \Test:nnn #1 #2 {
%   \__bnvs_test_extract:Nnnn \c__bnvs_A_key_pm_Z_regex { #1 } { #1, #2 }
% }
% \Test:nnn {A} {A,{},{}} {1}
% \Test:nnn {_A1} {_A1, {},{}} {2}
% \Test:nnn {A.1} {A, {}, .1} {3}
% \Test:nnn {_A1.1} {_A1, {}, .1} {4}
% \Test:nnn {_A1.1.2} {_A1, {}, .1.2} {5}
% \Test:nnn {?!A} {?!A, ?!, {}} {1-?!}
% \Test:nnn {?!_A1} {?!_A1, ?!, {}} {2-?!}
% \Test:nnn {?!A.1} {?!A, ?!, .1} {3-?!}
% \Test:nnn {?!_A1.1} {?!_A1, ?!, .1} {4-?!}
% \Test:nnn {?!_A1.1.2} {?!_A1, ?!, .1.2} {5-?!}
% \Test:nnn {A.n} {A,{},.n} {1'}
% \Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \Test:nnn {A.1.n} {A, {}, .1.n} {3'}
% \Test:nnn {_A1.1.n} {_A1, {}, .1.n} {4'}
% \Test:nnn {_A1.1.2.n} {_A1, {}, .1.2.n} {5'}
% \Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \Test:nnn {?!A.1.n} {?!A, ?!, .1.n} {3'-?!}
% \Test:nnn {?!_A1.1.n} {?!_A1, ?!, .1.n} {4'-?!}
% \Test:nnn {?!_A1.1.2.n} {?!_A1, ?!, .1.2.n} {5'-?!}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_colons_regex}
% For ranges defined by a colon syntax.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_colons_regex { :(:+)? }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=colons_regex]
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_split:Nnnn \c__bnvs_colons_regex
% }
% \Test:nnn { A:C } {{A},{},{C}} {1}
% \Test:nnn { A::C } {{A},{:},{C}} {2}
% \Test:nnn { A:::C } {{A},{::},{C}} {3}
% \Test:nnn { :B::C } {{},{},{B},{:},{C}} {4}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_list_regex}
% A comma separated list between square brackets.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_list_regex {
  \A \s* \[
%    \end{macrocode}
% \end{bnvs.macrocode}
% Capture groups:
% \begin{myList}
% \item 2: the content between the brackets, outer spaces trimmed out
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( [^\] %[---
    ]*? )
  \s* \] \Z
}
\regex_const:Nn \c__bnvs_list_pm_regex {
  \A \s* \[ %---]
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}[banner=list_pm_regex]
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_extract:Nnnn \c__bnvs_list_pm_regex
% }
% \Test:nnn {[]} {[} {1}
% \Test:nnn {]} {} {2}
% \end{bnvs.test}
% \begin{bnvs.test}[banner=list_regex]
% \cs_set:Npn \Test:nnn {
%   \__bnvs_test_extract:Nnnn \c__bnvs_list_regex
% }
% \Test:nnn {[]} {[],{}} {1}
% \Test:nnn {[x]} {[x], x} {2}
% \Test:nnn {[~x~]} {[~x~],{~x}} {3}
% \Test:nnn {[~x[~]} {[~x[~],{~x[}} {4}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 10 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{bnvs.macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}. We have on one hand 3 capture groups for pre |++| operator and on the other hand 16-3 capture groups.
%   \begin{myList}
%   \item 1: \meta{name} of a slide range
%   \item 2: \meta{id} of a slide range including the exclamation mark 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \+\+ ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 3: optionally followed by an integer path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/++...]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{},{},{},{},{},{},{},{},{}} { 1|2|3-#4~(++...) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ++ABC } {} {{ABC},{},{}} {a}
% \Test:nnnn { ++ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ++?!ABC } {} {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ++?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ++?!ABC.1.2~X~ } {++?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
% We continue with other expressions
%   \item 4: qualified \meta{name} of a slide range,
%   \item 5: \meta{id} of a slide range plus the exclamation mark
% (to manage void \meta{id})
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  | ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 6: optionally followed by an integer path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% Next comes another branching
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    (?:
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 7: the \meta{length} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
       \. l(e)ngth
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.length]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{e},{},{},{},{},{},{},{},{},{},{}} { 7-#4~(.length) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { A.length } {} {{A},{},{}} {a}
% \Test:nnnn { A.1.2.length } {} {{A},{},{.1.2}} {b}
% \Test:nnnn { ?!A.length } {} {{?!A},{?!},{}} {c}
% \Test:nnnn { ?!A.1.2.length } {} {{?!A},{?!},{.1.2}} {d}
% \Test:nnnn { ?!A.1.2.length~X } {?!A.1.2.length~} {{?!A},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 8: the \meta{last} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \. l(a)st
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.last]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{a},{},{},{},{},{},{},{},{},{}} { 8-#4~(.last) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { A.last } {} {{A},{},{}} {a}
% \Test:nnnn { A.1.2.last } {} {{A},{},{.1.2}} {b}
% \Test:nnnn { ?!A.last } {} {{?!A},{?!},{}} {c}
% \Test:nnnn { ?!A.1.2.last } {} {{?!A},{?!},{.1.2}} {d}
% \Test:nnnn { ?!A.1.2.last~X~ } { ?!A.1.2.last~ } {{?!A},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 9: the \meta{next} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \. (p)revious
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.previous]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{p},{},{},{},{},{},{},{},{}} { 9-#4~(.previous) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { A.previous } {} {{A},{},{}} {a}
% \Test:nnnn { A.1.2.previous } {} {{A},{},{.1.2}} {b}
% \Test:nnnn { ?!A.previous } {} {{?!A},{?!},{}} {c}
% \Test:nnnn { ?!A.1.2.previous } {} {{?!A},{?!},{.1.2}} {d}
% \Test:nnnn { ?!A.1.2.previous~X~ } {?!A.1.2.previous~} {{?!A},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 10: the \meta{next} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \. ne(x)t
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.next]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{},{x},{},{},{},{},{},{},{}} { 10-#4~(.next) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { A.next } {} {{A},{},{}} {a}
% \Test:nnnn { A.1.2.next } {} {{A},{},{.1.2}} {b}
% \Test:nnnn { ?!A.next } {} {{?!A},{?!},{}} {c}
% \Test:nnnn { ?!A.1.2.next } {} {{?!A},{?!},{.1.2}} {d}
% \Test:nnnn { ?!A.1.2.next~X~ } {?!A.1.2.next~} {{?!A},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 11: the \meta{range} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \. (r)ange
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.range]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{},{},{r},{},{},{},{},{},{}} { 11-#4~(.range) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { A.range } {} {{A},{},{}} {a}
% \Test:nnnn { A.1.2.range } {} {{A},{},{.1.2}} {b}
% \Test:nnnn { ?!A.range } {} {{?!A},{?!},{}} {c}
% \Test:nnnn { ?!A.1.2.range } {} {{?!A},{?!},{.1.2}} {d}
% \Test:nnnn { ?!A.1.2.range~X~ } {?!A.1.2.range~} {{?!A},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 12: the \meta{++n} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \.(\+)\+n
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.++n]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{},{},{},{+},{},{},{},{},{} } { 12-#4~(.++n) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC.++n } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2.++n~~ } {}  {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC.++n } {}  {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2.++n~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2.++n~X~ } { ?!ABC.1.2.++n~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 13: the \meta{n} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \. (n)
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.n]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{},{},{},{},{n},{},{},{},{} } { 13-#4~(.n) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC.n } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2.n~~ } {} {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC.n } {} {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2.n~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2.n~X~ } {?!ABC.1.2.n~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 14: the poor man integer expression after `|.n+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    (?: \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner={\string\c__bnvs_split_regex/.n+=}]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{} } { 14-#4~(.n+=) } 
% }
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl { #3,{},{},{},{},{},{},{n},{#4} }
% }
% \Test:nnnnn { ABC.n += 421 } {} {{ABC}, {}, {}} {421} {a}
% \Test:nnnnn { ABC.n += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {b}
% \Test:nnnnn { ABC.n += 1+P.1~X } { ABC.n += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {c}
% \Test:nnnnn { ABC.n += (P.1+1)~~^^A(
% ) } { ABC.n += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {d}
% \Test:nnnnn { ?!ABC.n += 421 } {} {{?!ABC}, {?!}, {}} {421} {e}
% \Test:nnnnn { ?!ABC.n += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {f}
% \Test:nnnnn { ?!ABC.n += 1+P.1~X } {?!ABC.n += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {g}
% \Test:nnnnn { ?!ABC.n += (P.1+1)~~^^A(
% ) } {?!ABC.n += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {h}
% \end{bnvs.test}
%   \item 15: the \meta{n++} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      | (\+)\+ )?
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/.n++]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{},{},{},{},{n},{},{+},{},{}} { 15-#4~(.n++) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC.n++ } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2.n++~~ } {}  {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC.n++ } {}  {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2.n++~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2.n++~X~ } { ?!ABC.1.2.n++~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 16: the poor man integer expression after `|+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    |  \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner={\string\c__bnvs_split_regex/+=}]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{} } { 16-#4~(+=) } 
% }
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl { #3,{},{},{},{},{},{},{},{},{},#4 }
% }
% \Test:nnnnn { ABC += 421 } {} {{ABC}, {}, {}} {421} {`+='~1}
% \Test:nnnnn { ABC += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {`+='~2}
% \Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {`+='~3}
% \Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {`+='~4}
% \Test:nnnnn { ?!ABC += 421 } {} {{?!ABC}, {?!}, {}} {421} {`+='~5}
% \Test:nnnnn { ?!ABC += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {`+='~6}
% \Test:nnnnn { ?!ABC += 1+P.1~X } {?!ABC += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {`+='~7}
% \Test:nnnnn { ?!ABC += (P.1+1)~~^^A(
% ) } {?!ABC += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {`+='~8}
% \end{bnvs.test}
%   \item 17: the post increment
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | (\+)\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/++]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{},{},{},{},{},{},{},{},{+}} { 17-#4~(...++) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC++ } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2++~~ } {} {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC++ } {} {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2++~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2++~X~ } {?!ABC.1.2++~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
% \end{myList}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  )? ) \s*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_regex/split]
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__bnvs_test_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},{},{},{},{},{},{},{},{},/2 } { split-#3 }
% }
% \Test:nnn { ++A }     {{A},{},{}} { 1-a }
% \Test:nnn { ++?!A }   {{?!A},{?!},{}} { 1-b }
% \Test:nnn { ++A.3 }   {{A},{},{.3}} { 1-c }
% \Test:nnn { ++?!A.3 } {{?!A},{?!},{.3}} { 1-d }
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__bnvs_test_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,{},{},{},#2,/2 } { split-#3 }
% }
% \Test:nnn { A.++n }   {{A},{},{},{},{},{},{},{},{+},{},{},{},{},{}} { 2-a }
% \Test:nnn { ?!A.++n } {{?!A},{?!},{},{},{},{},{},{},{+},{},{},{},{},{}} { 2-b }
% \Test:nnn { A.3.++n } {{A},{},{.3},{},{},{},{},{},{+},{},{},{},{},{}} { 1-c }
% \Test:nnn {?!A.3.++n} {{?!A},{?!},{.3},{},{},{},{},{},{+},{},{},{},{},{}} { 1-d }
% \Test:nnn { A }   {{A},{},{},{},{},{},{},{},{},{},{},{},{},{}} { 2-a }
% \Test:nnn { A.n } {{A},{},{},{},{},{},{},{},{},{n},{},{},{},{}} { 2-b }
% \Test:nnn { ?!A } {{?!A},{?!},{},{},{},{},{},{},{},{},{},{},{},{}} { 2-c }
% \Test:nnn { ?!A.n } {{?!A},{?!},{},{},{},{},{},{},{},{n},{},{},{},{}} { 2-d }
% \Test:nnn { A.3 } {{A},{},{.3},{},{},{},{},{},{},{},{},{},{},{}} { 2-e }
% \Test:nnn { A.3.n } {{A},{},{.3},{},{},{},{},{},{},{n},{},{},{},{}} { 2-f }
% \Test:nnn { ?!A.3 } {{?!A},{?!},{.3},{},{},{},{},{},{},{},{},{},{},{}} { 2-g }
% \Test:nnn { ?!A.3.n } {{?!A},{?!},{.3},{},{},{},{},{},{},{n},{},{},{},{}} { 2-h }
% \Test:nnn { A++ }   {{A},{},{},{},{},{},{},{},{},{},{},{},{},{+}} { 3-a }
% \Test:nnn { A.n++ }   {{A},{},{},{},{},{},{},{},{},{n},{},{+},{},{}} { 3-b }
% \Test:nnn { ?!A++ } {{?!A},{?!},{},{},{},{},{},{},{},{},{},{},{},{+}} { 3-c }
% \Test:nnn { ?!A.n++ } {{?!A},{?!},{},{},{},{},{},{},{},{n},{},{+},{},{}} { 3-d }
% \Test:nnn { A.3++ } {{A},{},{.3},{},{},{},{},{},{},{},{},{},{},{+}} { 3-e }
% \Test:nnn { A.3.n++ } {{A},{},{.3},{},{},{},{},{},{},{n},{},{+},{},{}} { 3-f }
% \Test:nnn { ?!A.3++ } {{?!A},{?!},{.3},{},{},{},{},{},{},{},{},{},{},{+}} { 3-g }
% \Test:nnn { ?!A.3.n++ } {{?!A},{?!},{.3},{},{},{},{},{},{},{n},{},{+},{},{}} { 3-h }
% \Test:nnn { A.length } {{A},{},{},{e},{},{},{},{},{},{},{},{},{},{}} { 4-a }
% \Test:nnn { A.3.length } {{A},{},{.3},{e},{},{},{},{},{},{},{},{},{},{}} { 4-b }
% \Test:nnn { ?!A.length } {{?!A},{?!},{},{e},{},{},{},{},{},{},{},{},{},{}} { 4-c }
% \Test:nnn { ?!A.3.length } {{?!A},{?!},{.3},{e},{},{},{},{},{},{},{},{},{},{}} { 4-d }
% \Test:nnn { A.last } {{A},{},{},{},{a},{},{},{},{},{},{},{},{},{}} { 5-a }
% \Test:nnn { ?!A.last } {{?!A},{?!},{},{},{a},{},{},{},{},{},{},{},{},{}} { 5-b }
% \Test:nnn { A.3.last } {{A},{},{.3},{},{a},{},{},{},{},{},{},{},{},{}} { 5-c }
% \Test:nnn { ?!A.3.last } {{?!A},{?!},{.3},{},{a},{},{},{},{},{},{},{},{},{}} { 5-d }
% \Test:nnn { A.previous } {{A},{},{},{},{},{p},{},{},{},{},{},{},{},{}} { 6-a }
% \Test:nnn { ?!A.previous } {{?!A},{?!},{},{},{},{p},{},{},{},{},{},{},{},{}} { 6-b }
% \Test:nnn { A.3.previous } {{A},{},{.3},{},{},{p},{},{},{},{},{},{},{},{}} { 6-c }
% \Test:nnn { ?!A.3.previous } {{?!A},{?!},{.3},{},{},{p},{},{},{},{},{},{},{},{}} { 6-d },{},{},{}
% \Test:nnn { A.next } {{A},{},{},{},{},{},{x},{},{},{},{},{},{},{}} { 6-a }
% \Test:nnn { ?!A.next } {{?!A},{?!},{},{},{},{},{x},{},{},{},{},{},{},{}} { 6-b }
% \Test:nnn { A.3.next } {{A},{},{.3},{},{},{},{x},{},{},{},{},{},{},{}} { 6-c }
% \Test:nnn { ?!A.3.next } {{?!A},{?!},{.3},{},{},{},{x},{},{},{},{},{},{},{}} { 6-d },{},{},{}
% \Test:nnn { A.range } {{A},{},{},{},{},{},{},{r},{},{},{},{},{},{}} { 7-a }
% \Test:nnn { ?!A.range } {{?!A},{?!},{},{},{},{},{},{r},{},{},{},{},{},{}} { 7-b }
% \Test:nnn { A.3.range } {{A},{},{.3},{},{},{},{},{r},{},{},{},{},{},{}} { 7-c }
% \Test:nnn { ?!A.3.range } {{?!A},{?!},{.3},{},{},{},{},{r},{},{},{},{},{},{}} { 7-d }
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_pm_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 7 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_pm_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{bnvs.macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \+\+
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \begin{myList}
%   \item 1: \meta{name} of a slide range
%   \item 2: \meta{id} of a slide range including the exclamation mark 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 3: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_pm_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_pm_regex/]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_pm_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{}} { 1|2|3-#4 } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ++ABC } {} {{ABC},{},{}} {a'}
% \Test:nnnn { ++ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b'}
% \Test:nnnn { ++?!ABC } {} {{?!ABC},{?!},{}} {c'}
% \Test:nnnn { ++?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d'}
% \Test:nnnn { ++?!ABC.1.2~X~ } {++?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e'}
% \end{bnvs.test}
%   \item 4: \meta{name} of a slide range
%   \item 5: \meta{id} of a slide range including the exclamation mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 6: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      ( \ur{c__bnvs_path_pm_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_pm_regex/]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_pm_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{}} { 4|5|6-#4 } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC } {} {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2~X~ } {?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e}
% \Test:nnnn { ABC.3.N.n~~ } {} {{ABC},{},{.3.N.n}} {f}
% \end{bnvs.test}
% We continue with other expressions
%   \item 7: the \meta{++n} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      (?: \.(\+)\+n
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_pm_regex/.++n]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_pm_regex
%     { #1 }
%     { {#2},{},{},{},#3,{+},{},{} } { 7-#4~(.++n) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC.++n } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2.++n~~ } {}  {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC.++n } {}  {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2.++n~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2.++n~X~ } { ?!ABC.1.2.++n~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 8: the poor man integer expression after `|+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      |  \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner={\string\c__bnvs_split_pm_regex/+=}]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { `+='~#4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_pm_regex
%     { #1 }
%     { {#2},{},{},{},#3,{} } { 8-#4~(+=) } 
% }
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl { #3, {}, #4 }
% }
% \Test:nnnnn { ABC += 421 } {} {{ABC}, {}, {}} {421} {1}
% \Test:nnnnn { ABC += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {2}
% \Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {3}
% \Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {4}
% \Test:nnnnn { ?!ABC += 421 } {} {{?!ABC}, {?!}, {}} {421} {5}
% \Test:nnnnn { ?!ABC += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {6}
% \Test:nnnnn { ?!ABC += 1+P.1~X } {?!ABC += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {7}
% \Test:nnnnn { ?!ABC += (P.1+1)~~^^A(
% ) } {?!ABC += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {8}
% \end{bnvs.test}
%   \item 9: the post increment
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      | (\+)\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_pm_regex/...++]
% \cs_set:Npn \:nnnn #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \__bnvs_test_extract:Nnnn \c__bnvs_split_pm_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{+}} { 9-#4~(...++) } 
% }
% \cs_set:Npn \Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%   } {
%     \exp_not:n { #2 }
%   } }
%   \exp_args:NnV
%   \:nnnn { #1 } \l__bnvs_a_tl
% }
% \Test:nnnn { ABC++ } {} {{ABC},{},{}} {a}
% \Test:nnnn { ABC.1.2++~~ } {} {{ABC},{},{.1.2}} {b}
% \Test:nnnn { ?!ABC++ } {} {{?!ABC},{?!},{}} {c}
% \Test:nnnn { ?!ABC.1.2++~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \Test:nnnn { ?!ABC.1.2++~X~ } {?!ABC.1.2++~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
% \end{myList}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    )?
  ) \s*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\c__bnvs_split_pm_regex/split]
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__bnvs_test_split:Nnnn \c__bnvs_split_pm_regex
%  { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},/2 } { split-#3 }
% }
% \Test:nnn { ++A }     {{A},{},{}} { 1-a }
% \Test:nnn { ++?!A }   {{?!A},{?!},{}} { 1-b }
% \Test:nnn { ++A.3 }   {{A},{},{.3}} { 1-c }
% \Test:nnn { ++?!A.3 } {{?!A},{?!},{.3}} { 1-d }
% \cs_set:Npn \Test:nnn #1 #2 #3 {
%   \__bnvs_test_split:Nnnn \c__bnvs_split_pm_regex
%  { 1/#1/2 } { 1/,{},{},{},#2,/2 } { split-#3 }
% }
% \Test:nnn { A.++n }   {{A},{},{},{+},{},{}} { 2-a' }
% \Test:nnn { ?!A.++n } {{?!A},{?!},{},{+},{},{}} { 2-b' }
% \Test:nnn { A.3.++n } {{A},{},{.3},{+},{},{}} { 2-c' }
% \Test:nnn {?!A.3.++n} {{?!A},{?!},{.3},{+},{},{}} { 2-d' }
% \Test:nnn { A }   {{A},{},{},{},{},{}} { 2-a }
% \Test:nnn { A.n } {{A},{},{.n},{},{},{}} { 2-b }
% \Test:nnn { ?!A } {{?!A},{?!},{},{},{},{}} { 2-c }
% \Test:nnn { ?!A.n } {{?!A},{?!},{.n},{},{},{}} { 2-d }
% \Test:nnn { A.3 } {{A},{},{.3},{},{},{}} { 2-e }
% \Test:nnn { A.3.n } {{A},{},{.3.n},{},{},{}} { 2-f }
% \Test:nnn { A.N.3.n } {{A},{},{.N.3.n},{},{},{}} { 2-f' }
% \Test:nnn { ?!A.3 } {{?!A},{?!},{.3},{},{},{}} { 2-g }
% \Test:nnn { ?!A.3.n } {{?!A},{?!},{.3.n},{},{},{}} { 2-h }
% \Test:nnn { A++ }   {{A},{},{},{},{},{+}} { 3-a }
% \Test:nnn { A.n++ }   {{A},{},{.n},{},{},{+}} { 3-b }
% \Test:nnn { ?!A++ } {{?!A},{?!},{},{},{},{+}} { 3-c }
% \Test:nnn { ?!A.n++ } {{?!A},{?!},{.n},{},{},{+}} { 3-d }
% \Test:nnn { A.3++ } {{A},{},{.3},{},{},{+}} { 3-e }
% \Test:nnn { A.3.n++ } {{A},{},{.3.n},{},{},{+}} { 3-f }
% \Test:nnn { ?!A.3++ } {{?!A},{?!},{.3},{},{},{+}} { 3-g }
% \Test:nnn { ?!A.3.n++ } {{?!A},{?!},{.3.n},{},{},{+}} { 3-h }
% \Test:nnn { A.length } {{A},{},{.length},{},{},{}} { 4-a }
% \Test:nnn { A.3.length } {{A},{},{.3.length},{},{},{}} { 4-b }
% \Test:nnn { ?!A.length } {{?!A},{?!},{.length},{},{},{}} { 4-c }
% \Test:nnn { ?!A.3.length } {{?!A},{?!},{.3.length},{},{},{}} { 4-d }
% \Test:nnn { A.last } {{A},{},{.last},{},{},{}} { 5-a }
% \Test:nnn { ?!A.last } {{?!A},{?!},{.last},{},{},{}} { 5-b }
% \Test:nnn { A.3.last } {{A},{},{.3.last},{},{},{}} { 5-c }
% \Test:nnn { ?!A.3.last } {{?!A},{?!},{.3.last},{},{},{}} { 5-d }
% \Test:nnn { A.previous } {{A},{},{.previous},{},{},{}} { 6-a }
% \Test:nnn { ?!A.previous } {{?!A},{?!},{.previous},{},{},{}} { 6-b }
% \Test:nnn { A.3.previous } {{A},{},{.3.previous},{},{},{}} { 6-c }
% \Test:nnn { ?!A.3.previous } {{?!A},{?!},{.3.previous},{},{},{}} { 6-d }
% \Test:nnn { A.next } {{A},{},{.next},{},{},{}} { 6-a }
% \Test:nnn { ?!A.next } {{?!A},{?!},{.next},{},{},{}} { 6-b }
% \Test:nnn { A.3.next } {{A},{},{.3.next},{},{},{}} { 6-c }
% \Test:nnn { ?!A.3.next } {{?!A},{?!},{.3.next},{},{},{}} { 6-d }
% \Test:nnn { A.range } {{A},{},{.range},{},{},{}} { 7-a }
% \Test:nnn { ?!A.range } {{?!A},{?!},{.range},{},{},{}} { 7-b }
% \Test:nnn { A.3.range } {{A},{},{.3.range},{},{},{}} { 7-c }
% \Test:nnn { ?!A.3.range } {{?!A},{?!},{.3.range},{},{},{}} { 7-d }
% \end{bnvs.test}
% \end{variable}
%
% \subsubsection{\pkg{beamer.cls} interface}
% Work in progress.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\RequirePackage{keyval}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l__bnvs_id_last_tl { #1 ! }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
  \__bnvs_DEBUG_on:
  \__bnvs_DEBUG:x {THIS_IS_KEY}
  \__bnvs_DEBUG_off:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/before}{
  \__bnvs_n_gclear:
  \bool_set_true:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
  \__bnvs_DEBUG_a:nn {THIS_IS_BEFORE} {}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/after}{
  \bool_set_false:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
  \__bnvs_DEBUG_a:nn {THIS_IS_AFTER} {}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsubsection{Defining named slide ranges}
%
% \begin{function}{\__bnvs_parse:Nnn}
%   \begin{syntax}
%     \cs{__bnvs_parse:Nnn} \meta{command} \marg{key} \marg{definition}
%   \end{syntax}
% Auxiliary function called within a group.
% \meta{key} is the overlay reference key, 
% including eventually a dotted path and a frame identifier,
% \meta{definition} is the corresponding definition.
% \meta{command} is \cs{__bnvs_range:nVVV} at runtime.
% \begin{variable}{\l__bnvs_match_seq}
% Local storage for the match result.
% \end{variable}
% \end{function}
%
% \begin{function}{\__bnvs_range:Nnnnn}
%   \begin{syntax}
%     \cs{__bnvs_range:Nnnnn} \meta{boolean} \marg{key} \marg{first} \marg{length} \marg{last}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% The first argument is \cs{c_true_bool} to override and \cs{c_false_bool}
% to just provide.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_range:Nnnnn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_range:Nnnnn }
\__bnvs_DEBUG:x { TORF = / \string#1 / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \bool_if:NTF #1 {
    \__bnvs_n_gremove:n { #2 }
    \__bnvs_gclear_cache:n { #2 }
    \__bnvs_range:nnnn { #2 }
  } {
    \__bnvs_if_in:nnTF A { #2 } {
      \use_none:nnn
    } {
      \__bnvs_if_in:nnTF L { #2 } {
        \use_none:nnn
      } {
        \__bnvs_if_in:nnTF Z { #2 } {
          \use_none:nnn
        } {
          \__bnvs_range:nnnn { #2 }
        }
      }
    }
  }
}
\cs_generate_variant:Nn \__bnvs_range:Nnnnn { NnVVV }
\cs_new:Npn \__bnvs_range:nnnn #1 #2 #3 #4 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_range:nnnn... }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { FIRST = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { LENGTH = / \tl_to_str:n { #3 } / }
\__bnvs_DEBUG:x { LAST = / \tl_to_str:n { #4 } / }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #3 } {
    \tl_if_empty:nTF { #2 } {
      \tl_if_empty:nTF { #4 } {
        \__bnvs_error:n { Not~a~range:~:~#1 }
      } {
        \__bnvs_gput:nnn Z { #1 } { #4 }
      }
    } {
      \__bnvs_gput:nnn A { #1 } { #2 }
      \tl_if_empty:nF { #4 } {
        \__bnvs_gput:nnn Z { #1 } { #4 }
        \__bnvs_gput:nnn L { #1 } { #1.last - (#1.1) + 1 }
      }
    }
  } {
    \tl_if_eq:nnTF { #3 } { * } {
      \tl_if_empty:nTF { #2 } {
        \tl_if_empty:nF { #4 } {
          \__bnvs_gput:nnn Z { #1 } { #4 }
        }
      } {
        \__bnvs_gput:nnn A { #1 } { #2 }
        \__bnvs_gput:nnn * { #1 } { * }
      }
    } {
      \tl_if_empty:nTF { #2 } {
        \__bnvs_gput:nnn L { #1 } { #3 }
        \tl_if_empty:nF { #4 } {
          \__bnvs_gput:nnn Z { #1 } { #4 }
          \__bnvs_gput:nnn A { #1 } { #1.last - (#1.length) + 1 }
        }
      } {
        \__bnvs_gput:nnn A { #1 } { #2 }
        \__bnvs_gput:nnn L { #1 } { #3 }
        \__bnvs_gput:nnn Z { #1 } { #1.1 + #1.length - 1 }
      }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_range:Nnnnn }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { FIRST = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { LENGTH = / \tl_to_str:n { #3 } / }
\__bnvs_DEBUG:x { LAST = / \tl_to_str:n { #4 } / }
\__bnvs_log_gprop:
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=range]
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {#1} } { #2 } {\cs{__bnvs_range:nnnn}~#5~A }
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {#1} } { #3 } {\cs{__bnvs_range:nnnn}~#5~L }
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {#1} } { #4 } {\cs{__bnvs_range:nnnn}~#5~Z }
% }
% \cs_new:Npn \range:nnnn {
%   \__bnvs_parse_pm:Nn \c_true_bool
% }
% \range:nnnn {X} {FIRST} {} {}
% \Test { X } {FIRST} {} {} {TestB~\cs{__bnvs_range:nnnn}~X}
% \range:nnnn {X} {} {LENGTH} {}
% \Test { X } {} {LENGTH} {} {TestC~\cs{__bnvs_range:nnnn}~X.1}
% \range:nnnn {X} {} {} {LAST}
% \Test { X } {} {} {LAST} {TestC~\cs{__bnvs_range:nnnn}~X.1}
% \range:nnnn {X.1} {FIRST} {} {}
% \Test { X.1 } {FIRST} {} {} {TestB~\cs{__bnvs_range:nnnn}~X.1}
% \range:nnnn {X.1} {} {LENGTH} {}
% \Test { X.1 } {} {LENGTH} {} {TestC~\cs{__bnvs_range:nnnn}~X.1}
% \range:nnnn {X.1} {} {} {LAST}
% \Test { X.1 } {} {} {LAST} {TestC~\cs{__bnvs_range:nnnn}~X.1}
% \range:nnnn {X} {FIRST} {LENGTH} {}
% \Test { X } {FIRST} {LENGTH} {X.1+X.length-1} {\cs{__bnvs_range:nnnn}~a}
% \range:nnnn {X} {FIRST} {} {LAST}
% \Test { X } {FIRST} {X.last-(X.1)+1} {LAST} {\cs{__bnvs_range:nnnn}~b}
% \range:nnnn {X} {} {LENGTH} {LAST}
% \Test { X } {X.last-(X.length)+1} {LENGTH} {LAST} {\cs{__bnvs_range:nnnn}~c}
% \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%   \cs_set:Npn \Test ##1 ##2 ##3 ##4 ##5 { }
% }
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__bnvs_assert_equal:xxn { MISSING~ERROR } {  } {\cs{__bnvs_range:nnnn}~#5~Z }
% }
% \range:nnnn {X} {} {} {}
% \Test { X } {} {} {} {TestA~\cs{__bnvs_range:nnnn}~X}
% \cs_set:Npn \Test #1 #2 #3 #4 #5 {
%   \__bnvs_assert_equal:xxn { MISSING~ERROR } {  } {\cs{__bnvs_range:nnnn}~#5~Z }
% }
% \range:nnnn {X.1} {} {} {}
% \Test { X.1 } {} {} {} {TestA~\cs{__bnvs_range:nnnn}~X.1}
% \end{bnvs.test}
% \begin{function}{\__bnvs_parse:Nn}
%   \begin{syntax}
%     \cs{__bnvs_parse:Nn} \meta{command} \marg{key}
%   \end{syntax}
% Define a hidden range, for which slides are never shown.
% This is useful to conditionally show or hide a sequence of slides.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_parse:Nn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_parse:Nn... }
\__bnvs_DEBUG:x { CMD = \string #1 }
\__bnvs_DEBUG:x { KEY = / #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \__bnvs_id_name_set:nNNTF { #2 } \l__bnvs_id_tl \l__bnvs_name_tl {
    \__bnvs_gput:nVn C  \l__bnvs_name_tl { 1 }
    \__bnvs_gput:nVn {} \l__bnvs_name_tl { 1 }
    \exp_args:NNNV
    \__bnvs_group_end:
    \tl_set:Nn \l__bnvs_id_last_tl \l__bnvs_id_last_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse:Nn...DONE }
\__bnvs_DEBUG:x { CMD = / \string #1 / }
\__bnvs_DEBUG:x { KEY = / #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \__bnvs_error:n { Unexpected~key:~#2 }
    \__bnvs_group_end:
  }
}
\cs_new:Npn \__bnvs_parse_pm:Nn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_parse_pm:Nn... }
\__bnvs_DEBUG:x { TORF = / \string #1 / }
\__bnvs_DEBUG:x { KEY = / #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \regex_match:NnTF \c__bnvs_list_regex { #2 } {
    \tl_if_empty:NTF \l__bnvs_root_tl {
      \__bnvs_error:x { No~[...]~list~at~top~level.}
    } {
      \__bnvs_group_begin:
      \int_clear:N \l__bnvs_int
      \__bnvs_parse_list:Nn #1 #2
      \__bnvs_group_end:
    }
  } {
    \tl_if_empty:NTF \l__bnvs_root_tl {
      \__bnvs_id_name_set:nNNTF { #2 } \l__bnvs_id_tl \l__bnvs_name_tl {
        \bool_if:NTF #1 {
          \exp_args:NnV \__bnvs_gput:nnn C  \l__bnvs_name_tl { 1 }
          \exp_args:NnV \__bnvs_gput:nnn {} \l__bnvs_name_tl { 1 }
        } {
          \exp_args:NnV \__bnvs_gprovide:nnn C  \l__bnvs_name_tl { 1 }
          \exp_args:NnV \__bnvs_gprovide:nnn {} \l__bnvs_name_tl { 1 }
        }
        \exp_args:NNNV
        \__bnvs_group_end:
        \tl_set:Nn \l__bnvs_id_last_tl \l__bnvs_id_last_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse:Nn...Complete }
\__bnvs_DEBUG:x { TORF = / \string #1 / }
\__bnvs_DEBUG:x { KEY = / #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      } {
        \__bnvs_error:n { Unexpected~key:~#2 }
        \__bnvs_group_end:
      }
    } {
      \int_incr:N \l__bnvs_int
      \__bnvs_parse_record:Nxn #1 {
        \l__bnvs_root_tl . \int_use:N \l__bnvs_int
      } { #2 }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
%
% \begin{function}[TF]{\__bnvs_parse_range:nNNN}
%   \begin{syntax}
%     \cs{__bnvs_parse_range:nNNN} \marg{input} \meta{first tl} \meta{length tl} \meta{last tl} \marg{true code} \marg{false code}
%   \end{syntax}
% Parse \meta{input} as a range according to \cs{c__bnvs_colons_regex}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVV }
\cs_new:Npn \__bnvs_range_set:NNNn #1 #2 #3 #4 {
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {\string\__bnvs_range_set:nNNNTF}
\__bnvs_DEBUG:x {/\string#1/\string#2/\string#3/}
\__bnvs_DEBUG:x {input=/#4/}
%</!gubed>
% \end{bnvs.gobble}
% This is not a list.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \tl_clear:N \l__bnvs_a_tl
  \tl_clear:N \l__bnvs_b_tl
  \tl_clear:N \l__bnvs_c_tl
  \regex_split:NnN \c__bnvs_colons_regex { #4 } \l__bnvs_split_seq
  \seq_pop_left:NNT \l__bnvs_split_seq \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l__bnvs_a_tl} may contain the \meta{start}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_pop_left:NNT \l__bnvs_split_seq \l__bnvs_b_tl {
      \tl_if_empty:NTF \l__bnvs_b_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a one colon range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_b_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l__bnvs_b_tl} may contain the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \seq_pop_left:NNT \l__bnvs_split_seq \l__bnvs_c_tl {
          \tl_if_empty:NTF \l__bnvs_c_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% A |::| was expected:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \__bnvs_error:n { Invalid~range~expression(1):~#4 }
          } {
            \int_compare:nNnT { \tl_count:N \l__bnvs_c_tl } > { 1 } {
              \__bnvs_error:n { Invalid~range~expression(2):~#4 }
            }
            \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_c_tl
            \tl_if_empty:NT \l__bnvs_b_tl {
              \tl_if_empty:NT \l__bnvs_a_tl {
                \tl_set:Nn \l__bnvs_b_tl { * }
              }
            }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l__bnvs_c_tl} may contain the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \seq_if_empty:NF \l__bnvs_split_seq {
              \__bnvs_error:n { Invalid~range~expression(3):~#4 }
            }
          }
        }
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a two colon range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \int_compare:nNnT { \tl_count:N \l__bnvs_b_tl } > { 1 } {
          \__bnvs_error:n { Invalid~range~expression(4):~#4 }
        }
        \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_c_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l__bnvs_c_tl} contains the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \seq_pop_left:NNTF \l__bnvs_split_seq \l__bnvs_b_tl {
          \tl_if_empty:NTF \l__bnvs_b_tl {
            \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_b_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{l_b_tl} may contain the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \seq_if_empty:NF \l__bnvs_split_seq {
              \__bnvs_error:n { Invalid~range~expression(5):~#4 }
            }
          } {
              \__bnvs_error:n { Invalid~range~expression(6):~#4 }
          }
        } {
          \tl_clear:N \l__bnvs_b_tl
        }
      }
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Providing both the \meta{start}, \meta{length} and \meta{end} of a range
% is not allowed, even if they happen to be consistent.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \bool_if:nF {
    \tl_if_empty_p:N \l__bnvs_a_tl
    || \tl_if_empty_p:N \l__bnvs_b_tl
    || \tl_if_empty_p:N \l__bnvs_c_tl
  } {
    \__bnvs_error:n { Invalid~range~expression(7):~#3 }
  }
  \cs_set:Npn \:nnn ##1 ##2 ##3 {
    \__bnvs_group_end:
    \tl_set:Nn #1 { ##1 }
    \tl_set:Nn #2 { ##2 }
    \tl_set:Nn #3 { ##3 }
  }
  \exp_args:NVVV \:nnn \l__bnvs_a_tl \l__bnvs_b_tl \l__bnvs_c_tl
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\__bnvs_parse_record:Nnn}
%   \begin{syntax}
%     \cs{__bnvs_parse_record:Nnn} \meta{command} \marg{full name}
%   \end{syntax}
% Auxiliary function for \cs{__bnvs_parse:Nn}.
% \meta{command} is \cs{__bnvs_range:nVVV} at runtime and must have
% signature |nVVV|.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_empty:nTF { xTF }
\cs_new:Npn \__bnvs_parse_record:Nnn #1 #2 #3 {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_parse_record:Nnn... }
\__bnvs_DEBUG:x { TORF = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #3 } / }
%</!gubed>
% \end{bnvs.gobble}
% This is not a list.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \__bnvs_range_set:NNNn \l__bnvs_a_tl \l__bnvs_b_tl \l__bnvs_c_tl { #3 }
  \__bnvs_range:NnVVV #1 { #2 } \l__bnvs_a_tl \l__bnvs_b_tl \l__bnvs_c_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string\__bnvs_parse_record:Nnn }
\__bnvs_DEBUG:x { TORF = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #3 } / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \__bnvs_parse_record:Nnn { Non, NVn }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=do_parse]
% \cs_set:Npn \Test:nnnn #1 #2 #3 #4 {
% \__bnvs_DEBUG:n {Test:~do_parse/#4/#1/}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {X} } {#1} {\cs{__bnvs_parse_record:Nnn}~#4-a}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {X} } {#2} {\cs{__bnvs_parse_record:Nnn}~#4-b}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {X} } {#3} {\cs{__bnvs_parse_record:Nnn}~#4-c}
% }
% \__bnvs_parse_record:Nnn \c_true_bool {X} {A}
% \Test:nnnn {A} {} {} {1}
% \__bnvs_parse_record:Nnn \c_true_bool {X} {A:B}
% \Test:nnnn {A} {B} {X.1+X.length-1} {2}
% \__bnvs_parse_record:Nnn \c_true_bool {X} {A::C}
% \Test:nnnn {A} {X.last-(X.1)+1} {C} {3}
% \__bnvs_parse_record:Nnn \c_true_bool {X} {:B::C}
% \Test:nnnn {X.last-(X.length)+1} {B} {C} {4}
% \__bnvs_parse_record:Nnn \c_true_bool {X} {::C:B}
% \Test:nnnn {X.last-(X.length)+1} {B} {C} {5}
% {
%   \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%     \cs_set:Npn \Test:nnnn ##1 ##2 ##3 ##4 { }
%   }
%   \__bnvs_parse_record:Nnn \c_true_bool {X} {A::C:B}
% }
% {
%   \cs_set:Npn \msg_error:nnn #1 #2 #3 {
%     \cs_set:Npn \Test:nnnn ##1 ##2 ##3 ##4 { }
%   }
%   \__bnvs_parse_record:Nnn \c_true_bool {X} {A:B::C}
% }
% \end{bnvs.test}
% \begin{function}[TF]{\__bnvs_id_name_set:nNN}
% \begin{syntax}
% \cs{__bnvs_id_name_set:nNNTF} \marg{key} \meta{id tl var} \meta{full name tl var} \marg{ true code} \marg{ false code}
% \end{syntax}
% If the \meta{key} is a key, put the name it defines into the \meta{name tl var} with
% the current frame id prefix \cs{l__bnvs_id_tl} if none was given, then
% execute \meta{true code}.
% Otherwise execute \meta{false code}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_id_name_set:nNN #1 #2 #3 { T, F, TF } {
  \__bnvs_group_begin:
  \regex_extract_once:NnNTF \c__bnvs_A_key_Z_regex {
    #1
  } \l__bnvs_match_seq {
    \tl_set:Nx #2 { \seq_item:Nn \l__bnvs_match_seq 3 }
    \tl_if_empty:NTF #2 {
      \exp_args:NNNx
      \__bnvs_group_end:
      \tl_set:Nn #3 { \l__bnvs_id_last_tl #1 }
      \tl_set_eq:NN #2 \l__bnvs_id_last_tl
    } {
      \cs_set:Npn \:n ##1 {
        \__bnvs_group_end:
        \tl_set:Nn #2 { ##1 }
        \tl_set:Nn \l__bnvs_id_last_tl { ##1 }
      }
      \exp_args:NV
      \:n #2
      \tl_set:Nn #3 { #1 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_id_name_set:nNN\space TRUE/}
\__bnvs_DEBUG:x { in = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string#3 = / \tl_to_str:V #3 / }
\__bnvs_DEBUG:x { \string\l__bnvs_id_last_tl:\l__bnvs_id_last_tl/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_id_name_set:nNN\space FALSE/}
\__bnvs_DEBUG:x { in = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string#3 = / \tl_to_str:V #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=__bnvs_id_name_set:nNN]
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \__bnvs_id_name_set:nNNTF { #1 } \l__bnvs_b_tl \l__bnvs_c_tl {
%     \tl_set:Nn \l__bnvs_a_tl { SUCCESS }
%   } {
%     \tl_set:Nn \l__bnvs_a_tl { FAILURE }
%   }
%   \tl_if_empty:nTF { #2 } {
%     \__bnvs_assert_equal:xxn { \l__bnvs_a_tl } { FAILURE } { #5-a }%   
%   } {
%     \__bnvs_assert_equal:xxn { \l__bnvs_a_tl } { SUCCESS } { #5-a }%   
%     \__bnvs_assert_equal:xxn { \l__bnvs_b_tl } { #2 } { #5-b }
%     \__bnvs_assert_equal:xxn { \l__bnvs_c_tl } { #3 } { #5-c }
%     \__bnvs_assert_equal:xxn { \l__bnvs_id_last_tl } { #4 } { #5-d }
%   }
% }
% \Test:nnnnn { X     } { ?! } { ?!X   } { ?! } { 1 }
% \Test:nnnnn { X.1   } { ?! } { ?!X.1 } { ?! } { 2 }
% \Test:nnnnn { F!X   } { F! } { F!X   } { F! } { 3 }
% \Test:nnnnn { X     } { F! } { F!X   } { F! } { 4 }
% \Test:nnnnn { X!X   } { X! } { X!X   } { X! } { 5 }
% \Test:nnnnn { Y!X.1 } { Y! } { Y!X.1 } { Y! } { 6 }
% \Test:nnnnn { ?!!X.1 } { } { } {  } { 7 }
% \end{bnvs.test}
%
% \begin{function}[TF]{\__bnvs_id_name_pm_set:nNN}
% \begin{syntax}
% \cs{__bnvs_id_name_pm_set:nNNTF} \marg{key} \meta{id tl var} \meta{full name tl var} \marg{ true code} \marg{ false code}
% \end{syntax}
% If the \meta{key} is a key, put the name it defines into the \meta{name tl var} with
% the current frame id prefix \cs{l__bnvs_id_tl} if none was given, then
% execute \meta{true code}.
% Otherwise execute \meta{false code}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_id_name_pm_set:nNN #1 #2 #3 { T, F, TF } {
  \__bnvs_group_begin:
  \regex_extract_once:NnNTF \c__bnvs_A_key_pm_Z_regex {
    #1
  } \l__bnvs_match_seq {
    \tl_set:Nx #2 { \seq_item:Nn \l__bnvs_match_seq 3 }
    \tl_if_empty:NTF #2 {
      \exp_args:NNNx
      \__bnvs_group_end:
      \tl_set:Nn #3 { \l__bnvs_id_last_tl #1 }
      \tl_set_eq:NN #2 \l__bnvs_id_last_tl
    } {
      \cs_set:Npn \:n ##1 {
        \__bnvs_group_end:
        \tl_set:Nn #2 { ##1 }
        \tl_set:Nn \l__bnvs_id_last_tl { ##1 }
      }
      \exp_args:NV
      \:n #2
      \tl_set:Nn #3 { #1 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_id_name_pm_set:nNNTF...TRUE }
\__bnvs_DEBUG:x { WHAT = / #1/ }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string #3 = / \tl_to_str:V #3 / }
\__bnvs_DEBUG:x { \string\l__bnvs_id_last_tl = / \l__bnvs_id_last_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_id_name_pm_set:nNNTF...FALSE }
\__bnvs_DEBUG:x { WHAT = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string#3 = / \tl_to_str:V #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=__bnvs_id_name_pm_set:nNN]
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \tl_if_empty:nTF { #2 } {
%     \__bnvs_id_name_pm_set:nNNT { #1 } \l__bnvs_b_tl \l__bnvs_c_tl {
%       \test_fail:n { #5~FAIL }
%     }
%   } {
%     \__bnvs_id_name_pm_set:nNNTF { #1 } \l__bnvs_b_tl \l__bnvs_c_tl {
%       \__bnvs_assert_equal:xxn { \l__bnvs_b_tl } { #2 } { #5-b }
%       \__bnvs_assert_equal:xxn { \l__bnvs_c_tl } { #3 } { #5-c }
%       \__bnvs_assert_equal:xxn { \l__bnvs_id_last_tl } { #4 } { #5-d }
%     } {
%       \test_fail:n { #5~FAIL }
%     }
%   }
% }
% \Test:nnnnn { X     } { ?! } { ?!X   } { ?! } { 1 }
% \Test:nnnnn { X.1   } { ?! } { ?!X.1 } { ?! } { 2 }
% \Test:nnnnn { F!X   } { F! } { F!X   } { F! } { 3 }
% \Test:nnnnn { X     } { F! } { F!X   } { F! } { 4 }
% \Test:nnnnn { X!X   } { X! } { X!X   } { X! } { 5 }
% \Test:nnnnn { Y!X.1 } { Y! } { Y!X.1 } { Y! } { 6 }
% \Test:nnnnn { ?!!X.1 } { } { } {  } { 7 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_parse:Nnn #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_parse:Nnn... }
\__bnvs_DEBUG:x { \string#1/#2/#3/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \__bnvs_id_name_pm_set:nNNTF { #2 } \l__bnvs_id_tl \l__bnvs_name_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse:Nnn... }
\__bnvs_DEBUG:x { KEY = / #2 / }
\__bnvs_DEBUG:x { ID = / \tl_to_str:V \l__bnvs_id_tl / }
\__bnvs_DEBUG:x { NAME: = / \tl_to_str:V \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \regex_match:NnTF \c__bnvs_list_regex {
      #3
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a comma separated list, extract each item and go recursive.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \exp_args:NNx
      \seq_set_from_clist:Nn \l__bnvs_match_seq {
        \seq_item:Nn \l__bnvs_match_seq { 2 }
      }
      \seq_map_indexed_inline:Nn \l__bnvs_match_seq {
        \__bnvs_parse_record:Non #1  { \l__bnvs_name_tl.##1 } { ##2 }
      }
    } {
      \__bnvs_parse_record:NVn #1 \l__bnvs_name_tl { #3 }
    }
  } {
    \__bnvs_error:n { Invalid~key:~#2 }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We export \cs{l__bnvs_id_tl}:
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse:Nnn }
\__bnvs_DEBUG:x { KEY = / #2 / }
\__bnvs_DEBUG:x { ID = / \l__bnvs_id_tl / }
\__bnvs_DEBUG:x { NAME: = / \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \exp_args:NNNV
  \__bnvs_group_end:
  \tl_set:Nn \l__bnvs_id_last_tl \l__bnvs_id_last_tl
}
\cs_new:Npn \__bnvs_parse_pm:Nnn #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_parse_pm:Nnn... }
\__bnvs_DEBUG:x { TORF = / \string #1 / }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { VALUE = / \tl_to_str:n { #3 } / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_set:Nn \l__bnvs_a_tl { #2 }
  \tl_put_left:NV \l__bnvs_a_tl \l__bnvs_root_tl
  \exp_args:NV
  \__bnvs_id_name_pm_set:nNNTF \l__bnvs_a_tl \l__bnvs_id_tl \l__bnvs_name_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse_pm:Nnn... }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n { #2 } / }
\__bnvs_DEBUG:x { ID = / \tl_to_str:V \l__bnvs_id_tl / }
\__bnvs_DEBUG:x { NAME = / \tl_to_str:V \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \tl_if_empty:nTF { #3 } {
      \exp_args:NV
					\__bnvs_gclear:n \l__bnvs_name_tl
      \exp_args:NV
					\__bnvs_n_gclear:n \l__bnvs_name_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% Empty value given: remove the reference.
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse_m:Nnn}/empty~value,
% ]
%   \__bnvs_range:Nnnnn \c_true_bool { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \tl_set:Nn \l__bnvs_a_tl { ?!X/#1 }
%     \__bnvs_get:nnNF { #1 } { ?!X } \l__bnvs_b_tl {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%     }
%   }
%   \__bnvs_parse_pm:Nnn \c_true_bool {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \tl_set:Nn \l__bnvs_a_tl { ?!X/#1 }
%     \__bnvs_get:nnNT { #1 } { ?!X } \l__bnvs_b_tl {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%     }
%   }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse_pm:Nnn...REMOVED... }
\__bnvs_DEBUG:x { NAME: = / \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    } {
      \regex_match:NnTF \c__bnvs_list_pm_regex {
        #3
      } {
        \__bnvs_group_begin:
        \tl_set:NV \l__bnvs_root_tl \l__bnvs_name_tl
        \int_set:Nn \l__bnvs_int { 0 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a comma separated list, go recursive.
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse_pm:Nnn... }
\__bnvs_DEBUG:x { KEY = / #2 / }
\__bnvs_DEBUG:x { ID = / \l__bnvs_id_tl / }
\__bnvs_DEBUG:x { NAME: = / \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse_m:Nnn}/list,
% ]
%   \__bnvs_range:Nnnnn \__bnvs_gput:nn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \tl_set:Nn \l__bnvs_a_tl { ?!X/#1 }
%     \__bnvs_get:nnNF { #1 } { ?!X } \l__bnvs_b_tl {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%     }
%   }
%   \__bnvs_parse_pm:Nnn \c_true_bool {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \tl_set:Nn \l__bnvs_a_tl { ?!X/#1 }
%     \__bnvs_get:nnNT { #1 } { ?!X } \l__bnvs_b_tl {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%     }
%   }
% \end{bnvs.test}
%    \begin{macrocode}
        \__bnvs_parse_list:Nn #1 #3
        \__bnvs_group_end:
      } {
%    \end{macrocode}
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse_m:Nnn}/{KEY=VALUE}, debug,
% ]
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST:LENGTH }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_get:nnNTF L { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { LENGTH } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/L }
%  }
%  \__bnvs_parse_pm:Nnn \c_true_bool { X } { FIRST::LAST }
%  \__bnvs_get:nnNTF A { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/A }
%  }
%  \__bnvs_get:nnNTF Z { ?!X } \l__bnvs_a_tl {
%    \assert_equal:xxn { \l__bnvs_a_tl } { LAST } {1}
%  } {
%    \test_fail:n { MISSING~KEY~?!X/Z }
%  }
% \end{bnvs.test}
%    \begin{macrocode}
        \__bnvs_parse_record:NVn #1 \l__bnvs_name_tl { #3 }
      }
    }
  } {
    \__bnvs_error:n { Invalid~key:~#2 }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We export \cs{l__bnvs_id_tl}:
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_parse:Nnn }
\__bnvs_DEBUG:x { KEY = / #2 / }
\__bnvs_DEBUG:x { ID = / \l__bnvs_id_tl / }
\__bnvs_DEBUG:x { NAME: = / \l__bnvs_name_tl / }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \exp_args:NNNV
  \__bnvs_group_end:
  \tl_set:Nn \l__bnvs_id_last_tl \l__bnvs_id_last_tl
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse:Nnn}+\cs{__bnvs_item:n},
% ]
% \cs_set:Npn \Test:nnnnnn #1 #2 #3 #4 #5 {
%   \__bnvs_parse:Nnn \c_true_bool {X} {#1}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#3} {#5-b}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#4} {#5-c}
%   \clist_map_inline:nn {D, D:E, D::F, :E::F} {
%     \__bnvs_parse:Nnn \c_false_bool {X} { ##1 }
%     \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {?!X} } {#2} {#5-a(##1)}
%     \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {?!X} } {#3} {#5-b(##1)}
%     \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {?!X} } {#4} {#5-c(##1)}
%   }
% }
% \Test:nnnnnn {A    } {A} {} {} {1}
% \Test:nnnnn {A:B  } {A} {B} {?!X.1+?!X.length-1} {2}
% \Test:nnnnn {A::C } {A} {?!X.last-(?!X.1)+1} {C} {3}
% \Test:nnnnn {:B::C} {?!X.last-(?!X.length)+1} {B} {C} {4}
% \end{bnvs.test}
% \begin{bnvs.test}[
%   banner=\cs{__bnvs_parse:Nnn}+\cs{__bnvs_item:n}
% ]
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 #5 {
%   \__bnvs_parse:Nnn \c_true_bool {X.1.2} {#1}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {?!X.1.2} } {#2} {#5-A}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {?!X.1.2} } {#3} {#5-L}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {?!X.1.2} } {#4} {#5-Z}
% }
% \Test:nnnnn {A} {A} {} {} {1}
% \Test:nnnnn {A:B} {A} {B} {?!X.1.2.1+?!X.1.2.length-1} {2}
% \Test:nnnnn {A::C} {A} {?!X.1.2.last-(?!X.1.2.1)+1} {C} {3}
% \cs_set:Npn \Test:nnnnn #1 #2 #3 #4 #5 {
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn A {?!X.#5} } {#1} {\cs{__bnvs_parse:Nnn}~#4-a}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn L {?!X.#5} } {#2} {\cs{__bnvs_parse:Nnn}~#4-b}
%   \__bnvs_assert_equal:xxn {\__bnvs_item:nn Z {?!X.#5} } {#3} {\cs{__bnvs_parse:Nnn}~#4-c}
% }
% \__bnvs_parse:Nnn \c_true_bool {X.3} {[A,A:B,A::C,:B::C,::C:B]}
% \Test:nnnnn {A} {} {} {4-1} {3.1}
% \Test:nnnnn {A} {B} {?!X.3.2.1+?!X.3.2.length-1} {4-2} {3.2}
% \Test:nnnnn {A} {?!X.3.3.last-(?!X.3.3.1)+1} {C} {4-3} {3.3}
% \Test:nnnnn {?!X.3.4.last-(?!X.3.4.length)+1} {B} {C} {4-4} {3.4}
% \Test:nnnnn {?!X.3.5.last-(?!X.3.5.length)+1} {B} {C} {4-5} {3.5}
% \end{bnvs.test}
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key--value list}
%   \end{syntax}
%   The keys are the slide overlay references.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{key--value} items are parsed by \cs{__bnvs_parse:Nnn}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\IfBooleanTF {#1} { 
  \__bnvs_DEBUG:x { \string\Beanoves * }
} { 
  \__bnvs_DEBUG:x { \string\Beanoves }
}
\__bnvs_DEBUG:x { \tl_to_str:n { #2 } }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_gput_right:Nn \g__bnvs_def_seq { #2 }
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, clear everything.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_gclear:
    }
    \__bnvs_group_begin:
    \tl_clear:N \l__bnvs_root_tl
    \int_zero:N \l__bnvs_int
    \tl_set:Nn \l__bnvs_a_tl { [ }
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, use the global definitions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \seq_if_empty:NF \g__bnvs_def_seq {
        \tl_put_left:Nx \l__bnvs_a_tl {
          \seq_use:Nn \g__bnvs_def_seq , ,
        }
      }
    }
    \tl_put_right:Nn \l__bnvs_a_tl { #2 ] }
    \regex_replace_all:nnN { \[ %---]
    } {
      [ \c{c_group_begin_token} %---]
    } \l__bnvs_a_tl
    \regex_replace_all:nnN { %---[
    \] } {
      \c{c_group_end_token}
    } \l__bnvs_a_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \Beanoves \IfBooleanT {#1} { * }... }
\__bnvs_DEBUG:x { \string \l__bnvs_a_tl = / \tl_to_str:V \l__bnvs_a_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \IfBooleanTF {#1} {
      \exp_args:NNV
      \__bnvs_parse_list:Nn \c_false_bool \l__bnvs_a_tl %---]
    } {
      \exp_args:NNV
      \__bnvs_parse_list:Nn \c_true_bool \l__bnvs_a_tl %---]
    }
    \__bnvs_group_end:
    \ignorespaces
  }
}
\cs_new:Npn \__bnvs_parse_list:Nn #1 [ %---]
 {
  \keyval_parse:nnn {
    \__bnvs_parse_pm:Nn #1
  } {
    \__bnvs_parse_pm:Nnn #1
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\beamer@frame, \beamer@masterdecode}
% \begin{syntax}
% \cs{beamer@frame} \marg{overlay specification}
% \cs{beamer@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} reads it.
% \begin{variable}{\l__bnvs_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% Save the original macro \cs{beamer@masterdecode} and then override it
% to properly preprocess the argument.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set_eq:NN \__bnvs_beamer@frame \beamer@frame
\cs_set:Npn \beamer@frame < #1 > {
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \__bnvs_scan:nNN { #1 } \__bnvs_eval:nN \l__bnvs_ans_tl
  \exp_args:NNNV
  \__bnvs_group_end:
  \__bnvs_beamer@frame < \l__bnvs_ans_tl >
}
\cs_set_eq:NN \__bnvs_beamer@masterdecode \beamer@masterdecode
\cs_set:Npn \beamer@masterdecode #1 {
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \__bnvs_scan:nNN { #1 } \__bnvs_eval:nN \l__bnvs_ans_tl
  \exp_args:NNV
  \__bnvs_group_end:
  \__bnvs_beamer@masterdecode \l__bnvs_ans_tl
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_scan:nNN}
% \begin{syntax}
% \cs{__bnvs_scan:nNN} \marg{named overlay expression} \meta{eval} \meta{tl variable}
% \end{syntax}
% Scan the \meta{named overlay expression} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from the \meta{eval} function, which is \cs{__bnvs_eval:nN}.
% A group is created to use local variables:
% \begin{variable}{\l__bnvs_ans_tl}
% The token list that will be appended to \meta{tl variable} on return.
% \end{variable}
% \begin{variable}{\l__bnvs_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l__bnvs_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l__bnvs_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l__bnvs_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_scan:nNN #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_scan:nNN }
\__bnvs_DEBUG:x { #1 / }
\__bnvs_DEBUG:x { \string#2 / }
\__bnvs_DEBUG:x { \string#3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \seq_clear:N \l__bnvs_token_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Explode the \meta{named overlay expression} into a list of tokens:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:nnN {} { #1 } \l__bnvs_token_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\scan_question:}
% \begin{syntax}
% \cs{scan_question:}
% \end{syntax}
% At top level state, scan the tokens of the
% \meta{named overlay expression} looking for a `|?|' character.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \cs_set:Npn \scan_question: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\scan_question: }
\__bnvs_DEBUG:x { \string\l__bnvs_ans_tl :~\l__bnvs_ans_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \seq_pop_left:NNT \l__bnvs_token_seq \l__bnvs_token_tl {
      \tl_if_eq:NnTF \l__bnvs_token_tl { ? } {
        \require_open:
      } {
        \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_token_tl
        \scan_question:
      }
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\require_open:}
% \begin{syntax}
% \cs{require_open:}
% \end{syntax}
% We just found a `|?|',
% we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
% \end{function}
%    \begin{macrocode}
  \cs_set:Npn \require_open: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\require_open: }
\__bnvs_DEBUG:x { \string\l__bnvs_ans_tl :~\l__bnvs_ans_tl/}
%</!gubed>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_pop_left:NNTF \l__bnvs_token_seq \l__bnvs_token_tl {
      \tl_if_eq:NnTF \l__bnvs_token_tl { ( %)
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Set the parenthesis depth to 1 (on first passage).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \int_set:Nn \l__bnvs_int { 1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Record the forthcomming content in
% the \cs{l__bnvs_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \tl_clear:N \l__bnvs_query_tl
        \require_close:
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Ignore this token and loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \require_open:
      }
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% End reached but no opening parenthesis found, raise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \msg_fatal:nnx { beanoves } { :n } {Missing~'('%---)
        ~after~a~?:~#1}
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\require_close:}
% \begin{syntax}
% \cs{require_close:}
% \end{syntax}
% We found a `|?(|', we record the forthcomming content in the \cs{l__bnvs_query_tl} variable,
% up to the next balancing `|)|`.
% \end{function}
%    \begin{macrocode}
  \cs_set:Npn \require_close: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\require_close: }
\__bnvs_DEBUG:x { \string\l__bnvs_query_tl :~\l__bnvs_query_tl/}
%</!gubed>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_pop_left:NNTF \l__bnvs_token_seq \l__bnvs_token_tl {
      \tl_if_eq:NnTF \l__bnvs_token_tl { ( %---)
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to \cs{l__bnvs_query_tl},
% then scan again for a^^A---(
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \int_incr:N \l__bnvs_int
        \tl_put_right:NV \l__bnvs_query_tl \l__bnvs_token_tl
        \require_close:
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is not a `|(|'.^^A---)
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \tl_if_eq:NnTF \l__bnvs_token_tl { %(---
          )
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a  ^^A(---
% `|)|', we decrement and test the depth.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \int_decr:N \l__bnvs_int
          \int_compare:nNnTF \l__bnvs_int = 0 {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to \cs{l_ans_tl}
% and look for the next |?|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \exp_args:NV #2 \l__bnvs_query_tl \l__bnvs_ans_tl
            \scan_question:
          } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to \cs{l__bnvs_query_tl} because it is not yet the
% end of sequence marker.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \tl_put_right:NV \l__bnvs_query_tl \l__bnvs_token_tl
            \require_close:
          }
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to \cs{l__bnvs_query_tl}
% and look for a^^A(---
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \tl_put_right:NV \l__bnvs_query_tl \l__bnvs_token_tl
          \require_close:
        }
      }
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Above ends the code for Not a  `|(|'^^A---)
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and terminate.
% As recovery we feed \cs{l__bnvs_query_tl} with the missing ^^A(---
% `|)|'.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \__bnvs_error:x {Missing~%(---
        `)':~#1 }
      \tl_put_right:Nx \l__bnvs_query_tl {
        \prg_replicate:nn { \l__bnvs_int } {%(---
        )}
      }
      \exp_args:NV #2 \l__bnvs_query_tl \l__bnvs_ans_tl
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Run the top level loop to scan for a `|?|':
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \scan_question:
  \exp_args:NNNV
  \__bnvs_group_end:
  \tl_put_right:Nn #3 \l__bnvs_ans_tl
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=scan]
% \cs_set:Npn \eval:nN #1 #2 {
%   \tl_put_right:Nn #2 { !(#1) }
% }
% \tl_clear:N \l__bnvs_a_tl
% \__bnvs_scan:nNN {1+1} \eval:nN \l__bnvs_a_tl
% \__bnvs_scan:nNN {?(A)} \eval:nN \l__bnvs_a_tl
% \cs_set:Npn \Test:nnn #1 #2 #3 {
% \__bnvs_DEBUG:n { Test:~scan/#3/#1/}
%   \tl_clear:N \l__bnvs_a_tl
%   \__bnvs_scan:nNN { #1 } \eval:nN \l__bnvs_a_tl
%   \exp_args:NV
%   \__bnvs_assert_equal:nnn \l__bnvs_a_tl { #2 } {
%     Test~\cs{__bnvs_scan:nNN}~#3
%   }
% }
% \Test:nnn {} {} {1}
% \Test:nnn {1+1} {1+1} {2}
% \Test:nnn {1?(+)1} {1!(+)1} {3}
% \Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \end{bnvs.test}I
%
% \subsubsection{Resolution}
%
% Given a frame id, a name and an integer path,
% we resolve any intermediate standalone reference.
% For example, with |A=B| and |B=C|, |A| is resolved in |C|.
% But with |A=B+1| and |B=C|, |A| is not resolved in |C+1|.
% With |A=B:D| and |B=C|, |A| is not resolved in |C:D| as well.
% \begin{function}[TF]{\__bnvs_inp:NNN}
% \begin{syntax}
% \cs{__bnvs_inp:NNNTF} \meta{id tl var} \meta{name tl var} \meta{path seq var} \marg{true code} \marg{false code}
% \end{syntax}
% Auxiliary function. \meta{id tl var} contains a frame id whereas
% \meta{name tl var} contains a range name.
% If we recognize a key, on return,
% \meta{name tl var} contains the resolved name,
% \meta{path seq var} is prepended with new integer path components,
% \marg{true code} is executed, otherwise \marg{false code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVx }
\prg_new_conditional:Npnn \__bnvs_inp:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp:NNNTF...START}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn#3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \exp_args:NNV
  \regex_extract_once:NnNTF \c__bnvs_A_key_Z_regex #2 \l__bnvs_match_seq {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a correct key, update the path sequence accordingly
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \exp_args:Nx
    \tl_if_empty:nT { \seq_item:Nn \l__bnvs_match_seq 3 } {
      \tl_put_left:NV #2 { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { VERIF~\tl_to_str:V #2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    }
    \exp_args:NNnx
    \seq_set_split:Nnn \l__bnvs_split_seq . {
      \seq_item:Nn \l__bnvs_match_seq 4
    }
    \seq_remove_all:Nn \l__bnvs_split_seq { }
    \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_a_tl
    \seq_if_empty:NTF \l__bnvs_split_seq {
%    \end{macrocode}
% \end{bnvs.macrocode}
% No new integer path component is added.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \cs_set:Npn \:nn ##1 ##2 {
        \__bnvs_group_end:
        \tl_set:Nn #1 { ##1 }
        \tl_set:Nn #2 { ##2 }
      }
      \exp_args:NVV \:nn #1 #2
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { END/\string#1:#1/\string#2:#2/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Some new integer path components 	are added.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp:NNNTF/}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn#3./}
\__bnvs_DEBUG:x { \string\l__bnvs_split_seq:\seq_use:Nn\l__bnvs_split_seq./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \cs_set:Npn \:nnn ##1 ##2 ##3 {
        \__bnvs_group_end:
        \tl_set:Nn #1 { ##1 }
        \tl_set:Nn #2 { ##2 }
        \seq_set_split:Nnn #3 . { ##3 }
        \seq_remove_all:Nn #3 { }
      }
      \exp_args:NVVx
      \:nnn #1 #2 {
        \seq_use:Nn \l__bnvs_split_seq . . \seq_use:Nn #3 .
      }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp:NNNTF...END}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn#3./}
\__bnvs_DEBUG:x { \string\l__bnvs_split_seq:\seq_use:Nn\l__bnvs_split_seq./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp:NNNTF...TRUE}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn#3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp:NNNTF...FALSE}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn#3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{\__bnvs_inp_pm:NNN}
% \begin{syntax}
% \cs{__bnvs_inp_pm:NNNTF} \meta{id tl var} \meta{name tl var} \meta{path seq var} \marg{true code} \marg{false code}
% \end{syntax}
% Auxiliary function. \meta{id tl var} contains a frame id whereas
% \meta{name tl var} contains a range name.
% If we recognize a key, on return,
% \meta{name tl var} contains the resolved name,
% \meta{path seq var} is prepended with new integer path components,
% \marg{true code} is executed, otherwise \marg{false code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\exp_args_generate:n { VVx }
\prg_new_conditional:Npnn \__bnvs_inp_pm:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_inp_pm:NNNTF...}
\__bnvs_DEBUG:x { \string #1 = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string #3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \exp_args:NNV
  \regex_extract_once:NnNTF \c__bnvs_A_key_pm_Z_regex #2 \l__bnvs_match_seq {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a correct key, update the path sequence accordingly
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \exp_args:Nx
    \tl_if_empty:nT { \seq_item:Nn \l__bnvs_match_seq 3 } {
      \tl_put_left:NV #2 { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_inp_pm:NNNTF...ID...}
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    }
    \exp_args:NNnx
    \seq_set_split:Nnn \l__bnvs_split_seq . {
      \seq_item:Nn \l__bnvs_match_seq 4
    }
    \seq_remove_all:Nn \l__bnvs_split_seq { }
    \seq_pop_left:NN \l__bnvs_split_seq \l__bnvs_a_tl
    \seq_if_empty:NTF \l__bnvs_split_seq {
%    \end{macrocode}
% \end{bnvs.macrocode}
% No new integer path component is added.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \cs_set:Npn \:nn ##1 ##2 {
        \__bnvs_group_end:
        \tl_set:Nn #1 { ##1 }
        \tl_set:Nn #2 { ##2 }
      }
      \exp_args:NVV \:nn #1 #2
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_inp_pm:NNNTF...}
\__bnvs_DEBUG:x { \string #1 = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Some new dotted path components 	are added.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_inp_pm:NNNTF...SPLIT...}
\__bnvs_DEBUG:x { \string \l__bnvs_split_seq: \seq_use:Nn \l__bnvs_split_seq . /}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \cs_set:Npn \:nnn ##1 ##2 ##3 {
        \__bnvs_group_end:
        \tl_set:Nn #1 { ##1 }
        \tl_set:Nn #2 { ##2 }
        \seq_set_split:Nnn #3 . { ##3 }
        \seq_remove_all:Nn #3 { }
      }
      \exp_args:NVVx
      \:nnn #1 #2 {
        \seq_use:Nn \l__bnvs_split_seq . . \seq_use:Nn #3 .
      }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_inp_pm:NNNTF...TRUE}
\__bnvs_DEBUG:x { \string #1 = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string #3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_inp_pm:NNNTF...FALSE}
\__bnvs_DEBUG:x { \string #1 = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string #3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{\__bnvs_resolve_pm_n:NNN, \__bnvs_resolve_pm_n:TFF, \__bnvs_resolve_pm_x:NNN, \__bnvs_resolve_pm_x:TFF}
% \begin{syntax}
% \cs{__bnvs_resolve_pm_x:TF} \marg{true code} \marg{false code}
% \cs{__bnvs_resolve_pm_x:NNNTF} \meta{id tl var} \meta{name tl var} \meta{path seq var} \marg{true code} \marg{false code}
% \cs{__bnvs_resolve_pm_n:TF} \marg{true code} \marg{false code}
% \cs{__bnvs_resolve_pm_n:NNNTF} \meta{id tl var} \meta{name tl var} \meta{path seq var} \marg{true code} \marg{false code}
% \end{syntax}
% When too many nested calls occurred, \marg{false code} is executed directly
% otherwise \marg{true code} will be executed once resolution has occurred.
% The \meta{id tl var}, \meta{name tl var} and \meta{path seq var}
% are meant to contain proper information on input and on output as well.
% On input, \marg{id tl var} contains a frame id, 
% \marg{name tl var} contains a slide range name and
% \marg{path seq var} contains the components of an integer path, possibly empty.
% On return, \meta{id tl var} contains the frame id used,
% \meta{name tl var} contains the resolved range name and
% \meta{path seq var} contains the sequence of integer path components that could not be resolved.
%
% To resolve a level of a named one slide specification
% \meta{qualified name}.\meta{i_1}.\meta{i_2}...\meta{i_n},
% we replace the shortest \meta{qualified name}.\meta{i_1}.\meta{i_2}...\meta{i_k}
% where 0$≤$k$≤$n by its definition \meta{qualified name'}.\meta{j_1}...\meta{j_p}
% if any. The \cs{__bnvs_resolve:NNNTF} function uses this one level resolution
% as many times as possible, but no more than a predefined limit to catch
% circular reference that would lead to an infinite loop.
%
% \begin{enumerate}
% \item If \meta{name tl var} content is the name of an unlimited range,
% and the first item of this range is exactly another name range with
% eventually a heading frame identifier or a trailing integer path,
% then \meta{name tl var} is replaced by this name, the \meta{id tl var}
% and \cs{l__bnvs_id_tl} are updates accordingly and
% the \meta{path seq var} is prepended with the integer path.
% \item If \meta{path seq var} is not empty,
% append to the right of \meta{name tl var} after a separating dot,
% all its left elements but the last one  and loop.
% Otherwise return.
%
% In the |_n| variant, the resolution is driven only when there is a non empty
% dotted path.
%
% In the |_x| variant, the resolution is driven one step further:
% if \meta{path seq var} is empty, \meta{name tl var} can contain anything.
%
% \end{enumerate}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_resolve_pm_x:TFF #1 #2 {
  \__bnvs_resolve_pm_x:NNNTF
  \l__bnvs_id_tl
  \l__bnvs_name_tl
  \l__bnvs_path_seq {
    \seq_if_empty:NTF \l__bnvs_path_seq { #1 } { #2 }
  }
}
\prg_new_conditional:Npnn \__bnvs_resolve_pm_x_old:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_x:NNNTF... }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_a_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...LOOP... }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
      \tl_set_eq:NN \l__bnvs_a_tl #2
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \__bnvs_get:nVNTF L \l__bnvs_a_tl \l__bnvs_b_tl {
          \cs_set:Nn \loop: { \return_true: }        
        } {
          \:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unknown key \meta{\cs{l_a_tl}}|/A| or
% the value for key \meta{\cs{l_a_tl}}|/A| does not fit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \cs_set:Nn \loop: { \return_true: }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \:F {
          \seq_pop_right:NNT \l__bnvs_a_seq \l__bnvs_c_tl {
            \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
          }
        }
      }
      \loop:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...TOO~MANY~CALLS }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \prg_return_false:
    }
  }
  \cs_set:Npn \:F ##1 {
    \__bnvs_get:nVNTF A \l__bnvs_a_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...RESOLUTION }
\__bnvs_DEBUG:x { \l__bnvs_a_tl / A=>\l__bnvs_b_tl}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_inp_pm:NNNTF #1 \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN #2 \l__bnvs_b_tl
        \seq_set_eq:NN #3 \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
      } {
        \seq_if_empty:NTF \l__bnvs_b_seq {
          \tl_set_eq:NN #2 \l__bnvs_b_tl
          \seq_clear:N #3
          \seq_clear:N \l__bnvs_a_seq
        } {
          ##1
        }
      }
    } { ##1 }
  }
  \cs_set:Npn \return_true: {
    \seq_pop_left:NNTF #3 \l__bnvs_a_tl {
      \seq_if_empty:NTF #3 {
        \tl_clear:N \l__bnvs_b_tl
						\__bnvs_if_index:VVNTF #2 \l__bnvs_a_tl \l__bnvs_b_tl {
						  \tl_set:NV #2 \l__bnvs_b_tl
						} {
\msg_warning:nnx { beanoves } { :n } { Unknown~#2}
						  \tl_set:NV #2 \l__bnvs_a_tl
						}
      } {
        \__bnvs_error:x { Path~too~long:~#2.\l__bnvs_a_tl
          .\seq_use:Nn\l__bnvs_path_seq .}
      }
    } {
      \tl_clear:N \l__bnvs_b_tl
					\__bnvs_if_counter:VNT #2 \l__bnvs_b_tl {
					  \tl_set:NV #2 \l__bnvs_b_tl
					}
    }
    \cs_set:Npn \:nnn ####1 ####2 ####3 {
      \__bnvs_group_end:
      \tl_set:Nn #1 { ####1 }
      \tl_set:Nn #2 { ####2 }
      \seq_set_split:Nnn #3 . { ####3 }
      \seq_remove_all:Nn #3 { }
    }
    \exp_args:NVVx
    \:nnn #1 #2 {
      \seq_use:Nn #3 .
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...TRUE }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \loop:
}
\prg_new_conditional:Npnn \__bnvs_resolve_pm_x:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_x:NNNTF... }
\__bnvs_DEBUG:x { \string #1 = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / #2 / }
\__bnvs_DEBUG:x { \string #3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_a_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
      \tl_set_eq:NN \l__bnvs_a_tl #2
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \__bnvs_get:nVNTF L \l__bnvs_a_tl \l__bnvs_b_tl {
          \cs_set:Nn \loop: { \return_true: }        
        } {
          \resolve:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unknown key \meta{\cs{l_a_tl}}|/A| or
% the value for key \meta{\cs{l_a_tl}}|/A| does not fit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \cs_set:Nn \loop: { \return_true: }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \resolve:F {
          \seq_pop_right:NNT \l__bnvs_a_seq \l__bnvs_c_tl {
            \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
          }
        }
      }
      \loop:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...TOO~MANY~CALLS }
\__bnvs_DEBUG:x { \string #1 = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / #2 / }
\__bnvs_DEBUG:x { \string #3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \prg_return_false:
    }
  }
  \cs_set:Npn \resolve:F ##1 {
    \__bnvs_get:nVNTF A \l__bnvs_a_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...RESOLUTION }
\__bnvs_DEBUG:x { \l__bnvs_a_tl / A=>\l__bnvs_b_tl}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_inp_pm:NNNTF #1 \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN #2 \l__bnvs_b_tl
        \seq_set_eq:NN #3 \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
      } {
        \seq_if_empty:NTF \l__bnvs_b_seq {
          \tl_set_eq:NN #2 \l__bnvs_b_tl
          \seq_clear:N #3
          \seq_clear:N \l__bnvs_a_seq
        } {
          ##1
        }
      }
    } { ##1 }
  }
  \cs_set:Npn \return_true: {
    \seq_pop_left:NNTF #3 \l__bnvs_a_tl {
      \seq_if_empty:NTF #3 {
        \tl_clear:N \l__bnvs_b_tl
						\__bnvs_if_index:VVNTF #2 \l__bnvs_a_tl \l__bnvs_b_tl {
						  \tl_set:NV #2 \l__bnvs_b_tl
						} {
\msg_warning:nnx { beanoves } { :n } { Unknown~#2}
						  \tl_set:NV #2 \l__bnvs_a_tl
						}
      } {
        \__bnvs_error:x { Path~too~long:~#2.\l__bnvs_a_tl
          .\seq_use:Nn\l__bnvs_path_seq .}
      }
    } {
      \tl_clear:N \l__bnvs_b_tl
					\__bnvs_if_counter:VNT #2 \l__bnvs_b_tl {
					  \tl_set:NV #2 \l__bnvs_b_tl
					}
    }
    \cs_set:Npn \:nnn ####1 ####2 ####3 {
      \__bnvs_group_end:
      \tl_set:Nn #1 { ####1 }
      \tl_set:Nn #2 { ####2 }
      \seq_set_split:Nnn #3 . { ####3 }
      \seq_remove_all:Nn #3 { }
    }
    \exp_args:NVVx
    \:nnn #1 #2 {
      \seq_use:Nn #3 .
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_x:NNNTF...TRUE }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3 . / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \loop:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_resolve_pm_n:TFF #1 #2 {
  \__bnvs_resolve_pm_n:NNNTF
  \l__bnvs_id_tl
  \l__bnvs_name_tl
  \l__bnvs_path_seq {
    \seq_if_empty:NTF \l__bnvs_path_seq { #1 } { #2 }
  }
}
\prg_new_conditional:Npnn \__bnvs_resolve_pm_n: { T, F, TF } {
  \__bnvs_resolve_pm_n:NNNTF
  \l__bnvs_name_tl
  \l__bnvs_id_tl
  \l__bnvs_path_seq {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Npnn \__bnvs_resolve_pm_n_old:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_n:NNNTF... }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l_a_seq} contains the index path components currently resolved.
% \item \cs{l_b_tl} contains the resolution.
% \item \cs{l_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
      \tl_set_eq:NN \l__bnvs_a_tl #2
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \__bnvs_get:nVNTF L \l__bnvs_a_tl \l__bnvs_b_tl {
          \cs_set:Npn \loop: { \return_true: }
        } {
          \seq_if_empty:NTF \l__bnvs_b_seq {
            \cs_set:Npn \loop: { \return_true: }
          } {
            \:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unknown key \meta{\cs{l_a_tl}}|/A| or
% the value for key \meta{\cs{l_a_tl}}|/A| does not fit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
              \cs_set:Npn \loop: { \return_true: }
            }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \:F {
          \seq_pop_right:NNT \l__bnvs_a_seq \l__bnvs_c_tl {
            \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
          }
        }
      }
      \loop:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_n:NNNTF...TOO~MANY~CALLS }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \prg_return_false:
    }
  }
  \cs_set:Npn \:F ##1 {
    \__bnvs_get:nVNTF A \l__bnvs_a_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_n:NNNTF...RESOLUTION... }
\__bnvs_DEBUG:x { \l__bnvs_a_tl / A=>\l__bnvs_b_tl}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_inp_pm:NNNTF #1 \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN #2 \l__bnvs_b_tl
        \seq_set_eq:NN #3 \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
      } { ##1 }
    } { ##1 }
  }
  \cs_set:Npn \return_true: {
    \cs_set:Npn \:nnn ####1 ####2 ####3 {
      \__bnvs_group_end:
      \tl_set:Nn #1 { ####1 }
      \tl_set:Nn #2 { ####2 }
      \seq_set_split:Nnn #3 . { ####3 }
      \seq_remove_all:Nn #3 { }
    }
    \exp_args:NVVx
    \:nnn #1 #2 { \seq_use:Nn #3 . }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_n:NNNTF...TRUE }
\__bnvs_DEBUG:x { \string#1 = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \loop:
}
\prg_new_conditional:Npnn \__bnvs_resolve_pm_n:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_n:NNNTF... }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_id_tl}, \cs{l__bnvs_name_tl},
%   \cs{l__bnvs_path_seq} contains the resolution.
% \item \cs{l__bnvs_a_seq} contains the dotted path components to be resolved.
% Initially empty.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \tl_set_eq:NN \l__bnvs_id_tl #1
  \tl_set_eq:NN \l__bnvs_name_tl #2
  \seq_set_eq:NN \l__bnvs_path_seq #3
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_n:NNNTF...LOOP... }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \tl_set_eq:NN \l__bnvs_a_tl \l__bnvs_name_tl
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \seq_if_empty:NTF \l__bnvs_b_seq {
          \group_end_return_true:
        } {
          \resolve:nF A {
            \resolve:nF C {
              \may_loop:
            }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \resolve:nF A {
          \resolve:nF C {
            \may_loop:
          }
        }
      }
    } {
      \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_n:NNNTF...TOO~MANY~CALLS }
\__bnvs_DEBUG:x { \string#1 = / #1 / }
\__bnvs_DEBUG:x { \string#2 = / #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
  \cs_set:Npn \may_loop: {
     \seq_pop_right:NNTF \l__bnvs_a_seq \l__bnvs_c_tl {
       \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
       \loop:
     } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_pm_n:NNNTF...Unknown~key }
\__bnvs_DEBUG:x { \string\l__bnvs_a_tl = / \tl_to_str:V \l__bnvs_a_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
       \group_end_return_true:
     }
  }
  \cs_set:Npn \resolve:nF ##1 ##2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_n:NNNTF...RESOLUTION~##1... }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_get:nVNTF ##1 \l__bnvs_a_tl \l__bnvs_b_tl {
      \__bnvs_inp_pm:NNNTF \l__bnvs_id_tl \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN \l__bnvs_name_tl \l__bnvs_b_tl
        \seq_set_eq:NN \l__bnvs_path_seq \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
        \loop:
      } {
        \may_loop:
      }
    } {
      ##2
    }
  }
  \cs_set:Npn \group_end_return_true: {
    \cs_set:Npn \:nnn ####1 ####2 ####3 {
      \__bnvs_group_end:
      \tl_set:Nn #1 { ####1 }
      \tl_set:Nn #2 { ####2 }
      \seq_set_split:Nnn #3 . { ####3 }
      \seq_remove_all:Nn #3 { }
    }
    \exp_args:NVVx
    \:nnn \l__bnvs_id_tl \l__bnvs_name_tl { \seq_use:Nn \l__bnvs_path_seq . }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_pm_n:NNNTF...TRUE }
\__bnvs_DEBUG:x { \string#1 = / \tl_to_str:V #1 / }
\__bnvs_DEBUG:x { \string#2 = / \tl_to_str:V #2 / }
\__bnvs_DEBUG:x { \string#3 = / \seq_use:Nn #3. / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \loop:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{\__bnvs_resolve_n:NNN, \__bnvs_resolve_x:NNN}
% \begin{syntax}
% \cs{__bnvs_resolve:NNNTF} \meta{id tl var} \meta{name tl var} \meta{path seq var} \marg{true code} \marg{false code}
% \end{syntax}
% When too many nested calls occurred, \marg{false code} is executed directly.
% \meta{id tl var}, \meta{name tl var} and \meta{path seq var}
% are meant to contain proper information.
% On input, \marg{id tl var} contains a frame id, 
% \marg{name tl var} contains a slide range name and
% \marg{path seq var} contains the components of an integer path, possibly empty.
% On return, \meta{id tl var} contains the frame id used,
% \meta{name tl var} contains the resolved range name and
% \meta{path seq var} contains the sequence of integer path components that could not be resolved.
%
% To resolve a level of a named one slide specification
% \meta{qualified name}.\meta{i_1}.\meta{i_2}...\meta{i_n},
% we replace the shortest \meta{qualified name}.\meta{i_1}.\meta{i_2}...\meta{i_k}
% where 0$≤$k$≤$n by its definition \meta{qualified name'}.\meta{j_1}...\meta{j_p}
% if any. The \cs{__bnvs_resolve:NNNTF} function uses this one level resolution
% as many times as possible, but no more than a predefined limit to catch
% circular reference that would lead to an infinite loop.
%
% \begin{enumerate}
% \item If \meta{name tl var} content is the name of an unlimited range,
% and the first item of this range is exactly another name range with
% eventually a heading frame identifier or a trailing integer path,
% then \meta{name tl var} is replaced by this name, the \meta{id tl var}
% and \cs{l__bnvs_id_tl} are updates accordingly and
% the \meta{path seq var} is prepended with the integer path.
% \item If \meta{path seq var} is not empty,
% append to the right of \meta{name tl var} after a separating dot,
% all its left elements but the last one  and loop.
% Otherwise return.
%
% \noindent NOTA BENE: Implementation details.
% None of the tl variables must be one of \cs{l_a_tl}, \cs{l_b_tl} or \cs{l_c_tl}.
% None of the seq variables must be one of \cs{l_a_seq}, \cs{l_b_seq}.
%
% In the |_x| variant, the resolution is driven one step further:
% if \meta{path seq var} is empty, \meta{name tl var} can contain anything.
%
% \end{enumerate}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_resolve_x:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_x:NNNTF...START }
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/ }
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l_a_seq} contains the index path components currently resolved.
% \item \cs{l_b_tl} contains the resolution.
% \item \cs{l_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\loop:...DEFINITION~X }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
      \tl_set_eq:NN \l__bnvs_a_tl #2
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \__bnvs_get:nVNTF L \l__bnvs_a_tl \l__bnvs_b_tl {
          \cs_set:Nn \loop: { \return_true: }        
        } {
          \get_extract:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unknown key \meta{\cs{l_a_tl}}|/A| or
% the value for key \meta{\cs{l_a_tl}}|/A| does not fit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \cs_set:Nn \loop: { \return_true: }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \get_extract:F {
          \seq_pop_right:NNT \l__bnvs_a_seq \l__bnvs_c_tl {
            \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
          }
        }
      }
      \loop:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_x:NNNTF\space~TOO~MANY~CALLS}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/ }
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \prg_return_false:
    }
  }
  \cs_set:Npn \get_extract:F ##1 {
    \__bnvs_get:nVNTF A \l__bnvs_a_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { RESOLUTION~X:~\l__bnvs_a_tl / A=>\l__bnvs_b_tl}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_inp:NNNTF #1 \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN #2 \l__bnvs_b_tl
        \seq_set_eq:NN #3 \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
      } {
        \seq_if_empty:NTF \l__bnvs_b_seq {
          \tl_set_eq:NN #2 \l__bnvs_b_tl
          \seq_clear:N #3
          \seq_clear:N \l__bnvs_a_seq
        } {
          ##1
        }
      }
    } { ##1 }
  }
  \cs_set:Npn \return_true: {
    \seq_pop_left:NNTF #3 \l__bnvs_a_tl {
      \seq_if_empty:NTF #3 {
        \tl_clear:N \l__bnvs_b_tl
						\__bnvs_if_index:VVNTF #2 \l__bnvs_a_tl \l__bnvs_b_tl {
						  \tl_set:NV #2 \l__bnvs_b_tl
						} {
\msg_warning:nnx { beanoves } { :n } { Unknown~#2}
						  \tl_set:NV #2 \l__bnvs_a_tl
						}
      } {
        \__bnvs_error:x { Path~too~long:~#2.\l__bnvs_a_tl
          .\seq_use:Nn\l__bnvs_path_seq .}
      }
    } {
      \tl_clear:N \l__bnvs_b_tl
					\__bnvs_if_counter:VNT #2 \l__bnvs_b_tl {
					  \tl_set:NV #2 \l__bnvs_b_tl
					}
    }
    \cs_set:Npn \:nnn ####1 ####2 ####3 {
      \__bnvs_group_end:
      \tl_set:Nn #1 { ####1 }
      \tl_set:Nn #2 { ####2 }
      \seq_set_split:Nnn #3 . { ####3 }
      \seq_remove_all:Nn #3 { }
    }
    \exp_args:NVVx
    \:nnn #1 #2 {
      \seq_use:Nn #3 .
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_x:NNNTF...TRUE/}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \loop:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_resolve_n:NNN
    #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_n:NNNTF...START }
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l_a_seq} contains the index path components currently resolved.
% \item \cs{l_b_tl} contains the resolution.
% \item \cs{l_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_set_eq:NN \l__bnvs_a_seq #3
  \seq_clear:N \l__bnvs_b_seq
  \cs_set:Npn \loop: {
    \__bnvs_call:TF {
      \tl_set_eq:NN \l__bnvs_a_tl #2
      \seq_if_empty:NTF \l__bnvs_a_seq {
        \__bnvs_get:nVNTF L \l__bnvs_a_tl \l__bnvs_b_tl {
          \return_true:
        } {
          \seq_if_empty:NTF \l__bnvs_b_seq {
            \return_true:
          } {
            \get_extract:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unknown key \meta{\cs{l_a_tl}}|/A| or
% the value for key \meta{\cs{l_a_tl}}|/A| does not fit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
              \return_true:
            }
          }
        }
      } {
        \tl_put_right:Nx \l__bnvs_a_tl { . \seq_use:Nn \l__bnvs_a_seq . }
        \get_extract:F {
          \seq_pop_right:NNT \l__bnvs_a_seq \l__bnvs_c_tl {
            \seq_put_left:NV \l__bnvs_b_seq \l__bnvs_c_tl
          }
        }
      }
      \loop:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_resolve_n:NNNTF\space~TOO~MANY~CALLS}
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \prg_return_false:
    }
  }
  \cs_set:Npn \get_extract:F ##1 {
    \__bnvs_get:nVNTF A \l__bnvs_a_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { RESOLUTION~N:~\l__bnvs_a_tl / A=>\l__bnvs_b_tl}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_inp:NNNTF #1 \l__bnvs_b_tl \l__bnvs_b_seq {
        \tl_set_eq:NN #2 \l__bnvs_b_tl
        \seq_set_eq:NN #3 \l__bnvs_b_seq
        \seq_set_eq:NN \l__bnvs_a_seq \l__bnvs_b_seq
        \seq_clear:N \l__bnvs_b_seq
      } { ##1 }
    } { ##1 }
  }
  \cs_set:Npn \return_true: {
    \cs_set:Npn \loop: { 
      \cs_set:Npn \:nnn ########1 ########2 ########3 {
        \__bnvs_group_end:
        \tl_set:Nn #1 { ########1 }
        \tl_set:Nn #2 { ########2 }
        \seq_set_split:Nnn #3 . { ########3 }
        \seq_remove_all:Nn #3 { }
      }
      \exp_args:NVVx
      \:nnn #1 #2 {
        \seq_use:Nn #3 .
      }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_resolve_n:NNNTF\space TRUE }
\__bnvs_DEBUG:x { \string#1:#1/\string#2:#2/}
\__bnvs_DEBUG:x { \string#3:\seq_use:Nn #3./}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  }
  \loop:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\__bnvs_resolve_pm_n:NNNTF]
% \Test_resolve_pm_n:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_resolve_pm_n:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_resolve_pm_n:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \Test_resolve_pm_n:nnnnnn { X=Y,Y } { X } { } { X } { } { 1B }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \Test_resolve_pm_n:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_resolve_pm_n:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_resolve_pm_n:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_resolve_pm_n:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { } { 7B }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B' }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1.2=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7C }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C' }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1=Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7D }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D' }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y=Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7E }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E' }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y.2.3=Z } { X } { 1.2.3.4 } { Z } { } { 7G }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G' }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y.2=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7H }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H' }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y=Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7I }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I' }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Z } { 3.4 } { 7J2 }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2' }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7L }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L' }
% \Test_resolve_pm_n:nnnnnn { X.1.2.3=Y, X.1.2=Z } { X } { 1.2.3.4 } { Z } { 4 } { 8A }
% \reset:n { YES }
% \Test_resolve_pm_n:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A' }
% \Test_resolve_pm_n:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A }
% \end{bnvs.test}
%
% \begin{bnvs.test}[banner=\string\__bnvs_resolve_pm_x:NNNTF]
% \Test_resolve_pm_x:nnnnnn { X } { X } { } { 1 } { } { 1A }
% \Test_resolve_pm_x:nnnnnn { X=1 } { X } { 1 } { 1 } { } { 2A }
% \Test_resolve_pm_x:nnnnnn { X } { X } { } { 1 } { } { 1A }
% \Test_resolve_pm_x:nnnnnn { X=1 } { X } { 1 } { 1 } { } { 2A }
% \Test_resolve_pm_x:nnnnnn { X.1=12 } { X } { 1 } { 12 } {  } { 3Ai }
% \Test_resolve_pm_x:nnnnnn { X.1.2=123 } { X } { 1.2 } { 123 } {  } { 3Aii }
% \Test_resolve_pm_x:nnnnnn { X.1.2.3=1234 } { X } { 1.2.3 } { 1234 } {  } { 3Aiii }
% \Test_resolve_pm_x:nnnnnn { X=Y,Y=1 } { X } { } { 1 } { } { 1B }
% \Test_resolve_pm_x:nnnnnn { X=Y,Y.1.2.3=123 } { X } { 1.2.3 } { 123 } { } { 2B }
% \Test_resolve_pm_x:nnnnnn { X=Y,Y=Z, Z=123 } { X } { } { 123 } { } { 3B }
% \Test_resolve_pm_x:nnnnnn { X=Y,Y=Z, Z.1.2.3=123 } { X } { 1.2.3 } { 123 } { } { 4B }
% \Test_resolve_pm_x:nnnnnn { X=Y,Y=Z, Z.1.2.3=12 } { X } { 1.2.3 } { 12 } { } { 4B }
% \Test_resolve_pm_x:nnnnnn { X.1=Y } { X } { 1 } { 1 } { } { 1C }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y=12 } { X } { 1 } { 12 } { } { 1C }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y=123 } { X } { 1.2 } { 123 } { } { 2C }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y.2 = 1234 } { X } { 1.2 } { 1234 } { } { 3C }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y.3=12 } { X } { 1.2.3 } { 12 } { } { 5C }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 6C }
% \Test_resolve_pm_x:nnnnnn { X=Y, Y.1.2.3.4=Z, Z = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7A }
% \Test_resolve_pm_x:nnnnnn { X=Y, Y.1.2.3=Z, Z.4 = 123 } { X } { 1.2.3.4 } { 123 } { } { 7B }
% \Test_resolve_pm_x:nnnnnn { X=Y, Y.1.2=Z, Z.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 7C }
% \Test_resolve_pm_x:nnnnnn { X=Y, Y.1=Z, Z.2.3.4 = 234} { X } { 1.2.3.4 } { 234 } { } { 7D }
% \Test_resolve_pm_x:nnnnnn { X=Y, Y=Z,Z.1.2.3.4 = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7D }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { 1 } { } { 7E }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y.2.3=Z, Z.4=4 } { X } { 1.2.3.4 } { 4 } { } { 7F }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y.2=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7G }
% \Test_resolve_pm_x:nnnnnn { X.1=Y, Y=Z, Z.2.3.4 = 234 } { X } { 1.2.3.4 } { 234 } { } { 7H }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { 1 } { } { 7I1 }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { 123 } { } { 7I2 }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y.3=Z, Z.4 = 4, } { X } { 1.2.3.4 } { 4 } { } { 7J }
% \Test_resolve_pm_x:nnnnnn { X.1.2=Y, Y=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7K }
% \Test_resolve_pm_x:nnnnnn { X.1.2.3=Y, X.1.2=Z, Y.4=4 } { X } { 1.2.3.4 } { 4 } { } { 8A }
% \Test_resolve_pm_x:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { 1 } { } { 9A }
% \end{bnvs.test}
%
% \subsubsection{Evaluation bricks}
%
% \begin{function}{ \__bnvs_fp_round:nN, \__bnvs_fp_round:N }
% \begin{syntax}
% \cs{__bnvs_fp_round:nN} \marg{expression} \meta{tl variable}
% \cs{__bnvs_fp_round:N} \meta{tl variable}
% \end{syntax}
% Shortcut for |\fp_eval:n{round(|\texttt{\meta{expression}}|)}| appended to \meta{tl variable}.
% The second variant replaces the variable content
% with its rounded floating point evaluation.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_fp_round:nN #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_fp_round:nN... }
\__bnvs_DEBUG:x { what=\tl_to_str:n{#1} / \string#2=>\tl_to_str:V #2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_fp_round:nN... }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \tl_put_right:Nx #2 {
      \fp_eval:n { round(#1) }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_fp_round:nN }
\__bnvs_DEBUG:x { \tl_to_str:V #2 => \string#2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \__bnvs_fp_round:nN { VN, xN }
\cs_new:Npn \__bnvs_fp_round:N #1 {
  \tl_if_empty:VTF #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\l__bnvs_fp_round:N ...EMPTY }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\l__bnvs_fp_round:N ...IN }
\__bnvs_DEBUG:x { \string#1=>\tl_to_str:N #1 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \tl_set:Nx #1 {
      \fp_eval:n { round(#1) }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\l__bnvs_fp_round:nN ...OUT }
\__bnvs_DEBUG:x { \string#1=>\tl_to_str:N #1 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{ \__bnvs_raw_first:nN, \__bnvs_raw_first:xN, \__bnvs_raw_first:VN }
% \begin{syntax}
% \cs{__bnvs_raw_first:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the first index of the \meta{name} slide range
% to the \meta{tl variable}.
% Cache the result.
% Execute \meta{true code} when there is a \meta{first}, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set:Npn \__bnvs_group_end_return_true:nnN #1 #2 #3 {
  \tl_if_empty:NTF \l__bnvs_ans_tl {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:n { RETURN_FALSE/SUBKEY=#1/KEY=#2/EMPTY }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_gremove_cache:nn { #1 } { #2 }
    \prg_return_false:
  } {
    \__bnvs_fp_round:N \l__bnvs_ans_tl
    \__bnvs_gput_cache:nnV { #1 } { #2 } \l__bnvs_ans_tl
    \exp_args:NNNV
    \__bnvs_group_end:
    \tl_put_right:Nn #3 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { RETURN_TRUE/SUBKEY=#1/KEY=#2/ans=\l__bnvs_ans_tl/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
\cs_set:Npn \__bnvs_group_end_return_false:nn #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:n { RETURN_FALSE/SUBKEY=#1/KEY=#2/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_end:
  \__bnvs_gremove_cache:nn { #1 } { #2 }
  \prg_return_false:
}
\prg_new_conditional:Npnn \__bnvs_raw_first:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_raw_first:nNTF...}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string#2 => \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get_cache:nnNTF A { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...NOT~CACHED...}
\__bnvs_DEBUG:x { KEY = / #1 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_group_begin:
    \tl_clear:N \l__bnvs_ans_tl
    \__bnvs_get:nnNTF A { #1 } \l__bnvs_a_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { #1/A => \tl_to_str:N \l__bnvs_a_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_if_append:VNTF \l__bnvs_a_tl \l__bnvs_ans_tl {
        \__bnvs_group_end_return_true:nnN A { #1 } #2
      } {
        \__bnvs_group_end_return_false:nn A { #1 }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\BeanovesLogGProp
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF... }
\__bnvs_DEBUG:x { Unknown~KEY = / #1 / A / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_get:nnNTF L { #1 } \l__bnvs_a_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF... }
\__bnvs_DEBUG:x { Known~KEY = / #1 / L / }
\__bnvs_DEBUG:x { \string\l__bnvs_a_tl => \tl_to_str:N \l__bnvs_a_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_get:nnNTF Z { #1 } \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF... }
\__bnvs_DEBUG:x { Known~KEY = / #1 / Z / }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_if_append:xNTF {
            \l__bnvs_b_tl - ( \l__bnvs_a_tl ) + 1
          } \l__bnvs_ans_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...TRUE}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string#2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \__bnvs_group_end_return_true:nnN A { #1 } #2
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...FALSE}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \__bnvs_group_end_return_false:nn A { #1 }
          }
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...FALSE}
\__bnvs_DEBUG:x { Unknown~KEY = / #1 / A / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_group_end_return_false:nn A { #1 }
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_first:nNTF...FALSE}
\__bnvs_DEBUG:x { unknown~KEY = / #1 / A / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_group_end_return_false:nn A { #1 }
      } 
    }
  }
}
\prg_generate_conditional_variant:Nnn
    \__bnvs_raw_first:nN { VN, xN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\__bnvs_raw_first:nNTF]
% \Test_raw:nnnn { first } { 222 } { 222 } { 1 }
% \Test_raw:nnnn { first } { 222 } { 222 } { 2 }
% \reset:n { YES }
% \Test_raw:nnnn { first } { FIRST } { 222 } { 3 }
% \Test_raw:nnnn { first } { FIRST } { 222 } { 4 }
% \Test_raw:nnnn { first } { FIRST:LENGTH } { 222 } { 5 }
% \Test_raw:nnnn { first } { FIRST:LENGTH } { 222 } { 6 }
% \Test_raw:nnnn { first } { FIRST::LAST } { 222 } { 7 }
% \Test_raw:nnnn { first } { FIRST::LAST } { 222 } { 8 }
% \Test_raw:nnnn { first } { :LENGTH::LAST } { 222 } { 8 }
% \Test_raw:nnnn { first } { :LENGTH::LAST } { 222 } { 9 }
% \Test_raw:nnnn { first } { ::LAST:LENGTH } { 222 } { 10 }
% \Test_raw:nnnn { first } { ::LAST:LENGTH } { 222 } { 11 }
% \end{bnvs.test}
% \begin{function}[TF]{ \__bnvs_if_first:nN }
% \begin{syntax}
% \cs{__bnvs_if_first:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the first index of the \meta{name} slide range
% to the \meta{tl variable}.
% If no first index was explicitely given,
% use the counter when available and 1 hen not.
% Cache the result.
% Execute \meta{true code} when there is a \meta{first}, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_first:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_first:nNTF... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { /\string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_raw_first:nNTF { #1 } #2 {
    \prg_return_true:
  } {
    \__bnvs_get:nnNTF C { #1 } \l__bnvs_a_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_first:nNTF... }
\__bnvs_DEBUG:n { / #1 / C / T / \l__bnvs_a_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \bool_set_true:N \l_no_counter_bool
      \__bnvs_if_append:VNTF \l__bnvs_a_tl \l__bnvs_ans_tl {
        \__bnvs_group_end_return_true:nnN A { #1 } #2
      } {
        \__bnvs_group_end_return_false:nn A { #1 }
      }
    } {
      \regex_match:NnTF \c__bnvs_A_key_Z_regex { #1 } {
        \__bnvs_gput:nnn A { #1 } { 1 }
        \tl_set:Nn #2 { 1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_first:nNTF...MATCH... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_group_end_return_true:nnN A { #1 } #2
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_first:nNTF...NO~MATCH... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \__bnvs_group_end_return_false:nn A { #1 }
      }
    }  
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\__bnvs_first:nN, \__bnvs_first:VN}
% \begin{syntax}
% \cs{__bnvs_first:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the start of the \meta{name} slide range
% to the \meta{tl variable}.
% Cache the result.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_first:nN #1 #2 {
  \__bnvs_if_first:nNF { #1 } #2 {
    \__bnvs_error:n { Range~with~no~first:~#1 }
  }
}
\cs_generate_variant:Nn \__bnvs_first:nN { VN }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=first]
% \reset:n { Y }
% \Test:nnnn { first } { 222 } { 222 } { 1 }
% \Test:nnnn { first } { 222 } { 222 } { 2 }
% \Test:nnnn { first } { FIRST } { 222 } { 3 }
% \Test:nnnn { first } { FIRST } { 222 } { 4 }
% \Test:nnnn { first } { FIRST:LENGTH } { 222 } { 5 }
% \Test:nnnn { first } { FIRST:LENGTH } { 222 } { 6 }
% \Test:nnnn { first } { FIRST::LAST } { 222 } { 7 }
% \Test:nnnn { first } { FIRST::LAST } { 222 } { 8 }
% \Test:nnnn { first } { :LENGTH::LAST } { 222 } { 8 }
% \Test:nnnn { first } { :LENGTH::LAST } { 222 } { 9 }
% \Test:nnnn { first } { ::LAST:LENGTH } { 222 } { 10 }
% \Test:nnnn { first } { ::LAST:LENGTH } { 222 } { 11 }
% \end{bnvs.test}
% \begin{function}[TF]{\__bnvs_raw_length:nN}
% \begin{syntax}
% \cs{__bnvs_raw_length:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the length of the \meta{name} slide range to \meta{tl variable}
% Execute \meta{true code} when there is a \meta{length}, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.test}[banner=raw_length]
% \reset:n { Y }
% \Test_raw:nnnn { length } { :445 } { 445 } { 1 }
% \Test_raw:nnnn { length } { :445 } { 445 } { 2 }
% \Test_raw:nnnn { length } { :LENGTH } { 445 } { 3 }
% \Test_raw:nnnn { length } { :LENGTH } { 445 } { 4 }
% \Test_raw:nnnn { length } { FIRST:LENGTH } { 445 } { 5 }
% \Test_raw:nnnn { length } { FIRST:LENGTH } { 445 } { 6 }
% \Test_raw:nnnn { length } { :LENGTH::LAST } { 445 } { 7 }
% \Test_raw:nnnn { length } { :LENGTH::LAST } { 445 } { 8 }
% \Test_raw:nnnn { length } { ::LAST:LENGTH } { 445 } { 9 }
% \Test_raw:nnnn { length } { ::LAST:LENGTH } { 445 } { 10 }
% \Test_append:nnnn { 222::666 } { X.last } { 666 } { A }
% \Test_append:nnnn { 222::666 } { X.1 } { 222 } { B }
% \Test_append:nnnn { 222::666 } { X.last - X.1 } { 444 } { C }
% \Test_append:nnnn { 222::666 } { X.last - (X.1) } { 444 } { D }
% \Test_append:nnnn { FIRST::LAST } { X.last } { 666 } { A2 }
% \Test_append:nnnn { FIRST::LAST } { X.1 } { 222 } { B2 }
% \Test_append:nnnn { FIRST::LAST } { X.last - X.1 } { 444 } { C2 }
% \Test_append:nnnn { FIRST::LAST } { X.last - (X.1) } { 444 } { D2 }
% \Test_raw:nnnn { length } { FIRST::LAST } { 445 } { 11 }
% \Test_raw:nnnn { length } { FIRST::LAST } { 445 } { 12 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_raw_length:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_raw_length:nNTF... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get_cache:nnNTF L { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_length:nNTF...CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { L = / \__bnvs_item_cache:nn L { #1 } / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_length:nNTF...NOT~CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_gput_cache:nnn L { #1 } { 0 }
    \__bnvs_group_begin:
    \tl_clear:N \l__bnvs_ans_tl
    \__bnvs_get:nnNTF L \l__bnvs_a_tl { #1 } {
      \__bnvs_if_append:VNTF \l__bnvs_a_tl \l__bnvs_ans_tl {
        \__bnvs_group_end_return_true:nnN L { #1 } #2
      } {
        \__bnvs_group_end_return_false:nn L { #1 }
      }
    } {
      \__bnvs_get:nnNTF A { #1 } \l__bnvs_a_tl {
        \__bnvs_get:nnNTF Z { #1 } \l__bnvs_b_tl {
          \__bnvs_if_append:xNTF {
            \l__bnvs_b_tl - (\l__bnvs_a_tl) + 1
          } \l__bnvs_ans_tl {
            \__bnvs_group_end_return_true:nnN L { #1 } #2
          } {
            \__bnvs_group_end_return_false:nn L { #1 }
          }
        } {
          \__bnvs_group_end_return_false:nn L { #1 }
        }
      } {
        \__bnvs_group_end_return_false:nn L { #1 }
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_raw_length:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\__bnvs_raw_last:nN}
% \begin{syntax}
% \cs{__bnvs_raw_last:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Put the last index of the fully qualified \meta{name} range to
% the right of the \meta{tl variable}, when possible.
% Execute \meta{true code} when a last index was given,
% \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_raw_last:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_raw_last:nNTF... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get_cache:nnNTF Z { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_last:nNTF...CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }  {
    \__bnvs_gput_cache:nnn Z { #1 } { 0 }
    \__bnvs_group_begin:
    \tl_clear:N \l__bnvs_ans_tl
    \__bnvs_get:nnNTF Z { #1 } \l__bnvs_a_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_raw_last:nNTF...NOT~CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_if_append:VNTF \l__bnvs_a_tl \l__bnvs_ans_tl {
        \__bnvs_group_end_return_true:nnN Z { #1 } #2
      } {
        \__bnvs_group_end_return_false:nn Z { #1 }
      }
    } {
      \__bnvs_get:nnNTF A { #1 } \l__bnvs_a_tl {
        \__bnvs_get:nnNTF L { #1 } \l__bnvs_b_tl {
          \__bnvs_if_append:xNTF {
            \l__bnvs_a_tl + (\l__bnvs_b_tl) - 1
          } \l__bnvs_ans_tl {
            \__bnvs_group_end_return_true:nnN Z { #1 } #2
          } {
            \__bnvs_group_end_return_false:nn Z { #1 }
          }
        } {
          \__bnvs_group_end_return_false:nn Z { #1 }
        }
      } {
        \__bnvs_group_end_return_false:nn Z { #1 }
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_raw_last:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_last:nN, \__bnvs_last:VN}
% \begin{syntax}
% \cs{__bnvs_last:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the last index of the fully qualified \meta{name} slide range to
% \meta{tl variable}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_last:nN #1 #2 {
  \__bnvs_raw_last:nNF { #1 } #2 {
    \__bnvs_error:n { Range~with~no~last:~#1 }
  }
}
\cs_generate_variant:Nn \__bnvs_last:nN { VN }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=last]
% \reset:n { Y }
% \Test_raw:nnnn { last } { ::666 } { 666 } { 1 }
% \Test_raw:nnnn { last } { ::666 } { 666 } { 2 }
% \Test_raw:nnnn { last } { ::LAST } { 666 } { 3 }
% \Test_raw:nnnn { last } { ::LAST } { 666 } { 4 }
% \Test_raw:nnnn { last } { FIRST::LAST } { 666 } { 5 }
% \Test_raw:nnnn { last } { FIRST::LAST } { 666 } { 6 }
% \Test_raw:nnnn { last } { :LENGTH::LAST } { 666 } { 7 }
% \Test_raw:nnnn { last } { :LENGTH::LAST } { 666 } { 8 }
% \Test_raw:nnnn { last } { ::LAST:LENGTH } { 666 } { 9 }
% \Test_raw:nnnn { last } { ::LAST:LENGTH } { 666 } { 10 }
% \Test_raw:nnnn { last } { FIRST:LENGTH } { 666 } { 10 }
% \Test_raw:nnnn { last } { FIRST:LENGTH } { 666 } { 11 }
% \end{bnvs.test}
%
% \begin{function}[TF]{\__bnvs_if_previous:nN}
% \begin{syntax}
% \cs{__bnvs_if_previous:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% Execute \meta{true code} when there is a \meta{next} index, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.test}[banner=\string\__bnvs_if_previous:nNTF]
% \reset:n { Y }
% \Test:nnnn { previous } { 222 } { 221 } { 1 }
% \Test:nnnn { previous } { 222: } { 221 } { 2 }
% \Test:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test:nnnn { previous } { FIRST } { 221 } { 1' }
% \Test:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test:nnnn { previous } { ::LAST } { 221 } { 4 }
% \Test:nnnn { previous } { ::LAST } { 221 } { 4' }
% \Test:nnnn { previous } { FIRST::LAST } { 221 } { 5 }
% \Test:nnnn { previous } { FIRST::LAST } { 221 } { 5' }
% \Test:nnnn { previous } { :LENGTH::LAST } { 221 } { 6 }
% \Test:nnnn { previous } { :LENGTH::LAST } { 221 } { 6' }
% \Test:nnnn { previous } { ::LAST:LENGTH } { 221 } { 7 }
% \Test:nnnn { previous } { ::LAST:LENGTH } { 221 } { 7' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_previous:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_previous:nNTF... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get_cache:nnNTF P { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_previous:nNTF...CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_previous:nNTF...NOT~CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_group_begin:
    \cs_set:Npn \return_false: {
      \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_previous:nNTF...FALSE }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
    \tl_clear:N \l__bnvs_a_tl
    \__bnvs_if_counter:nNTF { #1 } \l__bnvs_a_tl {
      \__bnvs_if_append:xNTF {
        \l__bnvs_a_tl - 1
      } \l__bnvs_ans_tl {
        \tl_if_empty:NTF \l__bnvs_ans_tl {
          \return_false:
        } {
          \__bnvs_fp_round:N \l__bnvs_ans_tl
          \__bnvs_gput_cache:nnV P { #1 } \l__bnvs_ans_tl
          \exp_args:NNNV
          \__bnvs_group_end:
          \tl_put_right:Nn #2 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_previous:nNTF...TRUE }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        }
      } {
        \return_false:
      }
    } {
      \return_false:
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_previous:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_previous:nN, \__bnvs_previous:VN}
% \begin{syntax}
% \cs{__bnvs_previous:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_previous:nN #1 #2 {
  \__bnvs_if_previous:nNF { #1 } #2 {
    \__bnvs_error:n { Range~with~no~previous:~#1 }
  }
}
\cs_generate_variant:Nn \__bnvs_previous:nN { VN }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{\__bnvs_if_next:nN}
% \begin{syntax}
% \cs{__bnvs_if_next:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% Execute \meta{true code} when there is a \meta{next} index, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.test}[banner=\string\__bnvs_if_next:nNTF]
% \reset:n { Y }
% \Test:nnnn { next } { ::666 } { 667 } { 1 }
% \Test:nnnn { next } { ::666 } { 667 } { 2 }
% \Test:nnnn { next } { ::LAST } { 667 } { 3 }
% \Test:nnnn { next } { ::LAST } { 667 } { 4 }
% \Test:nnnn { next } { FIRST::LAST } { 667 } { 5 }
% \Test:nnnn { next } { FIRST::LAST } { 667 } { 6 }
% \Test:nnnn { next } { :LENGTH::LAST } { 667 } { 7 }
% \Test:nnnn { next } { :LENGTH::LAST } { 667 } { 8 }
% \Test:nnnn { next } { ::LAST:LENGTH } { 667 } { 9 }
% \Test:nnnn { next } { ::LAST:LENGTH } { 667 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_next:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_next:nNTF... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_get_cache:nnNTF N { #1 } #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_next:nNTF...CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_next:nNTF...NOT~CACHED... }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_group_begin:
    \cs_set:Npn \return_false: {
      \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_next:nNTF...FALSE }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
    \tl_clear:N \l__bnvs_a_tl
    \__bnvs_raw_last:nNTF { #1 } \l__bnvs_a_tl {
      \__bnvs_if_append:xNTF {
        \l__bnvs_a_tl + 1
      } \l__bnvs_ans_tl {
        \tl_if_empty:NTF \l__bnvs_ans_tl {
          \return_false:
        } {
          \__bnvs_fp_round:N \l__bnvs_ans_tl
          \__bnvs_gput_cache:nnV N { #1 } \l__bnvs_ans_tl
          \exp_args:NNNV
          \__bnvs_group_end:
          \tl_put_right:Nn #2 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_next:nNTF...TRUE }
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        }
      } {
        \return_false:
      }
    } {
      \return_false:
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_next:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_next:nN, \__bnvs_next:VN}
% \begin{syntax}
% \cs{__bnvs_next:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_next:nN #1 #2 {
  \__bnvs_if_next:nNF { #1 } #2 {
    \__bnvs_error:n { Range~with~no~next:~#1 }
  }
}
\cs_generate_variant:Nn \__bnvs_next:nN { VN }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{\__bnvs_if_index:nnN, \__bnvs_if_index:VVN, \__bnvs_if_index:nnnN}
% \begin{syntax}
% \cs{__bnvs_if_index:nnNTF} \marg{name} \marg{integer} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the index associated to the \marg{name} and \marg{integer} slide range
% to the right of \meta{tl variable}.
% When \meta{integer shift} is 1, this is the first index,
% when \meta{integer shift} is 2, this is the second index, and so on.
% When \meta{integer shift} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \meta{true code} is executed, otherwise
% \meta{false code} is executed.
% The computation may fail when too many recursion calls are made.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_index:nnN #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_index:nnNTF...}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { index = / #2 / }
\__bnvs_DEBUG:x { \string#3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \__bnvs_raw_first:nNTF { #1 } \l__bnvs_a_tl {
    \tl_set_eq:NN \l__bnvs_ans_tl \l__bnvs_a_tl
    \tl_put_right:Nn \l__bnvs_ans_tl { + (#2) - 1}
    \exp_args:NV \__bnvs_fp_round:nN \l__bnvs_ans_tl \l__bnvs_ans_tl
    \__bnvs_raw_last:nNTF { #1 } \l__bnvs_b_tl {
      \int_compare:nNnT \l__bnvs_ans_tl < \l__bnvs_a_tl {
        \tl_set_eq:NN \l__bnvs_ans_tl \l__bnvs_a_tl
      }
      \int_compare:nNnT \l__bnvs_ans_tl > \l__bnvs_b_tl {
        \tl_set_eq:NN \l__bnvs_ans_tl \l__bnvs_b_tl
      }
    } {
      \__bnvs_get:nnNT * { #1 } \l__bnvs_b_tl {
        \int_compare:nNnT \l__bnvs_ans_tl < \l__bnvs_a_tl {
          \tl_set_eq:NN \l__bnvs_ans_tl \l__bnvs_a_tl
        }
      }
    }
    \exp_args:NNV
    \__bnvs_group_end:
    \__bnvs_fp_round:nN \l__bnvs_ans_tl #3
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_index:nnNTF...TRUE}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { index = / #2 / }
\__bnvs_DEBUG:x { \string#3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_index:nnNTF...FALSE}
\__bnvs_DEBUG:x { KEY = / #1 / }
\__bnvs_DEBUG:x { index = / #2 / }
\__bnvs_DEBUG:x { \string#3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_group_end:
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_index:nnN { VVN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=index]
% \reset:n { Y }
% \Test_index:nnnn { 11 } {  1 } { 11 } { 1 }
% \Test_index:nnnn { 11 } {  2 } { 12 } { 2 }
% \Test_index:nnnn { 11 } {  3 } { 13 } { 3 }
% \Test_index:nnnn { 11 } {  0 } { 10 } { 4 }
% \Test_index:nnnn { 11 } { -1 } {  9 } { 5 }
% \Test_index:nnnn { 11 } { -2 } {  8 } { 6 }
% \end{bnvs.test}
%
% \begin{function}[TF]{\__bnvs_if_range:nN}
% \begin{syntax}
% \cs{__bnvs_if_range:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the range of the \meta{name} slide range to the \meta{tl variable}.
% Execute \meta{true code} when there is a \meta{range}, \meta{false code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_range:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x{ RANGE:key=#1/\string#2/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \bool_if:NTF \l__bnvs_no_range_bool {
    \prg_return_false:
  } {
    \__bnvs_if_in:nnTF {} { #1 } {
      \tl_put_right:Nn { 0-0 }
    } {
      \__bnvs_group_begin:
      \tl_clear:N \l__bnvs_a_tl
      \tl_clear:N \l__bnvs_b_tl
      \tl_clear:N \l__bnvs_ans_tl
      \__bnvs_raw_first:nNTF { #1 } \l__bnvs_a_tl {
        \int_compare:nNnT { \l__bnvs_a_tl } < 0 {
          \tl_set:Nn \l__bnvs_a_tl { 0 }
        }
        \__bnvs_raw_last:nNTF { #1 } \l__bnvs_b_tl {
          \int_compare:nNnT { \l__bnvs_b_tl } < 0 {
            \tl_set:Nn \l__bnvs_b_tl { 0 }
          }
          \exp_args:NNNx
          \__bnvs_group_end:
          \tl_put_right:Nn #2 { \l__bnvs_a_tl - \l__bnvs_b_tl }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x{ RANGE_TRUE_A_Z:key=#1/\string#2=#2/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
          \exp_args:NNNx
          \__bnvs_group_end:
          \tl_put_right:Nn #2 { \l__bnvs_a_tl - }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x{ RANGE_TRUE_A:key=#1/\string#2=#2/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        }
      } {
        \__bnvs_raw_last:nNTF { #1 } \l__bnvs_b_tl {
        \int_compare:nNnT { \l__bnvs_b_tl } < 0 {
          \tl_set:Nn \l__bnvs_b_tl { 0 }
        }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x{ RANGE_TRUE_Z:key=#1/\string#2=#2/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \exp_args:NNNx
          \__bnvs_group_end:
          \tl_put_right:Nn #2 { - \l__bnvs_b_tl }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x{ RANGE_FALSE:key=#1/}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \__bnvs_group_end:
          \prg_return_false:
        }
      }
    }
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_range:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\__bnvs_range:nN, \__bnvs_range:VN}
% \begin{syntax}
% \cs{__bnvs_range:nN} \marg{name} \meta{tl variable}
% \end{syntax}
% Append the range of the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_range:nN #1 #2 {
  \__bnvs_if_range:nNF { #1 } #2 {
    \__bnvs_error:n { No~range~available:~#1 }
  }
}
\cs_generate_variant:Nn \__bnvs_range:nN { VN }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=range]
% \bool_set_false:N \l__bnvs_no_range_bool
% \Test_range:nnn { 222 } { 222- } { 1 }
% \Test_range:nnn { ::666 } { -666 } { 2 }
% \Test_range:nnn { 222::666 } { 222-666 } { 3 }
% \Test_range:nnn { 222:445 } { 222-666 } { 4 }
% \Test_range:nnn { :445::666 } { 222-666 } { 5 }
% \Test_range:nnn { ::666:445 } { 222-666 } { 6 }
% \reset:n { Y }
% \Test_range:nnn { FIRST } { 222- } { 1 }
% \Test_range:nnn { ::LAST } { -666 } { 2 }
% \Test_range:nnn { FIRST::LAST } { 222-666 } { 3 }
% ^^A\Test_range:nnn { FIRST:LENGTH } { 222-666 } { 4 }
% \Test_range:nnn { :LENGTH::LAST } { 222-666 } { 5 }
% \Test_range:nnn { ::LAST:LENGTH } { 222-666 } { 6 }
% \end{bnvs.test}
%
% \begin{function}[TF]{\__bnvs_if_free_counter:nN, \__bnvs_if_free_counter:VN}
% \begin{syntax}
% \cs{__bnvs_if_free_counter:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Set the \meta{tl variable} to the value of
% the counter associated to the \marg{name} slide range.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_free_counter:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_free_counter:nNTF... }
\__bnvs_DEBUG:x { KEY = /\tl_to_str:n{#1} }
\__bnvs_DEBUG:x { value=\__bnvs_item:nn C {#1} }
\__bnvs_DEBUG:x { cs=\string #2/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \__bnvs_get:nnNF C { #1 } \l__bnvs_ans_tl {
    \__bnvs_raw_first:nNF { #1 } \l__bnvs_ans_tl {
      \__bnvs_raw_last:nNF { #1 } \l__bnvs_ans_tl { }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_free_counter:nNTF... }
\__bnvs_DEBUG:x { \string \l__bnvs_ans_tl = \tl_to_str:V \l__bnvs_ans_tl/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \l__bnvs_ans_tl {
    \__bnvs_group_end:
    \regex_match:NnTF \c__bnvs_A_key_Z_regex { #1 } {
      \__bnvs_gput:nnn C { #1 } { 1 }
      \tl_set:Nn #2 { 1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_free_counter:nNTF...MATCH }
\__bnvs_DEBUG:x { KEY = /\tl_to_str:n{#1}/ }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_free_counter:nNTF...NO~MATCH }
\__bnvs_DEBUG:x { KEY = /\tl_to_str:n{#1}/ }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \__bnvs_gput:nnV C { #1 } \l__bnvs_ans_tl
    \exp_args:NNNV
    \__bnvs_group_end:
    \tl_set:Nn #2 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_free_counter:nNTF...TRUE }
\__bnvs_DEBUG:x { KEY = / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2 = / \tl_to_str:V #2 / }

%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_free_counter:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=if_free_counter:nNTF]
% \reset:n { Y }
% \Test_free_counter:nnn { 1 } { 1 } { 1 }
% \Test_free_counter:nnn { 222 } { 222 } { 2 }
% \Test_free_counter:nnn { ::666 } { 666 } { 3 }
% \Test_free_counter:nnn { FIRST } { 222 } { 4 }
% \Test_free_counter:nnn { ::LAST } { 666 } { 5 }
% \reset:n { YES }
% \Test_free_counter:nnn { A } { 1 } { 6 }
% \Test_free_counter:nnn { A+B } { 2 } { 7 }
% \Test_free_counter:nnn { A+B+C } { 3 } { 8 }
% \Test_free_counter:nnn { ::A } { 1 } { 9 }
% \Test_free_counter:nnn { ::A+B } { 2 } { 10 }
% \Test_free_counter:nnn { ::A+B+C } { 3 } { 11 }
% \end{bnvs.test}
% \begin{function}[TF]{\__bnvs_if_counter:nN, \__bnvs_if_counter:VN}
% \begin{syntax}
% \cs{__bnvs_if_counter:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the value of the counter associated to the \meta{name} overlay reference
% to the right of \meta{tl variable}.
% The value always lays in between the range, whenever possible.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_counter:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { IF_COUNTER:key=
  \tl_to_str:n{#1}/\string #2=\tl_to_str:V #2
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \__bnvs_if_free_counter:nNTF { #1 } \l__bnvs_ans_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% If there is a \meta{first}, use it to bound the result from below.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \tl_clear:N \l__bnvs_a_tl
    \__bnvs_raw_first:nNT { #1 } \l__bnvs_a_tl {
      \fp_compare:nNnT { \l__bnvs_ans_tl } < { \l__bnvs_a_tl } {
        \tl_set:NV \l__bnvs_ans_tl \l__bnvs_a_tl
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% If there is a \meta{last}, use it to bound the result from above.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \tl_clear:N \l__bnvs_a_tl
    \__bnvs_raw_last:nNT { #1 } \l__bnvs_a_tl {
      \fp_compare:nNnT { \l__bnvs_ans_tl } > { \l__bnvs_a_tl } {
        \tl_set:NV \l__bnvs_ans_tl \l__bnvs_a_tl
      }
    }
    \exp_args:NNV
    \__bnvs_group_end:
    \__bnvs_fp_round:nN \l__bnvs_ans_tl #2
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { IF_COUNTER_TRUE:key=\tl_to_str:n{#1}/
  \string #2=\tl_to_str:V #2
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {IF_COUNTER_FALSE:key=\tl_to_str:n{#1}/
  \string #2=\tl_to_str:V #2
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \__bnvs_group_end:
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_counter:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.gobble}
% \begin{bnvs.test}[banner=counter, reset=YES]
% \Test_counter:nnn { 1 } { 1 } { 1 }
% \Test_counter:nnn { 222 } { 222 } { 2 }
% \Test_counter:nnn { ::666 } { 666 } { 3 }
% \reset:n { YES }
% \Test_counter:nnn { FIRST } { 222 } { 4 }
% \Test_counter:nnn { ::LAST } { 666 } { 5 }
% \Test_counter:nnn { FIRST+LENGTH-1 } { 666 } { 6 }
% \Test_counter:nnn { ::FIRST+LENGTH-1 } { 666 } { 7 }
% \end{bnvs.test}
% \end{bnvs.gobble}
% \begin{function}[TF]{\__bnvs_if_n_counter:nN, \__bnvs_if_n_counter:VN}
% \begin{syntax}
% \cs{__bnvs_if_n_counter:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the value of the n counter associated to the \marg{name} overlay reference
% to the right of \meta{tl variable}.
% Initialize this counter to 1 on the first use.
% \meta{false code} is never executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_n_counter:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_n_counter:nNTF...}
\__bnvs_DEBUG:x { key= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2= / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_n_get:nNF { #1 } #2 {
    \tl_set:Nn #2 { 1 }
    \__bnvs_n_gput:nn { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_counter:nNTF...TRUE}
\__bnvs_DEBUG:x { key= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2= / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_n_counter:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=n_index]
% \Test_n_counter:nnn { 1 } { 1 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 123 }
% \Test_n_counter:nnn { } { 123 } { 2 }
% \end{bnvs.test}
%
% \begin{function}[TF]{\__bnvs_if_n_index:nN, \__bnvs_if_n_index:VN}
% \begin{syntax}
% \cs{__bnvs_if_n_counter:nNTF} \marg{name} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Append the value of the n counter associated to the \marg{name} slide range
% to the right of \meta{tl variable}.
% Initialize this counter to 1 on the first use.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_n_index:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_n_index:nNTF...}
\__bnvs_DEBUG:x { key= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2= / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \__bnvs_if_n_counter:nNF { #1 } \l__bnvs_a_tl { }
  \exp_args:NNnV
  \__bnvs_group_end:
  \__bnvs_if_index:nnNTF { #1 } \l__bnvs_a_tl #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_index:nNTF...TRUE}
\__bnvs_DEBUG:x { key= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2= / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_index:nNTF...FALSE}
\__bnvs_DEBUG:x { key= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { \string #2= / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_n_index:nN { VN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\__bnvs_if_n_index:nNTF]
% \Test_n_index:nnn { FIRST } { 1 } { 1 }
% \__bnvs_n_gput:nn { ?!X } { 445 }
% \Test_n_counter:nnn { } { 445 } { 2 }
% \__bnvs_log_gprop:
% \Test_raw_first:nnn { } { 1 } { 3 }
% \Test_n_index:nnn { } { 445 } { 4 }
% \end{bnvs.test}
%
% \begin{function} [TF] {\__bnvs_if_incr:nn, \__bnvs_if_incr:nnN, \__bnvs_if_incr:VnN, \__bnvs_if_incr:VVN}
% \begin{syntax}
% \cs{__bnvs_if_incr:nnTF}  \marg{name} \marg{offset} \marg{true code} \marg{false code}
% \cs{__bnvs_if_incr:nnNTF} \marg{name} \marg{offset} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% \end{function}
% Increment the free counter position accordingly.
% When requested, put the result in the \meta{tl variable}.
% In the second version, the result will lay within the declared range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_incr:nn #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_incr:nnTF... }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_a_tl
  \__bnvs_if_free_counter:nNTF { #1 } \l__bnvs_a_tl {
    \tl_clear:N \l__bnvs_b_tl
    \__bnvs_if_append:xNTF { \l__bnvs_a_tl + (#2) } \l__bnvs_b_tl {
      \__bnvs_fp_round:N \l__bnvs_b_tl
      \__bnvs_gput:nnV C { #1 } \l__bnvs_b_tl
      \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...TRUE }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...FALSE(1) }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...FALSE(2) }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_new_conditional:Npnn \__bnvs_if_incr:nnN #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_incr:nnTF... }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_incr:nnTF { #1 } { #2 } {
    \__bnvs_if_counter:nNTF { #1 } #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...TRUE }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...FALSE(1) }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_incr:nnTF...FALSE(2) }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_incr:nnN { VnN, VVN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=if_incr]
% \Test_incr:nnnn { 123 } { 123 } { 246 } { 1 }
% \Test_incr:nnnn { 123 } { 100+20+3 } { 246 } { 2 }
% \reset:n { YES }
% \Test_incr:nnnn { FIRST } { LENGTH-1 } { 666 } { 2 }
% \end{bnvs.test}
% \begin{function} [TF] {\__bnvs_if_n_incr:nn, \__bnvs_if_n_incr:nnN, \__bnvs_if_n_incr:VnN, \__bnvs_if_n_incr:VVN}
% \begin{syntax}
% \cs{__bnvs_if_n_incr:nnTF}  \marg{name} \marg{offset} \marg{true code} \marg{false code}
% \cs{__bnvs_if_n_incr:nnNTF} \marg{name} \marg{offset} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Increment the implicit index counter accordingly.
% When requested, put the result in the \meta{tl variable}.
% \end{function}
% \begin{bnvs.test}[banner=if_n_incr:nnNTF]
% \reset:n{ YES }
% \Test_n_incr:nnnn { 123 } { 123 } { 124 } { 1 }
% \Test_n:nnn { } { 124 } { 2 }
% \Test_n_incr:nnnn { 123 } { 500+40+2 } { 543 } { 2 }
% \reset:n { YES }
% \Test_n_incr:nnnn { FIRST } { LENGTH-1 } { 445 } { 2 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_n_incr:nn #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_n_incr:nnTF... }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_a_tl
  \__bnvs_n_get:nNF { #1 } \l__bnvs_a_tl {
    \tl_set:Nn \l__bnvs_a_tl { 1 }
  }
  \tl_clear:N \l__bnvs_b_tl
  \__bnvs_if_append:xNTF { \l__bnvs_a_tl + #2 } \l__bnvs_b_tl {
    \__bnvs_fp_round:N \l__bnvs_b_tl
    \__bnvs_n_gput:nV { #1 } \l__bnvs_b_tl
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_incr:nnTF...TRUE }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \__bnvs_group_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_incr:nnTF...FALSE }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_new_conditional:Npnn \__bnvs_if_n_incr:nnN #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_n_incr:nnNTF... }
\__bnvs_DEBUG:x { NAME = / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR = / \tl_to_str:n{#2} / }
\__bnvs_DEBUG:x { \string #3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_n_incr:nnTF { #1 } { #2 } {
    \__bnvs_n_get:nNT { #1 } #3 {}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_incr:nnNTF...TRUE }
\__bnvs_DEBUG:x { NAME = / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR = / \tl_to_str:n{#2} / }
\__bnvs_DEBUG:x { \string #3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_n_incr:nnNTF...FALSE }
\__bnvs_DEBUG:x { NAME= / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR= / \tl_to_str:n{#2} / }
\__bnvs_DEBUG:x { \string #3 => / \tl_to_str:N #3 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_n_incr:nnN { VnN, VVN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function} [TF] {\__bnvs_if_post:nnN, \__bnvs_if_post:VnN, \__bnvs_if_post:VVN}
% \begin{syntax}
% \cs{__bnvs_if_post:nnNTF} \marg{name} \marg{offset} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% \end{function}
% Put the value of the free counter for the given \meta{name} in
% the \meta{tl variable} then increment this free counter position
% accordingly.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_post:nnN #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_post:nnNTF... }
\__bnvs_DEBUG:x { NAME = / \tl_to_str:n{#1} / }
\__bnvs_DEBUG:x { INCR = / \tl_to_str:n{#2} / }
\__bnvs_DEBUG:x { \string#3 = / \tl_to_str:n{#3} / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_if_counter:nNTF { #1 } #3 {
    \__bnvs_if_incr:nnTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_post:nnNTF\space TRUE }
\__bnvs_DEBUG:x { \string#3=/#3/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_post:nnNTF\space FALSE(1) }
\__bnvs_DEBUG:x { \string #3 = /#3/ }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ... \string\__bnvs_if_post:nnNTF\space FALSE(2) }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_post:nnN { VnN, VVN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\__bnvs_if_post:nnNTF]
% \Test_post:nnnn { 123 } { 123 } { 123 } { 1 }
% \Test_post:nnnn { } { 123 } { 246 } { 1 }
% \Test_post:nnnn { } { 0 } { 369 } { 1 }
% \Test_post:nnnn { 123 } { 100+20+3 } { 123 } { 2 }
% \Test_post:nnnn { } { 0 } { 246 } { 1 }
% \reset:n { YES }
% \Test_post:nnnn { FIRST } { LENGTH-1 } { 222 } { 3 }
% \Test_post:nnnn { } { 0 } { 666 } { 3 }
% \end{bnvs.test}
%
% \subsubsection{Evaluation}
%
% \begin{function}[TF]{\__bnvs_if_append:nN,\__bnvs_if_append:VN,\__bnvs_if_append:xN}
% \begin{syntax}
% \cs{__bnvs_if_append:nNTF} \marg{integer expression} \meta{tl variable} \Arg{true code} \Arg{false code}
% \end{syntax}
% Evaluates the \meta{integer expression},
% replacing all the named specifications by their static
% counterpart then put the result to
% the right of the \meta{tl variable}.
% Executed within a group.
% Heavily used by \cs{__bnvs_eval_query:nN}, where \meta{integer expression}
% was initially enclosed in `|?(...)|'.
% Local variables: 
% \begin{variable}{\l__bnvs_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l__bnvs_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l__bnvs_split_int}
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\int_new:N  \l__bnvs_split_int
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{variable}{\l__bnvs_name_tl}
%    Storage for \cs{l_split_seq} items that represent names.
% \end{variable}
% \begin{variable}{\l__bnvs_path_tl}
%    Storage for \cs{l_split_seq} items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% Open a main \TeX\ group to define local functions and variables,
% sometimes another grouping level is used.
% The main \TeX\ group is closed in the \cs{return_...} functions.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_append:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_append:nNTF...}
\__bnvs_DEBUG:x { what= / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_call:TF {
    \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \int_zero:N  \l__bnvs_split_int
    \seq_clear:N \l__bnvs_split_seq
    \tl_clear:N  \l__bnvs_id_tl
    \tl_clear:N  \l__bnvs_name_tl
    \tl_clear:N  \l__bnvs_path_tl
    \tl_clear:N  \l__bnvs_group_tl
    \tl_clear:N  \l__bnvs_ans_tl
    \tl_clear:N  \l__bnvs_a_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% Implementation:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \regex_split:NnN \c__bnvs_split_regex { #1 } \l__bnvs_split_seq
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...}
\__bnvs_DEBUG:x { \#\string \l__bnvs_split_seq => \seq_count:N \l__bnvs_split_seq / }
\__bnvs_DEBUG:x { \string \l__bnvs_split_seq => \seq_use:Nn \l__bnvs_split_seq / / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \int_set:Nn \l__bnvs_split_int { 1 }
    \tl_set:Nx \l__bnvs_ans_tl {
      \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ANS: \l__bnvs_ans_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\switch:nTF}
% \begin{syntax}
% \cs{switch:nTF} \marg{capture group number} \marg{black code} \marg{white code}
% \end{syntax}
% Helper function to locally set the |\l__bnvs_group_tl| variable
% to the captured group \meta{capture group number}
% and branch.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
      \tl_set:Nx ##2 {
        \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int + ##1 }
      }
      \tl_if_empty:NTF ##2 {
        ##4 } {
        ##3
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{prg_return_true:} and \cs{prg_return_false:} are wrapped locally
% to close the group and return the proper value.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \fp_round: {
      \__bnvs_fp_round:N \l__bnvs_ans_tl
    }
    \cs_set:Npn \return_false: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...FALSE}
\__bnvs_DEBUG:x { what=\tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_end:
      \cs_set:Npn \loop: { \prg_return_false: }
    }
    \cs_set:Npn \return_false:x ##1 {
      \__bnvs_error:x { ##1 }
      \return_false:
    }
    \cs_set:Npn \:NnnT ##1 ##2 ##3 ##4 {
      \switch:nNTF { ##2 } \l__bnvs_id_tl { } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
      }
      \switch:nNTF { ##3 } \l__bnvs_path_tl {
        \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
        \seq_remove_all:Nn \l__bnvs_path_seq { }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...}
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      } {
        \seq_clear:N \l__bnvs_path_seq
      }
      ##1 \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
        \cs_set:Npn \: {
          ##4
        }
      } {
        \cs_set:Npn \: { \return_false: }
      }
      \:
    }
    \cs_set:Npn \:T ##1 {
      \seq_if_empty:NTF \l__bnvs_path_seq { ##1 } {
        \return_false:
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Main loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \loop: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...}
\__bnvs_DEBUG:x { LOOP:\int_use:N\l__bnvs_split_int /
  \seq_count:N \l__bnvs_split_seq /
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \int_compare:nNnTF {
        \l__bnvs_split_int } < { \seq_count:N \l__bnvs_split_seq
      } {
        \switch:nNTF 1 \l__bnvs_name_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item Case \texttt{++\meta{name}\meta{integer path}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~++... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \:NnnT \__bnvs_resolve_n:NNNTF 2 3 {
            \__bnvs_if_incr:VnNF \l__bnvs_name_tl 1 \l__bnvs_ans_tl {
              \return_false:
            }
          }
        } {
          \switch:nNTF 4 \l__bnvs_name_tl {
            \switch:nNTF 7 \l__bnvs_a_tl {
              \:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
                \:T {
                  \__bnvs_raw_length:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
                    \return_false:
                  }
                }
              }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...length}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...length }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/length]
% \reset:n { YES }
% \Test_append:nnnn { :445 } { X.length } { 445 } { 1 }
% \Test_append:nnnn { 222:445 } { X.length } { 445 } { 2 }
% \Test_append:nnnn { 222::666 } { X.length } { 445 } { 3 }
% \Test_append:nnnn { :445::666 } { X.length } { 445 } { 4 }
% \Test_append:nnnn { :LENGTH } { X.length } { 445 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.length } { 445 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.length } { 445 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.length } { 445 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            } {
              \switch:nNTF 8 \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...last}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...last }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                \:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
                  \:T {
                    \__bnvs_raw_last:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
                      \return_false:
                    }
                  }
                }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=append/last]
% \Test_append:nnnn { ::666 } { X.last } { 666 } { 1 }
% \Test_append:nnnn { 222:445 } { X.last } { 666 } { 2 }
% \Test_append:nnnn { 222::666 } { X.last } { 666 } { 3 }
% \Test_append:nnnn { :445::666 } { X.last } { 666 } { 4 }
% \reset:n { }
% \Test_append:nnnn { ::LAST } { X.last } { 666 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.last } { 666 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.last } { 666 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.last } { 666 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
              } {
                \switch:nNTF 9 \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...previous}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...previous }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/previous]
% \Test_append:nnnn { 222 } { X.previous } { 221 } { 1 }
% \Test_append:nnnn { 222:445 } { X.previous } { 221 } { 2 }
% \Test_append:nnnn { 222::666 } { X.previous } { 221 } { 3 }
% \Test_append:nnnn { :445::666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X.previous } { 221 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.previous } { 221 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.previous } { 221 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                  \:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
                    \:T {
\__bnvs_if_previous:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
  \return_false:
}
                    }
                  }
                } {
                  \switch:nNTF { 10 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...next}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...next }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/next]
% \Test_append:nnnn { ::666 } { X.next } { 667 } { 1 }
% \Test_append:nnnn { 222:445 } { X.next } { 667 } { 2 }
% \Test_append:nnnn { 222::666 } { X.next } { 667 } { 3 }
% \Test_append:nnnn { :445::666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_append:nnnn { ::LAST } { X.next } { 667 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.next } { 667 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.next } { 667 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.next } { 667 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                    \:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
                      \:T {
                        \__bnvs_if_next:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
                          \return_false:
                        }
                      }
                    }
                  } {
                    \switch:nNTF { 11 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...range}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...range }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append]
% \Test_append:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_append:nnnn { ::666 } { X.range } { -666 } { 2 }
% \Test_append:nnnn { 222:445 } { X.range } { 222-666 } { 3 }
% \Test_append:nnnn { 222::666 } { X.range } { 222-666 } { 4 }
% \Test_append:nnnn { :445::666 } { X.range } { 222-666 } { 5 }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_append:nnnn { ::LAST } { X.range } { -666 } { 7 }
% \Test_append:nnnn { FIRST:LENGTH } { X.range } { 222-666 } { 8 }
% \Test_append:nnnn { FIRST::LAST } { X.range } { 222-666 } { 9 }
% \Test_append:nnnn { :LENGTH::LAST } { X.range } { 222-666 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
  \:T {
    \__bnvs_if_range:VNTF \l__bnvs_name_tl \l__bnvs_ans_tl {
      \cs_set_eq:NN \fp_round: \prg_do_nothing:
    } {
      \return_false:
    }
  }
}
                    } {
                      \switch:nNTF { 12 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++n}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...++n }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append/...++n}]
% \reset:n { YES }
% \Test_append:nnnn { 222 } { X.++n } { 223 } { 1-a }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-a }
% \reset:n { YES }
% \Test_append:nnnn { FIRST } { X.++n } { 223 } { 1-b }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-b }
% \Test_append:nnnn { A,X.3=B,B=111,X.3.2=555 } { X.3.++n } { 555 } { 3-a }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\switch:nNTF { 5 } \l__bnvs_id_tl { } {
  \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
  \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
}
\switch:nNTF { 6 } \l__bnvs_path_tl {
  \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
  \seq_remove_all:Nn \l__bnvs_path_seq { }
} {
  \seq_clear:N \l__bnvs_path_seq
}
\__bnvs_group_begin:
\__bnvs_resolve_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \tl_clear:N \l__bnvs_b_tl
    \__bnvs_if_n_incr:VnNTF \l__bnvs_name_tl { 1 } \l__bnvs_b_tl {
      \exp_args:NNNV
      \__bnvs_group_end:
      \tl_set:Nn \l__bnvs_b_tl \l__bnvs_b_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
\__bnvs_resolve_x:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
  } {
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \return_false:x { Unknown~.<integer>~path:~#1 }
}
    } {
       \__bnvs_group_end:
    }
  } {
    \__bnvs_group_end:
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \__bnvs_group_end:
  \return_false:
}
                      } {
                        \switch:nNTF { 14 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{....n+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...n+=... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append/...n+=...}]
% \reset:n { YES }
% \Test_append:nnnn { 222 } { X.n += 444 } { 666 } { 1 }
% \Test_append:nnnn { } { X.n } { 666 } { 2 }
% \Test_append:nnnn { } { X.n += -444 } { 222 } { 3 }
% \Test_append:nnnn { } { X.n } { 222 } { 4 }
% \reset:n { YES }
% \Test_append:nnnn { FIRST } { X.n += 444 } { 666 } { B }
% \Test_append:nnnn { } { X.n } { 666 } { C }
% \Test_append:nnnn { } { X.n += -444 } { 222 } { D }
% \Test_append:nnnn { } { X.n } { 222 } { E }
% \Test_append:nnnn { } { X.n += (LENGTH - 1) } { 666 } { F }
% \Test_append:nnnn { } { X.n } { 666 } { G }
% \Test_append:nnnn { } { X.n += (-(LENGTH-1)) } { 222 } { H }
% \Test_append:nnnn { } { X.n } { 222 } { I }
% \Test_append:nnnn { } { X.n += LENGTH - 1 } { 666 } { J }
% \Test_append:nnnn { } { X.n } { 666 } { K }
% \Test_append:nnnn { } { X.n += -444~4 } { 2224 } { L }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\switch:nNTF { 5 } \l__bnvs_id_tl { } {
  \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
  \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
}
\switch:nNTF { 6 } \l__bnvs_path_tl {
  \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
  \seq_remove_all:Nn \l__bnvs_path_seq { }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
} {
  \seq_clear:N \l__bnvs_path_seq
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
\__bnvs_group_begin:
\__bnvs_resolve_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \tl_clear:N \l__bnvs_b_tl
    \__bnvs_if_n_incr:VVNTF \l__bnvs_name_tl \l__bnvs_a_tl \l__bnvs_b_tl {
      \exp_args:NNNV
      \__bnvs_group_end:
      \tl_set:Nn \l__bnvs_b_tl \l__bnvs_b_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
\__bnvs_resolve_x:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
  } {
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \return_false:x { Unknown~.<integer>~path:~#1 }
}
    } {
      \__bnvs_group_end:
    }
  } {
  \__bnvs_group_end:
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \__bnvs_group_end:
  \return_false:
}
                        } {
                          \switch:nNTF { 15 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...n++}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...n++ }
%</!gubed>
% \end{bnvs.gobble}
% We first resolve the named index reference, then we increment the index counter.
% \begin{bnvs.test}[banner={__bnvs_if_append:nNTF/...n++}]
% \Test_append:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_append:nnnn { } { X.n ++ } { 222 } { 1-b }
% \Test_append:nnnn { } { X.n   } { 223 } { 1-c }
% \reset:n { YES }
% \Test_append:nnnn { FIRST } { X.n ++ } { 222 } { 2-a }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-b }
% \Test_append:nnnn { LENGTH-1 } { X.n ++ } { 444 } { 3-a }
% \Test_append:nnnn { } { X.n   } { 445 } { 3-b }
% \Test_append:nnnn { LAST-1 } { X.n ++ } { 665 } { 4-a }
% \Test_append:nnnn { } { X.n   } { 666 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\switch:nNTF { 5 } \l__bnvs_id_tl { } {
  \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
  \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
}
\switch:nNTF { 6 } \l__bnvs_path_tl {
  \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
  \seq_remove_all:Nn \l__bnvs_path_seq { }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
} {
  \seq_clear:N \l__bnvs_path_seq
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
\__bnvs_group_begin:
\__bnvs_resolve_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \__bnvs_if_n_counter:VNT \l__bnvs_name_tl \l__bnvs_b_tl { }
    \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl    
    \__bnvs_resolve_x:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
      \seq_if_empty:NTF \l__bnvs_path_seq {
        \cs_set:Npn \:nn ####1 ####2 {
          \__bnvs_group_end:
          \tl_put_right:Nn \l__bnvs_ans_tl { ####1 }
          \__bnvs_n_gput:Vn \l__bnvs_name_tl { ####2 }
        }
        \tl_put_right:Nn \l__bnvs_b_tl { +1 }
        \__bnvs_fp_round:N \l__bnvs_b_tl
        \exp_args:NVV
        \:nn \l__bnvs_name_tl \l__bnvs_b_tl
      } {
        \__bnvs_group_end:
        \return_false:x { Too~many~.<integer>~components:~#1 }
      }
    } {
      \__bnvs_group_end:
      \return_false:x { Unknown~.<integer>~path:~#1 }
    }
  } {
    \__bnvs_group_end:
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \__bnvs_group_end:
  \return_false:
}
                          } {
                            \switch:nNTF { 13 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...n}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...n }
%</!gubed>
% \end{bnvs.gobble}
% The explanations given here also apply to other cases.
% We start by recovering the frame id and the integer path.
% Then we resolve the slide range name and path to
% the last possible name and a void integer path.
% We raise if we cannot obtain a void integer path.
% \begin{bnvs.test}[banner={append/...n}]
% \reset:n { YES }
% \Test_append:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_append:nnnn { FIRST+1 } { X.n } { 223 } { 1-b }
% \Test_append:nnnn { LENGTH-1 } { X.n } { 444 } { 1-c }
% \Test_append:nnnn { LAST } { X.n } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\switch:nNTF { 5 } \l__bnvs_id_tl { } {
  \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
  \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
}
\switch:nNTF { 6 } \l__bnvs_path_tl {
  \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
  \seq_remove_all:Nn \l__bnvs_path_seq { }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
} {
  \seq_clear:N \l__bnvs_path_seq
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
\__bnvs_group_begin:
\__bnvs_resolve_n:NNNTF \l__bnvs_id_tl \l__bnvs_name_tl \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \exp_args:NNV
    \__bnvs_group_end:
    \__bnvs_if_n_counter:nNTF \l__bnvs_name_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
\seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
\__bnvs_resolve_x:NNNTF \l__bnvs_id_tl  \l__bnvs_name_tl  \l__bnvs_path_seq {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
  } {
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \return_false:x { Undefined~.<integer>~path:~#1 }
}
    } {
      \return_false:
    }
  } {
    \__bnvs_group_end:
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
} {
  \__bnvs_group_end:
  \return_false:
}
                          } {
                            \switch:nNTF { 16 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...+=... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append/+=}]
% \Test_append:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_append:nnnn { } { X } { 666 } { 2 }
% \Test_append:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_append:nnnn { } { X } { 222 } { 4 }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_append:nnnn { } { FIRST } { 222 } { B }
% \Test_append:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_append:nnnn { } { X } { 666 } { 8 }
% \Test_append:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_append:nnnn { } { X } { 222 } { 10 }
% \Test_append:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_append:nnnn { } { X } { 666 } { 12 }
% \Test_append:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 16 }
% \Test_append:nnnn { } { X } { 667 } { 13 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \__bnvs_if_incr:VVNF \l__bnvs_name_tl \l__bnvs_a_tl \l__bnvs_ans_tl {
      \return_false:
    }
  } {
    \return_false:x { Too~many~.<integer>~components:~#1 }
  }
}
                            } {
                              \switch:nNTF { 17 } \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...++ }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append/...++}]
% \Test_append:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_append:nnnn { } { X++ } { 223 } { 2-a }
% \Test_append:nnnn { } { X   } { 224 } { 3-a }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_append:nnnn { } { X++ } { 223 } { 2-b }
% \Test_append:nnnn { } { X   } { 224 } { 3-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
  \seq_if_empty:NTF \l__bnvs_path_seq {
    \__bnvs_if_post:VnNF \l__bnvs_name_tl { 1 } \l__bnvs_ans_tl {
      \return_false:
    }
  } {
     \return_false:x { Too~many~.<integer>~components:~#1 }
  }
}
                              } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{No special attribute}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append/counter}]
% \Test_append:nnnn { 222 } { X } { 222 } { 1-a }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_append:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_append:nnnn { LAST } { X } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\:NnnT \__bnvs_resolve_n:NNNTF 5 6 {
  \seq_pop_left:NNTF \l__bnvs_path_seq \l__bnvs_b_tl {
    \seq_if_empty:NTF \l__bnvs_path_seq {
      \__bnvs_if_index:VVNF \l__bnvs_name_tl \l__bnvs_b_tl \l__bnvs_ans_tl {
        \return_false:
      }
    } {
      \return_false:x { Too~many~.<integer>~components:~#1 }
    }
  } {
    \__bnvs_if_counter:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
      \return_false:x { Undefined~counter:~#1 }
    }
  }
}
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% No name. Unreachable code.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          }
        }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...}
\__bnvs_DEBUG:x { \string\l__bnvs_ans_tl = \tl_to_str:N \l__bnvs_ans_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \int_add:Nn \l__bnvs_split_int { 18 }
        \tl_put_right:Nx \l__bnvs_ans_tl {
          \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int }
        }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ITERATE~ANS=\l__bnvs_ans_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \loop:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {END_OF_LOOP~ANS=\l__bnvs_ans_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \fp_round:
        \exp_args:NNNV
        \__bnvs_group_end:
        \tl_put_right:Nn #2 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append:nNTF...TRUE}
\__bnvs_DEBUG:x { what=\tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => \/ tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
    }
    \loop:
  } {
    \__bnvs_error:x { Too~many~calls:~ #1 }
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn
  \__bnvs_if_append:nN { VN, xN } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}














% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Nnn \__bnvs_if_append_pm:nN { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string\__bnvs_if_append_pm:nNTF...}
\__bnvs_DEBUG:x { what= / \tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_call:TF {
    \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% This \TeX\ group is closed just before returning.
% Local variables:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \int_zero:N  \l__bnvs_split_int
    \seq_clear:N \l__bnvs_split_seq
    \tl_clear:N  \l__bnvs_id_tl
    \tl_clear:N  \l__bnvs_name_tl
    \tl_clear:N  \l__bnvs_path_tl
    \tl_clear:N  \l__bnvs_group_tl
    \tl_clear:N  \l__bnvs_ans_tl
    \tl_clear:N  \l__bnvs_a_tl
%    \end{macrocode}
% \end{bnvs.macrocode}
% Implementation:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \regex_split:NnN \c__bnvs_split_pm_regex { #1 } \l__bnvs_split_seq
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF...}
\__bnvs_DEBUG:x { \#\string \l__bnvs_split_seq => / \seq_count:N \l__bnvs_split_seq / }
\__bnvs_DEBUG:x { \string \l__bnvs_split_seq => / \seq_use:Nn \l__bnvs_split_seq / / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \int_set:Nn \l__bnvs_split_int { 1 }
    \tl_set:Nx \l__bnvs_ans_tl {
      \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { START~ANS: \l__bnvs_ans_tl }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\switch:nNTF}
% \begin{syntax}
% \cs{switch:nNTF} \marg{capture group number} \marg{tl variable} \marg{black code} \marg{white code}
% \end{syntax}
% Helper function to locally set the \meta{tl variable}
% to the captured group \meta{capture group number}
% and branch.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
      \tl_set:Nx ##2 {
        \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int + ##1 }
      }
      \tl_if_empty:NTF ##2 {
        ##4 } {
        ##3
      }
    }
    \cs_set:Npn \fp_round: {
      \__bnvs_fp_round:N \l__bnvs_ans_tl
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \cs{prg_return_true:} and \cs{prg_return_false:} are wrapped locally
% to close the group and return the proper value.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \group_end_return_false: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF...FALSE}
\__bnvs_DEBUG:x { what=\tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:N #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \cs_set:Npn \loop: {
        \__bnvs_group_end:
        \prg_return_false:
      }
    }
    \cs_set:Npn \group_end_return_false:x ##1 {
      \__bnvs_error:x { ##1 }
      \group_end_return_false:
    }
    \cs_set:Npn \resolve_n:T ##1 {
      \__bnvs_resolve_pm_n:TFF {
        ##1
      } {
        \group_end_return_false:x { Too~many~dotted~components:~#1 }
      } {
        \group_end_return_false:x { Unknown~dotted~path:~#1 }
      }
    }
    \cs_set:Npn \resolve_x:T ##1 {
      \__bnvs_resolve_pm_x:TFF {
        ##1
      } {
        \group_end_return_false:x { Too~many~dotted~components:~#1 }
      } {
        \group_end_return_false:x { Unknown~dotted~path:~#1 }
      }
    }
    \cs_set:Npn \:nn ##1 ##2 {
      \switch:nNTF { ##1 } \l__bnvs_id_tl { } {
        \tl_set_eq:NN \l__bnvs_id_tl \l__bnvs_id_last_tl
        \tl_put_left:NV \l__bnvs_name_tl \l__bnvs_id_tl
      }
      \switch:nNTF { ##2 } \l__bnvs_path_tl {
        \seq_set_split:NnV \l__bnvs_path_seq { . } \l__bnvs_path_tl
        \seq_remove_all:Nn \l__bnvs_path_seq { }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF...}
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      } {
        \seq_clear:N \l__bnvs_path_seq
      }
    }
    \cs_set:cpn {.n?:TF} ##1 ##2 {
      \seq_get_right:NNTF \l__bnvs_path_seq \l__bnvs_b_tl {
        \exp_args:NV 
        \str_if_eq:nnTF \l__bnvs_b_tl { n } {
          \seq_pop_right:NN \l__bnvs_path_seq \l__bnvs_b_tl
          ##1
        } { ##2 }
      } { ##2 }
    }
    \cs_set:cpn {...++n:} {
      \__bnvs_group_begin:
      \__bnvs_resolve_pm_n:TFF {
        \tl_clear:N \l__bnvs_b_tl
        \__bnvs_if_n_incr:VnNTF \l__bnvs_name_tl { 1 } \l__bnvs_b_tl {
          \exp_args:NNNV
          \__bnvs_group_end:
          \tl_set:Nn \l__bnvs_b_tl \l__bnvs_b_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:V \l__bnvs_b_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
          \resolve_x:T {
            \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
          }
        } {
          \__bnvs_group_end:
        }
      } {
        \__bnvs_group_end:
        \group_end_return_false:x { Too~many~dotted~components:~#1 }
      } {
        \__bnvs_group_end:
        \group_end_return_false:
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Main loop.
% The explanations given here apply to quite every case.
% We start by recovering the frame id and the dotted path.
% Then we resolve the slide range name and path to
% the last possible name and a void integer path.
% We raise if we cannot obtain a void integer path.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \loop: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF... }
\__bnvs_DEBUG:x { LOOP = / \int_use:N\l__bnvs_split_int /
  \seq_count:N \l__bnvs_split_seq /
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \int_compare:nNnTF {
        \l__bnvs_split_int } < { \seq_count:N \l__bnvs_split_seq
      } {
        \switch:nNTF { 1 } \l__bnvs_name_tl {
          \:nn { 2 } { 3 }
          \use:c {.n?:TF} {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item Case \texttt{++...n}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~++...n }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/++...n}]
% \reset:n { YES }
% \Test_append_pm:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-a }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-b }
% \Test_append_pm:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_append_pm:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \use:c { ...++n: }
          } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{++\meta{name}\meta{integer path}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~++... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={\string\__bnvs_if_append_pm:nNTF/++...}]
% \Test_append_pm:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_append_pm:nnnn { } { ++X } { 224 } { 2-a }
% \Test_append_pm:nnnn { } { X   } { 224 } { 3-a }
% \reset:n { }
% \Test_append_pm:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_append_pm:nnnn { } { ++X } { 224 } { 2-b }
% \Test_append_pm:nnnn { } { X   } { 224 } { 3-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \resolve_n:T {
              \tl_clear:N \l__bnvs_ans_tl
              \__bnvs_if_incr:VnNF \l__bnvs_name_tl 1 \l__bnvs_ans_tl {
                \group_end_return_false:
              }
            }
          }
        } {
          \switch:nNTF 4 \l__bnvs_name_tl {
            \:nn { 5 } { 6 }
            \switch:nNTF 7 \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++n}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...++n }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/...++n}]
% \reset:n { YES }
% \Test_append_pm:nnnn { 222 } { X.++n } { 223 } { 1-a }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-a }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X.++n } { 223 } { 1-b }
% \Test_append:nnnn { } { X.n   } { 223 } { 2-b }
% \Test_append_pm:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { X.3.N.++n } { 555 } { 3-b }
% \Test_append_pm:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
              \use:c { ...++n: }
            } {
              \switch:nNTF 8 \l__bnvs_a_tl {
                \use:c { .n?:TF } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{....n+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...n+=... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/...n+=...}]
% \reset:n { YES }
% \Test_append_pm:nnnn { 222 } { X.n += 444 } { 666 } { 1 }
% \Test_append_pm:nnnn { } { X.n } { 666 } { 2 }
% \Test_append_pm:nnnn { } { X.n += -444 } { 222 } { 3 }
% \Test_append_pm:nnnn { } { X.n } { 222 } { 4 }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X.n += 444 } { 666 } { B }
% \Test_append_pm:nnnn { } { X.n } { 666 } { C }
% \Test_append_pm:nnnn { } { X.n += -444 } { 222 } { D }
% \Test_append_pm:nnnn { } { X.n } { 222 } { E }
% \Test_append_pm:nnnn { } { X.n += (LENGTH - 1) } { 666 } { F }
% \Test_append_pm:nnnn { } { X.n } { 666 } { G }
% \Test_append_pm:nnnn { } { X.n += (-(LENGTH-1)) } { 222 } { H }
% \Test_append_pm:nnnn { } { X.n } { 222 } { I }
% \Test_append_pm:nnnn { } { X.n += LENGTH - 1 } { 666 } { J }
% \Test_append_pm:nnnn { } { X.n } { 666 } { K }
% \Test_append_pm:nnnn { } { X.n += -444~4 } { 2224 } { L }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\__bnvs_group_begin:
\__bnvs_resolve_pm_n:TFF {
  \tl_clear:N \l__bnvs_b_tl
  \__bnvs_if_n_incr:VVNTF \l__bnvs_name_tl \l__bnvs_a_tl \l__bnvs_b_tl {
    \exp_args:NNNV
    \__bnvs_group_end:
    \tl_set:Nn \l__bnvs_b_tl \l__bnvs_b_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
    \resolve_x:T {
      \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
    }
  } {
    \__bnvs_group_end:
  }
} {
    \__bnvs_group_end:
    \group_end_return_false:x { Too~many~dotted~components:~#1 }
} {
  \__bnvs_group_end:
  \group_end_return_false:x { Unknown~dotted~path:~#1 }
}
                } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{A+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...+=... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/...+=...}]
% \Test_append_pm:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_append_pm:nnnn { } { X } { 666 } { 2 }
% \Test_append_pm:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_append_pm:nnnn { } { X } { 222 } { 4 }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_append_pm:nnnn { } { FIRST } { 222 } { B }
% \Test_append_pm:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_append_pm:nnnn { } { X } { 666 } { 8 }
% \Test_append_pm:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_append_pm:nnnn { } { X } { 222 } { 10 }
% \Test_append_pm:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_append_pm:nnnn { } { X } { 666 } { 12 }
% \Test_append_pm:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 16 }
% \Test_append_pm:nnnn { } { X } { 667 } { 13 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\resolve_n:T {
  \__bnvs_if_incr:VVNF \l__bnvs_name_tl \l__bnvs_a_tl \l__bnvs_ans_tl {
    \group_end_return_false:
  }
}
                }
              } {
                \switch:nNTF 9 \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...++ }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/...++}]
% \Test_append:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_append:nnnn { } { X++ } { 223 } { 2-a }
% \Test_append:nnnn { } { X   } { 224 } { 3-a }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_append:nnnn { } { X++ } { 223 } { 2-b }
% \Test_append:nnnn { } { X   } { 224 } { 3-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\resolve_n:T {
  \__bnvs_if_post:VnNF \l__bnvs_name_tl { 1 } \l__bnvs_ans_tl {
    \return_false:
  }
}
                } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Only the path, branch according to the last component.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\seq_pop_right:NNTF \l__bnvs_path_seq \l__bnvs_b_tl {
  \exp_args:NV
  \str_case:nnF \l__bnvs_b_tl {
    { n } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...n}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...n }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/...n}]
% \reset:n { YES }
% \Test_append_pm:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_append_pm:nnnn { FIRST+1 } { X.n } { 223 } { 1-b }
% \Test_append_pm:nnnn { LENGTH-1 } { X.n } { 444 } { 1-c }
% \Test_append_pm:nnnn { LAST } { X.n } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { PATH_SEQ:\l__bnvs_path_tl==.\seq_use:Nn\l__bnvs_path_seq .}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \__bnvs_group_begin:
      \resolve_n:T {
        \exp_args:NNV
        \__bnvs_group_end:
        \__bnvs_if_n_counter:nNTF \l__bnvs_name_tl \l__bnvs_b_tl {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF... }
\__bnvs_DEBUG:x { \string\l__bnvs_b_tl => / \tl_to_str:N \l__bnvs_b_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \seq_put_right:NV \l__bnvs_path_seq \l__bnvs_b_tl
          \resolve_x:T {
            \tl_put_right:NV \l__bnvs_ans_tl \l__bnvs_name_tl
          }
        } {
\group_end_return_false:x { Undefined~dotted~path:~#1 }
        }
      }
    }
    { length } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...length}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...length }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append_pm/last]
% \Test_append_pm:nnnn { ::666 } { X.last } { 666 } { 1 }
% \Test_append_pm:nnnn { 222:445 } { X.last } { 666 } { 2 }
% \Test_append_pm:nnnn { 222::666 } { X.last } { 666 } { 3 }
% \Test_append_pm:nnnn { :445::666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_append_pm:nnnn { ::LAST } { X.last } { 666 } { 5 }
% \Test_append_pm:nnnn { FIRST:LENGTH } { X.last } { 666 } { 6 }
% \Test_append_pm:nnnn { FIRST::LAST } { X.last } { 666 } { 7 }
% \Test_append_pm:nnnn { :LENGTH::LAST } { X.last } { 666 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \resolve_n:T {
        \__bnvs_raw_length:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
          \group_end_return_false:
        } 
      }
    }
    { last } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...last}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...last }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/last]
% \Test_append_pm:nnnn { ::666 } { X.last } { 666 } { 1 }
% \Test_append_pm:nnnn { 222:445 } { X.last } { 666 } { 2 }
% \Test_append_pm:nnnn { 222::666 } { X.last } { 666 } { 3 }
% \Test_append_pm:nnnn { :445::666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_append_pm:nnnn { ::LAST } { X.last } { 666 } { 5 }
% \Test_append_pm:nnnn { FIRST:LENGTH } { X.last } { 666 } { 6 }
% \Test_append_pm:nnnn { FIRST::LAST } { X.last } { 666 } { 7 }
% \Test_append_pm:nnnn { :LENGTH::LAST } { X.last } { 666 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \resolve_n:T {
        \__bnvs_raw_last:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
          \group_end_return_false:
        }
      }
    }
    { range } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...range}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...range }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append]
% \Test_append_pm:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_append_pm:nnnn { ::666 } { X.range } { -666 } { 2 }
% \Test_append_pm:nnnn { 222:445 } { X.range } { 222-666 } { 3 }
% \Test_append_pm:nnnn { 222::666 } { X.range } { 222-666 } { 4 }
% \Test_append_pm:nnnn { :445::666 } { X.range } { 222-666 } { 5 }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_append_pm:nnnn { ::LAST } { X.range } { -666 } { 7 }
% \Test_append_pm:nnnn { FIRST:LENGTH } { X.range } { 222-666 } { 8 }
% \Test_append_pm:nnnn { FIRST::LAST } { X.range } { 222-666 } { 9 }
% \Test_append_pm:nnnn { :LENGTH::LAST } { X.range } { 222-666 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \resolve_n:T {
        \__bnvs_if_range:VNTF \l__bnvs_name_tl \l__bnvs_ans_tl {
          \cs_set_eq:NN \fp_round: \prg_do_nothing:
        } {
          \group_end_return_false:
        }
      }
    }
    { previous } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...previous}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...previous }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/previous]
% \Test_append:nnnn { 222 } { X.previous } { 221 } { 1 }
% \Test_append:nnnn { 222:445 } { X.previous } { 221 } { 2 }
% \Test_append:nnnn { 222::666 } { X.previous } { 221 } { 3 }
% \Test_append:nnnn { :445::666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_append:nnnn { FIRST } { X.previous } { 221 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.previous } { 221 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.previous } { 221 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \resolve_n:T {
        \__bnvs_if_previous:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
          \group_end_return_false:
        }
      }
    }
    { next } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...next}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...next }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner=append/next]
% \Test_append:nnnn { ::666 } { X.next } { 667 } { 1 }
% \Test_append:nnnn { 222:445 } { X.next } { 667 } { 2 }
% \Test_append:nnnn { 222::666 } { X.next } { 667 } { 3 }
% \Test_append:nnnn { :445::666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_append:nnnn { ::LAST } { X.next } { 667 } { 5 }
% \Test_append:nnnn { FIRST:LENGTH } { X.next } { 667 } { 6 }
% \Test_append:nnnn { FIRST::LAST } { X.next } { 667 } { 7 }
% \Test_append:nnnn { :LENGTH::LAST } { X.next } { 667 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \resolve_n:T {
        \__bnvs_if_next:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
          \group_end_return_false:
        }
      }
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...\meta{integer}}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~...<integer> }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/counter}]
% \Test_append_pm:nnnn { 222 } { X.1 } { 222 } { 1-a }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X.1 } { 222 } { 1-b }
% \Test_append_pm:nnnn { LENGTH } { X.1 } { 445 } { 1-c }
% \Test_append_pm:nnnn { LAST } { X.1 } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \resolve_n:T {
      \__bnvs_if_index:VVNF \l__bnvs_name_tl \l__bnvs_b_tl \l__bnvs_ans_tl {
        \group_end_return_false:
      }
    }
  }
} {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...}.
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ▃▃▃▃▃~CASE~... }
%</!gubed>
% \end{bnvs.gobble}
% \begin{bnvs.test}[banner={append_pm/counter}]
% \Test_append_pm:nnnn { 222 } { X } { 222 } { 1-a }
% \reset:n { YES }
% \Test_append_pm:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_append_pm:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_append_pm:nnnn { LAST } { X } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \resolve_n:T {
    \__bnvs_if_counter:VNF \l__bnvs_name_tl \l__bnvs_ans_tl {
      \group_end_return_false:
    }
  }
}
                }
              }
            }
          } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% No name. Unreachable code.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          }
        }
        \int_add:Nn \l__bnvs_split_int { 10 }
        \tl_put_right:Nx \l__bnvs_ans_tl {
          \seq_item:Nn \l__bnvs_split_seq { \l__bnvs_split_int }
        }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF...POOL...}
\__bnvs_DEBUG:x { \string \l__bnvs_ans_tl => / \tl_to_str:V \l__bnvs_ans_tl / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \loop:
      } {
        \fp_round:
        \exp_args:NNNV
        \__bnvs_group_end:
        \tl_put_right:Nn #2 \l__bnvs_ans_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_append_pm:nNTF...TRUE}
\__bnvs_DEBUG:x { WHAT = /\tl_to_str:n { #1 } / }
\__bnvs_DEBUG:x { \string #2 => / \tl_to_str:V #2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
    }
    \loop:
  } {
    \__bnvs_error:x { Too~many~calls:~ #1 }
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
%
% \begin{function}[TF]{\__bnvs_if_eval_query:nN}
% \begin{syntax}
% \cs{__bnvs_if_eval_query:nNTF} \marg{overlay query} \meta{tl variable} \marg{true code} \marg{false code}
% \end{syntax}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of the \meta{seq variable}.
% Ranges are supported with the colon syntax.
% This is executed within a local \TeX\ group.
% Below are local variables and constants.
% \begin{variable}{\l__bnvs_a_tl}
% Storage for the first index of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_b_tl}
% Storage for the last index of a range, or its length.
% \end{variable}
% \begin{variable}{\c__bnvs_A_cln_Z_regex}
% Used to parse slide range overlay specifications.
% Next are the capture groups.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item 2: \meta{first}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      ( [^:]* ) \s* :
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 3: second optional colon
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      (:)? \s*
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 4: \meta{length}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      ( [^:]* )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 5: standalone \meta{first}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( [^:]+ )
  ) \s* \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}[banner=A_cln_Z]
% \Test_regex:nnnn { A_cln_Z } {A:B} {A:B,{A},{},{B},{}} {1}
% \Test_regex:nnnn { A_cln_Z } {A} {A,{},{},{},A} {2}
% \Test_regex:nnnn { A_cln_Z } {A:B} {A:B,{A},{},{B},{}} {3}
% \Test_regex:nnnn { A_cln_Z } {A::B} {A::B,{A},{:},{B},{}} {4}
% \Test_regex:nnnn { A_cln_Z } {A:} {A:,{A},{},{},{}} {5}
% \Test_regex:nnnn { A_cln_Z } {A::} {A::,{A},{:},{},{}} {6}
% \Test_regex:nnnn { A_cln_Z } {::B} {::B,{},:,B,{}} {7}
% \Test_regex:nnnn { A_cln_Z } {::} {::,{},:,{},{}} {8}
% \Test_regex:nnnn { A_cln_Z } {:} {:,{},{},{},{}} {9}
% \end{bnvs.test}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \__bnvs_if_eval_query:nN #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { \string \__bnvs_if_eval_query:nNTF... }
\__bnvs_DEBUG:x { query = / #1 / }
\__bnvs_DEBUG:x { \string #2 = \tl_to_str:N #2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_call_greset:
  \cs_set:Npn \return_true: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_eval_query:nNTF...TRUE }
\__bnvs_DEBUG:x { query = / #1 / }
\__bnvs_DEBUG:x { \string #2 = \tl_to_str:N #2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
  \cs_set:Npn \return_false: {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_eval_query:nNTF...FALSE }
\__bnvs_DEBUG:x { query = / #1 / }
\__bnvs_DEBUG:x { \string #2 = \tl_to_str:N #2 }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
  \regex_extract_once:NnNTF \c__bnvs_A_cln_Z_regex {
    #1
  } \l__bnvs_match_seq {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_eval_query:nNTF...MATCH... }
\__bnvs_DEBUG:x { query = / #1 / }
\__bnvs_DEBUG:x { \string\l__bnvs_match_seq/\seq_use:Nn \l__bnvs_match_seq // }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \bool_set_false:N \l__bnvs_no_counter_bool
    \bool_set_false:N \l__bnvs_no_range_bool
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\switch:nNTF}
% \begin{syntax}
% \cs{switch:nNTF} \marg{capture group number} \meta{tl variable} \marg{black code} \marg{white code}
% \end{syntax}
% Helper function to locally set the \meta{tl variable}
% to the captured group \meta{capture group number}
% and branch depending on the emptyness of this variable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_eval_query:nNTF... }
\__bnvs_DEBUG:x { switch = / ##1 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \tl_set:Nx ##2 {
        \seq_item:Nn \l__bnvs_match_seq { ##1 }
      }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x { ...\string \__bnvs_if_eval_query:nNTF... }
\__bnvs_DEBUG:x { \string ##2 = / \tl_to_str:N ##2 / }
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \tl_if_empty:NTF ##2 { ##4 } { ##3 }
    }
    \switch:nNTF 5 \l__bnvs_a_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} Single expression
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \bool_set_false:N \l__bnvs_no_range_bool
      \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
        \return_true:
      } {
        \return_false:
      }
    } {
      \switch:nNTF 2 \l__bnvs_a_tl {
        \switch:nNTF 4 \l__bnvs_b_tl {
          \switch:nNTF 3 \l__bnvs_c_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}::\meta{last}} range
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
              \tl_put_right:Nn #2 { - }
              \__bnvs_if_append:VNTF \l__bnvs_b_tl #2 {
                \return_true:
              } {
                \return_false:
              }
            } {
              \return_false:
            }
          } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:\meta{length}} range
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
              \tl_put_right:Nx #2 { - }        
              \tl_put_right:Nx \l__bnvs_a_tl { + ( \l__bnvs_b_tl ) - 1}  
              \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
                \return_true:
              } {
                \return_false:
              }
            } {
              \return_false:
            }
          }
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:} and \texttt{\meta{first}::} range
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
            \tl_put_right:Nn #2 { - }
            \return_true:
          } {
            \return_false:
          }
        }
      } {
        \switch:nNTF 4 \l__bnvs_b_tl {
          \switch:nNTF 3 \l__bnvs_c_tl {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{::\meta{last}} range
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \tl_put_right:Nn #2 { - }
            \__bnvs_if_append:VNTF \l__bnvs_a_tl #2 {
              \return_true:
            } {
              \return_false:
            }
          } {
            \__bnvs_error:x { Syntax~error(Missing~first):~#1 }
          }
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \seq_put_right:Nn #2 { - }
        } 
      }
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Error
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \__bnvs_error:n { Syntax~error:~#1 }
    \return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string\__bnvs_eval_query:nNTF]
% \Test_query:nnnn { 100 } { 1 } { 1 } { 1 }
% \Test_query:nnnn { } { 1+1 } { 2 } { 2 }
% \Test_query:nnnn { } { X.1+X.11 } { 210 } { 3 }
% \Test_query:nnnn { } { X.1::X.111 } { 100-210 } { 4 }
% \Test_query:nnnn { } { X.1:111 } { 100-210 } { 5 }
% \Test_query:nnnn { 4 } { X.1 } { 4 } { 6 }
% \Test_query:nnnn { } { X.0 } { 3 } { 7 }
% \Test_query:nnnn { } { X.-1 } { 2 } { 8 }
% \Test_query:nnnn { } { X.-2 } { 1 } { 9 }
% \Test_query:nnnn { } { X.-3 } { 0 } { 10 }
% \end{bnvs.test}
%
% \begin{function}{\__bnvs_eval:nN}
% \begin{syntax}
% \cs{__bnvs_eval:nN} \marg{overlay query list} \meta{tl variable}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated list of \meta{overlay query}'s,
% replacing all the named overlay specifications and integer expressions
% by their static counterparts by calling \cs{__bnvs_eval_query:nN},
% then append the result to the right of the \meta{tl variable}.
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l__bnvs_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l__bnvs_ans_seq}
% Storage of the evaluated result.
% \end{variable}
% \begin{variable}{\c__bnvs_comma_regex}
% Used to parse slide range overlay specifications.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_eval:nN #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!gubed>
\__bnvs_DEBUG:x {\string\__bnvs_eval:nN:\tl_to_str:n{#1}/
  \string#2=\tl_to_str:V #2
}
%</!gubed>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \__bnvs_group_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables declaration
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_clear:N \l__bnvs_query_seq
  \seq_clear:N \l__bnvs_ans_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{first}::\meta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:NnN \c__bnvs_comma_regex { #1 } \l__bnvs_query_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Then each component is evaluated and the result is stored in \cs{l__bnvs_ans_seq}
% that we have clear before use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \seq_map_inline:Nn \l__bnvs_query_seq {
    \tl_clear:N \l__bnvs_ans_tl
    \__bnvs_if_eval_query:nNTF { ##1 } \l__bnvs_ans_tl {
      \seq_put_right:NV \l__bnvs_ans_seq \l__bnvs_ans_tl
    } {
      \seq_map_break:n {
\msg_fatal:nnn { beanoves } { :n } { Circular/Undefined~dependency~in~#1}
      }
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to \meta{tl variable}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \exp_args:NNNx
  \__bnvs_group_end:
  \tl_put_right:Nn #2 { \seq_use:Nn \l__bnvs_ans_seq , }
}
\cs_generate_variant:Nn \__bnvs_eval:nN { VN, xN }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=\string \__bnvs_eval:nNTF]
% \reset:n { }
% \Test_append:nnnn { 222 } { X.1 } { 222 } { A }
% \__bnvs_DEBUG:x { \string \l__bnvs_ans_tl }
% \tl_clear:N \l__bnvs_ans_tl
% \__bnvs_eval:nN {X.1} \l__bnvs_ans_tl
% \assert_equal:xxn { \l__bnvs_ans_tl } { 222 } { 1 }
% \end{bnvs.test}
%
% \begin{function}{\BeanovesEval}
%   \begin{syntax}
%     \cs{BeanovesEval} \oarg{tl variable} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{__bnvs_eval:nN}
% within a group. \cs{l_ans_tl} is used locally to store the result.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesEval { s o m } {
  \__bnvs_group_begin:
  \tl_clear:N \l__bnvs_ans_tl
  \IfBooleanTF { #1 } {
    \bool_set_true:N  \l__bnvs_no_counter_bool
  } {
    \bool_set_false:N \l__bnvs_no_counter_bool
  }
  \__bnvs_eval:nN { #3 } \l__bnvs_ans_tl
  \IfValueTF { #2 } {
    \exp_args:NNNV
    \__bnvs_group_end:
    \tl_set:Nn #2 \l__bnvs_ans_tl
  } {
    \exp_args:NV
    \__bnvs_group_end: \l__bnvs_ans_tl
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}[banner=BeanovesEval]
% \reset:n { }
% \Test_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BeanovesEval[\l__bnvs_ans_tl]{X.1}
% \assert_equal:xxn { \l__bnvs_ans_tl } { 222 } { 1 }
% \end{bnvs.test}
%
% \subsubsection{Reseting slide ranges}
% \begin{function}{\BeanovesReset}
%   \begin{syntax}
%     \cs{beanovesReset} \oarg{first value} \marg{Slide range name}
%   \end{syntax}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesReset { O{1} m } {
  \__bnvs_reset:nn { #1 } { #2 }
  \ignorespaces
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Forwards to \cs{__bnvs_reset:nn}.
% \end{function}
%
% \begin{function}{\__bnvs_reset:nn}
% \begin{syntax}
% \cs{__bnvs_reset:nn} \marg{first value} \marg{slide range name}
% \end{syntax}
% Reset the counter to the given \meta{first value}.
% Clean the cached values also.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \__bnvs_reset:nn #1 #2 {
  \bool_if:nTF {
       \__bnvs_if_in_p:nn A { #2 }
    || \__bnvs_if_in_p:nn Z { #2 }
    || \__bnvs_if_in_p:nn C { #2 }
  } {
    \__bnvs_gremove:nn C { #2 }
    \__bnvs_gremove_cache:nn A { #2 }
    \__bnvs_gremove_cache:nn L { #2 }
    \__bnvs_gremove_cache:nn Z { #2 }
    \__bnvs_gremove_cache:nn P { #2 }
    \__bnvs_gremove_cache:nn N { #2 }
    \__bnvs_gput:nnn { C0 } { #2 } { #1 }
  } {
    \msg_warning:nnn { beanoves } { :n } { Unknown~name:~#2 }
  }
}
\makeatother
\ExplSyntaxOff
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.gobble}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{bnvs.gobble}
% \end{implementation}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
