% \iffalse meta-comment
% !TEX program  = pdfLaTeX
%
%% File: beanover.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2022 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanover --- beamer named overlay ranges
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of multiple time lines in |beamer| documents.
Time lines are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
beanover --- beamer named overlay ranges
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanover.dtx
and the derived files           beanover.ins,
                                beanover.pdf and
                                beanover.sty.

\endpostamble
\usedir{tex/latex/beanover}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanover}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanover}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% ! TeX proot = ...
\ProvideDocumentCommand\directlua{m}{\wlog{Run with LuaLaTeX}}
\directlua {
  local cmd = 'pdftex "\jobname.dtx"'
  local f = assert(io.popen(cmd, 'r')) 
  local s = assert(f:read('*a')) 
  f:close() 
}
\documentclass{l3doc}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\tcbuselibrary{minted}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\GetFileInfo{beanover.sty}
\title{\pkg{beamer} named overlay ranges with \pkg{beanover}}
\author{Jérôme Laurens}
\date{\fileversion \qquad \filedate}
\begin{document}
\maketitle
\changes{v1.0}{2009/10/06}{First public release}
\begin{abstract}
This package allows the management of multiple slide ranges in |beamer| documents.
Slide ranges are very handy both during edition and to manage complex and variable overlay specifications.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanover}
\begin{document}
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\Beanover{
  A = 1:2,
  B = A.next:3,
  C = B.next,
}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.1)-?(B.last)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2)-?(B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.3)-> {From slide 3}\\
\visible<?(B.3)-?(B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 8, we declare a slide range named `A', starting at slide 1 and with length 2.
On line 12, the new overlay specification \texttt{?(A.1)} stands for 1,
on line 15, \texttt{?(A.2)} stands for 2
and on line 18, \texttt{?(A.3)} stands for 3.
%
On line 9, we declare a second slide range named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last side has number 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide after time line `B' has number 6
which is also the first slide of the third time line
due to line 10.
\section{What is a named slide range?}
Within a frame, there are different slides that appear in turn.
The main slide range covers all the slide numbers, from one to the total amount of slides.
In general, a slide range is a range of positive integers identified by a unique name.
The main practical interest is that time lines may be defined relative to one another.
Moreover we can specify overlay specifications based on time lines.
%
\section{Defining named slide ranges}
%
\begin{function}{\Beanover}
  \begin{syntax}
    \cs{Beanover}\marg{key--value list}
  \end{syntax}
\end{function}
The keys are the slide ranges names, they must contain no spaces nor dots.
When the same key is used multiple times, only the last is taken into account.
The possible values are \meta{start}, \meta{start}:\meta{length}, \meta{start}::\meta{end} or \meta{start}! where \meta{start}, \meta{end} and \meta{length} are algebraic expression involving any named overlay specification when an integer.
%
\section{Named overlay specifications}
%
The named overlay specifications are detailled in the tables below together with
their replacement meaning value as beamer standard overlay specification.

%
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{syntax} & \bfseries \textrm{meaning} 
\\\hline
\multicolumn{2}{c}{\ttfamily \meta{name} = \{\(i\), \(i+1\), \(i+2\),...\}}
\\\hline
\meta{name}.1 & \(i\)\\
\meta{name}.2 & \(i+1\) \\
\meta{name}.\meta{integer} & \(i+ \meta{integer} - 1\) \\
\hline
\end{tabular}
\end{center}
In the frame example below, we use the \cs{BeanoverEval} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
}
 \begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
 \Beanover{
   A = 3,
 }
 \ttfamily
 \BeanoverEval(A.1) ==3,
 \BeanoverEval(A.2) ==4,
 \BeanoverEval(A.-1)==1,
 \end{frame}
 \end{tcblisting}
%
For finite time lines, we also have
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|l|l}
\hline
\bfseries \textrm{syntax} & \bfseries \textrm{meaning} & \bfseries \textrm{output}
\\\hline
\multicolumn{2}{c|}{\ttfamily \meta{name} = \{\(i\), \(i+1\),..., \(j\)\}}
\\\hline
\meta{name}.length & \(j-i+1\) & A.length & 6\\
\meta{name}.last & \(j\) & A.last & 8\\
\meta{name}.next & \(j+1\) & A.next & 9\\
\meta{name}.range & \(i\) ''-'' \(j\) & A.range & 3-8\\
\hline
\end{tabular}
\end{center}
\begin{tcblisting} {
  listing only,
}
 \begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
 \Beanover{
   A = 3:6,
 }
 \ttfamily
 \BeanoverEval(A.length) == 6,
 \BeanoverEval(A.1)      == 3,
 \BeanoverEval(A.2)      == 4,
 \BeanoverEval(A.-1)     == 1,
 \end{frame}
 \end{tcblisting}
%
Using these specification on unfinite time lines is unsupported.
%
Finally each time line has a dedicated cursor \texttt{\meta{name}.n} that we can use and increment.
\begin{description}
\item[\ttfamily\meta{name}]: use the position of the cursor 
\item[\ttfamily\meta{name}.n+=\meta{integer}]: advance the cursor by \meta{integer} and use the new position
\item[\ttfamily++\meta{name}.n]: advance the cursor by 1 and use the new position
\end{description}
%
\section{\texttt{?(...)} expressions}
\pkg{beamer} defines \meta{overlay specifications} included between pointed brackets. Before they are processed by the \pkg{beamer} class,
the \pkg{beanover} package scans the \meta{overlay specifications} for any occurrence of `\texttt{?(\meta{queries})}'. Each of them is then evaluated and replaced by its static counterpart.
The overall result is finally forwarded to \pkg{beamer}.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s.
Each \meta{query} may be one of `\texttt{\meta{start}}', `\texttt{\meta{start}:\meta{length}}' or `\texttt{\meta{start}::\meta{last}}', where \meta{start}, \meta{length} and \meta{end} both denote algebraic expressions possibly involving 
named overlay specifications.
For example \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been defined with a length.
\end{documentation}
  \DocInput{beanover.dtx}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=beanover>
%    \end{macrocode}
%
% \subsection{Package declarations}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
  {beanover}
  {2022/10/05}
  {0.2}
  {Named overlay specifications for beamer}
%    \end{macrocode}
%
% \begin{implementation}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% In that case, variables need not follow exactly the \LaTeX3\ naming convention:
% we do not specialize with the module name.
%    \begin{macrocode}
\bgroup_begin:
\tl_clear_new:N  \l_a_tl
\tl_clear_new:N  \l_b_tl
\tl_clear_new:N  \l_ans_tl
\seq_clear_new:N \l_ans_seq
\seq_clear_new:N \l_match_seq
\seq_clear_new:N \l_token_seq
\int_zero_new:N  \l_split_int
\seq_clear_new:N \l_split_seq
\int_zero_new:N  \l_depth_int
\tl_clear_new:N  \l_name_tl
\tl_clear_new:N  \l_group_tl
\tl_clear_new:N  \l_query_tl
\seq_clear_new:N \l_query_seq
\bgroup_end:
%    \end{macrocode}
%
% \subsection{Overlay specification}
% \subsubsection{In slide range definitions}
% \begin{variable} {\g_@@_prop}
% \meta{key}--\meta{value} property list to store the slide ranges.
% The basic keys are, assuming \meta{name} is a slide range identifier,
% \begin{description}
% \item [\texttt{\meta{name}.1}] for the start index
% \item [\texttt{\meta{name}.l}] for the length when provided
% \item [\texttt{\meta{name}.n}] for the cursor value, when used
% \item [\texttt{\meta{name}.c}] for initial value of the cursor (when reset)
% \end{description}
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges.
% \begin{description}
% \item [\texttt{\meta{name}.A}] for the cached start index
% \item [\texttt{\meta{name}.L}] for the cached length
% \end{description}
% And in case a length has been given
% \begin{description}
% \item [\texttt{\meta{name}.N}] for the cached next index
% \item [\texttt{\meta{name}.Z}] for the cached last index
% \end{description}
% We definitely use the fact that \meta{name} contains no `.' character.
%    \begin{macrocode}
\prop_new:N \g_@@_prop
%    \end{macrocode}
% \end{variable}
% Utility message.
%    \begin{macrocode}
\msg_new:nnn { @@ } { :n } { #1 }
%    \end{macrocode}
%
% \subsubsection{Defining named slide ranges}
% \begin{function}{\Beanover}
%   \begin{syntax}
%     \cs{Beanover} \marg{key--value list}
%   \end{syntax}
%   The keys are the slide range names.
% We do not accept key only items, they are managed by \cs{@@_error:n}.
% \meta{key--value} items are parsed by \cs{@@_parse:nn}.
% A group is open.
%    \begin{macrocode}
\NewDocumentCommand \Beanover { m } {
  \group_begin:
  \keyval_parse:NNn \@@_error:n \@@_parse:nn { #1 }
  \group_end:
  \ignorespaces
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\@@_error:n}
% Prints an error message when a key only item is used.
%    \begin{macrocode}
\cs_new:Npn \@@_error:n #1 {
  \msg_fatal:nnn { @@ } { :n } { Missing~value~for~#1 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\@@_parse:nn}
%   \begin{syntax}
%     \cs{@@_parse:nn} \marg{name} \marg{definition}
%   \end{syntax}
% Auxiliary function called within a group.
% \meta{name} is the slide range name, \meta{definition} is the definition.
% \begin{variable}{\l_match_seq}
% Local storage for the match result.
% \end{variable}
% \begin{variable}{\c@@_key_regex}
% The name of a slide range consists of an alphabetical character
% eventually followed by any alphanumerical character.
% A leading underscore may be used for aliases. Under development.
%    \begin{macrocode}
\regex_const:Nn \c@@_id_regex {
  [[:alpha:]][[:alnum:]_]*
}
%    \end{macrocode}
%    \begin{macrocode}
\regex_const:Nn \c@@_key_regex {
  \A (_)? \ur{c@@_id_regex} \Z
}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c@@_range_regex}
% Capture groups:
% \begin{description}
% \item [2:] the start of the slide range
% \item [3:] the second colon
% \item [4:] the length or the end of the range
% \end{description}
%    \begin{macrocode}
\regex_const:Nn \c@@_range_regex {
  \A \s* ([^:]+?) \s* (?: \: (\:)? \s * ( .*? ) \s* )? \Z
}
%    \end{macrocode}
% \end{variable}
% \end{function}
%
%    \begin{macrocode}
\cs_new:Npn \@@_parse:nn #1 #2 {
  \regex_extract_once:NnNTF \c@@_key_regex { #1 } \l_match_seq {
%    \end{macrocode}
% We got a valid key.
%    \begin{macrocode}
    \exp_args:Nx
    \tl_if_empty:nTF { \seq_item:Nn \l_match_seq 2 } {
\regex_extract_once:NnNTF \c@@_range_regex { #2 } \l_match_seq {
        \exp_args:Nx
        \tl_if_empty:nTF { \seq_item:Nn \l_match_seq 3 } {
%    \end{macrocode}
% This is not a \texttt{\meta{start}::\meta{end}} value.
%    \begin{macrocode}
          \exp_args:Neee   
          \@@_l:nnn
            { #1 }
            { \seq_item:Nn \l_match_seq { 2 } }
            { \seq_item:Nn \l_match_seq { 4 } }
        } {
          \exp_args:Neee   
          \@@_n:nnn
            { #1 }
            { \seq_item:Nn \l_match_seq { 2 } }
            { \seq_item:Nn \l_match_seq { 4 } }
        }
      } {
        \msg_error:nnn { @@ } { :n } { Invalid~declaration:~#2 }
      }
    } {
%    \end{macrocode}
% This is an alias.
%    \begin{macrocode}
      \prop_gput:Nnn \g_@@_prop { #1 } { #2 }
    }
  } {
    \msg_error:nnn { @@ } { :n } { Invalid~declaration:~#1 }
  }
}
%    \end{macrocode}
% \begin{function}{\@@_l:nnn}
%   \begin{syntax}
%     \cs{@@_l:nnn} \marg{name} \marg{start} \marg{length}
%   \end{syntax}
% Auxiliary function called within a group.
% The \meta{length} may be empty.
% Set the keys \texttt{\marg{name}.1} and eventually \texttt{\marg{name}.l}.
%    \begin{macrocode}
\cs_new:Npn \@@_l:nnn #1 #2 #3 {
  \prop_gput:Nnn \g_@@_prop { #1.1 } { #2 }
  \tl_if_empty:nF { #3 } {
    \prop_gput:Nnn \g_@@_prop { #1.l } { #3 }
  }
}
%    \end{macrocode}%
% \end{function}
%
% \begin{function}{\@@_n:nnn}
%   \begin{syntax}
%     \cs{@@_n:nnn} \marg{name} \marg{start} \marg{end}
%   \end{syntax}
% Auxiliary function called within a group.
% The \meta{end} defaults to \marg{start}.
%    \begin{macrocode}
\cs_new:Npn \@@_n:nnn #1 #2 #3 {
  \prop_gput:Nnn \g_@@_prop { #1.1 } { #2 }
  \tl_if_empty:nF { #3 } {
    \prop_gput:Nnn \g_@@_prop { #1.l } { #3 - #1.0 }
  }
}
%    \end{macrocode}
% \end{function}
%
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer command to support |?(...)| instructions in overlay specifications.
% \begin{function}{\beamer@masterdecode}
% \begin{syntax}
% \cs{beamer@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} uses it.
% \begin{variable}{\l_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% Save the original macro \cs{beamer@masterdecode} and then override it
% to properly preprocess the argument.
%    \begin{macrocode}
\cs_set_eq:NN \@@_beamer@masterdecode \beamer@masterdecode
\cs_set:Npn \beamer@masterdecode #1 {
  \group_begin:
  \tl_clear:N \l_ans_tl
  \@@_scan:Nn \l_ans_tl { #1 }
  \exp_args:NNV
  \group_end:
  \@@_beamer@masterdecode \l_ans_tl
}
%    \end{macrocode}
% \begin{function}{\@@_scan:n}
% \begin{syntax}
% \cs{@@_scan:Nn} \meta{tl variable} \marg{named overlay expression}
% \end{syntax}
% Scan the \meta{named overlay expression} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from \cs{@@_eval:Nn}.
% A group is created to use local variables:
% \begin{description}
%   \item[\cs{l_ans_tl}:] is the token list that will be appended to \meta{tl variable} on return.
% \end{description}
% \begin{variable}{\l_depth_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l@@_ask_bool}
% Whether a loop may continue.
% Controls the continuation of the main loop that scans
%     the tokens of the \meta{named overlay expression} looking for a question mark.
%    \begin{macrocode}
\bool_new:N \l@@_ask_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l@@_query_bool}
% Whether a loop may continue. 
% Controls the continuation of the secondary loop that scans
%     the tokens of the \meta{overlay expression} looking for an opening
%     parenthesis follow the question mark.
%     It then controls the loop looking for the balanced closing parenthesis.
%    \begin{macrocode}
\bool_new:N \l@@_query_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_scan:Nn #1 #2 {
  \group_begin:
  \tl_clear:N \l_ans_tl
  \int_zero:N \l_depth_int
  \seq_clear:N \l_token_seq
%    \end{macrocode}
% Explode the \meta{named overlay expression} into a list of tokens:
%    \begin{macrocode}
  \regex_split:nnN {} { #2 } \l_token_seq
%    \end{macrocode}
% Run the top level loop to scan for a `|?|':
%    \begin{macrocode}
  \bool_set_true:N \l@@_ask_bool
  \bool_while_do:Nn \l@@_ask_bool {
    \seq_pop_left:NN \l_token_seq \l_token_tl
    \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% We reached the end of the sequence (and the token list),
% we end the loop here.
%    \begin{macrocode}
      \bool_set_false:N \l@@_ask_bool
    } {
%    \end{macrocode}
% \cs{l_token_tl} contains a `normal' token.
%    \begin{macrocode}
      \tl_if_eq:NnTF \l_token_tl { ? } {
%    \end{macrocode}
% We found a `|?|', we first gobble tokens until the next `|(|', ---)
% whatever they may be. In general, no tokens should be silently ignored.
%    \begin{macrocode}
        \bool_set_true:N \l@@_query_bool
        \bool_while_do:Nn \l@@_query_bool {
%    \end{macrocode}
% Get next token.
%    \begin{macrocode}
          \seq_pop_left:NN \l_token_seq \l_token_tl
          \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% No opening parenthesis found, raise.
%    \begin{macrocode}
            \msg_fatal:nnx { @@ } { :n } {Missing~'('%---)
              ~after~a~?:~#2}
          } {
            \tl_if_eq:NnT \l_token_tl { ( %)
            } {
%    \end{macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Increment the parenthesis depth to 1 (on first passage).
%    \begin{macrocode}
              \int_incr:N \l_depth_int
%    \end{macrocode}
% Record the forthcomming content in the \cs{l_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
%    \begin{macrocode}
              \tl_clear:N \l_query_tl
              \bool_while_do:Nn \l@@_query_bool {
%    \end{macrocode}
% Get next token.
%    \begin{macrocode}
                \seq_pop_left:NN \l_token_seq \l_token_tl
                \quark_if_no_value:NTF \l_token_tl {
%    \end{macrocode}
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and end both bool while loops.
% As recovery we feed \cs{l_query_tl} with the missing ^^A(---
% `|)|'.
% |\l_depth_int| is 0 whenever |\l@@_query_bool| is false.
%    \begin{macrocode}
                  \msg_error:nnx { @@ } { :n } {Missing~%(---
                    `)':~#2 }
                  \int_do_while:nNnn \l_depth_int > 1 {
                    \int_decr:N \l_depth_int
                    \tl_put_right:Nn \l_query_tl {%(---
                    )}
                  }
                  \int_zero:N \l_depth_int
                  \bool_set_false:N \l@@_query_bool
                  \bool_set_false:N \l@@_ask_bool
                } {
                  \tl_if_eq:NnTF \l_token_tl { ( %---)
                  } {
%    \end{macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to \cs{l_query_tl}.
%    \begin{macrocode}
                    \int_incr:N \l_depth_int
                    \tl_put_right:NV \l_query_tl \l_token_tl
                  } {
%    \end{macrocode}
% This is not a `|(|'.^^A---)
%    \begin{macrocode}
                    \tl_if_eq:NnTF \l_token_tl { %(
                      )
                    } {
%    \end{macrocode}
% We found a  ^^A(---
% `|)|', decrement the depth.
%    \begin{macrocode}
                      \int_decr:N \l_depth_int
                      \int_compare:nNnTF \l_depth_int = 0 {
%    \end{macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to \cs{l_ans_tl}
% and stop the inner loop.
%    \begin{macrocode}
  \exp_args:NNNV
  \@@_eval:NNn \c_false_bool \l_ans_tl \l_query_tl
  \bool_set_false:N \l@@_query_bool
                      } {
%    \end{macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to \cs{l_query_tl} because it is not the
% end of sequence marker.
%    \begin{macrocode}
                        \tl_put_right:NV \l_query_tl \l_token_tl
                      }
%    \end{macrocode}
% Above ends the code for a positive depth.
%    \begin{macrocode}
                    } {
%    \end{macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to \cs{l_query_tl}.
%    \begin{macrocode}
                      \tl_put_right:NV \l_query_tl \l_token_tl
                    }
                  }
                }
%    \end{macrocode}
% Above ends the code for Not a  `|(|'^^A---)
%    \begin{macrocode}
              }
            }
%    \end{macrocode}
% Above ends the code for: Found the `|(|' after the `|?|' ^^A---)
%    \begin{macrocode}
          }
%    \end{macrocode}
% Above ends the code for not a no value quark.
%    \begin{macrocode}
        }
%    \end{macrocode}
% Above ends the code for the bool while loop to find the `|(|' after the `|?|'.^^A---)
%
% If we reached the end of the token list, then end both the current loop and its containing loop.
%    \begin{macrocode}
        \quark_if_no_value:NT \l_token_tl {
          \bool_set_false:N \l@@_query_bool
          \bool_set_false:N \l@@_ask_bool
        }
      } {
%    \end{macrocode}
% This is not a `|?|', append the token to right of \cs{l_ans_tl} and continue.
%    \begin{macrocode}
        \tl_put_right:NV \l_ans_tl \l_token_tl
      }
%    \end{macrocode}
% Above ends the code for the bool while loop to find a `|(|' after the `|?|' ^^A---)
%    \begin{macrocode}
    }
  }
%    \end{macrocode}
% Above ends the outer bool while loop to find `|?|' characters.
% We can append our result to \meta{tl variable}
%    \begin{macrocode}
  \exp_args:NNNV
  \group_end:
  \tl_put_right:Nn #1 \l_ans_tl
}
%    \end{macrocode}
% Each new frame has its own slide ranges set,
% we clear the property list on entering a new frame environment.
%    \begin{macrocode}
\AddToHook
  { env/beamer@framepauses/before }
  { \prop_gclear:N \g_@@_prop }
%    \end{macrocode}
%
% \subsubsection{Evaluation}
% \begin{function}{\BeanoverEval}
%   \begin{syntax}
%     \cs{BeanoverEval} \oarg{tl variable} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{@@_eval:NNn}
% within a group. \cs{l_ans_tl} is used to store the result.
% \end{function}
%    \begin{macrocode}
\NewExpandableDocumentCommand \BeanoverEval { s o m } {
  \group_begin:
  \tl_clear:N \l_ans_tl
  \exp_args:Nx \@@_eval:NNn {
      \IfBooleanTF { #1 } { \c_true_bool } { \c_false_bool }
    }
    \l_ans_tl { #3 }
  \IfValueTF { #2 } {
    \exp_args:NNNV
    \group_end:
    \tl_set:Nn #2 \l_ans_tl
  } {
    \exp_args:NV
    \group_end: \l_ans_tl
  }
}
%    \end{macrocode}
%
% \begin{function}{\@@_eval:NNn}
% \begin{syntax}
% \cs{@@_eval:NNn} \meta{bool variable} \meta{tl variable} \marg{overlay queries}
% \end{syntax}
% Evaluates the \meta{overlay queries},
% replacing all the named overlay specifications and integer expressions
% by their static counterparts, then append the result to
% the right of the \meta{tl variable}.
% If the \meta{bool variable} is true then
% the cursor is not available (more explanation required).
% This is executed within a local group.
% Below are local variables and constants.
% \begin{variable}{\l_query_seq}
% Storage for a sequence of queries.
% \end{variable}
% \begin{variable}{\l_ans_seq}
% Storage of the evaluated result.
% \end{variable}
% \begin{variable}{\c@@_comma_regex}
% Used to parse slide range overlay specifications.
%    \begin{macrocode}
\regex_const:Nn \c@@_comma_regex { \s* ,  \s* }
%    \end{macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{variable}{\c@@_eval_regex}
% Used to parse slide range overlay specifications.
%    \begin{macrocode}
\regex_const:Nn \c@@_eval_regex { \s* ( ?: (,) | (:) | :: ) \s* }
%    \end{macrocode}
% \end{variable}
%    \begin{macrocode}
\cs_new:Npn \@@_eval:NNn #1 #2 #3 {
  \group_begin:
  \regex_split:NnN \c@@_eval_regex { #3 } \l_split_seq
  \int_zero:N \l_split_int
  \cs_set:Npn \top: {
    \seq_pop_left:NN \l_split_seq \l_token_tl
    \exp_args:NV \quark_if_no_value:nTF \l_token_tl {
      \cs_set:Npn \next: { \prg_do_nothing: }
    } {
      \seq_pop_left:NN \l_split_seq \l_a_tl
      \exp_args:NV \quark_if_no_value:nTF \l_a_tl {
        \exp_args:NnV
        \use:nn {
          \@@_static:NNNn \c_true_bool #1 \l_ans_tl 
        } \l_token_tl
        \cs_set:Npn \next: { }
      } {
        \seq_pop_left:NN \l_split_seq \l_b_tl
        \tl_if_empty:NTF \l_a_tl {
%    \end{macrocode}
% This is a range
%    \begin{macrocode}        
          \exp_args:NnV
          \use:nn {
            \@@_static:NNNn \c_true_bool #1 \l_ans_tl 
          } \l_group_tl
          \seq_pop_left:NN \l_split_seq \l_group_tl
          \exp_args:NnV
          \use:nn {
            \@@_static:NNNn \c_true_bool #1 \l_ans_tl 
          } \l_group_tl
          \cs_set:Npn \next: { \comma: }          
          \tl_if_empty:NTF \l_b_tl {
            
          } {
          }
        } {
        }
      
      }
      
    }
  }
  \cs_set:Npn \loop: {
    \seq_pop_left:NN \l_split_seq \l_token_tl
    \exp_args:NV \quark_if_no_value:nTF \l_token_tl {
      \cs_set:Npn \loop: { \prg_do_nothing: }
    } {
      \seq_pop_left:NN \l_split_seq \l_a_tl
      \exp_args:NV \quark_if_no_value:nTF \l_a_tl {
        \exp_args:NnV
        \use:nn {
          \@@_eval_query:NNNn \c_true_bool #1 \l_ans_seq 
        } \l_token_tl
        \cs_set:Npn \loop: { \prg_do_nothing: }
      } {
      
      
      }
      
    }
    \main:
  }
  \cs_set:Npn \main: {
    \seq_pop_left:NN \l_split_seq \l_token_tl
    \exp_args:NV \quark_if_no_value:nTF \l_token_tl {
      \cs_set:Npn \main: {
        \last:
      }
    } {
      \current:
    }
    \main:
  }

}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_eval_a:NNn #1 #2 #3 {
  \group_begin:
%    \end{macrocode}
% Local variables declaration
%    \begin{macrocode}
  \tl_clear:N  \l_a_tl
  \tl_clear:N  \l_b_tl
  \tl_clear:N  \l_ans_tl
  \seq_clear:N \l_ans_seq
  \seq_clear:N \l_query_seq
%    \end{macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{start}::\meta{end}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
%    \begin{macrocode}
  \@@_eval_static:NNn #1 \l_ans_tl { #3 }
  \exp_args:NNV
  \regex_split:NnN \c@@_comma_regex \l_ans_tl \l_query_seq
%    \end{macrocode}
% Then each component is evaluated and the result is stored in \cs{l_seq}
% that we must clear before use.
%    \begin{macrocode}
  \seq_map_tokens:Nn \l_query_seq {
    \@@_eval_query:NNn #1 \l_ans_seq
  }
%    \end{macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to \meta{tl variable}.
%    \begin{macrocode}
  \exp_args:NNNx
  \group_end:
  \tl_put_right:Nn #2 { \seq_use:Nn \l_ans_seq , }
}
%    \end{macrocode}
%
% \begin{function}{\@@_eval_query:NNn}
% \begin{syntax}
% \cs{@@_query:NNn} \meta{bool variable} \meta{seq variable} \marg{overlay query}
% \end{syntax}
% Evaluates the single \meta{overlay query},
% which is expected to contain no comma.
% Replaces all the named overlay specifications by their static counterparts,
% make the computation then append the result to 
% the right of the \meta{seq variable}.
% Ranges are supported with the colon syntax.
% If the \meta{bool variable} is true then
% the cursor is not available.
% This is executed within a local group.
% Below are local variables and constants.
% \begin{variable}{\l_a_tl}
% Storage for the start of a range.
% \end{variable}
% \begin{variable}{\l_b_tl}
% Storage for the end of a range, or its length.
% \end{variable}
% \begin{variable}{\g_@@_colon_regex}
% Used to parse slide range overlay specifications.
% Next are the capture groups.
% \begin{description}
%   \item [2:] \meta{start}
%   \item [3:] Second colon
%   \item [4:] \meta{end} or \meta{length}
% \end{description}
%    \begin{macrocode}
\regex_const:Nn \c@@_colon_regex {
  \A \s*( [^\:]*? ) \s* \: \s* (\:)? \s* ( [^\:]*? ) \s* \Z
}
%    \end{macrocode}
% \end{variable}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_eval_query:NNn #1 #2 #3 {
  \regex_extract_once:NnNTF \c@@_colon_regex {
    #3
  } \l_match_seq {
%    \end{macrocode}
% We captured colon syntax ranges: one of \texttt{\meta{start}:\meta{length}} 
% or \texttt{\meta{start}::\meta{last}}.
% We recover the \meta{start} and \meta{end} or \meta{length} respectively
% in \cs{l_a_tl} and \cs{l_b_tl}.
%    \begin{macrocode}
    \tl_set:Nx \l_a_tl  { \seq_item:Nn \l_match_seq 2 }
    \tl_set:Nx \l_b_tl  { \seq_item:Nn \l_match_seq 4 }
    \exp_args:Nx
    \tl_if_empty:nTF { \seq_item:Nn \l_match_seq 3 } {
%    \end{macrocode}
%
% This is a \texttt{\meta{start}:\meta{length}} range,
%    \begin{macrocode}
      \tl_if_empty:VT \l_a_tl {
%    \end{macrocode}
% raise when \meta{start} is void because we cannot evaluate the last index
% without knowing the first.
%    \begin{macrocode}
        \msg_error:nnn { @@ } { :n } { Missing~range~start:~#1 }
        \tl_set:Nn \l_a_tl 1
      }
%    \end{macrocode}
% When not provided, \meta{length} defaults to $\infty$.
% If there is a \meta{length}, evaluate it.
%    \begin{macrocode}
      \tl_if_empty:VF \l_b_tl {
        \tl_set:Nx \l_b_tl { \fp_to_int:n {
          \l_a_tl + \l_b_tl - 1
        } }
      }
    } {
%    \end{macrocode}
%
% This is a \texttt{\meta{start}::\meta{end}} range,
% with optional \meta{start} and \meta{end}.
% If there is \meta{start}, evaluate it,
%    \begin{macrocode}
    \tl_if_empty:VF \l_a_tl {
      \tl_set:Nx \l_a_tl {
        \exp_args:NV \fp_to_int:n \l_a_tl
      }
    }
%    \end{macrocode}
% and if there is an \meta{end}, evaluate it as well.
%    \begin{macrocode}
      \tl_if_empty:VF \l_b_tl {
        \tl_set:Nx \l_b_tl {
          \exp_args:NV \fp_to_int:n \l_b_tl 
        }
      }
    }
%    \end{macrocode}
% We can store the standard \pkg{beamer} range.
%    \begin{macrocode}
    \exp_args:NNx
    \seq_put_right:Nn \l_ans_seq {
      \l_a_tl - \l_b_tl
    }
  } {
%    \end{macrocode}
% This is not a colon syntax range: we just evaluate the component and store the result,
% if any.
%    \begin{macrocode}
    \tl_if_empty:nF { #3 } {
      \exp_args:NNx
      \seq_put_right:Nn \l_seq { \fp_to_int:n { #3 } }
    }
  }
}
%    \end{macrocode}
%
% \begin{function}{\@@_eval_static:NNn}
% \begin{syntax}
% \cs{@@_eval_static:NNn} \meta{bool variable} \meta{tl variable} \marg{integer expression}
% \end{syntax}
% Evaluates the \meta{integer expression},
% replacing all the named specifications by their
% counterpart then put the result to
% the right of the \meta{tl variable}.
% If the \meta{boolean variable} is true then
% the cursor is not available (useful when used from \cs{Beanover}).
% Executed within a group.
% Local variables: 
% \cs{l_ans_tl} for the content of \meta{tl variable}
% \begin{variable}{\l_split_seq}
% The sequence of queries and non queries.
% \end{variable}
% \begin{variable}{\l_split_int}
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% \begin{variable}{\l_name_tl}
%    Storage for \cs{l_split_seq} items that represent names.
%    \begin{macrocode}
\tl_new:N \l_name_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l@@_static_tl}
%    Storage for the static values of named slide ranges.
% \end{variable}
% \begin{variable}{\l_group_tl}
%    Storage for capture groups.
% \end{variable}
% \begin{variable}{\c@@_int_regex}
% A decimal integer with an eventual sign.
%    \begin{macrocode}
\regex_const:Nn \c@@_int_regex {
  (?:[-+]\s*)?[0-9]+
}
%    \end{macrocode}
% \end{variable}
% \end{function}
%
% \begin{variable}{\c@@_split_regex}
% Used to parse slide ranges overlay specifications.
% Next are the capture groups.
% Group numbers are 1 based because it is used in splitting contex
% where only capture groups are considered.
% \end{variable}
%    \begin{macrocode}
\regex_const:Nn \c@@_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \begin{description}
%   \item [1:] optional prefix increment |++|
%   \item [2:] \meta{name} of a cursor
%    \begin{macrocode}
    ( \+\+ )? ( \ur{c@@_id_regex} ) \b
%    \end{macrocode}
%   \item [3:] \meta{name} of a cursor
%   \item [4:] the integer after |+=|
%    \begin{macrocode}
  | ( \ur{c@@_id_regex} ) \s*
      \+= \s* ( \ur{c@@_int_regex} )
%    \end{macrocode}
%   \item [5:] \meta{name} of a slide range followed by an attribute.
%    \begin{macrocode}
  | ( \ur{c@@_id_regex} ) \.
    ( ? :
%    \end{macrocode}
%   \item [6:]  \texttt{length}
%    \begin{macrocode}
        (l)ength\b
%    \end{macrocode}
%   \item [7:]  \texttt{range}
%    \begin{macrocode}
      | (r)ange\b
%    \end{macrocode}
%   \item [8:]  \texttt{last}
%    \begin{macrocode}
      | (l)ast\b
%    \end{macrocode}
%   \item [9:]  \texttt{next}
%    \begin{macrocode}
      | (n)ext\b
%    \end{macrocode}
%   \item [10:] the integer after the dot
%    \begin{macrocode}
      | ( \ur{c@@_int_regex} )
%    \end{macrocode}
%   \item [11:] \texttt{reset}
%    \begin{macrocode}
      | (r)eset\b
%    \end{macrocode}
%   \item [12:] \texttt{UNKNOWN}
%    \begin{macrocode}
      | ( \S+ )
    )
%    \end{macrocode}
%   \item [13:] Alias
%    \begin{macrocode}
  | ( _ \ur{c@@_id_regex} )
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  ) \s*
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \@@_eval_static:NNn #1 #2 #3 {
  \group_begin:
%    \end{macrocode}
% Local variables:
%    \begin{macrocode}
  \tl_clear:N  \l_ans_tl
  \int_zero:N  \l_split_int
  \seq_clear:N \l_split_seq
  \tl_clear:N  \l_name_tl
  \tl_clear:N  \l_group_tl
  \tl_clear:N  \l_a_tl
%    \end{macrocode}
% Implementation:
%    \begin{macrocode}  
  \regex_split:NnN \c@@_split_regex { #3 } \l_split_seq
  \int_set:Nn \l_split_int { 1 }
  \tl_set:Nx \l_ans_tl { \seq_item:Nn \l_split_seq { \l_split_int } }
%    \end{macrocode}
% The |++| prefix should not be given when postfix attributes are.
% \begin{function}{\guard:n}
% \begin{syntax}
% \cs{@@_a:n} \marg{code}
% \end{syntax}
% \end{function}
% Helper function defined locally. Execute the \meta{code} if the \texttt{++}
% prefix is not catched, ``raises'' an exception otherwise.
%    \begin{macrocode}
  \cs_set:Npn \guard:n ##1 {
    \exp_args:Nx
    \tl_if_empty:nTF {
      \seq_item:Nn \l_split_seq { \l_split_int + 1 }
    } {
      ##1
    } {
      \msg_fatal:nnn { @@ } { :n } {
        Unexpected~beanover~specification~(prefix):~ #3
      }
    }
  }
%    \end{macrocode}
% \begin{function}{\switch:nTF}
% \begin{syntax}
% \cs{switch:nTF} \marg{capture group number} \marg{empty code} \marg{non empty code}
% \end{syntax}
% Helper function to locally set the |\l_group_tl| variable
% to the captured group \meta{capture group number}
% and branch.
% \end{function}
%    \begin{macrocode}
  \cs_set:Npn \switch:nNTF ##1 ##2 ##3 ##4 {
    \tl_set:Nx ##2 {
      \seq_item:Nn \l_split_seq { \l_split_int + ##1 }
    }
    \tl_if_empty:NTF ##2 { ##3 } { ##4 }
  }
%    \end{macrocode}
% Main loop.
%    \begin{macrocode}
  \int_while_do:nNnn { \l_split_int } < { \seq_count:N \l_split_seq } {
    \switch:nNTF { 2 } \l_name_tl {
      \switch:nNTF { 3 } \l_name_tl {
        \switch:nNTF { 5 } \l_name_tl {
          \switch:nNTF { 13 } \l_name_tl {
%    \end{macrocode}
% Unreachable code. \textcolor{red}{PROBLEM WITH |::|.}
%    \begin{macrocode}
          } { % alias
%    \end{macrocode}
% Case \texttt{_\meta{name}}.
% This is an alias, go recursive.
% Work in progress.
%    \begin{macrocode}
  \exp_args:NNV
  \prop_if_in:NnTF \g_@@_prop \l_name_tl {
    \tl_set:Nx \l_a_tl {
      \exp_args:NNV
      \prop_item:Nn \g_@@_prop \l_name_tl
    }
    \tl_if_empty:NT \l_a_tl {
      \tl_set:Nn \l_a_tl { :: }
    }
  } {
    \exp_args:Nnnx
    \msg_error:nnn { @@ } { :n } {
      Unknown~ alias:~\tl_use:N \l_a_tl\space(in~#3)
    }
    \tl_set:Nn \l_a_tl { :: }
  }
  \exp_args:NNNV
  \@@_eval_static:NNn \c_false_bool \l_ans_tl \l_a_tl
          }
        } {
%    \end{macrocode}
% Case \texttt{\meta{name}.\meta{attribute}}.
%    \begin{macrocode}
          \switch:nNTF { 6 } \l_group_tl { % .length
            \switch:nNTF { 7 } \l_group_tl { % .range
              \switch:nNTF { 8 } \l_group_tl { % .last
                \switch:nNTF { 9 } \l_group_tl { % .next
                  \switch:nNTF { 10 } \l_group_tl { % .<integer>
                    \switch:nNTF { 11 } \l_group_tl { % .reset
                      \switch:nNTF { 12 } \l_group_tl { % .UNKNOWN
%    \end{macrocode}
% Unreachable code.
%    \begin{macrocode}
                      } {
%    \end{macrocode}
% Case \texttt{\meta{name}.UNKNOWN}.
%    \begin{macrocode}
  \msg_fatal:nnn { @@ } { :n } { Unknown~attribute~\l_group_tl:~#3 }
                      }
                    } {
%    \end{macrocode}
% Case \texttt{\meta{name}.reset}.
%    \begin{macrocode}
  \bool_if:NT #1 {
    \msg_fatal:nnn { @@ } { :n } {
      No~\l_name_tl~cursor~available~inside~\cs{Beanover}:~#3
    }
  }
  \exp_args:NnV
  \@@_reset:nn { 0 } \l_name_tl
                    }
                  } {
%    \end{macrocode}
% Case \texttt{\meta{name}.\meta{integer}}.
%    \begin{macrocode}
  \group_begin:
  \tl_clear:N \l_ans_tl
  \exp_args:NNV \@@_start:Nn \l_ans_tl \l_name_tl
  \tl_put_right:Nn \l_ans_tl { + ( \l_group_tl ) - 1 }
  \exp_args:NNNx
  \group_end:
  \tl_put_right:Nn \l_ans_tl {
    \fp_to_int:n \l_ans_tl
  }
                  }
                } {
%    \end{macrocode}
% Case \texttt{\meta{name}.next}.
%    \begin{macrocode}
  \exp_args:NNV \@@_next:Nn \l_ans_tl \l_name_tl
                }
              } {
%    \end{macrocode}
% Case \texttt{\meta{name}.last}.
%    \begin{macrocode}
  \exp_args:NNV \@@_last:Nn \l_ans_tl \l_name_tl
              }
            } {
%    \end{macrocode}
% Case \texttt{\meta{name}.range}. \textcolor{red}{PROBLEM with |::|}
%    \begin{macrocode}
  \bool_if:NT #1 {
    \msg_fatal:nnn { @@ } { :n } {
      No~\l_name_tl.range available:~#3
    }
  }
  \exp_args:NNV \@@_start:Nn \l_ans_tl \l_name_tl
  \tl_put_right:Nn \l_ans_tl { :: }
  \exp_args:NNV \@@_last:Nn \l_ans_tl \l_name_tl
            }
          } {
%    \end{macrocode}
% Case \texttt{\meta{name}.length}.
%    \begin{macrocode}
  \exp_args:NNV \@@_length:Nn \l_ans_tl \l_name_tl
          }
        }
      } {
        \switch:nNTF { 4 } \l_group_tl { % +=
  \msg_fatal:nnn { @@ } { :n } {
    No~integer~to~increment~\l_name_tl:~#3
  }
%    \end{macrocode}
% Case \texttt{\meta{name} += \meta{integer}}.
%    \begin{macrocode}
        } {
  \bool_if:NT #1 {
    \msg_fatal:nnn { @@ } { :n } {
      No~\l_name_tl~cursor~available~inside~\cs{Beanover}:~#3
    }
  }
  \exp_args:NNVV
  \@@_incr:Nnn \l_ans_tl \l_name_tl \l_group_tl
        }
      }
    } {
      \switch:nNTF { 1 } \l_name_tl {
%    \end{macrocode}
% Case \texttt{\meta{name}}.
%    \begin{macrocode}
        \bool_if:NT #1 {
          \msg_fatal:nnn { @@ } { :n } {
            No~\l_name_tl~cursor~available~inside~\cs{Beanover}:~#3
          }
        }
        \exp_args:NNV
        \@@_cursor:Nn \l_ans_tl \l_name_tl
      } { % ++ ?
%    \end{macrocode}
% Case \texttt{++\meta{name}}.
%    \begin{macrocode}
        \bool_if:NT #1 {
          \msg_fatal:nnn { @@ } { :n } {
            No~\l_name_tl~cursor~available~inside~\cs{Beanover}:~#3
          }
        }
        \exp_args:NNV
        \@@_incr:Nnn \l_ans_tl \l_name_tl 1
      }
    }
    \int_add:Nn \l_split_int { 13 }
    \tl_put_right:Nx \l_ans_tl {
      \seq_item:Nn \l_split_seq { \l_split_int }
    }
  }
  \exp_args:NNNV
  \group_end:
  \tl_put_right:Nn #2 \l_ans_tl
}
%    \end{macrocode}
%
% \begin{function}{\@@_start:Nn}
% \begin{syntax}
% \cs{@@_start:Nn} \meta{tl variable} \marg{name}
% \end{syntax}
% Append the start of the \meta{name} slide range
% to the \meta{tl variable}
% with \cs{@@_eval_static:NNn}.
% Cache the result.
%    \begin{macrocode}
\cs_new:Npn \@@_start:Nn #1 #2 {
  \prop_if_in:NnTF \g_@@_prop { #2.A } {
    \tl_put_right:Nx #1 {
      \prop_item:Nn \g_@@_prop { #2.A }
    }
  } {
    \group_begin:
    \tl_clear:N \l_ans_tl
    \prop_if_in:NnTF \g_@@_prop { #2.c } {
      \exp_args:NNNx
      \@@_eval:NNn \c_true_bool \l_ans_tl {
        \prop_item:Nn \g_@@_prop { #2.c } + 0
      }
    } {
      \exp_args:NNNx
      \@@_eval:NNn \c_false_bool \l_ans_tl {
        \prop_item:Nn \g_@@_prop { #2.1 } + 0 
      }
    }
    \prop_gput:NnV \g_@@_prop { #2.A } \l_ans_tl
    \exp_args:NNNV
    \group_end:
    \tl_put_right:Nn #1 \l_ans_tl
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}[TF]{\@@_length:n}
%   \begin{syntax}
%     \cs{@@_length:nTF} \marg{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{name} slide range has a length.
% \end{function}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_length:n #1 { TF } {
  \prop_has_item:NnTF \g_@@_prop { #1 } {
    \prg_return_true
  } {
    \prg_return_false
  }
}
%    \end{macrocode}
% \begin{function}{\@@_length:Nn}
% \begin{syntax}
% \cs{@@_length:Nn} \meta{tl variable} \marg{name}
% \end{syntax}
% Append the length of the \meta{name} slide range to \meta{tl variable}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_length:Nn #1 #2 {
  \prop_if_in:NnTF \g_@@_prop { #2.L } {
    \tl_put_right:Nx #1 { \prop_item:Nn \g_@@_prop { #2.L } }
  } {
    \@@_length:nTF { #2 } {
      \group_begin:
      \tl_clear:N \l_ans_tl
      \exp_args:NNNx
      \@@_eval:NNn \c_true_bool \l_ans_tl {
        \prop_item:Nn \g_@@_prop { #2.l } + 0
      }
      \tl_set:Nx \l_ans_tl {
        \exp_args:NV \fp_to_int:n \l_ans_tl
      }
      \prop_gput:NnV \g_@@_prop { #2.L } \l_ans_tl
      \exp_args:NNNV
      \group_end:
      \tl_put_right:Nn #1 \l_ans_tl
    } {
      \msg_error:nnn { @@ } { :n } { No~length~given:~#2 }
      \tl_put_right:Nn #1 { 0 }
    }
  }
}
%    \end{macrocode}
% \begin{function}{\@@_next:Nn}
% \begin{syntax}
% \cs{@@_next:Nn} \meta{tl variable} \marg{name}
% \end{syntax}
% Append the index after the \meta{name} slide range to the \meta{tl variable}.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_next:Nn #1 #2 {
  \prop_if_in:NnTF \g_@@_prop { #2.N } {
    \tl_put_right:Nx #1 {
      \prop_item:Nn \g_@@_prop { #2.N }
    }
  } {
    \@@_length:nTF { #2 } {
      \group_begin:
      \tl_clear:N \l_ans_tl
      \@@_start:Nn \l_ans_tl { #2 }
      \tl_put_right:Nn \l_ans_tl { + }
      \@@_length:Nn \l_ans_tl { #2 }
      \tl_clear:N \l_a_tl
      \exp_args:NNNV
      \@@_eval:NNn \c_true_bool \l_a_tl \l_ans_tl
      \tl_set:Nx \l_ans_tl {
        \exp_args:NV \fp_to_int:n \l_a_tl
      }
      \prop_gput:NnV \g_@@_prop { #2.N } \l_ans_tl
      \exp_args:NNNV
      \group_end:
      \tl_put_right:Nn #1 \l_ans_tl
    } {
      \msg_error:nnn { @@ } { :n } { No~length~given:~#2 }
      \@@_start:Nn #1 { #2 }
    }
  }
}
%    \end{macrocode}
% \begin{function}{\@@_last:Nn}
% \begin{syntax}
% \cs{@@_last:Nn} \meta{tl variable} \marg{name}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_last:Nn #1 #2 {
  \prop_if_in:NnTF \g_@@_prop { #2.Z } {
    \tl_put_right:Nx #1 {
      \prop_item:Nn \g_@@_prop { #2.Z }
    }
  } {
    \@@_length:nTF { #2 } {
      \group_begin:
      \tl_clear:N \l_ans_tl
      \@@_next:Nn \l_ans_tl { #2 }
      \tl_put_right:Nn \l_ans_tl { - 1 }
      \tl_set:Nx \l_ans_tl {
        \exp_args:NV \fp_to_int:n \l_ans_tl
      }
      \prop_gput:NnV \g_@@_prop { #2.Z } \l_ans_tl
      \exp_args:NNNV
      \group_end:
      \tl_put_right:Nn #1 \l_ans_tl
    } {
      \msg_error:nnn { @@ } { :n } { No~length~given:~#2 }
      \@@_start:Nn #1 { #2 }
    }
  }
}
%    \end{macrocode}
% \begin{function}{\@@_cursor:Nn}
% \begin{syntax}
% \cs{@@_cursor:Nn} \meta{tl variable} \marg{name}
% \end{syntax}
% Append the value of the cursor associated to the \marg{name} slide range
% to the right of \meta{tl variable}.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_cursor:Nn #1 #2 {
  \group_begin:
  \prop_get:NnNTF \g_@@_prop { #2 } \l_ans_tl {
    \tl_clear:N \l_a_tl
    \@@_start:Nn \l_a_tl {#2}
    \int_compare:nNnT { \l_ans_tl } < { \l_a_tl } {
      \tl_set_eq:NN \l_ans_tl \l_a_tl
    }
%    \end{macrocode}
% Not too low.
%    \begin{macrocode}
  } {
    \tl_clear:N \l_ans_tl
    \@@_start:Nn \l_ans_tl {#2}
    \prop_gput:NnV \g_@@_prop { #2 } \l_ans_tl
  }
%    \end{macrocode}
% If there is a length, use it to bound the result from above.
%    \begin{macrocode}
  \@@_length:nTF { #2 } {
    \tl_clear:N \l_a_tl
    \@@_last:Nn \l_a_tl {#2}
    \int_compare:nNnF { \l_ans_tl } > { \l_a_tl } {
      \tl_set_eq:NN \l_ans_tl \l_a_tl
    }
  }
  \exp_args:NNNV
  \group_end:
		\tl_set:Nn #1 \l_ans_tl
}
%    \end{macrocode}
% \begin{function}{\@@_incr:Nnn}
% \begin{syntax}
% \cs{@@_incr:Nnn} \meta{tl variable} \marg{name} \marg{offset}
% \end{syntax}
% \end{function}
% Increment the cursor position accordingly.
% The result will lay within the declared range.
%    \begin{macrocode}
\cs_new:Npn \@@_incr:Nnn #1 #2 #3 {
  \group_begin:
  \tl_clear:N \l_a_tl
  \tl_clear:N \l_ans_tl
  \@@_cursor:Nn \l_a_tl { #2 }
  \exp_args:NNx
  \@@_eval:Nn \l_ans_tl { \l_a_tl + ( #3 ) }
  \prop_gput:NnV \g_@@_prop { #2 } \l_ans_tl
  \exp_args:NNNV
  \group_end:
  \tl_put_right:Nn #1 \l_ans_tl
}
%    \end{macrocode}
%
% \subsubsection{Reseting slide ranges}
% \begin{function}{\BeanoverReset}
%   \begin{syntax}
%     \cs{BeanoverReset} \oarg{start value} \marg{Slide range name}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \BeanoverReset { O{1} m } {
  \@@_reset:nn { #1 } { #2 }
  \ignorespaces
}
%    \end{macrocode}
% Forwards to \cs{@@_reset:nn}.
% \end{function}
%
% \begin{function}{\@@_reset:nn}
% \begin{syntax}
% \cs{@@_reset:nn} \marg{start value} \marg{slide range name}
% \end{syntax}
% Reset the cursor to the given \meta{start value} which defaults to 1.
% Clean the cached values also (not usefull).
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_reset:nn #1 #2 {
  \prop_if_in:NnTF \g_@@_prop { #2.1 } {
    \prop_gremove:Nn \g_@@_prop { #2 }
    \prop_gremove:Nn \g_@@_prop { #2.A }
    \prop_gremove:Nn \g_@@_prop { #2.L }
    \prop_gremove:Nn \g_@@_prop { #2.N }
    \prop_gremove:Nn \g_@@_prop { #2.Z }
    \prop_gput:Nnn \g_@@_prop { #2.c } { #1 }
  } {
    \msg_warning:nnn { @@ } { :n } { Unknown~name:~#2 }
  }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\makeatother
\ExplSyntaxOff
%    \end{macrocode}
% \end{implementation}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
