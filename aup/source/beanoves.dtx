% \iffalse meta-comment
% !TEX program  = LuaLaTeX
% !TEX encoding = UTF-8
%
% File: beanoves.dtx
%
% Run this file twice with LuaLaTeX
%
% Copyright (C) 2023 Jérôme Laurens
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2020/01/01 or later.
%
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
beanoves --- beamer named overlay specifications
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See https://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package allows the management of multiple time lines in |beamer| documents.
Time lines are very handy both during edition and to manage complex and variable overlay specifications.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\generate{
  \nopreamble
  \nopostamble
  \file{\jobname-test.lua}{\from{\jobname.dtx}{test-lua}}
}
\preamble
\endpreamble
\postamble

beanoves --- beamer named overlay specifications

Copyright (C) 2023 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

https://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  beanoves.dtx
and the derived files           beanoves.ins,
                                beanoves.pdf,
                                beanoves.sty and
                                beanoves-debug.sty.

\endpostamble
\generate{
  \file{\jobname-debug.sty}{\from{\jobname.dtx}{package,debug}}
}
\usedir{tex/latex/beanoves}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package,final}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/beanoves}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/beanoves}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
% !TeX encoding = UTF-8
% !TeX program = lualatex
% !TeX proot = ...
\PassOptionsToPackage{enable-debug}{expl3}
\documentclass{l3doc}
\RequirePackage{luacode}
\RequirePackage{beanoves-debug}
\ExplSyntaxOn
\cs_new:Npn \BNVSNote {
  \msg_note:nnn { beanoves } { :n }
}
\ExplSyntaxOff
\ProvideDocumentEnvironment{bnvs.test}{+b}{}{}
\RequirePackage{hyperref}
\RequirePackage{multirow}
\RequirePackage{tcolorbox}
\RequirePackage{unicode}
\RequirePackage{unicode-math}
\RequirePackage{emoji}
\tcbuselibrary{minted}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\title{\pkg{beamer} named overlay specifications with \pkg{beanoves}}
\author{Jérôme Laurens}
\GetFileInfo{\jobname-debug.sty}
\date{\fileversion \qquad \filedate}
\NewDocumentEnvironment{bnvs.macrocode}{}{
  \setlength{\topsep}{0.4em plus 0.15 em minus 0.15 em}
  \begin{trivlist}
  \setlist[trivlist]{nosep}
  \item\vspace{-\baselineskip}
}{
  \end{trivlist}
}
%\OnlyDescription
\begin{document}
\maketitle
\changes{v1.0}{2023/01/07}{First public release}
\begin{abstract}
This package allows the management of multiple named slide number sets in \pkg{beamer} documents.
Named slide number sets are very handy both during edition and to manage complex and variable \pkg{beamer} overlay specifications. In particular, they allow to replace raw numbers in \pkg{beamer} |<...>| overlay specifications by logical identifiers. Demonstration files are \href[pdfnewwindow]{https://github.com/jlaurens/beanoves/tree/main/demo}{available for download} as part of the
\href[pdfnewwindow]{https://github.com/jlaurens/beanoves/}{development repository}.
\end{abstract}
%
\tableofcontents
%
\begin{documentation}
%
\section{Minimal example}
%
The document below is a contrived example to show how the |beamer|
overlay specifications have been extended.

\begin{tcblisting} {
  listing only,
  listing file = example1.tex,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\documentclass {beamer}
\RequirePackage {beanoves}
\begin{document}
\Beanoves {
      A = 1:3,
      B = A.next::3,
      C = B.next,
    }
\begin{frame}
  {\Large Frame \insertframenumber}
  {\Large Slide \insertslidenumber}
\visible<?(A.1)> {Only on slide 1}\\
\visible<?(B.1)-?(B.last)> {Only on slide 3 to 5}\\
\visible<?(C.1)> {Only on slide 6}\\
\visible<?(A.2)> {Only on slide 2}\\
\visible<?(B.2:B.last)> {Only on slide 4 to 5}\\
\visible<?(C.2)> {Only on slide 7}\\
\visible<?(A.next)-> {From slide 3}\\
\visible<?(B.3:B.last)> {Only on slide 5}\\
\visible<?(C.3)> {Only on slide 8}\\
\end{frame}
\end{document}
\end{tcblisting}
%
On line 4, we use the |\Beanoves| command to declare \emph{named overlay sets}.
On line 5, we declare an overlay set named `A', which is a range starting at slide 1 and ending at slide 3.
On line 12, the extended \emph{named overlay specification} \texttt{?(A.1)} stands for 1 because 1 is the first index of the overlay set named A.
On line 15, \texttt{?(A.2)} stands for 2
whereas on line 18, \texttt{?(A.next)} stands for 3.
%
On line 6, we declare a second overlay set named `B',
starting after the 2 slides of `A' namely 3.
Its length is 3 meaning that its last slide number is 5,
thus each \texttt{?(B.last)} is replaced by 5.
The next slide number after slide range `B' is 6
which is also the start of the third slide range
due to line 7.
\section{Named overlay sets}
\subsection{Presentation}
Within a \pkg{beamer} frame, there are different slides that appear in turn
according to overlay specifications. The main overlay sets is a range of integers
covering all the slide numbers, from one to the total amount of slides.
In general, an overlay set is a range of positive integers identified by a unique name.
The main practical interest is that such sets may be defined relative to one another, we can even have lists of overlay sets.
Finally, we can use these lists to build and organize \pkg{beamer} overlay
specifications logically.
\subsection{Named overlay reference}
|A.1|, |C.2| are \emph{named overlay references}, as well as |A| and |Y!C.2|.
More precisely, they are string identifiers, each one representing
a well defined static integer to be used in \pkg{beamer} overlay specifications.
They can take one of the next forms.
\begin{description}
\item[\texttt{\meta{short name}}]: like |A| and |C|,
\item[\texttt{\meta{frame id}|!|\meta{short name}}]: denoted by \emph{qualified names}, like |X!A| and |Y!C|.
\item[\texttt{\meta{short name}\meta{dotted path}}]:
  denoted by \emph{full names} like |A.1| and |C.2|,
\item[\texttt{\meta{frame id}|!|\meta{short name}\meta{dotted path}}]:
  denoted by \emph{qualified full names} like |X!A.1| and |Y!C.2|.
\end{description}
The \emph{short names} and \emph{frame ids} are alphanumerical case sensitive
identifiers, with possible underscores but no space nor leading digit.
Unicode symbols above \texttt{U+00A0} are allowed if the underlying \TeX\ engine
supports it. Identifiers consisting only of lowercase letters and underscores are reserved by the package.

The \emph{dotted path} is a string like
\texttt{.\meta{component_1}.\meta{component_2}....\meta{component_n}},
where each \meta{component_i} denotes either an integer, eventually signed,
or a \meta{short name}. The \emph{dotted path} can be empty in which case \texttt{n} is 0.
When not empty, the \emph{dotted path} starts with a dot but ends with no dot.

The mapping from \emph{named overlay references} to integers is defined
at the global \TeX\ level to allow its use in |\begin{frame}<...>| and to share the same overlay sets between different frames.
Hence the \emph{frame id} due to the need to possibly target a particular frame.

\subsection{Defining named overlay sets}
In order to define \emph{named overlay sets}, we can either execute the next |\Beanoves| command  before a \pkg{beamer} frame environment, or use the |beanoves| option of this environment.
The value of the |beanoves| option is similar to the argument of the |\Beanoves| commands, but the |\Beanoves| arguments take precedence over \pkg{beamer} frame environment options.
This behaviour may be useful to input the very same source code into different frames and have different combinations of slides.
%^^A:beanoves=...
\begin{function}{beanoves}
  \begin{syntax}
    beanoves = \{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
%^^A:\Beanoves
\begin{function}{\Beanoves}
  \begin{syntax}
    \cs{Beanoves}\{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}
  \end{syntax}
\end{function}
Each \meta{ref} key is a \emph{named overlay reference} whereas each \meta{spec} value
is an \emph{overlay set specifier}.
When the same \meta{ref} key is used multiple times, only the last one is taken into account.
\subsubsection{Basic case}
In the possible values for \meta{spec} below, \meta{value}, \meta{first}, \meta{length} and \meta{last} are algebraic expression possibly
involving any \emph{named overlay reference} defined above.
\begin{description}
\item[\texttt{\meta{value}},]
the simple \emph{value specifiers} for the whole signed integers set.
If only the \meta{key} is provided, the \meta{value} defaults to 1.
\item[\texttt{\meta{first}:} and \texttt{\meta{first}::},]
for the infinite range of signed integers starting at and including \meta{first}.
\item[\texttt{:\meta{last}},]
for the infinite range of signed integers ending at and including \meta{last}.
\item[\texttt{\meta{first}:\meta{last}}, \texttt{\meta{first}::\meta{length}}, \texttt{:\meta{last}::\meta{length}}, \texttt{::\meta{length}:\meta{last}},]
are variants for the finite range of signed integers starting at and including \meta{first}, ending at and including \meta{last}.
At least one of \meta{first} or \meta{last} must be provided.
We always have \(\meta{first}+\meta{length}=\meta{last}+1\).
\end{description}

When performed at the document level, the \cs{Beanoves} command starts by cleaning 
what was set by previous calls. When performed inside \LaTeX\ environments,
each call cumulates with the previous.
Notice that the argument of this function can contain macros:
they will be exhaustively expanded at resolution time.

\subsubsection{List specifiers}
Also possible values are \emph{list specifiers} which
are comma separated lists of \meta{ref}=\meta{spec} definitions.
The definition
\\[0.2ex]
\hphantom{xx}\texttt{\meta{key}=\{\meta{ref_1}=\meta{spec_1}, \meta{ref_2}=\meta{spec_2},..., \meta{ref_n}=\meta{spec_n}\}}
\\[0.2ex]
is a convenient shortcut for
\\[0.2ex]
\hphantom{xx}\texttt{\meta{key}.\meta{ref_1}=\meta{spec_1},}
\\\hphantom{xx}\texttt{\meta{key}.\meta{ref_2}=\meta{spec_2},}
\\\hphantom{xx}\texttt{...,}
\\\hphantom{xx}\texttt{\meta{key}.\meta{ref_n}=\meta{spec_n}.}
\\[0.2ex]
The rules above can apply individually to each line.

To support an array like syntax, we can omit the \meta{ref} key.
The first missing key is replaced by 1, the second by 2, and so on.

\subsubsection{\texttt{.n} specifiers}
\label{sect:.n specifiers}
\texttt{\meta{key}.n=\meta{value}} (with a litteral ``\texttt{.n}'') is used to set the value of
the index counter defined below.
%
\section{Named overlay resolution}
Turning a \emph{named overlay reference} into the static integer it represents,
as when above \texttt{<?(A.1)>} was replaced by 1, is denoted by \emph{named overlay resolution} or simply \emph{resolution}. This section is devoted to \emph{resolution rules} depending
on the definition of the named overlay set.
Here \meta{i} denotes an integer whereas \meta{first}, \meta{last} and \meta{length} stand for integers, or integer valued algebraic expressions.
%
\subsection{Simple definitions}
\begin{description}
\item[\texttt{\meta{key} = \meta{value}}]
For an unlimited range
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{value}\)\\
\meta{key}.2 & \(\meta{value}+1\) \\
\meta{key}.\meta{i} & \(\meta{value} + \meta{i} - 1\) \\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = \meta{first}:}] as well as \texttt{\meta{first}::}.
For a range limited from below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{first}\)\\
\meta{key}.2 & \(\meta{first}+1\) \\
\meta{key}.\meta{i} & \(\meta{first} + \meta{i} - 1\) \\
\meta{key}.previous & \(\meta{first}-1\)\\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = :\meta{last}}]
For a range limited from above:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{last}\)\\
\meta{key}.0 & \(\meta{last}-1\) \\
\meta{key}.\meta{i} & \(\meta{last} + \meta{i} - 1\) \\
\meta{key}.next & \(\meta{last}+1\)\\
\hline
\end{tabular}
\end{center}
\item[\texttt{\meta{key} = \meta{first}:\meta{last}}]
as well as variants \texttt{\meta{first}::\meta{length}},
\texttt{::\meta{length}:\meta{last}}
or \texttt{:\meta{last}::\meta{length}},
which are equivalent provided \(\meta{first}+\meta{length} = \meta{last}+1\).

For a range limited from both above and below:
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{reference} & \bfseries \textrm{resolution} 
\\\hline
\meta{key}.1 & \(\meta{first}\)\\
\meta{key}.2 & \(\meta{first}+1\) \\
\meta{key}.\meta{i} & \(\meta{first} + \meta{i} - 1\bigr)\) \\
\meta{key}.previous & \(\meta{first}-1\)\\
\meta{key}.last & \(\meta{last}\)\\
\meta{key}.next & \(\meta{last}+1\)\\
\meta{key}.length & \(\meta{length}\)\\
\meta{key}.range & \(\max(0,\meta{first})\) ''-'' \(\max(0,\meta{last})\)\\
\hline
\end{tabular}
\end{center}
Notice that the resolution of \texttt{\meta{key}.range} is not an algebraic difference,
and negative integers do not make sense there while in \pkg{beamer} context.

In the frame example below and after, we use the \cs{BeanovesEval} command for the demonstration.
It is mainly used for debugging and testing purposes.

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3:8, % or equivalently A = 3::6, A = ::6:8 and A = :8::6
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval[see](A.1)        == 3,
\BeanovesEval[see](A.-1)       == 1,
\BeanovesEval[see](A.previous) == 2,
\BeanovesEval[see](A.last)     == 8,
\BeanovesEval[see](A.next)     == 9,
\BeanovesEval[see](A.length)   == 6,
\BeanovesEval[see](A.range)    == 3-8,
\end{frame}
\end{tcblisting}
%
\end{description}
For example both \texttt{?(A.next)}, \texttt{?(A.last+1)}, \texttt{?(A.1+A.length)} give the same result as soon as the slide range named `|A|' has been properly defined with a starting value and a length.
\subsection{Counters}
\label{sect:counters}
Each named overlay set defined has a dedicated value counter
which is some kind of variable that can be used and incremented.
A simple \texttt{\meta{key}} \emph{named value reference} is resolved into
the position of this value counter.
For each frame, this variable is initialized to the
first available amongst the
\meta{value} of the \texttt{.n} initializer, \texttt{\meta{key}.first} or \texttt{\meta{key}.last}.
If none is available, an error is raised.

For each named overlay set defined, we also have an implicit index counter always starting at 1,
its actual value is an integer denoted \meta{n}.
The \texttt{\meta{key}.n} \emph{named index reference} (with a literal ``\texttt{.n}'') is resolved into \texttt{\meta{key}.\meta{n}},
which in turn is resolved according to the preceding rules.
%

Additionnaly, resolution rules are provided for the \emph{named value references}:
\begin{description}
\item[\texttt{\meta{key}+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the value counter by \meta{integer}
and use the new position.
Here \meta{integer expression} is the longest character sequence with no space%
\footnote{The parser for algebraic expression is very rudimentary.}.
\item[\texttt{++\meta{key}},] advance the value counter for \meta{key} by 1 and use the new position.
\item[\texttt{\meta{key}++},] use the actual position
and advance the value counter for \meta{key} by 1.
\end{description}

We have resolution rules as well for the \emph{named index references}:
\begin{description}
\item[\texttt{\meta{key}.n+=\meta{integer expression}},] resolve \meta{integer expression} into \meta{integer}, advance the implicit index counter associate to \meta{key} by \meta{integer} and use the resolution of \texttt{\meta{key}.n}.
Here again, \meta{integer expression} denotes the longest character sequence with no space.
\item[\texttt{\meta{key}.++n}, \texttt{++\meta{key}.n},] advance the implicit index counter associate to \meta{key} by 1 and use the resolution of \texttt{\meta{key}.n},
\item[\texttt{\meta{key}.n++},] use the resolution of \texttt{\meta{key}.n} and increment the implicit index counter associate to \meta{key} by 1.
\end{description}

In order to decrement a counter, one can increment with a negative value, no dedicated syntax is provided yet.

These counters are reset to their default value for each new frame, which is 1 for the \texttt{\meta{key}.n} counter, and whichever \texttt{\meta{key}.first} or \texttt{\meta{key}.last} is defined for the \texttt{\meta{key}} counter.
\subsection{Dotted paths}
\begin{description}
\item[\texttt{\meta{key}.\meta{i} = \meta{spec}},]
All the preceding rules are overriden by this particular one and \texttt{\meta{key}.\meta{i}} resolves to the resolution of \meta{spec}.

For example

\begin{tcblisting} {
  listing only,
  minted options={
    fontsize=\small,
    breaklines,
    linenos,
    numbersep=0.5\baselineskip,
  },
  minted style = autumn,
}
\Beanoves {
    A = 3,
    A.3 = 0,
  }
\begin{frame} {Frame \insertframenumber} {Slide \insertslidenumber}
\ttfamily
\BeanovesEval[see](A.1) == 3,
\BeanovesEval[see](A.2) == 4,
\BeanovesEval[see](A.-1)== 1,
\BeanovesEval[see](A.3) == 0,
\end{frame}
\end{tcblisting}
Without line 3, |A.3| would be evaluated to 5.
%
\item[\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_k} = \meta{range spec}}]
When a dotted path has more than one component,
a \emph{named overlay reference} like |A.1.2| needs some well defined
resolution rule to avoid ambiguity.
To resolve one level of such a reference
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}},
we replace the longest \texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_k}}
where 0$≤$k$≤$n by its definition \texttt{\meta{name'}.\meta{c'_1}...\meta{c'_p}}
if any (the path can be empty). \pkg{beanoves} uses this one level resolution
as many times as possible, but no more than a predefined limit to catch
circular reference that would lead to an infinite \TeX\ loop.
One final resolution occurs with rules above if possible or an error is raised.

For a \emph{named indexed reference} like
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}.n},
we must first resolve \texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}}
into \texttt{\meta{name'}} with an empty dotted path, then retrieve the value of \texttt{\meta{name'}.n} denoted as \meta{n'} and finally use the resolved 
\texttt{\meta{key}.\meta{c_1}.\meta{c_2}...\meta{c_n}.\meta{n'}}.
\end{description}
%
%
\subsection{Frame id}
Except for very special situations, the \emph{frame ids} can be left unspecified.
When no \emph{frame id} has been explicitly provided,
\pkg{beanoves} uses the \emph{last frame id}. At the beginning of each frame,
the \emph{last frame id} is set to the \emph{frame id} of the current frame,
which is denoted \emph{current frame id} and defaults to a single question mark ``|?|''.
Then it gets updated after each named reference resolution.
For example, the first time |A.1| reference is resolved within a given frame,
it is first translated to \texttt{\meta{current frame id}!A.1},
but when used just after \texttt{Y!C.2}, it becomes a shortcut to
\texttt{Y!A.1} because the \emph{last frame id} was then \texttt{Y}.

In order to set the \emph{frame id} of the current frame to \meta{frame id},
use the new \texttt{beanoves id} option of the \pkg{beamer} frame environment. 
%^^A:beanoves id=...
\begin{function}{beanoves id}
  \begin{syntax}
    beanoves id=\meta{frame id},
  \end{syntax}
\end{function}
We can use the same \emph{frame id} for different frames to share named overlay sets. 
%
\section{\texttt{?(...)} query expressions}
This is the key feature of the \pkg{beanoves} package, extending \pkg{beamer} \emph{overlay specifications} included between pointed brackets. Before the \emph{overlay specifications} are processed by the \pkg{beamer} class,
the \pkg{beanoves} package scans them for any occurrence of `\texttt{?(\meta{queries})}'. Each one is then evaluated and replaced by its resolved static counterpart.
The overall result is finally forwarded to the \pkg{beamer} class.

The \meta{queries} argument is a comma separated list of individual \meta{query}'s of next table.
Sometimes, using \texttt{\meta{key}.range} is not allowed because
the resolution would be interpreted as an algebraic difference
instead of a \pkg{beamer} range.
If it is not possible, an error is raised.
\begin{center}
\begin{tabular}{>{ \ttfamily \bfseries }l|>{ \ttfamily }l|>{ \ttfamily }l}
\hline
\bfseries \textrm{query} & \bfseries \textrm{resolution} & \bfseries \textrm{limitation}
\\\hline
\phantom{xxx}\meta{start expr} & \meta{start} & \\
\phantom{xxx}\meta{start expr}: & \meta{start} - & \textrm{no }\meta{key}.range \\
\phantom{xxx}\meta{start expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
::\meta{length expr}:\meta{end expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{::\meta{length expr}}:\meta{end expr} & \phantom{\meta{start}} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{::\meta{length expr}}: & \phantom{\meta{start}} - & \\
\phantom{xx}\meta{start expr}:: & \meta{start} -  & \textrm{no }\meta{key}.range \\
\phantom{xx}\meta{start expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{xxx}:\meta{end expr}::\meta{length expr} & \meta{start} - \meta{end} & \textrm{no }\meta{key}.range \\
\phantom{xxx:\meta{end expr}}:: & \phantom{\meta{start}} - & \\
\hline
\end{tabular}
\end{center}
Here \meta{start expr}, \meta{end expr} and \meta{length expr}
both denote algebraic expressions possibly involving named overlay references and counters.
As integers, they are respectively resolved into \meta{start}, \meta{end} and \meta{length}.

Notice that nesting \texttt{?(...)} query expressions is not supported.
\section{Support}
See \url{https://github.com/jlaurens/beanoves}.
One can report issues.
\end{documentation}
\DocInput{beanoves.dtx}
\begin{luacode}
local bnvs = require("./\jobname-test.lua")
tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
local ra = bnvs.check_variants("\jobname.sty")
tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
--[[
if ra then
  for _,v in ipairs(ra) do
    tex.print("\\verb|"..v.."|\\\\")
  end
end
]]
\end{luacode}
\end{document}
%</driver>
% \fi
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \NewDocumentEnvironment {bnvs.gobble} { +b } {} {}
% \begin{implementation}
% \begin{bnvs.gobble}
%<*package>
% \end{bnvs.gobble}
%
%\begin{bnvs.gobble}
%\begin{luacode}
%local bnvs = require("./\jobname-test.lua")
%tex.print("\\BNVSNote{".. bnvs.__INFO__.."}%")
%local ra = bnvs.check_variants("\jobname-debug.sty")
%tex.print("\\BNVSNote{"..table.concat(ra, "^^J").."}")
%--[[
%if ra then
%  for _,v in ipairs(ra) do
%    tex.print("\\verb|"..v.."|\\\\")
%  end
%end
%]]
%\end{luacode}
%\end{bnvs.gobble}
%
% \begin{bnvs.test}{bnvs:c={if_kip_resolve:TF}, noigre}
% \Test_if_kip_resolve:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_if_kip_resolve:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_if_kip_resolve:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \BNVS_DEBUG_on:
%         \tl_set:Nn \l__bnvs_key_tl { X }
%         \seq_set_split:Nnn \l__bnvs_a_seq {.} { }
%         \seq_remove_all:Nn \l__bnvs_a_seq { }
%         \BNVS_DEBUG_log_set:bn { kip_if_resolve:nTF } {
%           \BNVS_DEBUG_log_arg:nn { KEY } { X|?!| }
%         }
%         \BNVS_kip_if_resolve:TF {
%           \BNVS_log:x { ABC \l__bnvs_key_tl DE  }
%           \assert_equal_tl:vnn { key } { Y } { 1B-key }
%           \assert_equal:xnn { \BNVS_seq_use:in { a } . } { } { 1B-a }
%         } {
%           \test_fail:n { 1B-CALL }
%         }

% \Test_if_kip_resolve:nnnnnn { X=Y } { X } { } { Y } { } { 1B }
% \BNVS_DEBUG_on:
% \Test_if_kip_resolve:nnnnnn { X=Y,Y } { X } { } { Y } { } { 1B' }
% \Test_if_kip_resolve:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \BNVS_DEBUG_on:
% \Test_if_kip_resolve:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_if_kip_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_if_kip_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_if_kip_resolve:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \Test_if_kip_resolve:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_if_kip_resolve:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B }
% \Test_if_kip_resolve:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C }
% \Test_if_kip_resolve:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D }
% \Test_if_kip_resolve:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H }
% \Test_if_kip_resolve:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2 }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_if_kip_resolve:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L }
% \Test_if_kip_resolve:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A }
% \Test_if_kip_resolve:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A' }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c={kip_n_path_resolve:TF}, noigre}
% \BNVS_DEBUG_on:
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \Test_kip_n_path_resolve:nnnnnn { X=Y } { X } { } { Y } { } { 1B }
% \BNVS_DEBUG_on:
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y } { X } { } { Y } { } { 1B' }
% \Test_kip_n_path_resolve:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \BNVS_DEBUG_on:
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2 }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A' }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={parse:...}{[...]}}
% \Beanoves{
%   A.1 = 401,
% }
% \cs_new:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_if_resolve:niTF { #1 } { ans } {
%     \assert_equal_ans:nn { #2 } { #3 }
%   } {
%     \test_fail:n { NO_WAY-#3 }
%   }
% }
% \BNVS_DEBUG_on:
% \BeanovesLogGProp
% \BNVS_Test:nnn { A.1.21 } { 421 } { 5 }
% \cs_undefine:N \BNVS_Test:nnn
% \end{bnvs.test}
% \section{Implementation}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention, unused).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
%<@@=bnvs>
%    \end{macrocode}
% \end{bnvs.macrocode}
% Reserved namespace:
% identifiers containing the case insensitive string |beanoves| or
% the case insensitive string |bnvs| delimited by two non characters.
%
% \subsection{Package declarations}
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2020/01/01]
\ProvidesExplPackage
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!debug>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {beanoves}
%    \end{macrocode}
% \begin{bnvs.gobble}
%</!debug>
%<*!final>
  {beanoves-debug}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  {2023/01/07}
  {1.0}
  {Named overlay specifications for beamer}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsection{logging}
%
% Utility message.
%
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\msg_new:nnn { beanoves } { :n } { #1 }
\msg_new:nnn { beanoves } { :nn } { #1~(#2) }
\cs_new:Npn \BNVS_warning:n {
  \msg_warning:nnn { beanoves } { :n }
}
\cs_generate_variant:Nn \BNVS_warning:n { x }
\cs_new:Npn \BNVS_error:n {
  \msg_error:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_error:x {
  \msg_error:nnx { beanoves } { :n }
}
\cs_new:Npn \BNVS_fatal:n {
  \msg_fatal:nnn { beanoves } { :n }
}
\cs_new:Npn \BNVS_fatal:x {
  \msg_fatal:nnx { beanoves } { :n }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.gobble}
% Next are unexposed functions.
%<*!final>
\cs_new:Npn \BNVS_log_a:nn #1 #2 {
  \msg_term:nnn { beanoves } { :n } { #1~#2 }
}
\cs_generate_variant:Nn \BNVS_log_a:nn { xn }
\int_zero_new:N \l__bnvs_group_int
\cs_new:Npn \BNVS_DEBUG_log:n {
  \BNVS_log_a:xn
  { ▃▃ \prg_replicate:nn { \l__bnvs_group_int } {▁▃} \space }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \BNVS_log:n { x }
\cs_new:Npn \BNVS_log:N #1 { \BNVS_log:x { \token_to_str:N #1 } }
\cs_new:Npn \BNVS_DEBUG_on: {
  \cs_set:Npn \BNVS_log:n { \BNVS_DEBUG_log:n }
}
\cs_new:Npn \BNVS_DEBUG_off: {
  \cs_set:Npn \BNVS_log:n { \use_none:n }
}
\BNVS_DEBUG_on:
%    \end{macrocode}
%
% \subsection{Facility layer: definitions and naming}
%
% In order to make the code shorter and easier to read, we add a layer
% over \LaTeX3. The |c| and |v| argument specifiers take a different meaning when
% used in a function which name contains |bnvs| or |BNVS|.
% Where \LaTeX3 would transform |l__bnvs_key_tl| into |\l__bnvs_key_tl|,
% \pkg{bnvs} will directly transform |key| into |\l__bnvs_key_tl|.
% The type of the local variable used depends on the context and may be
% |seq| or |int| for example instead of |tl|.
% There are however a pair of exceptions mentionned below.
%
% For a better reading experience,
% `|key|' will generally stand for |\l__bnvs_key_tl|,
% whereas `|path| sequence' will generally stand for |\l__bnvs_path_seq|.
% Other similar shortcuts are used as well. 
%
% Functions with |BNVS| in their names are management functions.
% They belong to a deeper layer and do not contain any \pkg{beanoves}
% specific logic.
%
% We make use of special argument specifiers that are not used by standard \LaTeX3.
% Whereas known argument specifiers are
% |N|, |n|, |c|, |V|, |v|, |o|, |x|, |e|, |f|, |T|, |F|, |p|, |w|, |D|
% and are related to the implementation, we use |t|, |i|, |b|, |B| and |s|.
% \begin{description}
% \item[\texttt{t}] for a \LaTeX3\ data type, one of |bool|, |tl|, |int|, |seq|, |prop|...
% \item[\texttt{i}] for a variable core id,
% local variables are actually named |\l__bnvs_<id>_<type>| whereas
% global variables are named |\g__bnvs_<id>_<type>|.
% \item[\texttt{B}] stands for a boolean specification:
% a comma separated list of |p|, |T|, |F| or |TF|.
% \item[\texttt{b}] stands for a partial |c| argument.
% \item[\texttt{s}] stands for function signature.
% \end{description}
% When there is an |it| pair of argument specifiers, it may refer to a variable
% as |c|, |N|, |V| or |n| result. In order to make this clear for functions,
% the letters before the |:| separator are argument specifiers.
% For each occurrence of |i| in the signature,
% there is a corresponding |c|, |N|, |V| or |n| before the |:|.
% The order of arguments is preserved.
% \begin{function} {
%   \BNVS_c:b,
%   \BNVS_l_c:ti,
%   \BNVS_g_c:ti,
%   \BNVS_c_c:ti,
% }
% \begin{syntax}
% \cs{BNVS_c:b} \marg{cs core name}
% \cs{BNVS_l_c:ti} \marg{ type } \marg{local variable id}
% \cs{BNVS_g_c:ti} \marg{ type } \marg{global variable id}
% \cs{BNVS_c_c:ti} \marg{ type } \marg{global variable id}
% \end{syntax}
% These are naming functions.
% They transform the short argument into a longer name.
% Their output is is used as |c| argument, hence the |c| before the |:|.
% \cs{BNVS_use:b} wraps |\use:c| for a |b| argument, it needs 3 expansion steps.
% The longer |\use:c { \BNVS_c:b { ... } }| which gives the same result
% only needs 2 expansion steps.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\BNVS_c:b, \BNVS_l_c:ti, \BNVS_g_c:ti
%    \begin{macrocode}
\cs_new:Npn \BNVS_c:b    #1    { BNVS_#1     }
\cs_new:Npn \BNVS_l_c:ti #1 #2 { l__bnvs_#2_#1 }
\cs_new:Npn \BNVS_g_c:ti #1 #2 { g__bnvs_#2_#1 }
\cs_new:Npn \BNVS_c_c:ti #1 #2 { c__bnvs_#2_#1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use:N,
%   \BNVS_use:c,
%   \BNVS_use:b,
% }
% \begin{syntax}
% \cs{BNVS_use:N} \meta{function}
% \cs{BNVS_use:c} \marg{cs name}
% \cs{BNVS_use:b} \marg{core cs name}
% \end{syntax}
% In normal mode, \cs{BNVS_use:N} just calls its argument.
% In debug mode, raise if \meta{function} does not exist.
% \cs{BNVS_use:c} is a wrapper over \cs{use:c}, with function existence check
%, in debug mode only.
% It needs 3 expansion steps, one more than \cs{use:c}.
% \cs{BNVS_use:b} is a wrapper over \cs{use:c}, after a |b| to |c| translation.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:N #1 { #1 }
\cs_generate_variant:Nn \BNVS_use:N { c }
\cs_new:Npn \BNVS_use:b #1 {
  \BNVS_use:c { \BNVS_c:b { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_saved_use:N \BNVS_use:N
\cs_set:Npn \BNVS_use:N #1 {
  \cs_if_exist:NF #1 {
    \BNVS_use:b { fatal:x } { Unknown~command~\token_to_str:N #1~(c) }
  }
  #1
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_use:N, noigre}
% \BNVS_set:bpn { TEST: } {}
% \BNVS_use:N \BNVS_TEST:
% \BNVS_undefine:b { TEST: }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use:c, noigre}
% \BNVS_set:bpn { TEST: } {}
% \BNVS_use:c { BNVS_TEST: }
% \BNVS_undefine:b { TEST: }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use:b, noigre}
% \BNVS_set:bpn { TEST: } {}
% \BNVS_use:b { TEST: }
% \BNVS_undefine:b { TEST: }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_new:bpn,
%   \BNVS_set:bpn,
% }
% \cs{BNVS_new:bpn} is like \cs{cs_new:cpn} except that the |b| name
% argument is tagged for \pkg{beanoves} package and turned into a |c| argument.
% Similarly for \cs{BNVS_set:bpn}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_new:bpn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_new:b { #1 }
%</!final>
% \end{bnvs.gobble}
%^^A:\BNVS_c:b
%    \begin{macrocode}
  \cs_new:cpn { \BNVS_c:b { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine:b #1 {
  \cs_undefine:c { \BNVS_c:b { #1 } }
}
\cs_new:Npn \BNVS_DEBUG_log_new:N #1 {
  \BNVS_log:x { New => \token_to_str:N #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_new:c #1 {
  \BNVS_log:x { New => \token_to_str:c { #1 } }
}
\cs_new:Npn \BNVS_DEBUG_log_new:b #1 {
  \BNVS_log:x { New => \token_to_str:c { \BNVS_c:b { #1 } } }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new:bpn, noigre}
% \BNVS_new:bpn { TEST: } { }
% \cs_if_exist:NF \BNVS_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_undefine:b { TEST: }
% \cs_if_exist:NT \BNVS_TEST: {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%^^A:\BNVS_set:bpn
%    \begin{macrocode}
\cs_new:Npn \BNVS_set:bpn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
% \BNVS_log:n {Set=>#1}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_set:cpn { \BNVS_c:b { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_set:bpn, noigre}
% \BNVS_new:bpn { TEST:n } #1 { #1#1 }
% \cs_if_exist:NF \BNVS_TEST:n {
%   \test_fail:n { NO_WAY/1 }
% }
% \tl_set:Nx \l__bnvs_TEST_A_tl { \BNVS_TEST:n { X } }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { XX } { 
%   \test_fail:n { NO_WAY/2 }
% }
% \BNVS_undefine:b { TEST:n }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \cs_generate_variant:Nn { c }
\cs_new:Npn \BNVS_generate_variant:bn #1 {
  \cs_generate_variant:cn { \BNVS_c:b { #1 } }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use_signed:nN,
%   \BNVS_use_signed:nc,
%   \BNVS_use_signed:nb,
%   \BNVS_use_head_signed:nN,
%   \BNVS_use_head_signed:nc,
%   \BNVS_use_head_signed:nb,
% }
% \begin{syntax}
% \cs{\BNVS_use_signed:nN} \marg{signature} \meta{function}
% \cs{\BNVS_use_signed:nc} \marg{signature} \marg{function}
% \cs{\BNVS_use_signed:nb} \marg{signature} \marg{function}
% \cs{\BNVS_use_head_signed:nN} \marg{signature head} \meta{function}
% \cs{\BNVS_use_head_signed:nc} \marg{signature head} \marg{function}
% \cs{\BNVS_use_head_signed:nb} \marg{signature head} \marg{function}
% \end{syntax}
% In normal mode the signature is ignored and the function is called as is.
% In debug mode, the \meta{function} or \marg{function} is checked against
% the given signature before use. In the |head| version, the head of the
% \meta{function} or \marg{function} signature is checked,
% otherwise the whole signature is checked.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\BNVS_use...
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_signed:nN #1 {}
\cs_generate_variant:Nn \BNVS_use_signed:nN { nc }
\cs_new:Npn \BNVS_use_signed:nb #1 #2 { \BNVS_use_signed:nc { #1 } { \BNVS_c:b { #2 } } }
\cs_new:Npn \BNVS_use_head_signed:nN #1 {}
\cs_generate_variant:Nn \BNVS_use_head_signed:nN { nc }
\cs_new:Npn \BNVS_use_head_signed:nb #1 #2 { \BNVS_use_head_signed:nc { #1 } { \BNVS_c:b { #2 } } }
%    \end{macrocode}
%    \begin{macrocode}
\quark_new:N \q__bnvs
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_ensure_signed:nN #1 #2 {
  \exp_args:Nnx \str_if_eq:nnF { #1 } {
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:N #2 }
  } {
    \msg_fatal:nnx { beanoves } { :n } {
      \token_to_str:N #2~signature~should~be~#1~instead~of~\exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:N #2 }
    }
  }
}
\cs_generate_variant:Nn \cs_split_function:N { c }
\cs_new:Npn \BNVS_ensure_signed:nc #1 #2 {
  \exp_args:Nnx \str_if_eq:nnF { #1 } {
    \exp_last_unbraced:Nf \use_ii:nnn {
      \cs_split_function:c { #2 }
    }
  } {
    \msg_fatal:nnx { beanoves } { :n } {
      \token_to_str:N #2~signature~should~be~#1~instead~of~\exp_last_unbraced:Nf \use_ii:nnn {
        \cs_split_function:c { #2 }
      }
    }
  }
}
\cs_new:Npn \BNVS_ensure_signed:nb #1 #2 {
  \exp_args:Nnx \str_if_eq:nnF { #1 } {
    \exp_last_unbraced:Nf \use_ii:nnn {
      \cs_split_function:c { \BNVS_c:b { #2 } }
    }
  } {
    \msg_fatal:nnx { beanoves } { :n } {
      \token_to_str:N #2~signature~should~be~#1~instead~of~\exp_last_unbraced:Nf \use_ii:nnn {
        \cs_split_function:c { \BNVS_c:b { #2 } }
      }
    }
  }
}
\tl_new:N \l__bnvs_ehs_a_tl
\tl_new:N \l__bnvs_ehs_b_tl
\tl_new:N \l__bnvs_ehs_c_tl
\cs_new:Npn \BNVS_ensure_head_signed:n #1 {
  \exp_args:Nff \tl_if_eq:nnF {
    \tl_item:Nn \l__bnvs_ehs_a_tl { #1 }
  } {
    \tl_item:Nn \l__bnvs_ehs_b_tl { #1 }
  } {
    \msg_fatal:nnx { beanoves } { :n } {
    \backslash\l__bnvs_ehs_b_tl\space signature~should~start~with~#1~instead~of~\l__bnvs_ehs_c_tl
    }
  }
}
\cs_new:Npn \BNVS_ensure_head_signed:nN #1 #2 {
}
\cs_new:Npn \BNVS_ensure_head_signed_NO:nN #1 #2 {
  \tl_set:Nf \l__bnvs_ehs_a_tl { #1 }
  \tl_set:Nf \l__bnvs_ehs_b_tl {
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:N #2 }
  }
  \tl_set:Nn \l__bnvs_ehs_c_tl {
    \token_to_str:N #2\space signature~should~start~with~#1~instead~of~\exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:N #2 }
  }
  \int_step_function:nN { \tl_count:N \l__bnvs_ehs_a_tl } \BNVS_ensure_head_signed:n
}
\cs_new:Npn \BNVS_ensure_head_signed:nc #1 #2 {
  \exp_args:Nx \str_if_in:nnF { \q__bnvs #1 } {
    \exp_not:n \q__bnvs \exp_last_unbraced:Nf \use_ii:nnn {
      \cs_split_function:c { #2 }
    }
  } {
    \msg_fatal:nnx { beanoves } { :n } {
      \token_to_str:N #2\space signature~should~start~with~#1~instead~of~\exp_last_unbraced:Nf \use_ii:nnn {
        \cs_split_function:c { #2 }
      }
    }
  }
}
\cs_new:Npn \BNVS_ensure_head_signed:nb #1 #2 {
  \BNVS_ensure_head_signed:nc { #1 } { \BNVS_c:b { #2 } }
}
\cs_set:Npn \BNVS_use_signed:nN #1 #2 {
  \BNVS_ensure_signed:nN { #1 } #2
  #2
}
\cs_set:Npn \BNVS_use_signed:nc #1 #2 {
  \BNVS_ensure_signed:nc { #1 } #2
  \use:c { #2 }
}
\cs_set:Npn \BNVS_use_signed:nb #1 #2 {
  \BNVS_ensure_signed:nb { #1 } #2
  \BNVS_use:b { #2 }
}
\cs_set:Npn \BNVS_use_head_signed:nN #1 #2 {
  \BNVS_ensure_head_signed:nN { #1 } #2
  #2
}
\cs_set:Npn \BNVS_use_head_signed:nc #1 #2 {
  \BNVS_ensure_head_signed:nc { #1 } #2
  \use:c { #2 }
}
\cs_set:Npn \BNVS_use_head_signed:nb #1 #2 {
  \BNVS_ensure_head_signed:nb { #1 } #2
  \BNVS_use:b { #2 }
}
%</!final>
% \end{bnvs.gobble}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use:NN,
%   \BNVS_use:NV,
%   \BNVS_use:Nc,
%   \BNVS_use:Nb,
% }
% \begin{syntax}
% \cs{BNVS_use:NN} \meta{caller} \meta{token}
% \cs{BNVS_use:NV} \meta{caller} \meta{token}
% \cs{BNVS_use:Nc} \meta{caller} \marg{cs name}
% \cs{BNVS_use:Nb} \meta{caller} \marg{cs core}
% \end{syntax}
% For each function, 
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:NN #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { N } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  #1 #2
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_saved_use:NN \BNVS_use:NN
\cs_set:Npn \BNVS_use:NN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_use:b { fatal:x } { Unknown~command~\token_to_str:N #2~(N) }
  }
  \BNVS_saved_use:NN #1 #2
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:NV #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { V } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  #1 #2
}
\cs_generate_variant:Nn \BNVS_use:NN { Nc }
\cs_new:Npn \BNVS_use:Nb #1 #2 {
  \BNVS_use:Nc #1 { \BNVS_c:b { #2 } }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use:nN,
%   \BNVS_use:nV,
%   \BNVS_use:nc,
%   \BNVS_use:nb,
% }
% \begin{syntax}
% \cs{BNVS_use:nN} \marg{tokens} \meta{token}
% \cs{BNVS_use:nV} \marg{tokens} \meta{token}
% \cs{BNVS_use:nc} \marg{tokens} \marg{cs name}
% \cs{BNVS_use:nb} \marg{tokens} \marg{cs core}
% \end{syntax}
% In debug mode only, the \meta{token} is checked for existence before use.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\BNVS_use...
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:nN #1 #2 {
  #1 #2
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_saved_use:nN \BNVS_use:nN
\cs_set:Npn \BNVS_use:nN #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_use:b { fatal:x } { Unknown~command~\token_to_str:N #2~(n) }
  }
  \BNVS_saved_use:nN { #1 } #2
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:nV #1 #2 {
  #1 #2
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_set_eq:NN \BNVS_saved_use:nV \BNVS_use:nV
\cs_set:Npn \BNVS_use:nV #1 #2 {
  \cs_if_exist:NF #2 {
    \BNVS_use:b { fatal:x } { Unknown~command~\token_to_str:N #2~(n) }
  }
  \BNVS_saved_use:nV { #1 } #2
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \BNVS_use:nN { nc }
\cs_new:Npn \BNVS_use:nb #1 #2 {
  \BNVS_use:nc { #1 } { \BNVS_c:b { #2 } }
}
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_use:nN{:nV/:nc/=nb}, noigre}
% \
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x { NO_WAY \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Nv \BNVS_Test:N { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_use:ni, noigre}
% \cs_new:Npn \BNVS_Test:N #1 {
%   \tl_if_eq:nnF { #1 } { \l__bnvs_TEST_tl } {
%     \test_fail:x {
%       ^^J=>\token_to_str:N #1
%       ^^J=>\tl_to_str:N #1
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:ni { \BNVS_Test:N } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_use:ni, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:x {
%       ^^J=>\tl_to_str:N \l__bnvs_TEST_tl
%       ^^J=>\tl_to_str:n { #1 }
%       ^^J NO~WAY
%     }
%   }
% }
% \BNVS_tl_use:ni { \BNVS_Test:n } { TEST }
% \prg_do_nothing:
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use:b, noigre}
% \tl_clear:N \l__bnvs_TEST_tl
% \cs_set:Npn \BNVS_Test: { SUCCESS }
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A }
% \tl_clear:N \l__bnvs_TEST_tl
% \tl_set:Nx \l__bnvs_TEST_tl { \BNVS_use:b { BNVS_Test: } }
% \assert_equal_tl:vnn { TEST } { SUCCESS } { A' }
% \tl_clear:N \l__bnvs_TEST_tl
% \BNVS_set:bpn { fatal:x } #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { FAILURE }
% }
% \cs_undefine:N \BNVS_Test:
% \BNVS_use:b { BNVS_Test: }
% \assert_equal_tl:vnn { TEST } { FAILURE } { B }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_use:Nc{/:nc}, noigre}
% \BNVS_new:bpn { TEST: } { SUCCESS }
% \cs_if_exist:cF { \BNVS_c:b { TEST: } } {
%   \BNVS_fatal:x { Unknown~bnvs~command~TEST:~(ii-N) }
% }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \exp_args:No \tl_if_eq:nnF { #1 } { SUCCESS } {
%     \test_fail:x { E / \token_to_str:N #1 / }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:b { TEST: }
% \BNVS_new:bpn { TEST: } { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \cs_if_eq:NNF #1 \BNVS_TEST: {
%     \test_fail:x { TEST / \token_to_str:N #1 }
%   }
% }
% \BNVS_use:Nc   \BNVS_Test:N   { TEST: }
% \BNVS_use:nc { \BNVS_Test:N } { TEST: }
% \cs_undefine:N \BNVS_Test:N
% \BNVS_undefine:b { TEST: }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsection{Facility layer: Variables}
% \begin{function}{
%   \BNVS_use:ti,
%}
% \begin{syntax}
% \cs{BNVS_use:ti} \marg{type} \marg{id}
% \end{syntax}
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use:ti #1 #2 {
  \use:c { \BNVS_l_c:ti #1 #2 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_use:ti}
% \tl_set:Nn \BNVS_l_TEST_tl { abc }
% \exp_args:Nno \use:n {
%   \exp_args:Nno \use:n {
%     \exp_args:Nno \use:n {
%       \tl_set:Nn \l_tmpa_tl
%     }
%   }
% } { \BNVS_use:ti { tl } { TEST } }
% \tl_if_eq:NnF \l_tmpa_tl { abc } {
%   \test_fail:n { Failure }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use_N:Nti,
%   \BNVS_use_V:Nti,
%   \BNVS_use_n:Nti,
%   \BNVS_use_N:cti,
%   \BNVS_use_V:cti,
%   \BNVS_use_n:cti,
%   \BNVS_use_N:bti,
%   \BNVS_use_V:bti,
%   \BNVS_use_n:bti,
%}
% \begin{syntax}
% \cs{BNVS_use_N:Nti} \meta{function} \marg{type} \marg{id}
% \cs{BNVS_use_V:Nti} \meta{function} \marg{type} \marg{id}
% \cs{BNVS_use_n:Nti} \meta{function} \marg{type} \marg{id}
% \cs{BNVS_use_N:cti} \marg{function} \marg{type} \marg{id}
% \cs{BNVS_use_V:cti} \marg{function} \marg{type} \marg{id}
% \cs{BNVS_use_n:cti} \marg{function} \marg{type} \marg{id}
% \cs{BNVS_use_N:bti} \marg{function} \marg{type} \marg{id}
% \cs{BNVS_use_V:bti} \marg{function} \marg{type} \marg{id}
% \cs{BNVS_use_n:bti} \marg{function} \marg{type} \marg{id}
% \end{syntax}
% Expands the |ti| arguments into a |n|,  |N| or |V| argument,
% according to what is just before the |:|,
% then inject the result after the \meta{function}.
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_use_n:Nti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:n #1 {
%   \tl_if_eq:nnF { #1 } { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_n:Nti \Test:n { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_N:Nti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:N #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_N:Nti \Test:N { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_V:Nti}
% \tl_set:Nn \l__bnvs_TEST_tl { def }
% \cs_set:Npn \Test:V #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { def } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_V:Nti \Test:V { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_n:cti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:n #1 {
%   \tl_if_eq:nnF { #1 } { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_n:cti { Test:n } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_N:cti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:N #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_N:cti { Test:N } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_V:cti}
% \tl_set:Nn \l__bnvs_TEST_tl { def }
% \cs_set:Npn \Test:V #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { def } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_V:ci { Test:V } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_n:bti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \\BNVS_set:bpn { Test:n } #1 {
%   \tl_if_eq:nnF { #1 } { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_n:bti { Test:n } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_N:bti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \BNVS_set:bpn { Test:N } #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_N:bti { Test:N } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_V:bti}
% \tl_set:Nn \l__bnvs_TEST_tl { def }
% \BNVS_set:bpn { Test:V } #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { def } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_V:bti { Test:V } { tl } { TEST }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use_N:nti,
%   \BNVS_use_V:nti,
%   \BNVS_use_n:nti,
%}
% \begin{syntax}
% \cs{BNVS_use_N:nti} \marg{arg} \marg{type} \marg{core}
% \cs{BNVS_use_V:nti} \marg{arg} \marg{type} \marg{core}
% \cs{BNVS_use_n:nti} \marg{arg} \marg{type} \marg{core}
% \end{syntax}
% Expands the |ti| arguments into a n|, ||N| or |V| argument,
% according to what is just before the |:|,
% then inject the result just after the \meta{arg}.
% \meta{type} is one of |tl|, |seq|...
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_use_n:nti #1 #2 #3 {
  \exp_args:Nnv \use:n { #1 } { \BNVS_l_c:ti { #2 } { #3 } }
}
\cs_new:Npn \BNVS_use_N:nti #1 #2 #3 {
  \exp_args:Nnc \use:n { #1 } { \BNVS_l_c:ti { #2 } { #3 } }
}
\cs_new:Npn \BNVS_use_V:nti #1 #2 #3 {
  \exp_args:Nnv \use:n { #1 } { \BNVS_l_c:ti { #2 } { #3 } }
}

%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_use_n:nti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:n #1 {
%   \tl_if_eq:nnF { #1 } { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_n:nti { \Test:n } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_N:nti}
% \tl_set:Nn \l__bnvs_TEST_tl { cde }
% \cs_set:Npn \Test:N #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { cde } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_N:nti { \Test:N } { tl } { TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_use_V:nti}
% \tl_set:Nn \l__bnvs_TEST_tl { def }
% \cs_set:Npn \Test:V #1 {
%   \exp_args:NV \tl_if_eq:nnF #1 { def } {
%     \test_fail:n { Failure }
%   }
% }
% \BNVS_use_V:nti { \Test:V } { tl } { TEST }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_kit_new:t,
%   \BNVS_kit_use:t,
% }
% \begin{syntax}
% \cs{BNVS_kit_new:t} \marg{type}
% \cs{BNVS_kit_use:t} \marg{type}
% \end{syntax}
% Creates typed utility functions, see usage below.
% Undefined when no longer used.
% \meta{type} is one of |bool|, |tl|, |seq|...
% \cs{BNVS_kit_use:t} is useless for |seq|.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\BNVS_(N|v)_new:c
%    \begin{macrocode}
\cs_new:Npn \BNVS_kit_new:t #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_new:b { #1_l_c:i }
\BNVS_DEBUG_log_new:b { #1_new:i }
\BNVS_DEBUG_log_new:b { #1_l_undefine:i }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \cs_new:cpn { BNVS_#1_l_c:i } ##1 {
    l \BNVS_c:b{ ##1 } \tl_if_empty:nF { ##1 } { _ } #1
  }
  \cs_new:cpn { BNVS_#1_new:i } ##1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { New => \token_to_str:c { \BNVS_l_c:ti { #1 } { ##1 } } }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \use:c { #1_new:c } { \BNVS_l_c:ti { #1 } { ##1 } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \cs_new:cpn { BNVS_#1_l_undefine:i } ##1 {
    \cs_undefine:c { \BNVS_l_c:ti { #1 } { ##1 } }  
  }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\exp_args_generate:n { nNc }
\cs_new:Npn \BNVS_kit_use:t #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_DEBUG_log_new:b { #1_use:i }
  \BNVS_DEBUG_log_new:b { #1_use_n:Ni }
  \BNVS_DEBUG_log_new:b { #1_use_N:Ni }
  \BNVS_DEBUG_log_new:b { #1_use_V:Ni }
  \BNVS_DEBUG_log_new:b { #1_use_n:ci }
  \BNVS_DEBUG_log_new:b { #1_use_N:ci }
  \BNVS_DEBUG_log_new:b { #1_use_V:ci }
  \BNVS_DEBUG_log_new:b { #1_use_n:bi }
  \BNVS_DEBUG_log_new:b { #1_use_N:bi }
  \BNVS_DEBUG_log_new:b { #1_use_V:bi }
  \BNVS_DEBUG_log_new:b { #1_use_n:ni }
  \BNVS_DEBUG_log_new:b { #1_use_N:ni }
  \BNVS_DEBUG_log_new:b { #1_use_V:ni }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_new:bpn { #1_use:i } ##1 {
    \use:c { #1_use:c } { \BNVS_l_c:ti { #1 } { ##1 } }
  }
  \BNVS_new:bpn { #1_use_n:Ni } ##1 ##2 {
    \exp_args:NNnc\exp_args:NnV
    \use:n {
      \BNVS_use_head_signed:nN {n} ##1
    } { \BNVS_l_c:ti { #1 } { ##2 } }
  }
  \BNVS_new:bpn { #1_use_N:Ni } ##1 ##2 {
    \exp_args:NnNc
    \BNVS_use_head_signed:nN {N} ##1 {
      \BNVS_l_c:ti { #1 } { ##2 }
    }
  }
  \BNVS_new:bpn { #1_use_V:Ni } ##1 ##2 {
    \exp_args:NnNc
    \BNVS_use_head_signed:nN {V} ##1 {
      \BNVS_l_c:ti { #1 } { ##2 }
    }
  }
  \BNVS_new:bpn { #1_use_n:ni } ##1 ##2 {
    \exp_args:NNnc \exp_args:NnV \use:n { ##1 } { \BNVS_l_c:ti { #1 } { ##2 } }
  }
  \BNVS_new:bpn { #1_use_N:ni } ##1 ##2 {
    \exp_args:Nnc \use:n { ##1 } { \BNVS_l_c:ti { #1 } { ##2 } }
  }
  \BNVS_new:bpn { #1_use_V:ni } ##1 ##2 {
    \exp_args:NNnc \exp_args:NnV \use:n { ##1 } { \BNVS_l_c:ti { #1 } { ##2 } }
  }
}
%    \end{macrocode}
% WHAT
% \begin{bnvs.test}{:Nn=\BNVS_kit_new:t{/_use:t}}
% \cs_set:Npn \Test:n #1 {
%   \cs_exist:cF { \BNVS_TEST_KIT_#1 } {
%     \test_fail:n { Missing~\token_to_str:N \BNVS_TEST_KIT_#1 }
%   }
% }
% \Test:n { _new:i }
% \Test:n { _use_n:i }
% \Test:n { _use_N:i }
% \Test:n { _use_V:i }
% \Test:n { _use_n:Ni }
% \Test:n { _use_N:Ni }
% \Test:n { _use_V:Ni }
% \Test:n { _use_n:ci }
% \Test:n { _use_N:ci }
% \Test:n { _use_V:ci }
% \Test:n { _use_n:bi }
% \Test:n { _use_N:bi }
% \Test:n { _use_V:bi }
% \Test:n { _use_n:ni }
% \Test:n { _use_N:ni }
% \Test:n { _use_V:ni }
% \cs_exist:cF { \BNVS_TEST_KIT_undefine_l_c:i } {
%   \test_fail:n { Missing~\token_to_str:N \BNVS_TEST_KIT_#1 }
% }
% \end{bnvs.test}
%
% \begin{bnvs.test}{:Nn=\BNVS_tl_use:Ni{|:nv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \tl_if_eq:NnF \l__bnvs_TEST_tl { #1 } {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_tl_use:Ni   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:ni { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_undefine_all:t #1 {
  \cs_undefine:c { BNVS_#1_l_c:i }
  \cs_undefine:c { BNVS_#1_l_undefine:i }
  \cs_undefine:c { BNVS_#1_new:i }
  \cs_undefine:c { BNVS_#1_use_n:i }
  \cs_undefine:c { BNVS_#1_use_N:i }
  \cs_undefine:c { BNVS_#1_use_V:i }
  \cs_undefine:c { BNVS_#1_use_n:Ni }
  \cs_undefine:c { BNVS_#1_use_N:Ni }
  \cs_undefine:c { BNVS_#1_use_V:Ni }
  \cs_undefine:c { BNVS_#1_use_n:ci }
  \cs_undefine:c { BNVS_#1_use_N:ci }
  \cs_undefine:c { BNVS_#1_use_V:ci }
  \cs_undefine:c { BNVS_#1_use_n:bi }
  \cs_undefine:c { BNVS_#1_use_N:bi }
  \cs_undefine:c { BNVS_#1_use_V:bi }
  \cs_undefine:c { BNVS_#1_use_n:ni }
  \cs_undefine:c { BNVS_#1_use_N:ni }
  \cs_undefine:c { BNVS_#1_use_V:ni }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_kit_new:t { bool }
\BNVS_kit_use:t { bool }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_bool:v, noigre}
% \exp_args:Nx \tl_if_eq:nnF { \BNVS_bool:v { TEST } } { l__bnvs_TEST_bool } {
%   \test_fail:x { TEST/\BNVS_bool:v { TEST } }
% }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_bool_use:Nv{/:nv}, noigre}
% \bool_set_true:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NF #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nv   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nv { \BNVS_Test:N } { TEST }
% \bool_set_false:N \l__bnvs_TEST_bool
% \cs_set:Npn \BNVS_Test:N #1 {
%   \bool_if:NT #1 {
%     \test_fail:n { TEST }
%   }
% }
% \BNVS_bool_use:Nv   \BNVS_Test:N   { TEST }
% \BNVS_bool_use:nv { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_kit_new:t { int }
\BNVS_kit_use:t { int }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_int_use:Nv{/:nv}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \int_add:Nn #1 { 245 }
%   \int_compare:nNnF { #1 } = { 666 } {
%     \test_fail:x { TEST / \int_use:N #1 / }
%   }
% }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:Nv   \BNVS_Test:N   { TEST }
% \int_set:Nn \l__bnvs_TEST_int { 421 }
% \BNVS_int_use:nv { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_kit_new:t { tl }
\BNVS_kit_use:t { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_use:Ni{/:nv}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \assert_equal:nnn { #1 } { \l__bnvs_TEST_tl } { A }
% }
% \BNVS_tl_use:Ni   \BNVS_Test:N   { TEST }
% \BNVS_tl_use:ni { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_use:ni, noigre}
% \tl_set:Nn \l__bnvs_TEST_tl { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \assert_equal_tl:vnn { TEST } { #1 } { A }
% }
% \BNVS_tl_use:Ni   \BNVS_Test:n   { TEST }
% \BNVS_tl_use:ni { \BNVS_Test:n } { TEST }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_kit_new:t { str }
\BNVS_kit_use:t { str }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_str_use:nv{/:Nv}, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNF #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A≠B }
%   }
% }
% \BNVS_str_use:Nv   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nv { \BNVS_Test:N } { TEST_A }
% \str_set:Nn \l__bnvs_TEST_A_str { FAILURE }
% \cs_set:Npn \BNVS_Test:N #1 {
%   \str_if_eq:NNT #1 \l__bnvs_TEST_B_str {
%     \test_fail:n { A=B }
%   }
% }
% \BNVS_str_use:Nv   \BNVS_Test:N   { TEST_A }
% \BNVS_str_use:nv { \BNVS_Test:N } { TEST_A }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \subsubsection{Sequence utilities}
%    \begin{macrocode}
\BNVS_kit_new:t { seq }
\BNVS_kit_use:t { seq }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*final>
\cs_undefine:N \BNVS_kit_new:t
\cs_undefine:N \BNVS_kit_use:t
%</final>
% \end{bnvs.gobble}
%    \begin{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_new:b { seq_use:in }
\BNVS_DEBUG_log_new:b { seq_use_n:Nin }
\BNVS_DEBUG_log_new:b { seq_use_n:cin }
\BNVS_DEBUG_log_new:b { seq_use_n:bin }
\BNVS_DEBUG_log_new:b { seq_use_n:nin }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { seq_use:Nin } #1 #2 #3 {
  \exp_args:NNx \BNVS_use:Nn #1 { \BNVS_seq_use:in { #2 } { #3 } }
}
\BNVS_new:bpn { seq_use:cin } #1 {
  \exp_args:Nc \BNVS_seq_use:Nin { #1 }
}
\BNVS_new:bpn { seq_use:bin } #1 {
  \BNVS_seq_use:cin { \BNVS_seq_use:in { #1 } }
}
\BNVS_new:bpn { seq_use:nin } #1 #2 #3 {
  \exp_args:Nnx \use:n { #1 } { \BNVS_seq_use:in { #2 } { #3 } } 
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_seq_use:in, noigre}
% \seq_const_from_clist:cn { \BNVS_l_c:i { TEST } { seq } } { a, c }
% \exp_args:Nx
% \tl_if_eq:nnF { \BNVS_seq_use:in { TEST } { b } } { abc } {
%   \test_fail:n { FAILURE }
% }
% \end{bnvs.test}
% \begin{bnvs.test}{:Nn=\BNVS_seq_use:Nin{/:cin/:bin/:nin}, noigre}
% \seq_const_from_clist:cn { \BNVS_l_c:i { TEST } { seq } } { a, c }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \tl_if_eq:nnF { #1 #2 } { abcd } {
%     \test_fail:n { FAILURE }
%   }
% }
% \BNVS_seq_use:Nin \BNVS_Test:nn { TEST } { b } { d }
% \BNVS_seq_use:cin { BNVS_Test:nn } { TEST } { b } { d }
% \BNVS_seq_use:bin { Test:nn } { TEST } { b } { d }
% \BNVS_seq_use:nin { \BNVS_Test:nn } { TEST } { b } { d }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new:bpn { seq_use_flat:i } #1 {
  \BNVS_seq_use_n:in { #1 } { \q__bnvs }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { seq_set_from_flat:in } #1 #2 {
  \BNVS_seq_set_split:inn { #1 } { \q__bnvs } { #2 }
  \BNVS_seq_remove_all:in { #1 } {}
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=BNVS_seq_set_from_flat:in, noigre}
%   \BNVS_seq_set_from_flat:in { TEST } { 1 \q__bnvs 2 \q__bnvs 3 \q__bnvs \q__bnvs 4 }
%   \exp_args:Nx \tl_if_eq:nnF { \BNVS_seq_use:in { TEST } { . } } { 1.2.3.4 } {
%     \test_fail:n { Failure }
%   }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new:bpn { seq_merge:ii } #1 #2 {
  \BNVS_seq_if_empty:iF { #2 } {
    \exp_args:Nnx
    \BNVS_seq_set_from_flat:in { #1 } {
      \BNVS_seq_use:in { #1 } { \q__bnvs }
      \exp_not:n { \q__bnvs }
      \BNVS_seq_use:in { #2 } { \q__bnvs } 
    }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=BNVS_seq_merge:ii, noigre}
%   \BNVS_seq_set_from_flat:in { TEST } { 1 \q__bnvs 2 }
%   \BNVS_seq_set_from_flat:in { MORE } { 3 \q__bnvs 4 }
%   \BNVS_seq_merge:ii { TEST } { MORE }
%   \exp_args:Nx \tl_if_eq:nnF { \BNVS_seq_use:in { TEST } { . } } { 1.2.3.4 } {
%     \test_fail:n { Failure }
%   }
% \end{bnvs.test}

% \begin{bnvs.test}{:Nn=\BNVS_seq_use:Ni{/:ci/:bi/:ni}, noigre}
% \cs_set:Npn \BNVS_Test:N #1 {
%   \tl_set:Nn \l__bnvs_TEST_tl { 421 }
%   \seq_pop_left:NNTF #1 \l__bnvs_TEST_tl {
%     \tl_if_eq:NnF \l__bnvs_TEST_tl { SUCCESS } {
%       \test_fail:n { TEST/1/\tl_to_str:N #1 }
%     }
%   } {
%     \test_fail:n { TEST/2/\token_to_str:N #1 }
%   }
% }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:Nv   \BNVS_Test:N   { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:ci { BNVS_Test:N } { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:bi { \BNVS_Test:N } { TEST }
% \seq_clear:N \l__bnvs_TEST_seq
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_seq_use:ni { \BNVS_Test:N } { TEST }
% \cs_undefine:N \BNVS_Test:N
% \end{bnvs.test}
% \begin{function}{
%   \BNVS_seq_item:in,
%}
% \begin{syntax}
% \cs{BNVS_seq_item:in} \marg{id} \marg{index}
% \end{syntax}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { seq_item:in } #1 {
  \BNVS_seq_use_N:Ni \seq_item:Nn { #1 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use:Ni,
%}
% \begin{syntax}
% \cs{BNVS_use:Ni} \marg{function} \marg{id}
% \end{syntax}
% Expands the |i| arguments into a |n|, |N| or |V| argument,
% according to the function signature.
% This function is used during development because it is
% slower than explicit altermatives provided below.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { use:Ni } #1 #2 {
  \exp_args:Nnc
  \use:n {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A ([^:_]*)_[^:]*:([NVn])
    } { \cs_to_str:N #1 }
  } { \BNVS_l_c:ti { seq } { match }
  } {
    \exp_args:Nx
    \tl_if_eq:nnT {
      \seq_item:in { match } { 3 }
    } { n } {
      \exp_args:NNV
    }
    \exp_args:Nc #1 { \BNVS_l_c:ti {
      \BNVS_seq_item:in { match } { 2 }
    } { #2 } }
  } {
    \BNVS_error:x { Unsupported~function:~\tl_to_str:N #1 }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_use_V:ti}
% \exp_args:Nno \use:n {
%   \exp_args:Nno \use:n {
%     \exp_args:Nno \use:n {
%       \tl_set:Nn \l_tmpa_tl
%     }
%   }
% } { \BNVS_use_V:ti { tl } { TEST } }
% \tl_if_eq:NnF \l_tmpa_tl { \BNVS_l_TEST_tl } {
%   \test_fail:n { Failure }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_use_N:Nti,
%   \BNVS_use_V:Nti,
%   \BNVS_use_n:Nti,
%   \BNVS_use_N:cti,
%   \BNVS_use_V:cti,
%   \BNVS_use_n:cti,
%   \BNVS_use_N:bti,
%   \BNVS_use_V:bti,
%   \BNVS_use_n:bti,
%   \BNVS_use_N:nti,
%   \BNVS_use_V:nti,
%   \BNVS_use_n:nti,
% }
% \end{function}
% \begin{syntax}
% \cs{BNVS_use_n:Nti} \meta{function} \marg{variable core} \marg{type}
% \cs{BNVS_use:nit} \marg{tokens} \marg{variable core} \marg{type}
% \end{syntax}
% The |c| argument is not functionally required. We keep it as the type of the variable.
%    \begin{macrocode}
\BNVS_new:bpn { use_n:Nti } #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { n } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \exp_args:Nv #1 { \BNVS_l_c:ti { #2 } { #3 } }
}
\BNVS_new:bpn { generate_c_b_variants:N } #1 {
  \group_begin:
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A([^:]+):N(.*)\Z
    } {
      \cs_to_str:N #1
    }
  } { match } {
    \cs_set:Npn \BNVS_:nn ##1 ##2 {
      \cs_new:cpn { ##1:c##2 } {
        \exp_args:Nc #1
      }
      \cs_new:cpn { ##1:b##2 } ####1 {
        \exp_args:Nc #1 { \BNVS_c:b { ####1 } }
      }
    }
    \exp_args:Nxx \BNVS_:nn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    }
  } {
    \BNVS_error:x: { Unsupported~argument: #1 }
  }
  \group_end:
}
\BNVS_generate_c_b_variants:N \BNVS_use_n:Nti

\cs_new:Npn \BNVS_use_N:Nti #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { N } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}  
  \exp_args:Nc #1 { \BNVS_l_c:ti { #2 } { #3 } }
}
\BNVS_generate_c_b_variants:N \BNVS_use_N:Nti
%
\cs_new:Npn \BNVS_use_V:Nti #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { V } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}  
  \exp_args:Nv #1 { \BNVS_l_c:ti { #2 } { #3 } }
}
\BNVS_generate_c_b_variants:N \BNVS_use_V:Nti
\cs_new:Npn \BNVS_use:Nti #1 {
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF { :([nNV]) } { \cs_to_str:N #1 }
  } { match } {
    \BNVS_use:b { use_ \BNVS_seq_item:in { match } {2} :Nti }
  } {
    \BNVS_error:x: { Unsupported~argument: #1 }
  }
}
\BNVS_generate_c_b_variants:N \BNVS_use:Nti
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\seq_new:N \g__bnvs_DEBUG_REQUIRED_seq
\BNVS_new:bpn { DEBUG_require:N } #1 {
  \cs_if_exist:NF #1 {
    \BNVS_log:x { REQUIRED => \token_to_str:N #1 }
    \seq_gpush:Nn \g__bnvs_DEBUG_REQUIRED_seq { #1 }
  }
}
\BNVS_generate_c_b_variants:N \BNVS_DEBUG_require:N
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new_wrap_I:tcc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_wrap_I:tcc { tl } { TEST_A } { n }
% \cs_if_exist:NF \BNVS_tl_TEST_A:in {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \BNVS_tl_TEST_A:cn
% \end{bnvs.test}
%    \begin{macrocode}
\cs_set_eq:NN \BNVS_begin: \group_begin:
\cs_set_eq:NN \BNVS_end: \group_end:
\exp_args_generate:n { xxx, xxxx }
\BNVS_new:bpn { new_i_wrap:Nt } #1 #2 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]+):([nN])(\S*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \cs_set:Npn \BNVS_:nnn ##1 ##2 ##3 {
      \BNVS_new:bpn { ##1 :i ##3 } ####1 {
        \BNVS_use:b { ##1 :Nti } #1 { #2 } { ####1 }
      }
    }
    \exp_args:Nxxx \BNVS_:nnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_i_wrap:Nt
\BNVS_new:bpn { new_i_wrap:N } #1 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log:x { *****~DEBUG~\token_to_str:N #1 }
  \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?(([^_:]+)_[^:]+):([nN])(\S*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
  \BNVS_log:x { *****~new_i_wrap:N~->~\token_to_str:N #1}
    \cs_set:Npn \BNVS_:nnnn ##1 ##2 ##3 ##4 {
      \BNVS_new:bpn { ##1 :i ##4 } ####1 {
        \BNVS_use:b { ##3 :Nti } #1 { ##2 } { ####1 }
      }
    }
  \BNVS_log:x { *****~new_i_wrap:N~->~\token_to_str:N #1}
  \BNVS_log:x { *****~\seq_use:Nn \l__bnvs_match_seq {///} }
  \BNVS_log:x { *****~ \BNVS_use:nc {
      \BNVS_use_head_signed:nN {N} \seq_item:Nn
    } { \BNVS_l_c:ti { seq } { match } }
    {2}
  }
  \BNVS_log:x { *****~\BNVS_seq_use_N:Ni \seq_item:Nn { match } {2} }
  \BNVS_log:x { *****~\BNVS_seq_item:in { match } {3} }
  \BNVS_log:x { *****~\BNVS_seq_item:in { match } {4} }
  \BNVS_log:x { *****~\BNVS_seq_item:in { match } {5} }
  \BNVS_log:x { ***** }
    \exp_args:Nxxxx \BNVS_:nnnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    } {
      \BNVS_seq_item:in { match } {5}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_i_wrap:N
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_wrap_i:N, noigre}
% \BNVS_new_wrap_i:tcc 
% 
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_wrap_in:tc { tl } { TEST_A }
% \cs_if_exist:NF \BNVS_tl_TEST_A:cn {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \BNVS_tl_TEST_A:cn
% \end{bnvs.test}
%    \begin{macrocode}
\exp_args_generate:n { xxxx }
\BNVS_new:bpn { new_ni_wrap:Nt } #1 #2 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
    \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]+):n([nNV])(\S*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \cs_set:Npn \BNVS_:nnn ##1 ##2 ##3 {
      \BNVS_new:bpn { ##1 :ni ##3 } #####1 ####2 {
        \BNVS_use:b { use_##2:nti } {
          #1 { ####1 }
        } { ##2 } { ####2 }
      }
    }
    \exp_args:Nxxx \BNVS_:nnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_ni_wrap:Nt
\BNVS_new:bpn { new_ii_wrap:Ntt } #1 #2 #3 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
    \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]+):([nN])([nN])(\S*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \cs_set:Npn \BNVS_:nnnn ##1 ##2 ##3 ##4 {
      \BNVS_new:bpn { ##1 :ii ##4 } #####1 ####2 {
        \BNVS_use:b { use_##3:nti } {
          \BNVS_use:b { use_##2 :Nti } #1 { #2 } { ####1 }
        } { #3 } { ####2 }
      }
    }
    \exp_args:Nxxxx \BNVS_:nnnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    } {
      \BNVS_seq_item:in { match } {5}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_ii_wrap:Ntt
\exp_args_generate:n { xxxxx }
\BNVS_new:bpn { new_ii_wrap:Nt } #1 #2 {
  \BNVS_begin:
  \BNVS_seq_use_N:ni {
    \BNVS_log:x { ***** A:\cs_to_str:N \tl_set_eq:NN }
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?(([^_:]+)_[^:]+):([nN])([nN])(\S*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \BNVS_log:x { ***** A}
    \BNVS_log:x { ***** \BNVS_seq_use:in { match } { // } }
    \cs_set:Npn \BNVS_:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \BNVS_log:x { ***** C}
      \BNVS_new:bpn { ##1 :ii ##5 } ####1 ####2 {
        \BNVS_use:b { use_##4:nti } {
          \BNVS_use:b { use_##3:Nti } #1 { ##2 } { ####1 }
        } { #2 } { ####2 }
      }
      \BNVS_log:x { ***** D}
    }
    \BNVS_log:x { ***** B}
    \exp_args:Nxxxxx \BNVS_:nnnnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    } {
      \BNVS_seq_item:in { match } {5}
    } {
      \BNVS_seq_item:in { match } {6}
    }
    \BNVS_log:x { ***** E}
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N \#1 }
  }
  \BNVS_end:
  \BNVS_log:x { ***** F}
}
\BNVS_generate_c_b_variants:N \BNVS_new_ii_wrap:Nt
\exp_args_generate:n { xxxxx }
\cs_new:Npn \BNVS_new_iii_wrap:Nttt #1 #2 #3 #4 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
    \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]+):([nN])([nN])([nN])(\S*) \Z
    } { \cs_to_str:N #1 }
  } { match } {
    \cs_set:Npn \BNVS_:nnnnn ##1 ##2 ##3 ##4 ##5 {
      \BNVS_new:bpn { ##1 :iii ##5 } ####1 ####2 ####3 {
        \BNVS_use:b { use_##4:nti } {
          \BNVS_use:b { use_##3:nti } {
            \BNVS_use:b { use_##2:Nti } #1 { #2 } { ####1 }
          } { #3 } { ####2 }
        } { #4 } { ####3 }
      }
    }
    \exp_args:Nxxxxx \BNVS_:nnnnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    } {
      \BNVS_seq_item:in { match } {5}
    } {
      \BNVS_seq_item:in { match } {6}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_iii_wrap:Nttt
\exp_args_generate:n { xxxxxx }
\cs_new:Npn \BNVS_new_iii_wrap:Ntt #1 #2 #3 {
  \BNVS_begin:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
    \BNVS_DEBUG_require:N #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A (([^_]+)_[^:]+):([nN])([nN])([nN])(\S*) \Z
    } { \cs_to_str:N #1 }
  } { match } {
    \cs_set:Npn \BNVS_:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \BNVS_new:bpn { ##1 :iii ##6 } ####1 ####2 ####3 {
        \BNVS_use:b { use_##5:nti } {
          \BNVS_use:b { use_##4:nti } {
            \BNVS_use:b { use_##3:Nti } #1 { ##2 } { ####1 }
          } { #2 } { ####2 }
        } { #3 } { ####3 }
      }
    }
    \exp_args:Nxxxxxx \BNVS_:nnnnnn {
      \BNVS_seq_item:in { match } {2}
    } {
      \BNVS_seq_item:in { match } {3}
    } {
      \BNVS_seq_item:in { match } {4}
    } {
      \BNVS_seq_item:in { match } {5}
    } {
      \BNVS_seq_item:in { match } {6}
    } {
      \BNVS_seq_item:in { match } {7}
    }
  } {
    \BNVS_error:x { Unsupported~function~\token_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_generate_c_b_variants:N \BNVS_new_iii_wrap:Ntt
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_wrap_iii:Ntt, noigre}
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_new_wrap_in:tc, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { 666 }
% \cs_set:Npn \tl_TEST_A:Nn #1 #2 {
%   \tl_if_eq:NnF #1 { 666 } {
%     \test_fail:n { 666 / \token_to_str:N #1 }
%   }
%   \tl_if_eq:nnF { #2 } { Y } {
%     \test_fail:n { Y / \l_to_str:N { #2 }  }
%   }
% }
% \BNVS_new_wrap_in:tc { tl } { TEST_A }
% \cs_if_exist:NF \BNVS_tl_TEST_A:cn {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_tl_TEST_A:cn { TEST_A } { Y }
% \cs_undefine:N \tl_TEST_A:Nn
% \cs_undefine:N \BNVS_tl_TEST_A:cn
% \end{bnvs.test}
% In next function, the |N| argument has signature |nnn|. This is ensured while debugging.
%    \begin{macrocode}  

\cs_new:Npn \BNVS_tl_use:Niii #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_ensure_head_signed:nN { nnn } #1
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}  
  \BNVS_tl_use:ni {
    \BNVS_tl_use:ni {
      \BNVS_tl_use:Ni #1 { #2 }
    } { #3 }
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_tl_use:Niii, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { AB }
% \tl_set:Nn \l__bnvs_TEST_C_tl { ABC }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { A } {
%     \test_fail:n { A }
%   }
%   \tl_if_eq:nnF { #2 } { AB } {
%     \test_fail:n { AB }
%   }
%   \tl_if_eq:nnF { #3 } { ABC } {
%     \test_fail:n { ABC }
%   }
% }
% \BNVS_tl_use:Niii \BNVS_Test:nnn { TEST_A } { TEST_B } { TEST_C }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_new_conditional:Npnn { c }
\cs_new:Npn \BNVS_new_conditional:bpnn #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x {New => \token_to_str:c { \BNVS_c:b { #1 } } [TF] }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_new_conditional:cpnn { \BNVS_c:b { #1 } }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\cs_generate_variant:Nn \cs_split_function:N { c }
\cs_new:Npn \BNVS_undefine_conditional:b #1 {
  \BNVS_undefine:b {
    \exp_last_unbraced:Nf \use_i:nnn  { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \BNVS_undefine:b { #1##1 }
  }
}
\cs_new:Npn \BNVS_prg_undefine_conditional:c #1 {
  \cs_undefine:c {
    \exp_last_unbraced:Nf \use_i:nnn { \cs_split_function:c { #1 } }
    _p:
    \exp_last_unbraced:Nf \use_ii:nnn { \cs_split_function:c { #1 } }
  }
  \clist_map_inline:nn { T, F, TF } {
    \cs_undefine:c { #1##1 }
  }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_new_conditional:bpnn, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_new_conditional:bpnn { TEST_A:N } #1 { p, T, F, TF } {
%   \tl_if_eq:NNTF #1 \l__bnvs_TEST_B_tl {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \cs_new:Npn \BNVS_Test: { \BNVS_use:b { TEST_A_p:N } \l__bnvs_TEST_A_tl }
% \bool_if:nTF { \BNVS_Test: } { } { \test_fail:n { A/1 } }
% \bool_if:nT  { \BNVS_Test: } { }
% \bool_if:nF  { \BNVS_Test: }    { \test_fail:n { A/2 } }
% \cs_new:Npn \BNVS_Test:n #1 { \BNVS_use:b { TEST_A:N#1 } \l__bnvs_TEST_A_tl }
% \BNVS_Test:n { TF } { } { \test_fail:n { A/3 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { A/4 } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \bool_if:nTF { \BNVS_Test: } { \test_fail:n { A/5 } } { }
% \bool_if:nT  { \BNVS_Test: } { \test_fail:n { A/6 } }
% \bool_if:nF  { \BNVS_Test: }                          { }
% \BNVS_Test:n { TF } { \test_fail:n { A/7 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/8 } }
% \BNVS_Test:n {  F }                          { }
% \cs_undefine:N \BNVS_Test:
% \cs_undefine:N \BNVS_Test:n
% \BNVS_undefine_conditional:b { TEST_A:N }
% \end{bnvs.test}
%    \begin{macrocode}
\cs_generate_variant:Nn \prg_generate_conditional_variant:Nnn { c }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { new_conditional_i_wrap:Nn } #1 #2 {
  \BNVS_begin:
  \BNVS_seq_use_N:ni {
\BNVS_log:n { *****~B:##1 }
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]+)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
      \tl_if_eq:nnTF { ##1 } { p } {
        \BNVS_new_i_wrap:c {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        }
      } {
        \BNVS_new_i_wrap:b { \cs_to_str:N #1 ##1 }
      }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}

%\cs_generate_variant:Nn \BNVS_new_conditional_i_wrap:Nn { c }

\BNVS_new:bpn { new_conditional_i_wrap:cn } #1 {
  \BNVS_new_conditional_i_wrap:cn { #1 }
}
\BNVS_new:bpn { new_conditional_i_wrap:bn } #1 {
  \BNVS_new_conditional_i_wrap:cn { \BNVS_c:b { #1 } }
}
\BNVS_new:bpn { new_conditional_ni_wrap:Nnt } #1 #2 #3 {
  \BNVS_begin:
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
      \tl_if_eq:nnTF { ##1 } { p } {
        \BNVS_new_ni_wrap:ct {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        } { #3 }
      } {
        \BNVS_new_ni_wrap:bt { \cs_to_str:N #1 ##1 } { #3 }
      }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}
\BNVS_new:bpn { new_conditional_ii_wrap:Nnt } #1 #2 #3 {
  \BNVS_begin:
  \BNVS_seq_use_N:ni {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
\BNVS_log:n { *****~new_conditional_ii_wrap:Nnt:~##1 }
      \tl_if_eq:nnTF { ##1 } { p } {
\BNVS_log:n { *****p }
        \BNVS_new_ii_wrap:ct {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        } { #3 }
\BNVS_log:n { *****G }
      } {
        \BNVS_new_ii_wrap:bt { \cs_to_str:N #1 ##1 } { #3 }
      }
\BNVS_log:n { *****~DONE~##1 }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}
\cs_new:Npn \BNVS_new_conditional_ii_wrap:Nntt #1 #2 #3 #4 {
  \BNVS_begin:
  \BNVS_seq_use_N:nti {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
      \tl_if_eq:nnTF { ##1 } { p } {
        \BNVS_new_ii_wrap:ctt {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        } { #3 } { #4 }
      } {
        \BNVS_new_ii_wrap:btt { \cs_to_str:N #1 ##1 } { #3 } { #4 }
      }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}
\cs_new:Npn \BNVS_new_conditional_ii_wrap:cnt #1 {
  \exp_args:Nc \BNVS_new_conditional_ii_wrap:Nnt { #1 }
}
\cs_new:Npn \BNVS_new_conditional_ii_wrap:bnt #1 {
  \BNVS_new_conditional_ii_wrap:cnt { \BNVS_c:b { #1 } }
}

\cs_new:Npn \BNVS_new_conditional_iii_wrap:Nnttt #1 #2 #3 #4 #5 {
  \BNVS_begin:
  \BNVS_seq_use_N:nti {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
      \tl_if_eq:nnTF { ##1 } { p } {
        \BNVS_new_iii_wrap:cttt {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        } { #3 } { #4 } { #5 }
      } {
        \BNVS_new_iii_wrap:bttt {
          \cs_to_str:N #1 ##1
        } { #3 } { #4 } { #5 }
      }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}
\cs_new:Npn \BNVS_new_conditional_iii_wrap:Nntt #1 #2 #3 #4 {
  \BNVS_begin:
  \BNVS_seq_use_N:nti {
    \exp_args:Nnx
    \regex_extract_once:nnNTF {
      \A(?:BNVS_)?([^:]*):([^TF]*)\Z
    } { \cs_to_str:N #1 }
  } { match } {
    \clist_map_inline:nn { #2 } {
      \tl_if_eq:nnTF { ##1 } { p } {
        \BNVS_new_iii_wrap:ctt {
          \BNVS_seq_item:in { match } { 2 }
          _p:
          \BNVS_seq_item:in { match } { 3 }
        } { #3 } { #4 }
      } {
        \BNVS_new_iii_wrap:btt {
          \cs_to_str:N #1 ##1
        } { #3 } { #4 }
      }
    }
  } {
    \BNVS_error:x { Unexpected~function:~\cs_to_str:N #1 }
  }
  \BNVS_end:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Regex}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { regex_use:Ni } #1 #2 {
  \BNVS_use:Nc #1 { c__ \BNVS_c:b { #2 } _regex }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_extract_once:nn,
%   \BNVS_extract_once:in,
%   \BNVS_extract_once:Nn,
%   \BNVS_extract_once:Ni,
%   \BNVS_regex_split:in,
% }
% \begin{syntax}
% \cs{BNVS_extract_once:NnTF} \meta{regex variable} \marg{expression}
% \marg{yes code} \marg{no code}
% \cs{BNVS_extract_once:nnTF} \marg{regex} \marg{expression}
% \marg{yes code} \marg{no code}
% \cs{BNVS_regex_split:iniTF} \meta{regex core} \marg{expression} \meta{seq core} \marg{yes code} \marg{no code}
% \cs{BNVS_regex_split:inTF} \meta{regex core} \marg{expression} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item \cs{regex_extract_once:NnNTF} with the default match sequence as N argument
% \item \cs{regex_extract_once:nnNTF} with the default match sequence as N argument
% \item \cs{regex_split:NnNTF} with the default split sequence as last N argument
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...extract_once:Nn
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { extract_once:in } #1 #2 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \BNVS_use:Nc \regex_extract_once:NnNTF { \BNVS_c_c:ti { regex } { #1 } } { #2 }
  } { match } { \prg_return_true: } { \prg_return_false: }
}
\BNVS_new_conditional:bpnn { extract_once:Nn } #1 #2 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \regex_extract_once:NnNTF #1 { #2 }
  } { match } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_extract_once:NnTF, noigre}
% \BNVS_extract_once:NnTF \c__bnvs_TEST_comma_regex { , } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { extract_once:Ni } #1 #2 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \BNVS_tl_use_n:ni {
      \regex_extract_once:NnNTF #1
    } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_extract_once:NiTF, noigre}
% \tl_set:Nn \l__bnvs_TEST_B_tl { , }
% \BNVS_extract_once:NiTF \c__bnvs_TEST_comma_regex { TEST_B } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { , } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { extract_once:nn } #1 #2 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \regex_extract_once:nnNTF { #1 } { #2 }
  } { match } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_extract_once:nnTF, noigre}
% \BNVS_extract_once:nnTF { A } { A } {
%   \seq_pop_left:NNTF \l__bnvs_match_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { A } { A/1 }
%   } {
%     \test_fail:n { A/2 }
%   }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
%^^A:\...match_pop_left:i
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { match_pop_left:i } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { match_pop_left:iTF } { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_tl_use_N:ni {
    \BNVS_seq_use_N:Ni \seq_pop_left:NNTF { match }
  } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { match_pop_left:iTF } { ...TRUE }
\BNVS_DEBUG_log_tl:i { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { match_pop_left:iTF } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { match_pop_left:iT } #1 #2 {
  \BNVS_use:b { match_pop_left:iTF }
    { #1 } { #2 } { \BNVS_query_eval_unreachable: }
}
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:c={match_pop_left:iTF}, noigre}
% \BNVS_seq_clear:i { match }
% \BNVS_seq_put_right:vn { match } { SUCCESS }
% \BNVS_match_pop_left:iTF { A } {
%   \BNVS_tl_if_eq:vnF { A } { SUCCESS } {
%     \test_fail:n { A/1 }
%   }
% } {
%   \test_fail:n { A/2 }
% }
% \end{bnvs.test}
%^^A:\...regex_split:ini
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { regex_split:ini } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \BNVS_regex_use:Ni \regex_split:NnNTF { #1 } { #2 }
  } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:bpnn { regex_split:in } #1 #2 { T, F, TF } {
  \BNVS_seq_use_N:ni {
    \BNVS_use:Nti \regex_split:NnNTF { regex } { #1 } { #2 }
  } { split } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_regex_split:inTF, noigre}
% \cs_set:Npn \BNVS_Test:nT #1 #2 {
%   \seq_pop_left:NNTF \l__bnvs_split_seq \l__bnvs_TEST_A_tl {
%     \assert_equal_tl:vnn { TEST_A } { #1 } { #1/1 }
%     #2
%   } {
%     \test_fail:n { #1/2 }
%   }
% }
% \BNVS_regex_split:inTF { TEST_comma } { A,B,C } {
%   \BNVS_Test:nT { A } { \BNVS_Test:nT { B } { \BNVS_Test:nT { C } { } } }
% } {
%   \test_fail:n { A/3 }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Token lists}
%^^A:\...tl_...
% \begin{function}{
%   \BNVS_tl_clear:i,
%   \BNVS_tl_use:v,
%   \BNVS_tl_set_eq:ii,
%   \BNVS_tl_set:in,
%   \BNVS_tl_set:vv,
%   \BNVS_tl_set:vx,
%   \BNVS_tl_put_left:in,
%   \BNVS_tl_put_right:in,
%   \BNVS_tl_put_right:ix,
%   \BNVS_tl_put_right:ii,
% }
% \begin{syntax}
% \cs{ BNVS_tl_clear:i } \marg{core}
% \cs{ BNVS_tl_use:v } \marg{core}
% \cs{ BNVS_tl_count:v } \marg{core}
% \cs{ BNVS_tl_set_eq:ii } \marg{lhs core} \marg{rhs core}
% \cs{ BNVS_tl_set:in } \marg{core} \marg{tl}
% \cs{ BNVS_tl_set:vv } \marg{core} \marg{value core}
% \cs{ BNVS_tl_put_left:in } \marg{core} \marg{tl}
% \cs{ BNVS_tl_put_right:in } \marg{core} \marg{tl}
% \cs{ BNVS_tl_put_right:ii } \marg{core} \marg{value core}
% \end{syntax}
% These are shortcuts respectively to
% \begin{itemize}
% \item |\tl_clear:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_use:c {l__bnvs_|\texttt{\meta{core}}|_tl}|
% \item |\tl_set_eq:cc {l__bnvs_|\texttt{\meta{lhs core}}|_tl}||{l__bnvs_|\texttt{\meta{rhs core}}|_tl}|
% \item |\tl_set:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \item |\tl_set:cx {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_left:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cn {l__bnvs_|\texttt{\meta{core}}|_tl}|\texttt{\marg{tl}}
% \item |\tl_put_right:cv {l__bnvs_|\texttt{\meta{core}}|_tl}||{l__bnvs_|\texttt{\meta{value core}}|_tl}|
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_new_conditional_vnc:cn, noigre}
% \BNVS_new_conditional:bpnn { TEST:nnv } #1 #2 #3 { T, F, TF } {
%   \BNVS_tl_use:Ni \tl_set:Nn { TEST_#3 } { #1 }
%   \BNVS_tl_use:Ni \tl_if_eq:NnTF { TEST_#3 } { #2 } {
%     \prg_return_true:
%   } {
%     \prg_return_false:
%   }
% }
% \BNVS_use:b { TEST:nnvTF } { A } { A } { B } { } { \test_fail:n { 0 } }
% \BNVS_use:b { TEST:nnvTF } { A } { B } { B } { \test_fail:n { 1 } } { }
% \BNVS_new_conditional_vnc:cn { TEST } { T, F, TF }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \BNVS_TEST:vncTF { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 2 } }
% \BNVS_use:b { TEST:vncTF } { TEST_A } { SUCCESS } { B } { } { \test_fail:n { 3 } }
% \cs_new:Npn \BNVS_TEST:n #1 {
%   \BNVS_use:b { TEST:vnc#1 } { TEST_A } { SUCCESS } { B }
% }
% \BNVS_TEST:n { TF } { } { \test_fail:n { B/1 } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { B/2 } }
% \tl_set:Nn \l__bnvs_TEST_A_tl { FAILURE }
% \BNVS_TEST:n { TF } { \test_fail:n { B/3 } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { B/4 } }
% \BNVS_TEST:n {  F }                          { }
% \cs_undefine:N \BNVS_TEST:n
% \BNVS_undefine_conditional:b { BNVS_TEST:nnv }
% \BNVS_undefine_conditional:b { BNVS_TEST:vnc }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_i_wrap:N \tl_clear:N
\BNVS_new_i_wrap:N \tl_count:N
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_clear:i{|use:c|count:c}, noigre}
% \BNVS_tl_new:c { TEST_NCUC }
% \tl_set:Nn \l__bnvs_TEST_NCUC_tl { SUCCESS }
% \assert_size_equal:nnn { SUCCESS } { \BNVS_tl_use:v { TEST_NCUC } } { 1 }
% \assert_size_equal:nnn { 7 } { \BNVS_tl_count:v { TEST_NCUC } } { 2 }
% \BNVS_tl_clear:i { TEST_NCUC }
% \assert_size_equal:nnn {   } { \BNVS_tl_use:v   { TEST_NCUC } } { 3 }
% \assert_size_equal:nnn { 0 } { \BNVS_tl_count:v { TEST_NCUC } } { 4 }
% \BNVS_tl_undefine:c { TEST_NCUC }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_ii_wrap:Nt \tl_set_eq:NN { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_tl_set_eq:ii, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \BNVS_tl_clear:i { TEST_B }
% \BNVS_tl_set_eq:ii { TEST_B } { TEST_A }
% \tl_if_eq:NNF \l__bnvs_TEST_A_tl \l__bnvs_TEST_B_tl { \test_fail:n { 1 } }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_i_wrap:N \tl_set:Nn
\BNVS_new_i_wrap:N \tl_set:Nx
\BNVS_new_ii_wrap:Nt \tl_set:Nn { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_set:in{|:cv|:cx}, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_tl_set:in { TEST_A } { SUCCESS }
% \tl_if_eq:NnF \l__bnvs_TEST_A_tl { SUCCESS } { \test_fail:x { cn/\l__bnvs_TEST_A_tl } }
% \tl_clear:N \l__bnvs_TEST_B_tl
% \BNVS_tl_set:vx { TEST_B } { \l__bnvs_TEST_A_tl }
% \tl_if_eq:NnF \l__bnvs_TEST_B_tl { SUCCESS } { \test_fail:n { cx } }
% \tl_clear:N \l__bnvs_TEST_C_tl
% \BNVS_tl_set:vv { TEST_C } { TEST_A }
% \tl_if_eq:NnF \l__bnvs_TEST_C_tl { SUCCESS } { \test_fail:n { cv } }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_i_wrap:N \tl_put_right:Nn
\BNVS_new_i_wrap:N \tl_put_right:Nx
\BNVS_new_ii_wrap:Nt \tl_put_right:Nn { tl }
\BNVS_new_i_wrap:N \tl_put_left:Nn
\BNVS_new_i_wrap:N \tl_put_left:Nx
\BNVS_new_ii_wrap:Nt \tl_put_left:Nn { tl }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
%^^A:\...tl_if_...
% \begin{function}[TF]{
%   \BNVS_tl_if_empty:i,
%   \BNVS_tl_if_blank:v,
%   \BNVS_tl_if_eq:vn,
% }
% \begin{syntax}
% \cs{ BNVS_tl_if_empty:iTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{ BNVS_tl_if_blank:vTF } \marg{core} \marg{yes code} \marg{no code}
% \cs{ BNVS_tl_if_eq:vnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:iTF {l__bnvs_|\texttt{\meta{core}}|_tl}| \texttt{\marg{yes code} \marg{no code}}
% \item |\tl_if_eq:cnTF {l__bnvs_|\texttt{\meta{core}}|_tl}| \texttt{\marg{tl} \marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_i_wrap:Nn \tl_if_empty:N { p, T, F, TF }
\BNVS_new_conditional_i_wrap:Nn \tl_if_blank:N { p, T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_tl_if_empty:i, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:bpn { TEST:n } #1 {
%   \BNVS_use:b { BNVS_tl_if_empty:i#1} { TEST_A }
% }
% \BNVS_tl_if_empty:iTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use:b { BNVS_tl_if_empty:iTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 1/B } }
% \BNVS_tl_set:in { TEST_A } { SUCCESS }
% \BNVS_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 2/B } }
% \BNVS_TEST:n {  F }                          { }
% \BNVS_undefine:b { TEST:n }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_tl_if_blank:v, noigre}
% \tl_clear:N \l__bnvs_TEST_A_tl
% \BNVS_new:bpn { TEST:n } #1 {
%   \BNVS_use:b { BNVS_tl_if_blank:v#1} { TEST_A }
% }
% \BNVS_tl_if_empty:iTF { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_use:b { BNVS_tl_if_blank:vTF} { TEST_A } { } { \test_fail:n { 1/A } }
% \BNVS_TEST:n { TF } { } { \test_fail:n { 1/A } }
% \BNVS_TEST:n { T  } { }
% \BNVS_TEST:n {  F }     { \test_fail:n { 1/B } }
% \BNVS_tl_set:in { TEST_A } { SUCCESS }
% \BNVS_TEST:n { TF } { \test_fail:n { 2/A } } { }
% \BNVS_TEST:n { T  } { \test_fail:n { 2/B } }
% \BNVS_TEST:n {  F }                          { }
% \BNVS_undefine:b { TEST:n }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional_i_wrap:Nn \tl_if_eq:nn { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ii_wrap:Nnt \tl_if_eq:NN { p, T, F, TF } { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_tl_if_eq:vn{|:vv}, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \BNVS_tl_if_eq:vnTF { TEST_A } { A } { } { \test_fail:n { 1/A } }
% \BNVS_tl_if_eq:vnT  { TEST_A } { A } { } 
% \BNVS_tl_if_eq:vnF  { TEST_A } { A }     { \test_fail:n { 1/B } }
% \BNVS_tl_if_eq:vnTF { TEST_A } { B } { \test_fail:n { 2/A } } { }
% \BNVS_tl_if_eq:vnT  { TEST_A } { B } { \test_fail:n { 2/B } }
% \BNVS_tl_if_eq:vnF  { TEST_A } { B }                          { }
% \tl_set:Nn \l__bnvs_TEST_B_tl { A }
% \BNVS_tl_if_eq:vvTF { TEST_A } { TEST_B } { } { \test_fail:n { 3/A } }
% \BNVS_tl_if_eq:vvT  { TEST_A } { TEST_B } { } 
% \BNVS_tl_if_eq:vvF  { TEST_A } { TEST_B }     { \test_fail:n { 3/B } }
% \tl_set:Nn \l__bnvs_TEST_B_tl { B }
% \BNVS_tl_if_eq:vvTF { TEST_A } { TEST_B } { \test_fail:n { 4/A } } { }
% \BNVS_tl_if_eq:vvT  { TEST_A } { TEST_B } { \test_fail:n { 4/B } }
% \BNVS_tl_if_eq:vvF  { TEST_A } { TEST_B }                          { }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Strings}
%^^A:\...str_if_...
% \begin{function}[TF]{
%   \BNVS_str_if_eq:vn,
% }
% \begin{syntax}
% \cs{ BNVS_str_if_eq:vnTF } \marg{core} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\tl_if_empty:iTF {l__bnvs_|\texttt{\meta{core}}|_tl}| \texttt{\marg{yes code} \marg{no code}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_i_wrap:Nn \str_if_eq:nn { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ii_wrap:Nnt \str_if_eq:NN { T, F, TF } { str }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_str_if_eq:vn/:vv, noigre, noigre}
% \str_set:Nn \l__bnvs_TEST_A_str { SUCCESS }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_str_if_eq:vn#1 } { TEST_A }
% }
% \BNVS_Test:n { TF } { SUCCESS } { } { \test_fail:n { 1/A } }
% \BNVS_Test:n { T  } { SUCCESS } { } 
% \BNVS_Test:n {  F } { SUCCESS }     { \test_fail:n { 1/B } }
% \BNVS_Test:n { TF } { FAILURE } { \test_fail:n { 2/A } } { }
% \BNVS_Test:n { T  } { FAILURE } { \test_fail:n { 2/B } }
% \BNVS_Test:n {  F } { FAILURE }                          { }
% \cs_set:Npn \BNVS_Test:n #1 { \BNVS_use:b { BNVS_str_if_eq:vv#1 } { TEST_A } }
% \str_set:Nn \l__bnvs_TEST_B_str { SUCCESS }
% \BNVS_Test:n { TF } { TEST_B } { } { \test_fail:n { 3/A } }
% \BNVS_Test:n {  T } { TEST_B } { }
% \BNVS_Test:n { F  } { TEST_B }     { \test_fail:n { 3/B } }
% \str_set:Nn \l__bnvs_TEST_B_str { FAILURE }
% \BNVS_Test:n { TF } { TEST_B } { \test_fail:n { 4/A } } { }
% \BNVS_Test:n { T  } { TEST_B } { \test_fail:n { 4/B } }
% \BNVS_Test:n {  F } { TEST_B }                          { }
% \cs_undefine:c { Test:n }
% \end{bnvs.test}
%    \begin{macrocode}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Sequences}
%^^A:\...seq_...
% \begin{function}{
%   \BNVS_seq_count:v,
%   \BNVS_seq_clear:i,
%   \BNVS_seq_set_eq:vv,
%   \BNVS_seq_use:in,
%   \BNVS_seq_item:vn,
%   \BNVS_seq_remove_all:vn,
%   \BNVS_seq_put_left:vv,
%   \BNVS_seq_put_right:vn,
%   \BNVS_seq_put_right:ii,
%   \BNVS_seq_set_split:inn,
%   \BNVS_seq_set_split:inv,
%   \BNVS_seq_pop_left:ii,
% }
% \begin{syntax}
% \cs{ BNVS_seq_new:c } \marg{core}
% \cs{ BNVS_seq_count:v } \marg{core}
% \cs{ BNVS_seq_clear:i } \marg{core}
% \cs{ BNVS_seq_set_eq:vv } \marg{core_1} \marg{core_2}
% \cs{ BNVS_seq_use:in } \marg{core} \marg{separator}
% \cs{ BNVS_seq_item:vn } \marg{core} \marg{integer expression}
% \cs{ BNVS_seq_remove_all:vn } \marg{core} \marg{tl}
% \cs{ BNVS_seq_put_right:vn } \marg{seq core} \marg{tl}
% \cs{ BNVS_seq_put_right:ii } \marg{seq core} \marg{tl core}
% \cs{ BNVS_seq_set_split:inn } \marg{seq core} \marg{tl} \marg{separator}
% \cs{ BNVS_seq_pop_left:ii } \marg{core_1} \marg{core_2}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\seq_set_eq:vv {l__bnvs_|\texttt{\meta{core_1}}|_seq} {l__bnvs_|\texttt{\meta{core_2}}|_seq}|
% \item |\seq_count:c {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_use:cn {l__bnvs_|\texttt{\meta{core}}|_seq}| \texttt{\marg{separator}}
% \item |\seq_item:vn {l__bnvs_|\texttt{\meta{core}}|_seq}| \texttt{\marg{integer expression}}
% \item |\seq_remove_all:vn {l__bnvs_|\texttt{\meta{core}}|_seq}| \texttt{\marg{tl}}
% \item |\BNVS_seq_clear:i {l__bnvs_|\texttt{\meta{core}}|_seq}|
% \item |\seq_put_right:cv {l__bnvs_|\texttt{\meta{seq core}}|_seq} {l__bnvs_|\texttt{\meta{tl core}}|_tl}|
% \item |\seq_set_split:vnn{l__bnvs_|\texttt{\meta{seq core}}|_seq} {l__bnvs_|\texttt{\meta{tl core}}|_tl} {|\texttt{\meta{tl}}|}|
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_i_wrap:N \seq_count:N
\BNVS_new_i_wrap:N \seq_clear:N
\BNVS_new_i_wrap:N \seq_use:Nn
% \BNVS_new_i_wrap:N \seq_item:Nn
\BNVS_new_i_wrap:N \seq_remove_all:Nn
\BNVS_new_i_wrap:N \seq_map_inline:Nn
\BNVS_new_ii_wrap:Nt \seq_set_eq:NN    { seq }
\BNVS_new_ii_wrap:Nt \seq_put_left:Nn  { tl }
\BNVS_new_ii_wrap:Nt \seq_put_right:Nn { tl }
\BNVS_new_ii_wrap:Nt \seq_pop_left:NN  { tl }
\BNVS_new_ii_wrap:Nt \seq_pop_right:NN { tl }

\BNVS_new_i_wrap:N \seq_set_split:Nnn

\BNVS_new_i_wrap:N \seq_set_split:Nnv
\BNVS_new_i_wrap:N \seq_set_split:Nnx
\BNVS_log:n { ********** }
%    \end{macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_seq{...}, noigre}
% \BNVS_seq_new:c { A_TEST }
% \BNVS_seq_new:c { B_TEST }
% \BNVS_seq_clear:i { A_TEST }
% \tl_set:Nn \l__bnvs_TEST_A_tl { SUCCESS }
% \tl_set:Nn \l__bnvs_TEST_B_tl { FAILURE }
% \assert_size_not_equal:nnn { \l__bnvs_TEST_A_tl } { \l__bnvs_TEST_B_tl } { 0 }
% \BNVS_seq_put_right:ii { A_TEST } { TEST_B }
% \int_compare:nNnF { \BNVS_seq_count:v { A_TEST } } = { 1 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \BNVS_seq_use:in { A_TEST } { , } } { FAILURE } { 1 }
% \BNVS_seq_put_left:vv { A_TEST } { TEST_A }
% \int_compare:nNnF { \BNVS_seq_count:v { A_TEST } } = { 2 } {
%   \test_fail:n { count/0 }
% }
% \assert_size_equal:nnn { \seq_use:Nn \l__bnvs_A_TEST_seq { , } } { SUCCESS , FAILURE } { 5 }
% \assert_size_equal:nnn { \BNVS_seq_use:in { A_TEST } { , } } { SUCCESS , FAILURE } { 6 }
% \BNVS_seq_set_eq:vv { B_TEST } { A_TEST }
% \assert_size_equal:nnn { \BNVS_seq_use:in { B_TEST } { , } } { SUCCESS , FAILURE } { 7 }
% \BNVS_seq_undefine:c { A_TEST }
% \BNVS_seq_undefine:c { B_TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_seq_split:cnn/pop_right:cc, noigre}
% \BNVS_seq_clear:i { TEST }
% \BNVS_seq_set_split:inn { TEST } { , } { A, B }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 1 } } { A } { 1 }
% \assert_equal:xnn { \seq_item:Nn \l__bnvs_TEST_seq { 2 } } { B } { 2 }
% \BNVS_tl_clear:i { TEST }
% \BNVS_seq_pop_right:cc { TEST } { TEST }
% \BNVS_tl_if_eq:vnF { TEST } { B } { \test_fail:n { 3 } }
% \BNVS_seq_pop_right:cc { TEST } { TEST }
% \BNVS_tl_if_eq:vnF { TEST } { A } { \test_fail:n { 4 } }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
%^^A::\...seq_if_...
% \begin{function}[TF]{
%   \BNVS_seq_if_empty:i,
%   \BNVS_seq_get_right:cc,
%   \BNVS_seq_pop_left:ii,
%   \BNVS_seq_pop_right:cc,
% }
% \begin{syntax}
% \cs{ BNVS_seq_if_empty:iTF } \marg{seq core name} \marg{yes code} \marg{no code}
% \cs{ BNVS_seq_get_right:ccTF } \marg{seq core name} \marg{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_i_wrap:Nn \seq_if_empty:N { T, F, TF }
\BNVS_new_conditional_ii_wrap:Nnt \seq_get_right:NN { T, F, TF } { tl }
\BNVS_new_conditional_ii_wrap:Nnt \seq_pop_left:NN { T, F, TF } { tl }
\BNVS_new_conditional_ii_wrap:Nnt \seq_pop_right:NN { T, F, TF } { tl }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_seq_if_empty:iTF, noigre}
% \BNVS_seq_clear:i { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { seq_if_empty:c#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \seq_put_right:Nn \l__bnvs_TEST_seq { SUCCESS }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_seq_get_right:ccTF, noigre}
% \BNVS_seq_clear:i { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { seq_get_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \BNVS_seq_set_split:inn { TEST } { , } { A, B }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_tl_if_eq:vnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { B } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_seq_pop_left:iiTF, noigre}
% \BNVS_seq_clear:i { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_seq_pop_left:ii#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \BNVS_seq_set_split:inn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_tl_if_eq:vnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { A } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_seq_pop_right:ccTF, noigre}
% \BNVS_seq_clear:i { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_seq_pop_right:cc#1 } { TEST } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { 1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 2 } }
% \BNVS_Test:n {  F }                        { }
% \BNVS_seq_set_split:inn { TEST } { , } { A, B, C }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_tl_if_eq:vnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:n { TF } { \BNVS_Test:nn { C } { 3/A } } { \test_fail:n { 3/B } }
% \BNVS_Test:n { T  } { \BNVS_Test:nn { B } { 4/A } }
% \BNVS_Test:n {  F }                            { \test_fail:n { 5/B } }
% \cs_undefine:N \BNVS_Test:n
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_seq_if_empty:iTF, noigre}
% \BNVS_seq_clear:i { TEST }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_seq_if_empty:i#1 } { TEST }
% }
% \BNVS_Test:n { TF } { } { \test_fail:n { 1 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { 2 } }
% \BNVS_seq_set_split:inn { TEST } { , } { A, B }
% \BNVS_Test:n { TF } { \test_fail:n { 3 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { 4 } }
% \BNVS_Test:n {  F }                        { }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Integers}
%^^A:::\...int_...
% \begin{function}{
%   \BNVS_int_new:c,
%   \BNVS_int_use:c,
%   \BNVS_int_inc:c,
%   \BNVS_int_decr:c,
%   \BNVS_int_set:cn,
%   \BNVS_int_set:cv
% }
% \begin{syntax}
% \cs{ BNVS_int_new:c  } \marg{core}
% \cs{ BNVS_int_use:c  } \marg{core}
% \cs{ BNVS_int_incr:c } \marg{core}
% \cs{ BNVS_int_decr:c } \marg{core}
% \cs{ BNVS_int_set:cn } \marg{core} \marg{value}
% \end{syntax}
% These are shortcuts to
% \begin{itemize}
% \item |\int_new:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_use:c   {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_incr:c  {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_idecr:c {l__bnvs_|\texttt{\meta{core}}|_int}|
% \item |\int_set:cn  {l__bnvs_|\texttt{\meta{core}}|_int}| \texttt{\marg{value}}
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
% \BNVS_new_i_wrap:N \int_new:N
% \BNVS_new_i_wrap:N \int_use:N
\BNVS_new_i_wrap:N \int_zero:N
\BNVS_new_i_wrap:N \int_incr:N
\BNVS_new_i_wrap:N \int_decr:N
\BNVS_new_i_wrap:N \int_set:Nn
\BNVS_new_ii_wrap:Nt \int_set:NN { int }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_int_new:c/use:c/set:cn, noigre}
% \BNVS_int_new:c  { A_TEST }
% \BNVS_int_set:cn { A_TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \BNVS_int_use:c { A_TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \BNVS_int_set:cn { A_TEST } { 2 }
% \BNVS_Test:nn { 2 } { 2 }
% \cs_undefine:N \BNVS_Test:nn
% \BNVS_int_undefine:c { A_TEST }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_int_incr:c/decr:c, noigre}
% \BNVS_int_set:cn { TEST } { 1 }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \BNVS_int_use:c { TEST } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 1 } { 1 }
% \BNVS_int_incr:c { TEST }
% \BNVS_Test:nn { 2 } { 2 }
% \BNVS_int_decr:c { TEST }
% \BNVS_Test:nn { 1 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_int_set:cv, noigre}
% \BNVS_int_set:cn { TEST_A } { 421 }
% \BNVS_int_set:cv { TEST_B } { TEST_A }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \int_compare:nNnF { \BNVS_int_use:c { TEST_B } } = { #1 } {
%     \test_fail:n { #2 }
%   }
% }
% \BNVS_Test:nn { 421 } { 1 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsubsection{Prop}
%^^A:\...prop_get:Nni
% \begin{function}[TF]{
%   \BNVS_prop_get:Nni,
% }
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { prop_get:Nni } #1 #2 #3 { T, F, TF } {
  \BNVS_use_N:nti {
    \prop_get:NnNTF #1 { #2 }
  } { tl } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_prop_get:NniTF, noigre}
% \prop_clear:N \l__bnvs_TEST_prop
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_use:b { BNVS_prop_get:Nni#1 }
%     \l__bnvs_TEST_prop { #2 } { TEST }
% }
% \BNVS_Test:nn { TF } { key } { \test_fail:n { A/1 } } { }
% \BNVS_Test:nn { T  } { key } { \test_fail:n { A/2 } }
% \BNVS_Test:nn {  F } { key }                        { }
% \prop_put:Nnn \l__bnvs_TEST_prop { key } { value }
% \cs_set:Npn \Test_a:nn #1 #2 {
%   \BNVS_tl_if_eq:vnF { TEST } { #1 } { \test_fail:n { #2 } }
% }
% \BNVS_Test:nn { TF } { key } { \Test_a:nn { value } { A/3 } } { \test_fail:n { B/3 } }
% \BNVS_Test:nn { T  } { key } { \Test_a:nn { value } { A/3 } }
% \BNVS_Test:nn {  F } { key }     { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \Test_a:nn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \subsection{Debug facilities}
% Typesetting file |beanoves.dtx| creates both \pkg{beanoves}
% and \pkg{beanoves-debug} style files. The former is intended for everyday
% use whereas the latter contains supplemental debugging and testing
% facilities which are intentionally left undocumented.
% In particular, we have aliases for |\group_begin:| and |\group_end:|
% to allow the display of supplemental informations while debugging.
%
% \subsection{Debug messages}
% \begin{bnvs.gobble}
%<*!debug>
\cs_new:Npn \BeanovesDebugOn {
  \BNVS_warning:x { Debugging~mode~requires~\jobname-debug.sty,~typeset~\jobname.dtx}
}
\cs_new:Npn \BeanovesDebugOff { \BeanovesDebugOn }
%</!debug>
%<*!final>
\cs_set_eq:NN \BeanovesDebugOn \BNVS_DEBUG_on:
\cs_set_eq:NN \BeanovesDebugOff \BNVS_DEBUG_off:
\cs_generate_variant:Nn \BNVS_log:n { x, V }
\cs_new:Npn \BNVS_DEBUG_b:nn #1 #2 {
  \BNVS_log:x { #1~#2 }
}
%</!final>
% \end{bnvs.gobble}
%
% \subsection{Variable facilities}
%
%
% \subsection{Testing facilities}
% \begin{bnvs.gobble}
%<*!final>
\cs_set:Npn \BNVS_begin: {
  \group_begin:
  \int_incr:N \l__bnvs_group_int
}
\cs_set_eq:NN \BNVS_end: \group_end:
\bool_new:N \l__bnvs_TEST_ignore_bool
\bool_set_false:N \l__bnvs_TEST_ignore_bool
\cs_new:Npn \BNVS_log:nn #1 {
  \exp_args:Nx
  \BNVS_DEBUG_b:nn
  { ▄▄ \prg_replicate:nn {\l__bnvs_group_int + 1} {#1} }
}
\cs_generate_variant:Nn \BNVS_log:nn { nx, nV }
\ProvideDocumentEnvironment {beanoves.failure} {} {} {}
\bool_new:N \l__bnvs_TEST_bool
\tl_new:N \g__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_banner_tl
\tl_new:N \l__bnvs_TEST_done_tl
\tl_clear:N \l__bnvs_TEST_done_tl
\tl_new:N \l__bnvs_TEST_tl
\tl_new:N \l__bnvs_TEST_A_tl
\tl_new:N \l__bnvs_TEST_B_tl
\tl_new:N \l__bnvs_TEST_C_tl
\str_new:N \l__bnvs_TEST_str
\str_new:N \l__bnvs_TEST_A_str
\str_new:N \l__bnvs_TEST_B_str
\seq_new:N \l__bnvs_TEST_seq
\seq_new:N \l__bnvs_TEST_A_seq
\seq_new:N \l__bnvs_TEST_B_seq
\int_new:N \l__bnvs_TEST_int
\int_new:N \l__bnvs_TEST_group_int
\prop_new:N \l__bnvs_TEST_prop
\prop_new:N \g__bnvs_TEST_prop
\regex_const:Nn \c__bnvs_TEST_comma_regex { , }
\NewDocumentEnvironment{bnvs.test} {} {
  \color{red}\bfseries\ExplSyntaxOn
  \debug_on:n { check-declarations }
  \BNVS_gclear_all:
  \int_gset:Nn \g__bnvs_call_int { 128 }
  \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
  \BNVS_provide_off:
  \BNVS_DEBUG_log_set:bnin { query_eval:inTF } { QUERY } { ans } { ? }
  \BNVS_TEST_BEGIN:n
} {
  \assert_equal:xxn {
    \int_use:N \l__bnvs_group_int
  } {
    \int_use:N \l__bnvs_TEST_group_int
  } { Bad~group~nesting }
  \tl_use:N \l__bnvs_TEST_done_tl
  \BNVS_gclear:
  \ExplSyntaxOff\ignorespacesafterend
}
\keys_define:nn { bnvs.test } {
  banner  .code:n = \tl_set:Nn \l__bnvs_TEST_banner_tl { #1 },
  :N      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:N #1
  },
  :Nn     .code:n = \exp_args:NNo \tl_set:No \l__bnvs_TEST_banner_tl { 
    \exp_last_unbraced:No \token_to_str:N { \use_i:nn #1 }
    \use_ii:nn #1
  },
  :c      .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { #1 }
  },
  :cn     .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \use_i:nn #1 } \use_ii:nn #1
  },
  bnvs:c  .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS_c:b { #1 } }
  },
  bnvs:cn .code:n = \tl_set:No \l__bnvs_TEST_banner_tl {
    \token_to_str:c { \BNVS_c:b { \use_i:nn #1 } } \use_ii:nn #1
  },
  debug  .code:n = \BNVS_DEBUG_on:,
  reset  .code:n = \reset:n { #1 },
  ignore .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { \BNVS_use:b { c_#1_bool } },
  ignore .default:n = true,
%  ignore .code:n = {}, % comment this line to ignore tests
  noigre .code:n = \bool_set:Nn \l__bnvs_TEST_ignore_bool { !(\BNVS_use:b { c_#1_bool }) },
  noigre .default:n = false,
  % noigre .code:n = {}, % comment this line to ignore no tests
}
\int_new:N \l__bnvs_TEST_A_int
\int_new:N \l__bnvs_TEST_B_int
\cs_new:Npn \BNVS_TEST_BEGIN:n #1 {
  \cs_set:Npn \reset:n ##1 {
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \tl_if_empty:nF { ##1 } {
      \BNVS_gclear:
      \BNVS_n_gclear:
      \BNVS_v_gclear:
      \BNVS_cache_gclear:
      \BNVS_kip_gclear:
    }
    \Beanoves { FIRST = 220+2, LENGTH = 440+5, LAST = 660+6 }
    \BNVS_end:
    \BNVS_provide_off:
  }
  \cs_set:Npn \reset_X: {
    \reset:n { YES }
    \BNVS_begin:
    \BNVS_DEBUG_off:
    \Beanoves {
      X1  = FIRST,
      X2  = LAST-LENGTH+1,
      A1  = FIRST:,
      A2  = LAST-LENGTH+1:,
      AA1 = FIRST::,
      AA2 = LAST-LENGTH+1::,
      Z1  = :LAST,
      Z2  = :FIRST+LENGTH-1,
      AL11 = FIRST::LENGTH,
      AL12 = FIRST::LAST-FIRST+1,
      AL21 = LAST-LENGTH+1::LENGTH,
      AL22 = LAST-LENGTH+1::LAST-FIRST+1,
      AZ11 = FIRST:LAST,
      AZ12 = FIRST:FIRST+LENGTH-1,
      AZ21 = LAST-LENGTH+1:LAST,
      AZ22 = LAST-LENGTH+1:FIRST+LENGTH-1,
      LZ11 = ::LENGTH:LAST,
      LZ12 = ::LENGTH:FIRST+LENGTH-1,
      LZ21 = ::LAST-FIRST+1:LAST,
      LZ22 = ::LAST-FIRST+1:FIRST+LENGTH-1,
      ZL11 = :LAST::LENGTH,
      ZL12 = :LAST::LAST-FIRST+1,
      ZL21 = :FIRST+LENGTH-1::LENGTH,
      ZL22 = :FIRST+LENGTH-1::LAST-FIRST+1,
    }
    \BNVS_end:
  }
  \tl_if_empty:nF { #1 } { \keys_set_known:nn {bnvs.test} {#1} }
  \bool_if:NTF \l__bnvs_TEST_ignore_bool {
    \tl_clear:N \l__bnvs_TEST_done_tl
    \RenewDocumentEnvironment{bnvs.test}{+b}{
      \BNVS_set:bpn { end_test: } {
        \BNVS_set:bpn { end_test: } { }
        \end{bnvs.test}
      }
    } {
      \BNVS_end_test:
    }
    \begin{bnvs.test}
  } {
    \cs_set:Npn \banner:n ##1 {
      \BNVS_call_greset:
      \BNVS_log_a:xn { ▶︎▶︎▶︎▶︎▶︎~TEST~##1~/~line:~\the\inputlineno} {}
    }
    \RenewDocumentEnvironment{beanoves.failure}{}
      {\begin{list}{\llap{\emoji{no-entry}\hspace{1em}}}{%
         \setlength{\itemindent}{0pt}%
         \setlength{\leftmargin}{0pt}%
         \setlength{\labelwidth}{0pt}%
         \addtolength{\topsep}{-0.5\parskip}%
         \listparindent \parindent
         \setlength{\parsep}{\parskip}}}
      {\end{list}}  
% Utilities
    \cs_set_eq:NN \test_extract:nnnn \BNVS_TEST_extract:nnnn
    \cs_set_eq:NN \test_extract:Nnnn \BNVS_TEST_extract:Nnnn
    \cs_set_eq:NN \test_split:Nnnn \BNVS_TEST_split:Nnnn
     \cs_set_eq:NN \assert_equal:nnn \BNVS_ASSERT_equal:nnn
    \cs_set_eq:NN \assert_equal:xnn \BNVS_ASSERT_equal:xnn
    \cs_set_eq:NN \assert_equal:xxn \BNVS_ASSERT_equal:xxn
     \cs_set_eq:NN \assert_size_equal:nnn \BNVS_ASSERT_size_equal:nnn
     \cs_set_eq:NN \assert_size_not_equal:nnn \BNVS_ASSERT_size_not_equal:nnn
    \cs_set_eq:NN \assert_equal_tl:vnn \BNVS_ASSERT_equal_tl:vnn
    \cs_set_eq:NN \test_fail:n \BNVS_TEST_fail:n
    \cs_set_eq:NN \test_fail:x \BNVS_TEST_fail:x
    \cs_set:Npn \assert_equal_ans:nn {
      \assert_equal_tl:vnn { ans }
    }
    \cs_set:Npn \preflight:n ##1 {
      \banner:n { ##1 }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \BNVS_tl_clear:i { ans }
    }
    \cs_set:Npn \preflight:nn ##1 ##2 {
      \banner:n { ##2~/~##1 }
      \tl_if_empty:nF { ##1 } {
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \BNVS_tl_clear:i { ans }
    }
    \cs_set:Npn \preflight:nnn ##1 ##2 ##3 {
      \tl_if_empty:nTF { ##1 } {
        \banner:n { ##2~/~##3~/ }
      } {
        \banner:n { ##2~/~X=##1->##2~/ }
        \group_begin:
        \BNVS_DEBUG_off:
        \regex_match:nnTF { ^X } { ##1 } {
          \Beanoves { ##1 }
        } {
          \Beanoves { X = ##1 }
        }
        \group_end:
        \BNVS_DEBUG_log_gprop:n {}
      }
      \BNVS_begin:
      \int_set_eq:NN \l__bnvs_TEST_group_int \l__bnvs_group_int
      \BNVS_tl_clear:i { ans }
    }
    \cs_set:Npn \postflight: {
      \assert_equal:xxn {
        \int_use:N \l__bnvs_group_int
      } {
        \int_use:N \l__bnvs_TEST_group_int
      } { Bad~group~nesting }
      \BNVS_end:
    }
    \cs_set:Npn \flight:nT ##1 ##2 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:n { ##1 }
        ##2
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnT ##1 ##2 ##3 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nn { ##1 } { ##2 }
        ##3
        \postflight:
      }
    }
    \cs_set:Npn \flight:nnnT ##1 ##2 ##3 ##4 {
      \bool_if:NF \l__bnvs_TEST_ignore_bool {
        \preflight:nnn { ##1 } { ##2 } { ##3 }
        ##4
        \postflight:
      }
    }
    \cs_set:Npn \Test_x_path_resolve:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \BNVS_kip_x_path_resolve:TF {
          \BNVS_ASSERT_equal_tl:vnn {id } { ?! } { ##6-id }
          \BNVS_ASSERT_equal_tl:vnn { id } { ?! } { ##6-id }
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \BNVS_seq_use:in { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
        \BNVS_gclear:
      }
    }
    \cs_set:Npn \Test_kip_n_path_resolve:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \BNVS_gclear_all:
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nx \l__bnvs_id_tl { ?! }
        \tl_set:Nx \l__bnvs_key_tl { \l__bnvs_id_tl ##2 }
        \seq_set_split:Nnn \l__bnvs_path_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_path_seq { }
        \BNVS_kip_n_path_resolve:TF {
          \assert_equal_tl:vnn { id } { ?! } { ##6-id }
          \exp_args:NNV
          \regex_match:NnTF \c__bnvs_A_key_Z_regex \l__bnvs_key_tl {
            \tl_if_in:VnTF \l__bnvs_key_tl { ! } {
              \assert_equal_tl:vnn { key } { ?!##4 } { ##6-?!name }
            } {
              \assert_equal_tl:vnn { key } {   ##4 } { ##6-name }
            }
          } {
            \assert_equal_tl:vnn { key } { ##4 } { ##6-target }
          }
          \assert_equal:xnn { \BNVS_seq_use:in { path } . } { ##5 } { ##6-path }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
% ##2: bare key, ##3: path, ##4: expected key, ##5: expected path
    \cs_set:Npn \Test_if_kip_resolve:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \BNVS_gclear_all:
      \flight:nnT { ##1 } { ##6 } {
        \tl_set:Nn \l__bnvs_key_tl { ##2 }
        \seq_set_split:Nnn \l__bnvs_a_seq {.} { ##3 }
        \seq_remove_all:Nn \l__bnvs_a_seq { }
        \BNVS_DEBUG_log_set:bn { kip_if_resolve:nTF } {
          \BNVS_DEBUG_log_arg:nn { KEY } { ##2|?!|##3 }
        }
        \BNVS_kip_if_resolve:TF {
          \assert_equal_tl:vnn { key } { ##4 } { ##6-key }
          \assert_equal:xnn { \BNVS_seq_use:in { a } . } { ##5 } { ##6-a }
        } {
          \test_fail:n { ##6-CALL }
        }
      }
    }
% Utilities
    \cs_set:Npn \Test_generic_ncTF:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        \BNVS_int_set:cv { TEST_A } { group }
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-TRUE }
        } {
          \test_fail:x { ##5-FALSE(\token_to_str:N ##1)}
        }
        \int_compare:nNnF { \l__bnvs_TEST_A_int } = { \l__bnvs_group_int } {
          \test_fail:n { ##5~group:~\token_to_str:N~##1 }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_ncTF:Nnnnn { c }
    \cs_set:Npn \Test_what_action_ncTF:ccnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_ncTF:cnnnn { BNVS_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\BNVS_##1_##2:ncTF }
      }
    }
%   Usage \Test_generic_X_ncTF:Nnnn \BNVS_previous_append:ncTF {X=123} {122} {label}
    \cs_set:Npn \Test_generic_X_ncTF:Nnnn ##1 ##2 {
      \Test_generic_ncTF:Nnnnn ##1 { ##2 } {}
    }
    \cs_generate_variant:Nn \Test_generic_X_ncTF:Nnnn { c }
    \cs_set:Npn \Test_what_action_X_ncTF:ccnnn ##1 ##2 ##3 ##4 ##5 {
      \cs_if_exist:cTF { BNVS_##1_##2:ncTF } {
        \BNVS_use:Nc
        \Test_generic_X_ncTF:Nnnn { ##1_##2:ncTF } { ##3 } { ##4 } { ##5 }
      } {
        \test_fail:x { ##5-NO~\token_to_str:N\BNVS_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnT { ##2 } { ##6 } {
        \exp_args:Nx
        ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
          \assert_equal_ans:nn { ##5 } { ##6-TRUE }
        } {
          \test_fail:n { ##6-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_nncTF:ccnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_nncTF:cnnnnn { BNVS_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\BNVS_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_generic_X_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnT { ##2 } { ##5 } {
        ##1 { ?!X } { ##3 } { ans } {
          \assert_equal_ans:nn { ##4 } { ##5-X-TRUE }
        } {
          \test_fail:n { ##5-X-FALSE(\token_to_str:N ##1) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_X_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_X_nncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF { BNVS_##1_##2:nnNTF } {
        \Test_generic_X_nncTF:cnnnnn { BNVS_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\BNVS_##1_##2:nnNTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_X:Nnnnn ##1 ##2 ##3 ##4 ##5 {
      \flight:nnnT { ##2 } { ##5 } { ##2~/~##3 } {
        \group_begin:
        \BNVS_V_resolve:inTF { ?!X } { a } {
          \group_end:
          ##1 { ?!X } { ##3 } { ans } {
            \assert_equal_ans:nn { ##4 } { ##5-b }
          } {
            \test_fail:x { ##5-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##5-d(V_resolve:inTF) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_X:Nnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_X_ncTF:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \cs_if_exist:cTF {__bnvs_##1_##2:ncTF} {
        \Test_generic_check_value_X:cnnnn { BNVS_##1_##2:ncTF } { ##3 } { ##4 } { ##5 } { ##6 }
      } {
        \test_fail:x { ##6-NO~\token_to_str:N\BNVS_##1_##2:ncTF }
      }
    }
    \cs_set:Npn \Test_generic_check_value_nncTF:Nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \flight:nnnT { ##2 } { ##6 } { ##2~/~##4 } {
        \group_begin:
        \exp_args:Nx
        \BNVS_V_resolve:inTF { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { a } {
          \group_end:
          \exp_args:Nx
          ##1 { \tl_if_empty:nTF { ##3 } { ?!X } { ##3 } } { ##4 } { ans } {
            \assert_equal_ans:nn { ##5 } { ##6-b }
          } {
            \test_fail:n { ##6-c^^JUnexpected~F~in~\token_to_str:N ##1 }
          }
        } {
          \group_end:
          \test_fail:n { ##6-d(V_resolve:inTF-2) }
        }
      }
    }
    \cs_generate_variant:Nn \Test_generic_check_value_nncTF:Nnnnnn { c }
    \cs_set:Npn \Test_what_action_check_value_nncTF:ccnnnnn ##1 ##2 ##3 ##4 ##5 ##6 ##7 {
      \cs_if_exist:cTF {__bnvs_##1_##2:nncTF} {
        \Test_generic_check_value_nncTF:cnnnnn { BNVS_##1_##2:nncTF } { ##3 } { ##4 } { ##5 } { ##6 } { ##7 }
      } {
        \test_fail:x { ##7-NO~\token_to_str:N\BNVS_##1_##2:nncTF }
      }
    }
    \cs_set:Npn \Test_what_resolve_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:ccnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_X_ncTF:nnnn ##1 {
      \Test_what_action_X_ncTF:ccnnn { ##1 } { append }
    }
    \cs_set:Npn \Test_what_resolve_ncTF:nnnnn ##1 {
      \Test_what_action_ncTF:ccnnnn { ##1 } { resolve }
    }
    \cs_set:Npn \Test_what_append_inTF:nnnnn ##1 {
      \Test_what_action_ncTF:ccnnnn { ##1 } { append }
    }
% General
    \cs_set:Npn \Test_index_resolve_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append_X:nnnn {
      \Test_what_action_X_nncTF:nnnnnn { index } { append }
    }
    \cs_set:Npn \Test_index_resolve:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { index } { resolve }
    }
    \cs_set:Npn \Test_index_append:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { index } { append }
    }
    \cs_set:Npn \Test_range_resolve:nnn {
      \Test_what_action_X_ncTF:ccnnn { range } { resolve }
    }
    \cs_set:Npn \Test_range_append:nnn {
      \Test_what_action_X_ncTF:ccnnn { range } { append }
    }
% n index
    \cs_set:Npn \Test_n_get:nnnn {
      \Test_generic_ncTF:Nnnnn \BNVS_n_get:niTF
    }
    \cs_set:Npn \Test_n_get_X:nnn {
      \Test_generic_X_ncTF:Nnnn \BNVS_n_get:niTF
    }
    \cs_set:Npn \Test_n_resolve:nnnn {
      \Test_what_action_ncTF:ccnnnn { n } { resolve }
    }
    \cs_set:Npn \Test_n_append:nnnn {
      \Test_what_action_ncTF:ccnnnn { n } { append }
    }
    \cs_set:Npn \Test_n_resolve_X:nnn {
      \Test_what_action_X_ncTF:ccnnn { n } { resolve }
    }
    \cs_set:Npn \Test_n_append_X:nnn {
      \Test_what_action_X_ncTF:ccnnn { n } { append }
    }
    \cs_set:Npn \Test_n_index_resolve_X:nnn {
      \Test_what_action_X_ncTF:ccnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_n_index_append_X:nnn {
      \Test_what_action_X_ncTF:ccnnn { n_index } { append }
    }
    \cs_set:Npn \Test_n_index_resolve:nnnn {
      \Test_what_action_ncTF:ccnnnn { n_index } { resolve }
    }
    \cs_set:Npn \Test_n_index_append:nnnn {
      \Test_what_action_ncTF:ccnnnn { n_index } { append }
    }
    \cs_set:Npn \Test_n_incr_resolve:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { n_incr } { resolve }
    }
    \cs_set:Npn \Test_n_incr_append:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { n_incr } { append }
    }
    \cs_set:Npn \Test_n_post_resolve:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { n_post } { resolve }
    }
    \cs_set:Npn \Test_n_post_append:nnnnn {
      \Test_what_action_nncTF:ccnnnnn { n_post } { append }
    }
% v
    \cs_set:Npn \Test_v_incr_resolve:nnnnn {
      \Test_what_action_check_value_nncTF:ccnnnnn { v_incr } { resolve }
    }
    \cs_set:Npn \Test_v_incr_append:nnnnn {
      \Test_what_action_check_value_nncTF:ccnnnnn { v_incr } { append }
    }
    \cs_set:Npn \Test_v_post_resolve:nnnnn {
      \Test_what_action_check_value_nncTF:ccnnnnn { v_post } { resolve }
    }
    \cs_set:Npn \Test_v_post_append:nnnnn {
      \Test_what_action_check_value_nncTF:ccnnnnn { v_post } { append }
    }
% query
    \cs_set:Npn \Test_if_append:nnnn {
      \Test_what_action_ncTF:ccnnnn { if } { append }
    }
    \cs_set:Npn \Test_if_resolve:nnnn {
      \Test_what_action_ncTF:ccnnnn { if } { resolve }
    }
    \cs_set:Npn \Test_regex:cnnn ##1 {
      \bool_if:NTF \l__bnvs_TEST_ignore_bool {
        \use_none:nnn
      } {
        \tl_if_exist:cTF { c__bnvs_##1_regex } {
          \BNVS_TEST_extract:cnnn { c__bnvs_##1_regex }
        } {
          \test_fail:n { Bad~name:~##1}
          \use_none:nnn
        }
      }
    }
    \cs_set:Npn \Test_query:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnnT { ##1 } { ##4 } { ##2==##3 } {
        \BNVS_tl_clear:i { TEST_A }
        \BNVS_query_eval:inTF { TEST_A } { ##2 } {
          \assert_equal_tl:vnn { TEST_A } { ##3 } {
            Test~\cs{BNVS_query_eval:in}:~##4-a
          }
        } {
          \test_fail:n { ##4-CALL }
        }
      }
    }
    \cs_set:Npn \Test_eval:nnnn ##1 ##2 ##3 ##4 {
      \flight:nnT { ##1 } { ##4 } {
        \BeanovesEval[in=\l__bnvs_ans_tl]{ ##2 }
        \assert_equal_ans:nn { ##3 } { ##4 }
      }
    }
    \BNVS_log_a:nn {▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎▶︎} {}
    \BNVS_log_a:xn {TEST~\l__bnvs_TEST_banner_tl\space file:~\BeanovesCurrentTestFile, line:~\the\inputlineno} {}
    \tl_set:Nn \l__bnvs_TEST_done_tl {
      \BNVS_log_a:xn { TEST~\l__bnvs_TEST_banner_tl...~DONE} {}
      \BNVS_log_a:nn {◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀︎◀} {}
    }
  }
}
\cs_new:Npn \BeanovesCurrentTestFile {
  \tl_if_empty:VF \CurrentFilePath { \CurrentFilePath / }
  \CurrentFile
}
\cs_set:Npn \BNVS_TEST_extract:nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \tl_if_empty:nT { #3 } {
    \BNVS_extract_once:nnT { #1 } { #2 } {
      \test_fail:n { #4-a }
    }
  } {
    \BNVS_extract_once:nnTF { #1 } { #2 } {
      \tl_set:Nx \l__bnvs_a_tl { \BNVS_seq_use:in { match } , }
      \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
      \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
        \BNVS_tl_if_empty:iTF { b } {
          \seq_put_left:Nn \l__bnvs_match_seq { #2 }
        } {
          \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
        }
      }
      \tl_set:Nx \l__bnvs_b_tl { \BNVS_seq_use:in { split } , }
      \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
    } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_set:Npn \BNVS_TEST_extract:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_extract_once:NnNTF #1 { #2 } \l__bnvs_match_seq {
    \tl_set:Nx \l__bnvs_a_tl { \BNVS_seq_use:in { match } , }
    \seq_set_from_clist:Nn \l__bnvs_match_seq { #3 }
    \seq_pop_left:NNT \l__bnvs_match_seq \l__bnvs_b_tl {
      \BNVS_tl_if_empty:iTF { b } {
        \seq_put_left:Nn \l__bnvs_match_seq { #2 }
      } {
        \seq_put_left:NV \l__bnvs_match_seq \l__bnvs_b_tl
      }
    }
    \tl_set:Nx \l__bnvs_b_tl { \BNVS_seq_use:in { match } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn
  \BNVS_TEST_extract:Nnnn { cnnn }
\cs_set:Npn \BNVS_TEST_split:Nnnn #1 #2 #3 #4 {
  \BNVS_begin:
  \regex_split:NnNTF #1 { #2 } \l__bnvs_split_seq {
    \tl_set:Nx \l__bnvs_a_tl { \BNVS_seq_use:in { split } , }
    \seq_set_from_clist:Nn \l__bnvs_split_seq { #3 }
    \tl_set:Nx \l__bnvs_b_tl { \BNVS_seq_use:in { split } , }
    \assert_equal:xxn { \l__bnvs_a_tl } { \l__bnvs_b_tl } { #4-seq }
  } {
    \tl_if_empty:nF { #3 } {
      \test_fail:n { #4-a }
    }
  }
  \BNVS_end:
}
\cs_generate_variant:Nn \msg_error:nnnn { nnnx }
\cs_set:Npn \BNVS_ASSERT_equal:nnn #1 #2 #3 {
  \tl_if_eq:nnF { #1 } { #2 } {
    \msg_error:nnnx { beanoves } { :nn } { FAILED~`#1'!=`#2' } { \BeanovesCurrentTestFile :\the\inputlineno :#3}
    \begin{beanoves.failure}
    \item FAILURE~`#1'!=`#2'~(\BeanovesCurrentTestFile :\the\inputlineno)
    \item #3
    \end{beanoves.failure}
  }
}
\box_new:N \l__bnvs_TEST_A_box
\box_new:N \l__bnvs_TEST_B_box
\cs_set:Npn \BNVS_ASSERT_size_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{beanoves.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{beanoves.failure}
    }
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_ASSERT_size_not_equal:nnn #1 #2 #3 {
  \hbox_set:Nn \l__bnvs_TEST_A_box { #1 }
  \hbox_set:Nn \l__bnvs_TEST_B_box { #2 }
  \bool_if:nTF {
         \dim_compare_p:nNn {
\box_wd:N \l__bnvs_TEST_A_box } = { \box_wd:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_ht:N \l__bnvs_TEST_A_box } = { \box_ht:N \l__bnvs_TEST_B_box
    } && \dim_compare_p:nNn {
\box_dp:N \l__bnvs_TEST_A_box } = { \box_dp:N \l__bnvs_TEST_B_box
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {
      \msg_error:nnxx { beanoves } { :nn } {
        FAILED~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }
      } { \BeanovesCurrentTestFile :\the\inputlineno :#3 }
      \begin{beanoves.failure}
      \item FAILURE~\tl_to_str:n { #1 } != \tl_to_str:n { #2 }~(\BeanovesCurrentTestFile :\the\inputlineno)
      \item #3
      \end{beanoves.failure}
    }
  } {
    \cs_set:Nn \BNVS_ASSERT: {}
  }
  \BNVS_ASSERT:
}
\cs_set:Npn \BNVS_TEST_fail:n #1 {
  \msg_error:nnnx { beanoves } { :nn } { TEST~FAILED } { \BeanovesCurrentTestFile :\the\inputlineno :#1~(\int_use:N \g__bnvs_call_int)}
  \begin{beanoves.failure}
  \item FAILURE~unexpected~branch~(\BeanovesCurrentTestFile :\the\inputlineno)
  \item #1
  \end{beanoves.failure}
}
\cs_generate_variant:Nn \BNVS_ASSERT_equal:nnn { x, xx }
\cs_set:Npn \BNVS_ASSERT_equal_tl:vnn {
  \BNVS_tl_use:Ni \BNVS_ASSERT_equal:nnn
}
\cs_generate_variant:Nn \BNVS_TEST_fail:n { x }
\cs_new:Npn \BNVS_DEBUG_log_f:c #1 {
  \BNVS_log:x { \token_to_str:c { \BNVS_c:b { #1 } } }
}
\cs_new:Npn \BNVS_DEBUG_log_f:b #1 {
  \BNVS_log:x { \token_to_str:c { #1 } }
}
\cs_new:Npn \BNVS_DEBUG_log_f:nbn #1 #2 #3 {
  \BNVS_log:x { #1 \token_to_str:c { \BNVS_c:b { #2 } } #3 }
}
\cs_new:Npn \BNVS_DEBUG_log_tl:i #1 {
  \BNVS_log:x {
    \BNVS_tl_use_N:Ni \token_to_str:N { #1 }
    -> / \BNVS_tl_use_n:Ni \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_int:c #1 {
  \BNVS_log:x {
    \BNVS_int_use:Nv \token_to_str:N { #1 }
    -> / \BNVS_int_use:Nv \tl_to_str:n { #1 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nc #1 #2 {
  \BNVS_log:x {
    \tl_to_str:n { #1 }
    -> / \tl_to_str:n { #2 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:ni #1 #2 {
  \BNVS_log:x {
    \tl_to_str:n { #1 }
    -> / l:\tl_to_str:n { #2 } /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { v }
\cs_new:Npn \BNVS_DEBUG_log_tl:nc #1 #2 {
  \BNVS_log:x {
    \tl_if_empty:nF { #1 } { #1 -> }
    \BNVS_tl_use:Ni \token_to_str:N  { #2 }
    -> / \BNVS_tl_use:Ni \tl_to_str:n { #2 } /
  }
}
\cs_new:Npn \BNVS_DEBUG_tl:i #1 {
  \BNVS_log:x {
    \BNVS_tl_use:Ni \token_to_str:N { #1 }
    -> / \BNVS_tl_use:Ni \tl_to_str:n { #1 } /
  }
}

\cs_new:Npn \BNVS_DEBUG_log_arg:nn #1 #2 {
  \BNVS_log:x { \tl_to_str:n { #1 } -> / \tl_to_str:n { #2 } / }
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnni #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:ni
}
\cs_new:Npn \BNVS_DEBUG_log_arg:ninn #1 #2 {
  \BNVS_DEBUG_log_arg:ni { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnni #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnni
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnn #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_arg:nnnnnnni #1 #2 {
  \BNVS_DEBUG_log_arg:nn { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnni
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnn #1 {
  \BNVS_DEBUG_log_f:b { #1 }
  \BNVS_DEBUG_log_arg:nn
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnn #1 {
  \BNVS_DEBUG_log_f:b { #1 }
  \BNVS_DEBUG_log_arg:nnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnnnn #1 {
  \BNVS_DEBUG_log_f:b { #1 }
  \BNVS_DEBUG_log_arg:nnnnnn
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnc #1 {
  \BNVS_DEBUG_log_f:b { #1 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnni #1 {
  \BNVS_DEBUG_log_f:b { #1 }
  \BNVS_DEBUG_log_arg:nnni
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:nbn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnni #1 #2 {
  \BNVS_DEBUG_log_f:nbn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnni
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnnnnc #1 #2 {
  \BNVS_DEBUG_log_f:nbn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnnc
}
\cs_new:Npn \BNVS_DEBUG_log_f:bnnnnnni #1 #2 {
  \BNVS_DEBUG_log_f:nbn { } { #1 } { #2 }
  \BNVS_DEBUG_log_arg:nnnnni
}
\cs_new:Npn \BNVS_DEBUG_log_cs:nN #1 #2 {
  \BNVS_log:x { \tl_to_str:n { #1 } == \token_to_str:N #2 }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:N #1 {
  \BNVS_log:x {
    \token_to_str:N #1 => / \seq_count:N #1 / \seq_use:Nn #1 . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:nN #1 #2 {
  \BNVS_log:x {
    \tl_to_str:n { #1 } => / \seq_count:N #2 / \seq_use:Nn #2 . /
  }
}
\cs_generate_variant:Nn \tl_to_str:n { x }
\cs_new:Npn \BNVS_DEBUG_log_seq:xi #1 #2 {
  \BNVS_log:x {
    #1
    => / \seq_count:c { l__bnvs_#2_seq }
       / \seq_use:cn { l__bnvs_#2_seq } . /
  }
}
\cs_new:Npn \BNVS_DEBUG_log_seq:i #1 {
  \BNVS_log:x {
    \token_to_str:c { l__bnvs_#1_seq }
    => / \seq_count:c { l__bnvs_#1_seq }
       / \seq_use:cn { l__bnvs_#1_seq } . /
  }
}
\tl_new:N \BNVS_DEBUG_tl
\cs_new:Npn \BNVS_DEBUG_log_current:c #1 {
  \tl_set:Nn \BNVS_DEBUG_tl { #1 }
  \tl_replace_once:Nnn \BNVS_DEBUG_tl { : } { _ }
  \cs_set_eq:cc { BNVS_DEBUG_log_\BNVS_DEBUG_tl :nn } { BNVS_DEBUG_log_current:nn }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bn #1 #2 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    #2
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnn #1 #2 #3 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nn { #2 } { #3 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnni #1 #2 #3 #4 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnni { #2 } { #3 } { IN } { #4 }
    \cs_if_exist:cT { l__bnvs_#4_tl } {
      \BNVS_DEBUG_log_tl:i { #4 }
    }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnin #1 #2 #3 #4 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:ninn { #2 } { #3 } { IN } { #4 }
    \cs_if_exist:cT { \BNVS_l_tl:i { #3 } } {
      \BNVS_DEBUG_log_tl:i { #3 }
    }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnnnn #1 #2 #3 #4 #5 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnn { #2 } { #3 } { #4 } { #5 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnnnnc #1 #2 #3 #4 #5 #6 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnc { #2 } { #3 } { #4 } { #5 } { IN } { #6 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnnnni #1 #2 #3 #4 #5 #6 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnni { #2 } { #3 } { #4 } { #5 } { IN } { #6 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnnnnnnc #1 #2 #3 #4 #5 #6 #7 #8 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnnc { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { IN } { #8 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
\cs_new:Npn \BNVS_DEBUG_log_set:bnnnnnni #1 #2 #3 #4 #5 #6 #7 #8 {
  \cs_set:Npn \BNVS_DEBUG_log_current:nn ##1 ##2 {
    \BNVS_DEBUG_log_f:nbn { ##1 } { #1 } { ##2 }
    \BNVS_DEBUG_log_arg:nnnnnnni { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { IN } { #8 }
  }
  \BNVS_DEBUG_log_current:c { #1 }
}
%</!final>
% \end{bnvs.gobble}
%
% \NewDocumentEnvironment{myList}{}
%   {\begin{list}{•}{%
%      \setlength{\itemindent}{0pt}%
%      \setlength{\leftmargin}{0pt}%
%      \setlength{\labelwidth}{-1\parindent}%
%      \addtolength{\topsep}{-0.5\parskip}%
%      \listparindent \parindent
%      \setlength{\parsep}{\parskip}}}
%   {\end{list}}
%
% \subsection{Local variables}
% We make heavy use of local variables and function scopes.
% Many functions are executed within a \TeX\ group,
% which ensures no name collision with the caller stack.
% The number of variables used has not been optimized,
% nor the \TeX\ groups used.
% Optimization often goes against readability.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_id_last_tl
\tl_set:Nn \l__bnvs_id_last_tl { ?! }
\tl_new:N \l__bnvs_a_tl
\tl_new:N \l__bnvs_b_tl
\tl_new:N \l__bnvs_c_tl
\tl_new:N \l__bnvs_V_tl
\tl_new:N \l__bnvs_A_tl
\tl_new:N \l__bnvs_L_tl
\tl_new:N \l__bnvs_Z_tl
\tl_new:N \l__bnvs_ans_tl
\tl_new:N \l__bnvs_key_tl
\tl_new:N \l__bnvs_key_base_tl
\tl_new:N \l__bnvs_id_tl
\tl_new:N \l__bnvs_n_tl
\tl_new:N \l__bnvs_path_tl
\tl_new:N \l__bnvs_group_tl
\tl_new:N \l__bnvs_scan_tl
\tl_new:N \l__bnvs_query_tl
\tl_new:N \l__bnvs_token_tl
\tl_new:N \l__bnvs_root_tl
\tl_new:N \l__bnvs_n_incr_tl
\tl_new:N \l__bnvs_incr_tl
\tl_new:N \l__bnvs_post_tl
\tl_new:N \l__bnvs_suffix_tl
\int_new:N \g__bnvs_call_int
\int_new:N \l__bnvs_int
\seq_new:N \g__bnvs_def_seq
\seq_new:N \l__bnvs_a_seq
\seq_new:N \l__bnvs_b_seq
\seq_new:N \l__bnvs_ans_seq
\seq_new:N \l__bnvs_match_seq
\seq_new:N \l__bnvs_split_seq
\seq_new:N \l__bnvs_path_seq
\seq_new:N \l__bnvs_path_base_seq
\seq_new:N \l__bnvs_query_seq
\seq_new:N \l__bnvs_token_seq
\bool_new:N \l__bnvs_in_frame_bool
\bool_set_false:N \l__bnvs_in_frame_bool
\bool_new:N \l__bnvs_parse_bool
%    \end{macrocode}
% \end{bnvs.macrocode}
% In order to implement the provide feature, we add getters and setters.
% Use \cs{BNVS_provide_off:} and \cs{BNVS_provide_on:} to switch to the appropriate
% provide mode.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\bool_new:N \l__bnvs_provide_bool
\BNVS_new:bpn { provide_on: } {
  \bool_set_true:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { PROVIDE...ON }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:bpn { provide_off: } {
  \bool_set_false:N \l__bnvs_provide_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { PROVIDE...OFF }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_provide_off:
%    \end{macrocode}
% \end{bnvs.macrocode}
%^^A\BNVS_if_provide:
% \begin{function}[TF]{\BNVS_if_provide: }
% \begin{syntax}
% \cs{BNVS_if_provide:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% Execute \meta{yes code} when in provide mode, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_provide: } { p, T, F, TF } {
  \bool_if:NTF \l__bnvs_provide_bool {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsection{Infinite loop management}
% Unending recursivity is managed here.
% \begin{variable} {\g__bnvs_call_int}
% Some functions calls, as well as some loop bodies, decrement this counter.
% When this counter reaches 0, an error is raised or
% a computation is aborted.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\int_const:Nn \c__bnvs_max_call_int { 2048 }
%    \end{macrocode}
% \end{bnvs.macrocode}
%^^A:\...call_greset:
% \begin{function}{\BNVS_call_greset:}
% \begin{syntax}
% \cs{BNVS_call_greset:}
% \end{syntax}
% Reset globally the call stack counter to its maximum value.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set:Npn  \BNVS_call_greset: {
  \int_gset:Nn \g__bnvs_call_int { \c__bnvs_max_call_int }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{function}
%^^A:\...call:
% \begin{function}[TF]{\BNVS_call:}
% \begin{syntax}
% \cs{BNVS_call:TF} \marg{ yes code } \marg{ no code }
% \end{syntax}
% Decrement the \cs{g__bnvs_call_int} counter globally and
% execute \meta{ yes code } if we have not reached 0,
% \meta{ no code } otherwise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { call: } { T, F, TF } {
  \int_gdecr:N \g__bnvs_call_int
  \int_compare:nNnTF \g__bnvs_call_int > 0 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { quark_if_nil:i } #1 { T, F, TF } {
  \BNVS_tl_use:Ni \quark_if_nil:NTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { QNIL...TRUE(#1)}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { QNIL...FALSE(#1)}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_quark_if_nil:iTF, noigre}
% \BNVS_tl_set:in { TEST_A } { \q_nil }
% \BNVS_DEBUG_on:
% \BNVS_quark_if_nil:iTF { TEST_A } {
%   \BNVS_log:n { T }
% } {
%   \test_fail:n { NO~WAY }
% }
% \BNVS_tl_set:in { TEST_A } { }
% \BNVS_quark_if_nil:iTF { TEST_A } {
%   \test_fail:n { NO~WAY }
% } {
%   \BNVS_log:n { F }
% }
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { quark_if_no_value:i } #1 { T, F, TF } {
  \BNVS_tl_use:Ni \quark_if_no_value:NTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { QNOVALUE...TRUE(#1)}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { QNOVALUE...FALSE(#1)}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_quark_if_no_value:iTF, noigre}
% \BNVS_tl_set:in { TEST_A } { \q_no_value }
% \BNVS_DEBUG_on:
% \BNVS_quark_if_no_value:iTF { TEST_A } {
%   \BNVS_log:n { T }
% } {
%   \test_fail:n { NO~WAY }
% }
% \BNVS_tl_set:in { TEST_A } { }
% \BNVS_quark_if_no_value:iTF { TEST_A } {
%   \test_fail:n { NO~WAY }
% } {
%   \BNVS_log:n { F }
% }
% \end{bnvs.test}
% 
% \end{bnvs.macrocode}
% \end{function}
%
% \subsection{Overlay specification}
% \subsection{Basic functions}
% \begin{variable} {\g__bnvs_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% The basic keys are, assuming \meta{id}!\meta{key} is a fully qualified overlay set name,
% \begin{description}
% \item [\texttt{\meta{id}!\meta{key}/V}] for the value
% \item [\texttt{\meta{id}!\meta{key}/A}] for the first index
% \item [\texttt{\meta{id}!\meta{key}/L}] for the length when provided
% \item [\texttt{\meta{id}!\meta{key}/Z}] for the last index when provided
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_prop {
      \BNVS_log:n { ##1 -> ##2 }
    }
  }
  \BNVS_DEBUG_log_cache_gprop:n {#1}
  \BNVS_DEBUG_log_kip_gprop:n {#1}
  \BNVS_DEBUG_log_v_gprop:n {#1}
  \BNVS_DEBUG_log_n_gprop:n {#1}
}
\NewDocumentCommand\BeanovesLogGProp {O{20}} {
  \BNVS_begin:
  \BNVS_DEBUG_on:
  \BNVS_DEBUG_log_gprop:n {#1}
  \BNVS_end:
}
%</!final>
%<*final>
\NewDocumentCommand\BeanovesLogGProp {O{20}} { \BNVS_error:n {Only~with~beanoves-debug} }
%</final>
% \end{bnvs.gobble}
%^^A:\...gput:nnn,...
% \begin{function}{
%   \BNVS_gput:nnn,
%   \BNVS_item:nn,
%   \BNVS_gremove:nn,
%   \BNVS_gclear:n,
%   \BNVS_gclear:v,
%   \BNVS_gclear:,
%   \BNVS_gput_nil:ii,
%   \BNVS_gput_no_value:nn,
%   \BNVS_gput_no_value:nnv,
% }
% \begin{syntax}
% \cs{BNVS_gput:nnn} \marg{subkey} \marg{key} \marg{value}
% \cs{BNVS_item:nn} \marg{subkey} \marg{key}
% \cs{BNVS_gremove:nn} \marg{subkey} \marg{key}
% \cs{BNVS_gclear:n} \marg{key}
% \cs{BNVS_gclear:}
% \cs{BNVS_gput_nil:ii} \marg{subkey} \marg{key}
% \cs{BNVS_gput_no_value:nn} \marg{subkey} \marg{key}
% \cs{BNVS_gput_no_value:nnv} \marg{subkey} \marg{key} \marg{value core}
% \end{syntax}
% Convenient shortcuts to manage the storage, it makes the code more concise and readable.
% This is a wrapper over \LaTeX3\ eponym functions.
% The key argument is \texttt{\meta{key}/\meta{subkey}}.
%
% The last two ones put respectively |\q_nil| and |\q_no_value|.
% The last ones also stores the content of \meta{value core}
% for subkey \texttt{\meta{subkey}/0}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { gput:nnn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { gput:nnn } #1 #2 #3 {
  \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
\BNVS_DEBUG_log_f:bnnnnnn { gput:nnn }
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { gput:nni } #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_gput:nnn { #1 } { #2 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_prop { #2 / #1 }
}
\BNVS_new:bpn { gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_prop { #2 / #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnn { gremove:nn } { SUBKEY } { #1 } { KEY } { #2 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:bpn { gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L } {
    \BNVS_gremove:nn { ##1 } { #1 }
    \BNVS_gremove:nn { ##1/0 } { #1 }
  }
  \BNVS_kip_gremove:n { #1 }
  \BNVS_cache_gclear:n { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnn { gclear:n } { KEY } { #1 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:bpn { gclear:v } {
   \BNVS_tl_use:Ni \BNVS_gclear:n
}
\BNVS_new:bpn { gclear: } {
  \prop_gclear:N \g__bnvs_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { gclear: }
%\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:bpn { gput_nil:ii } #1 #2 {
  \BNVS_gput:nnn { #1 } { #2 } { \q_nil }
}
\BNVS_new:bpn { gput_no_value:nn } #1 #2 {
  \BNVS_gput:nnn { #1 } { #2 } { \q_no_value }
}
\BNVS_new:bpn { gput_no_value:nnv } #1 #2 #3 {
  \BNVS_gput_no_value:nn { #1 } { #2 }
  \BNVS_gput:nni { #1/0 } { #2 } { #3 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_gput:nnn{|item:nn|gremove:nn}, noigre}
% \BNVS_gput:nnn { subkey } { key } { value }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \prop_item:Nn \g__bnvs_prop { key / subkey } } 
%   { value }
%   { \test_fail:n { A } }
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \BNVS_item:nn { subkey } { key } } 
%   { value }
%   { \test_fail:n { B } }
% \BNVS_gremove:nn {subkey} {key}
% \exp_args:Nx
% \tl_if_eq:nnF
%   { \BNVS_item:nn { subkey } { key } } 
%   { }
%   { \test_fail:n { C } }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_gclear:/n/v, noigre}
% \BNVS_gput:nnn { A } { key_1 } { value_1 }
% \BNVS_gput:nnn { A } { key_2 } { value_2 }
% \BNVS_gput:nnn { A } { key_3 } { value_3 }
% \cs_set:Npn \BNVS_Test:nnTF #1 #2 {
%   \exp_args:Nx
%   \tl_if_eq:nnTF
%     { \prop_item:Nn \g__bnvs_prop { key_#1 / A } } 
%     { #2 }
% }
% \cs_set:Npn \Test_in:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { value_#1 }
%     { }
%     { \test_fail:n { IN_#1/#2 } }
% }
% \cs_set:Npn \Test_out:nn #1 #2 {
%   \BNVS_Test:nnTF { #1 }
%     { }
%     { }
%     { \test_fail:n { OUT_#1/#2 } }
% }
% \Test_in:nn { 1 } { A }
% \Test_in:nn { 2 } { B }
% \Test_in:nn { 3 } { C }
% \BNVS_gclear:n { key_1 }
% \Test_out:nn { 1 } { D }
% \Test_in:nn { 2 } { E }
% \Test_in:nn { 3 } { F }
% \BNVS_tl_set:in { TEST_A } { key_2 }
% \BNVS_gclear:v { TEST_A }
% \Test_out:nn { 1 } { G }
% \Test_out:nn { 2 } { H }
% \Test_in:nn { 3 } { I }
% \BNVS_gclear:
% \Test_out:nn { 1 } { J }
% \Test_out:nn { 2 } { K }
% \Test_out:nn { 3 } { L }
% \cs_undefine:N \BNVS_Test:nnTF
% \cs_undefine:N \Test_in:nn
% \cs_undefine:N \Test_out:nn
% \end{bnvs.test}
%
% \begin{function}[pTF]{
%   \BNVS_if_in:nn,
%   \BNVS_if_in:n,
% }
% \begin{syntax}
% \cs{BNVS_if_in_p:nn} \marg{subkey} \marg{key}
% \cs{BNVS_if_in:nnTF} \marg{subkey} \marg{key} \marg{yes code} \marg{no code}
% \cs{BNVS_if_in_p:n} \marg{key}
% \cs{BNVS_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{key}/\meta{subkey}}, it makes the code more concise and readable.
% The version with no \meta{subkey} is the or combination for keys
% |V|, |A| and |Z|.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...if_in:nnTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_in:nn } #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_in:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \BNVS_if_in_p:nn V { #1 }
    || \BNVS_if_in_p:nn A { #1 }
    || \BNVS_if_in_p:nn Z { #1 }
  } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_in:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_if_in:nTF { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_if_in:nnTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_if_in:nn#1 } { subkey } { key }
% }
% \cs_set:Npn \BNVS_Test:TF {
%   \bool_if:nTF { \BNVS_if_in_p:nn { subkey } { key } }
% }
% \BNVS_Test:TF       { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { TF } { \test_fail:n { A/2 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/3 } }
% \BNVS_Test:n {  F }                        { }
% \BNVS_gput:nnn { subkey } { key } { value }
% \prop_if_in:NnF \g__bnvs_prop { key/subkey } { \test_fail:n { B } }
% \bool_if:nF { \prop_if_in_p:Nn \g__bnvs_prop { key/subkey } } { \test_fail:n { BB } }
% \BNVS_Test:TF       { } { \test_fail:n { B/1 } }

% \BNVS_Test:n { TF } { } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { }
% \BNVS_Test:n {  F }     { \test_fail:n { B/3 } }
% \cs_undefine:N \BNVS_Test:TF
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_gprovide:nnnT,
% }
% \begin{syntax}
% \cs{BNVS_gprovide:nnnT} \marg{subkey} \marg{key} \marg{value} \marg{true precode}
% \end{syntax}
% Execute \meta{true precode} before providing.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { gprovide:nnnT } #1 #2 #3 #4 {
  \prop_if_in:NnF \g__bnvs_prop { #2 / #1 } {
    #4
    \prop_gput:Nnn \g__bnvs_prop { #2 / #1 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnnnn { gprovide:nnnT } 
  { SUBKEY } { #1 } { KEY } { #2 } { VALUE } { #3 }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_gprovide:nnnT, noigre}
% \BNVS_gclear:
% \BNVS_if_in:nnT { subkey } { key } { \test_fail:n { A } }
% \BNVS_gprovide:nnnT { subkey } { key } { value } { }
% \BNVS_if_in:nnF { subkey } { key } { \test_fail:n { B } }
% \BNVS_gprovide:nnnT { subkey } { key } { value } {
%   \test_fail:n { C }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_get:nni
% }
% \begin{syntax}
% \cs{BNVS_get:nniTF} \marg{subkey} \marg{key} \marg{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined, on resolution only.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { get:nnc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use_N:ni {
    \prop_get:NnNTF \g__bnvs_prop { #2 / #1 }
  } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnnnnc { get:nniTF } { ...TRUE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnnnnc { get:nniTF } { ...FALSE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c=\BNVS_c:b{get:nniTF}, noigre}
% \BNVS_gclear:
% \BNVS_tl_clear:i { TEST }
% \BNVS_get:nniTF { subkey } { key } { TEST } { \test_fail:n { A/1 } } { }
% \BNVS_tl_clear:i { TEST }
% \cs_new:Npn \BNVS_Test:n #1 {
%   \BNVS_use:b { BNVS_get:nni#1 } { subkey } { key } { TEST }
% }
% \BNVS_Test:n { TF } { \test_fail:n { A/1 } } { }
% \BNVS_Test:n { T  } { \test_fail:n { A/2 } }
% \BNVS_Test:n {  F }                          { }
% \BNVS_gput:nnn { subkey } { key } { value }
% \cs_new:Npn \TestT:n #1 {
%   \BNVS_tl_if_eq:vnF { TEST } { value } { \test_fail:n { #1 } }
% }
% \BNVS_Test:n { TF } { \TestT:n { B/1 } } { \test_fail:n { B/2 } }
% \BNVS_Test:n { T  } { \TestT:n { B/3 } }
% \BNVS_Test:n {  F }                      { \test_fail:n { B/4 } }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
%    \begin{macrocode}
\BNVS_new_conditional_ni_wrap:Nnt \BNVS_get:nni { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \BNVS_gput:nnn X { A } { B }
% \BNVS_Test:xxn { \BNVS_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \BNVS_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \BNVS_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \BNVS_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \BNVS_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \BNVS_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \BNVS_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_if_in_p:nn X {B} || \BNVS_if_in_p:nn X {A} } TF } { T } { 11 }
% \BNVS_tl_clear:i { b }
% \BNVS_get:nniF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \BNVS_get:nniT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsection{Functions for aliases}
% \begin{variable} {\g__bnvs_kip_prop}
% \meta{key}--\meta{value} property list to store the alias overlay sets.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_kip_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% ``|kip|'' stands for key, id and path.
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_kip_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_kip_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \BNVS_set:bpn { k:n } #1 { / #1 }
    \BNVS_set:bpn { i:n } #1 { - #1 }
    \BNVS_set:bpn { p:n } #1 { - #1 }
    \prop_map_inline:Nn \g__bnvs_kip_prop {
      \BNVS_log:x { 
        kip: \exp_not:n { ##1 } -> ##2 /
      }
    }
  }
}
\NewDocumentCommand\BeanovesLogKIPProp {O{20}} { \BNVS_DEBUG_log_kip_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \BNVS_kip_gput_nil:n,
%   \BNVS_kip_gput:nnnn,
%   \BNVS_kip_gput:nvvv,
%   \BNVS_kip_gput:vvvv,
%   \BNVS_kip_gremove:n,
%   \BNVS_kip_gclear:
% }
% \begin{syntax}
% \cs{BNVS_kip_gput:nnnn} \marg{key} \marg{k} \marg{i} \marg{p}
% \cs{BNVS_kip_gremove:n} \marg{key}
% \cs{BNVS_kip_gclear:}
% \end{syntax}
% Wrapper over the standard \LaTeX3 functions for the |alias| property list.
% The \meta{k}, \meta{i} variables and \meta{p} sequence are merged into one value.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...kip_gput:nnnn
%    \begin{macrocode}
\BNVS_new:bpn { kip_gput:nnnn } #1 #2 #3 #4 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { kip_gput:nnnn }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
\BNVS_DEBUG_log_arg:nn { K } { #2 }
\BNVS_DEBUG_log_arg:nn { I } { #3 }
\BNVS_DEBUG_log_arg:nn { P } { #4 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prop_gput:Nnn \g__bnvs_kip_prop { #1 } {
    \BNVS_k:n { #2 }
    \BNVS_i:n { #3 }
    \BNVS_p:n { #4 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_gput:nvvv } #1 #2 #3 #4 {
  \exp_args:Nnx \use:n {
    \BNVS_tl_use:ni {
      \BNVS_tl_use:ni {
        \BNVS_kip_gput:nnnn { #1 }
      } { #2 }
    } { #3 }
  } { \BNVS_seq_use:in { #4 } . }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_gput:vvvv } #1 #2 #3 #4 {
  \exp_args:Nnx \use:n {
    \BNVS_tl_use:ni {
      \BNVS_tl_use:ni {
        \BNVS_tl_use:Ni \BNVS_kip_gput:nnnn { #1 }
      } { #2 }
    } { #3 }
  } { \BNVS_seq_use:in { #4 } . }
}
%    \end{macrocode}
% ^^A:\...kip_gput_nil:n
%    \begin{macrocode}
\BNVS_new:bpn { kip_gput_nil:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { kip_gput_nil:n }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prop_gput:Nnn \g__bnvs_kip_prop { #1 } { \q_nil }
}
%    \end{macrocode}
% ^^A:\...kip_gremove:n
%    \begin{macrocode}
\BNVS_new:bpn { kip_gremove:n } {
  \prop_gremove:Nn \g__bnvs_kip_prop
}
\BNVS_new:bpn { kip_gclear: } {
  \prop_gclear:N \g__bnvs_kip_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { kip_gclear: }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[pTF]{
%   \BNVS_kip_if_in:nn,
% }
% \begin{syntax}
% \cs{BNVS_kip_if_in_p:n} \marg{key}
% \cs{BNVS_kip_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{key}} in the |alias| property list,
% it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \BNVS_kip_if_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_kip_prop { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_kip_get:nccc,
%   \BNVS_kip_get:vccc
% }
% \begin{syntax}
% \cs{BNVS_kip_get:ncccTF } \marg{key} \marg{k core} \marg{i core} \marg{p core} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the various variables is undefined.
% NB: the associate predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\tl_new:N \l__bnvs_kip_tl
%    \end{macrocode}
%^^A:\...kip_get:ncccTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_get:nccc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:ni {
    \prop_get:NnNTF \g__bnvs_kip_prop { #1 }
  } { kip } {
    \BNVS_tl_use:Ni \quark_if_nil:NTF { kip } {
      \BNVS_fatal:n {Circular~definition:~#1}
      \BNVS_tl_set:in { #2 } { \q_nil }
      \prg_return_false:
    } {
      \BNVS_set:bpn { k:n } { \BNVS_tl_set:in { #2 } }
      \BNVS_set:bpn { i:n } { \BNVS_tl_set:in { #3 } }
      \BNVS_set:bpn { p:n } {
         \BNVS_seq_set_split:inn { #4 } .
      }
      \BNVS_tl_use:i { kip }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { kip_get:ncccTF } { ...TRUE }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
\BNVS_DEBUG_log_tl:c { #2 }
\BNVS_DEBUG_log_tl:c { #3 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:c={ kip_get... }, noigre}
% \BNVS_tl_set:in { TEST_A } { THE_KEY }
% \BNVS_tl_set:in { key } { KEY }
% \BNVS_tl_set:in { id  } { ID }
% \BNVS_seq_set_split:inn { path } { . } { 4.2.1 }
% \BNVS_kip_gput:nnnn { THE_KEY } { KEY } { ID } { 4.2.1 }
% \BNVS_kip_gput:vvvv { TEST_A } { key } { id  } { path }
% \prop_get:NnNTF \g__bnvs_kip_prop { THE_KEY } \l__bnvs_TEST_B_tl {
%   \BNVS_DEBUG_tl:i { TEST_B }
% } {
%   \test_fail:n { get }
% }
% \BNVS_tl_set:in { key } { FAIL }
% \BNVS_tl_set:in { id  } { FAIL}
% \BNVS_seq_set_split:inn { path } { . } { FAIL}
% \BNVS_kip_get:vcccTF { TEST_A } { key } { id  } { path } {
%   \assert_equal_tl:vnn { key } { KEY } { KEY }
%   \assert_equal_tl:vnn { id } { ID } { ID }
%   \assert_equal:xxn { \BNVS_seq_use:in { path } . } { 4.2.1 } { path }
% } {
%   \test_fail:n { get }
% }
% 
% \end{bnvs.test}
%    \begin{macrocode}
      \prg_return_true:    
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { kip_get:ncccTF } { ...FALSE }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_get:vccc } #1 #2 #3 #4 { T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_kip_get:ncccTF { #1 } { #2 } { #3 } { #4 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \begin{bnvs.test}{banner=kip~storage, noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \BNVS_kip_gput:nnnn { A } { B } { }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nTF {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nTF {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nT {A} T } { T } { 5 }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nT {B} T } { } { 6 }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nF {A} F } { } { 7 }
% \BNVS_Test:xxn { \BNVS_kip_if_in:nF {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_kip_if_in_p:n {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_kip_if_in_p:n {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_kip_if_in_p:n {B} || \BNVS_kip_if_in_p:nn X {A} } TF } { T } { 11 }
% \BNVS_tl_clear:i { b }
% \BNVS_kip_get:ncF {A} { b } {
%   \test_fail:n { 12 }
% }
% \BNVS_kip_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
%
% \subsection{Functions with cache}
% \begin{variable} {\g__bnvs_cache_prop}
% \meta{key}--\meta{value} property list to store the named overlay sets.
% Other keys are eventually used to cache results when some attributes
% are defined from other slide ranges.
% \begin{description}
% \item [\texttt{\meta{id}!\meta{key}/V}] for the cached static value of the value
% \item [\texttt{\meta{id}!\meta{key}/A}] for the cached static value of the first index
% \item [\texttt{\meta{id}!\meta{key}/L}] for the cached static value of the length
% \item [\texttt{\meta{id}!\meta{key}/Z}] for the cached static value of the last index
% \item [\texttt{\meta{id}!\meta{key}/P}] for the cached static value of the previous index
% \item [\texttt{\meta{id}!\meta{key}/N}] for the cached static value of the next index
% \end{description}
% The implementation is private, in particular, keys may change in future versions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_cache_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_cache_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_cache_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_cache_prop {
      \BNVS_log:n { c: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogCProp {O{20}} { \BNVS_DEBUG_log_cache_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \BNVS_cache_gput:iin,
%   \BNVS_cache_gput:nni,
%   \BNVS_cache_gput:nvn,
%   \BNVS_cache_item:nn,
%   \BNVS_cache_gremove:nn,
%   \BNVS_cache_gclear:n,
%   \BNVS_cache_gclear:
% }
% \begin{syntax}
% \cs{BNVS_cache_gput:iin} \marg{subkey} \marg{key} \marg{value}
% \cs{BNVS_cache_item:nn} \marg{subkey} \marg{key}
% \cs{BNVS_cache_gremove:nn} \marg{subkey} \marg{key}
% \cs{BNVS_cache_gclear:n} \marg{key}
% \cs{BNVS_cache_gclear:}
% \end{syntax}
% Wrapper over the functions above for \texttt{\meta{key}/\meta{subkey}}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { cache_gput:iin } #1 #2 {
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { cache_gput:iin } #1 #2 #3 {
\BNVS_DEBUG_log_f:b { cache_gput:iin }
\BNVS_DEBUG_log_arg:nn { SUBKEY } { #1 }
\BNVS_DEBUG_log_arg:nn { KEY } { #2 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #3 }
  \prop_gput:Nnn \g__bnvs_cache_prop { #2 / #1 } { #3 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\cs_generate_variant:Nn \BNVS_cache_gput:iin { nV, nnV }
\BNVS_new:bpn { cache_gput:nvn } #1 {
  \BNVS_tl_use:ni {
    \BNVS_cache_gput:nVn { #1 }
  }
}
\BNVS_new:bpn { cache_gput:nni } #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_cache_gput:nnV { #1 } { #2 }
  }
}
\BNVS_new:bpn { cache_item:nn } #1 #2 {
  \prop_item:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:bpn { cache_gremove:nn } #1 #2 {
  \prop_gremove:Nn \g__bnvs_cache_prop { #2 / #1 }
}
\BNVS_new:bpn { cache_gclear:n } #1 {
  \clist_map_inline:nn { V, A, Z, L, P, N } {
    \prop_gremove:Nn \g__bnvs_cache_prop { #1 / ##1 }
  }
}
\BNVS_new:bpn { cache_gclear: } {
  \prop_gclear:N \g__bnvs_cache_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { cache_gclear: }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[pTF]{
%   \BNVS_cache_if_in:nn,
% }
% \begin{syntax}
% \cs{BNVS_cache_if_in_p:nn} \marg{subkey} \marg{key}
% \cs{BNVS_cache_if_in:nnTF} \marg{subkey} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of \texttt{\meta{subkey}/\meta{key}}, it makes the code more concise and readable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \BNVS_cache_if_in:nn #1 #2 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_cache_prop { #2 / #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_cache_get:nni,
%   \BNVS_cache_get:nvc
% }
% \begin{syntax}
% \cs{BNVS_cache_get:nniTF} \marg{subkey} \marg{key} \marg{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { cache_get:nni } #1 #2 #3 { p, T, F, TF } {
  \BNVS_tl_use:ni {
    \prop_get:NnNTF \g__bnvs_cache_prop { #2 / #1 }
  } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnnnnc { cache_get:nniTF } { ...TRUE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnnnnc { cache_get:nniTF } { ...FALSE } { SUBKEY } { #1 } { KEY } { #2 } { => } { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_ni_wrap:Nnt \BNVS_cache_get:nni { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=cache_(put|remove|clear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%     \BNVS_ASSERT_equal:xxn { #1 } { #2 } {#3}
%  }
% \BNVS_cache_gput:iin X { A } { B }
% \BNVS_Test:xxn { \BNVS_cache_item:nn X {A} } { B } { 1 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnTF X {A} TF } { T } { 3 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnTF X {B} TF } { F } { 4 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnT X {A} T } { T } { 5 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnT X {B} T } { } { 6 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnF X {A} F } { } { 7 }
% \BNVS_Test:xxn { \BNVS_cache_if_in:nnF X {B} F } { F } { 8 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_cache_if_in_p:nn X {A} } TF } { T } { 9 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_cache_if_in_p:nn X {B} } TF } { F } { 10 }
% \BNVS_Test:xxn { \bool_if:nTF { \BNVS_cache_if_in_p:nn X {B} || \BNVS_cache_if_in_p:nn X {A} } TF } { T } { 11 }
% \BNVS_tl_clear:i { b }
% \BNVS_cache_get:nniF X {A} { b } {
%   \test_fail:n { 13 }
% }
% \BNVS_cache_get:nniT X {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsection{Implicit value counter}
% The implicit value counter is local to the current frame.
% It is defined at the global level because changes made
% at any depth must be visible at the frame depth.
% If the frame were a closure, this counter would belong to that closure.
% When used for the first time, it generally defaults to the firsrt index or last index.
% See sections \ref{sect:counters} and \ref{sect:.n specifiers}.
% \begin{variable} {\g__bnvs_v_prop}
% \meta{key}--\meta{value} property list to store the contents or the named value counters.
% The keys are \meta{id}!\meta{key}.
% Prefer accessors and functions below.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_v_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_v_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_v_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_v_prop {
      \BNVS_log:n { v: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogVProp {O{20}} { \BNVS_DEBUG_log_v_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \BNVS_v_gput:nn,
%   \BNVS_v_gput:nV,
%   \BNVS_v_gput:Vn,
%   \BNVS_v_item:n,
%   \BNVS_v_gremove:n,
%   \BNVS_v_gclear:
% }
% \begin{syntax}
% \cs{BNVS_v_gput:nn} \marg{key} \marg{value}
% \cs{BNVS_v_item:n} \marg{key}
% \cs{BNVS_v_gremove:n} \marg{key}
% \cs{BNVS_v_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 almost eponym functions applied to |\g__bnvs_v_prop|.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { v_gput:nn } {
  \prop_gput:Nnn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:bnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_v_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { v_gput:nv } #1 {
  \BNVS_tl_use:ni {
    \BNVS_v_gput:nn { #1 }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { v_item:n } #1 {
  \prop_item:Nn \g__bnvs_v_prop { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { v_gremove:n } {
  \prop_gremove:Nn \g__bnvs_v_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { v_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_v_prop { #1 }
\BNVS_DEBUG_log_f:bnn { v_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_v_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { v_gclear: } {
  \prop_gclear:N \g__bnvs_v_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { v_gclear: }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[pTF]{
%   \BNVS_v_if_in:n
% }
% \begin{syntax}
% \cs{BNVS_v_if_in_p:n} \marg{key}
% \cs{BNVS_v_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{key}} value counter.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_if_in:n } #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_v_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_v_get:nc,
% }
% \begin{syntax}
% \cs{BNVS_v_get:niTF} \marg{key} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_get:ni } #1 #2 { T, F, TF } {
  \BNVS_tl_use:ni {
    \prop_get:NnNTF \g__bnvs_v_prop { #1 }
  } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnc { v_get:niTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnc { v_get:niTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{cn={\BNVS_c:b{v_gput:nn}}{|get}, noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } { #3 }
% }
% \BNVS_v_gput:nn { A } { B }
% \BNVS_Test:xxn { \BNVS_v_item:n {A} } { B } { 1 }
% \BNVS_tl_clear:i { b }
% \BNVS_v_get:ncF {A} { b } {
%   \test_fail:n { 13 }
% }
% \BNVS_v_get:ncT {B} { b } {
%   \test_fail:n { 13 }
% }
% \cs_undefine:N \BNVS_Test:xxn
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \BNVS_v_greset:nn,
%   \BNVS_v_greset:vn,
%   \BNVS_greset_all:nn,
%   \BNVS_greset_all:vn,
% }
% \begin{syntax}
% \cs{BNVS_v_greset:nnTF} \marg{key} \marg{initial value} \marg{true code} \marg{false code}
% \cs{BNVS_greset_all:nnTF} \marg{key} \marg{initial value} \marg{true code} \marg{false code}
% \end{syntax}
% The key must include the frame id.
% Reset the value counter to the given \meta{initial value}.
% The |_all| version also cleans the cached values.
% If the \meta{key} is known, \meta{true code} is executed,
% otherwise \meta{false code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_greset:nn } #1 #2 { T, F, TF } {
  \BNVS_v_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { v_greset:nnTF } { }
\BNVS_DEBUG_log_arg:nn { KEY } { #1 }
\BNVS_DEBUG_log_arg:nn { VALUE } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_v_gremove:n { #1 }
    \tl_if_empty:nF { #2 } {
      \BNVS_v_gput:nn { #1 } { #2 }
    }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_greset:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_v_greset:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { greset_all:nn } #1 #2 { T, F, TF } {
  \BNVS_if_in:nTF { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnn { greset_all:nnTF } { KEY } { #1 } { VALUE } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_begin:
    \clist_map_inline:nn { V, A, Z, L } {
      \BNVS_get:nniT { ##1 } { #1 } { a } {
        \BNVS_quark_if_nil:iT { a } {
          \BNVS_cache_get:nniTF { ##1 } { #1 } { a } {
            \BNVS_gput:nni { ##1 } { #1 } { a }
          } {
            \BNVS_gput:nnn { ##1 } { #1 } { 1 }
          }
        }
      }
    }
    \BNVS_end:
    \BNVS_cache_gclear:n { #1 }
    \BNVS_v_greset:nnT { #1 } { #2 } {}
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { greset_all:vn } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_greset_all:nnTF { #1 } { #2 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\BNVS_gclear_all:n, \BNVS_gclear_all:}
% \begin{syntax}
% \cs{BNVS_gclear_all:n} \marg{key}
% \cs{BNVS_gclear_all:}
% \end{syntax}
% Convenient shortcuts to clear all the storage, for the given key in the first case.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { gclear_all: } {
  \BNVS_gclear:
  \BNVS_cache_gclear:
  \BNVS_n_gclear:
  \BNVS_v_gclear:
  \BNVS_kip_gclear:
}
\BNVS_new:bpn { gclear_all:n } #1 {
  \BNVS_gclear:n { #1 }
  \BNVS_cache_gclear:n { #1 }
  \BNVS_n_gremove:n { #1 }
  \BNVS_v_gremove:n { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
%  NO __bnvs_kip_gremove:n { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsection{Implicit index counter}
% The implicit index counter is also local to the current frame.
% It is defined at the global level because changes made
% at any depth must be visible at the frame depth.
% When used for the first time, it defaults to 1.
% Prefer the accessors and functions below.
% \begin{variable} {\g__bnvs_n_prop}
% \meta{key}--\meta{value} property list to store the contents of the named index counters.
% The keys are \meta{id}!\meta{key}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prop_new:N \g__bnvs_n_prop
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% \begin{bnvs.gobble}
%<*!final>
\cs_new:Npn \BNVS_DEBUG_log_n_gprop:n #1 {
  \int_compare:nNnT { \prop_count:N \g__bnvs_n_prop } < {
    \tl_if_empty:nTF { #1 } { 20 } { #1 }
  } {
    \prop_map_inline:Nn \g__bnvs_n_prop {
      \BNVS_log:n { n: ##1 -> ##2 }
    }
  }
}
\NewDocumentCommand\BeanovesLogNProp {O{20}} { \BNVS_DEBUG_log_n_gprop:n {#1} }
%</!final>
% \end{bnvs.gobble}
% \begin{function}{
%   \BNVS_n_gput:nn,
%   \BNVS_n_gput:nv,
%   \BNVS_n_gput:vn,
%   \BNVS_n_gprovide:nn,
%   \BNVS_n_item:n,
%   \BNVS_n_gremove:n,
%   \BNVS_n_gremove:v,
%   \BNVS_n_gclear:
% }
% \begin{syntax}
% \cs{BNVS_n_gput:nn} \marg{key} \marg{value}
% \cs{BNVS_n_item:n} \marg{key}
% \cs{BNVS_n_gremove:n} \marg{key}
% \cs{BNVS_n_gclear:}
% \end{syntax}
% Convenient shortcuts to manage the storage,
% it makes the code more concise and readable.
% This is a wrapper over \LaTeX3 almost eponym functions applied to |\g__bnvs_n_prop|.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { n_gput:nn } {
  \prop_gput:Nnn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { n_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:bnnnn { n_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_n_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { n_gput:nv } #1 {
  \BNVS_tl_use:Ni \BNVS_n_gput:nn { #1 }
}
\BNVS_new:bpn { n_gprovide:nn } #1 #2 {
  \prop_if_in:NnF \g__bnvs_n_prop { #1 } {
    \prop_gput:Nnn \g__bnvs_n_prop { #1 } { #2 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnn { n_gprovide:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_n_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\BNVS_new:bpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { n_item:n } #1 {
  \prop_item:Nn \g__bnvs_n_prop { #1 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { n_gremove:n } {
  \prop_gremove:Nn \g__bnvs_n_prop
}
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_set:bpn { n_gremove:n } #1 {
  \prop_gremove:Nn \g__bnvs_n_prop { #1 }
\BNVS_DEBUG_log_f:bnn { n_gremove:n } { KEY } { #1 }
\BNVS_DEBUG_log_n_gprop:n {}
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
\BNVS_new:bpn { n_gremove:v } {
  \BNVS_tl_use:Ni \BNVS_n_gremove:n
}
\BNVS_new:bpn { n_gclear: } {
  \prop_gclear:N \g__bnvs_n_prop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:b { n_gclear: }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[pTF]{\BNVS_n_if_in:n}
% \begin{syntax}
% \cs{BNVS_n_if_in_p:nn} \marg{key}
% \cs{BNVS_n_if_in:nTF} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to test for the existence of
% the  \texttt{\meta{key}} value counter.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\prg_new_conditional:Npnn \BNVS_n_if_in:n #1 { p, T, F, TF } {
  \prop_if_in:NnTF \g__bnvs_n_prop { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{\BNVS_n_get:ni}
% \begin{syntax}
% \cs{BNVS_n_get:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Convenient shortcuts to retrieve the value with branching, it makes the code more concise and readable.
% Execute \meta{yes code} when the item is found, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable} is undefined.
% NB: the predicate won't work because |\prop_get:NnNTF| is not expandable.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_get:ni } #1 #2 { T, F, TF } {
  \BNVS_prop_get:NniTF \g__bnvs_n_prop { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnc { n_get:niTF } { ...TRUE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:bnnnc { n_get:niTF } { ...FALSE } { KEY } { #1 } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=n_(gput|gremove|gclear|...):nn..., noigre}
% \cs_set:Npn \BNVS_Test:xxn #1 #2 #3 {
%   \exp_args:Nnnx
%   \assert_equal:xxn { #1 } { #2 } {#3}
% }
% \BNVS_n_gput:nn { A } { B }
% \BNVS_Test:xxn { \BNVS_n_item:n {A} } { B } { 1 }
% \BNVS_tl_clear:i { b }
% \BNVS_n_get:niF {A} { b } {
%   \test_fail:n { 13 }
% }
% \BNVS_n_get:niT {B} { b } {
%   \test_fail:n { 13 }
% }
% \end{bnvs.test}
%
% \subsection{Regular expressions}
%
% \begin{variable}{\c__bnvs_name_regex}
% The name of a slide range consists of a non void list of alphanumerical characters and
% underscore, but with no leading digit.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_name_regex {
  [[:alpha:]_][[:alnum:]_]*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=name_regex, noigre}
% \Test_regex:cnnn { name } {A} {A} {1}
% \Test_regex:cnnn { name } {_A1} {_A1} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_id_regex}
% The id of a slide range is an exclamation mark ``|!|'', possibly after a name or a single question mark ``|?|''.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_id_regex {
  (?: \ur{c__bnvs_name_regex} | [?] )? !
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=id_regex, noigre}
% \Test_regex:cnnn { id } {!} {!} {1}
% \Test_regex:cnnn { id } {_A1!} {_A1!} {2}
% \Test_regex:cnnn { id } {?!} {?!} {2}
% \end{bnvs.test}
% \end{variable}
% \begin{variable}{\c__bnvs_path_regex}
% A sequence of \texttt{.\meta{name}} or \texttt{.\meta{integer}} items representing a path.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_path_regex {
  (?: \. \ur{c__bnvs_name_regex} | \. [-+]? \d+ )*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=path_regex, noigre}
% \Test_regex:cnnn { path } {} {} {1}
% \Test_regex:cnnn { path } {.1} {.1} {2}
% \Test_regex:cnnn { path } {.1.2} {.1.2} {3}
% \Test_regex:cnnn { path } {.1.-2} {.1.-2} {4}
% \Test_regex:cnnn { path } {.-1} {.-1} {5}
% \Test_regex:cnnn { path } {.-1.2} {.-1.2} {6}
% \Test_regex:cnnn { path } {.-1.-2} {.-1.-2} {7}
% \Test_regex:cnnn { path } {.1.n} {.1.n} {2'}
% \Test_regex:cnnn { path } {.1.2.n} {.1.2.n} {3'}
% \Test_regex:cnnn { path } {.1.-2.n} {.1.-2.n} {4'}
% \Test_regex:cnnn { path } {.-1.n} {.-1.n} {5'}
% \Test_regex:cnnn { path } {.-1.2.n} {.-1.2.n} {6'}
% \Test_regex:cnnn { path } {.-1.-2.n} {.-1.-2.n} {7'}
% \Test_regex:cnnn { path } {.n.1} {.n.1} {2''}
% \Test_regex:cnnn { path } {.1.n.2} {.1.n.2} {3''}
% \Test_regex:cnnn { path } {.1.n.-2} {.1.n.-2} {4''}
% \Test_regex:cnnn { path } {.n.-1} {.n.-1} {5''}
% \Test_regex:cnnn { path } {.-1.n.2} {.-1.n.2} {6''}
% \Test_regex:cnnn { path } {.-1.n.-2} {.-1.n.-2} {7''}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_A_key_Z_regex}
% A key is the name of an overlay set possibly followed by a dotted path.
% Matches the whole string.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_key_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item[1:] The range name including the slide \meta{id} and exclamation mark if any
% \item[2:] slide \meta{id} including the question mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[3:] the path, if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \ur{c__bnvs_path_regex} ) \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}{:N=\c__bnvs_A_key_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_A_key_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1, {},{}} {2}
% \BNVS_Test:nnn {A.1} {A, {}, .1} {3}
% \BNVS_Test:nnn {_A1.1} {_A1, {}, .1} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1, {}, .1.2} {5}
% \BNVS_Test:nnn {?!A} {?!A, ?!, {}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!, {}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A, ?!, .1} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1, ?!, .1} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1, ?!, .1.2} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A, {}, .1.n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1, {}, .1.n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1, {}, .1.2.n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A, ?!, .1.n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1, ?!, .1.n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1, ?!, .1.2.n} {5'-?!}
% \end{bnvs.test}
%
% \begin{variable}{\c__bnvs_TEST_A_key_n_Z_regex}
% A key is the name of an overlay set possibly followed by a dotted path.
% Matches the whole string.
% Catch the ending \texttt{.n}.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_TEST_A_key_n_Z_regex {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{itemize}
% \item[1:] The full match
% \item[2:] The overlay set name including the slide \meta{id} and question mark if any, the dotted path but excluding the trailing \texttt{.n}
% \item[3:] slide \meta{id} including the question mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \A ( ( \ur{c__bnvs_id_regex} ? )
  \ur{c__bnvs_name_regex}
  (?: \. \ur{c__bnvs_name_regex} | \. [-+]? \d+ )*? )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item[4:] the last \texttt{.n} component if any.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  ( \. n )? \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{itemize}
% \begin{bnvs.test}{banner=A_key_n_Z_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 {
%   \BNVS_TEST_extract:Nnnn \c__bnvs_TEST_A_key_n_Z_regex { #1 } { #1, #2 }
% }
% \BNVS_Test:nnn {A} {A,{},{}} {1}
% \BNVS_Test:nnn {_A1} {_A1,{},{}} {2}
% \BNVS_Test:nnn {A.1} {A.1,{},{}} {3}
% \BNVS_Test:nnn {_A1.1} {_A1.1,{},{}} {4}
% \BNVS_Test:nnn {_A1.1.2} {_A1.1.2,{},{}} {5}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2,{},{.n}} {6}
% \BNVS_Test:nnn {?!A} {?!A, ?!,{}} {1-?!}
% \BNVS_Test:nnn {?!_A1} {?!_A1, ?!,{}} {2-?!}
% \BNVS_Test:nnn {?!A.1} {?!A.1, ?!,{}} {3-?!}
% \BNVS_Test:nnn {?!_A1.1} {?!_A1.1, ?!,{}} {4-?!}
% \BNVS_Test:nnn {?!_A1.1.2} {?!_A1.1.2, ?!,{}} {5-?!}
% \BNVS_Test:nnn {A.n} {A,{},.n} {1'}
% \BNVS_Test:nnn {_A1.n} {_A1, {},.n} {2'}
% \BNVS_Test:nnn {A.1.n} {A.1, {}, .n} {3'}
% \BNVS_Test:nnn {_A1.1.n} {_A1.1, {}, .n} {4'}
% \BNVS_Test:nnn {_A1.1.2.n} {_A1.1.2, {}, .n} {5'}
% \BNVS_Test:nnn {?!A.n} {?!A, ?!, .n} {1'-?!}
% \BNVS_Test:nnn {?!_A1.n} {?!_A1, ?!, .n} {2'-?!}
% \BNVS_Test:nnn {?!A.1.n} {?!A.1, ?!, .n} {3'-?!}
% \BNVS_Test:nnn {?!_A1.1.n} {?!_A1.1, ?!, .n} {4'-?!}
% \BNVS_Test:nnn {?!_A1.1.2.n} {?!_A1.1.2, ?!, .n} {5'-?!}
% \BNVS_Test:nnn {?!_A1.1.n.2.n} {?!_A1.1.n.2, ?!, .n} {5''-?!}
% \end{bnvs.test}
%
% \begin{variable}{\c__bnvs_colons_regex}
% For ranges defined by a colon syntax.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_colons_regex { :(:+)? }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=colons_regex, noigre}
% \cs_set:Npn \BNVS_Test:nnn {
%   \BNVS_TEST_split:Nnnn \c__bnvs_colons_regex
% }
% \BNVS_Test:nnn { A:C } {{A},{},{C}} {1}
% \BNVS_Test:nnn { A::C } {{A},{:},{C}} {2}
% \BNVS_Test:nnn { A:::C } {{A},{::},{C}} {3}
% \BNVS_Test:nnn { :B::C } {{},{},{B},{:},{C}} {4}
% \end{bnvs.test}
% \end{variable}
%
% \begin{variable}{\c__bnvs_split_regex}
% Used to parse slide list overlay specifications in queries.
% Next are the 9 capture groups.
% Group numbers are 1 based because the regex is used in splitting contexts
% where only capture groups are considered and not the whole match.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_split_regex {
  \s* ( ? :
%    \end{macrocode}
% \end{bnvs.macrocode}
% We start with `|++|' instrussions^^A
% \footnote{At the same time an instruction and an expression... this is a synonym of exprection}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \+\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
%   \item 1: \meta{key} of a slide range
%   \item 2: \meta{id} of a slide range including the exclamation mark 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 3: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:}, noigre}
% \BNVS_set:bpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},#3,{},{},{},{},{},{}} { 1|2|3-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \BNVS_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ++ABC } {} {{ABC},{},{}} {a'}
% \BNVS_Test:nnnn { ++ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b'}
% \BNVS_Test:nnnn { ++?!ABC } {} {{?!ABC},{?!},{}} {c'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d'}
% \BNVS_Test:nnnn { ++?!ABC.1.2~X~ } {++?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e'}
% \end{bnvs.test}
%   \item 4: \meta{key} of a slide range
%   \item 5: \meta{id} of a slide range including the exclamation mark
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( ( \ur{c__bnvs_id_regex}? ) \ur{c__bnvs_name_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
%   \item 6: optionally followed by a dotted path
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      ( \ur{c__bnvs_path_regex} )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:}, noigre, noigre}
% \BNVS_set:bpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     {{#2},{},{},{},#3,{},{},{}} { 4|5|6-#4 } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \BNVS_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2~X~ } {?!ABC.1.2~} {{?!ABC},{?!},{.1.2}} {e}
% \BNVS_Test:nnnn { ABC.3.N.n~~ } {} {{ABC},{},{.3.N.n}} {f}
% \end{bnvs.test}
% We continue with other expressions
%   \item 7: the \meta{++n} attribute
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      (?: \.(\+)\+n
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\c__bnvs_split_regex/.++n, noigre}
% \BNVS_set:bpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{+},{},{} } { 7-#4~(.++n) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \BNVS_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC.++n } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2.++n~~ } {}  {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC.++n } {}  {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~~ } {}  {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2.++n~X~ } { ?!ABC.1.2.++n~}  {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
%   \item 8: the poor man integer expression after `|+=|',
%   which is the longest sequence of black characters,
%   which ends just before a space or at the very last character.
%   This tricky definition allows quite any algebraic expression,
%   even those involving parenthesis.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      |  \s* \+= \s* ( \S+ )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner={\token_to_str:N\c__bnvs_split_regex/+=}, noigre}
% \BNVS_set:bpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { `+='~#4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{} } { 8-#4~(+=) } 
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \BNVS_:nnnn { #1 } \l__bnvs_a_tl { #3, {}, #4 }
% }
% \BNVS_Test:nnnnn { ABC += 421 } {} {{ABC}, {}, {}} {421} {1}
% \BNVS_Test:nnnnn { ABC += 1+P.1 } {} {{ABC}, {}, {}} {1+P.1} {2}
% \BNVS_Test:nnnnn { ABC += 1+P.1~X } { ABC += 1+P.1~ } {{ABC}, {}, {}} {1+P.1} {3}
% \BNVS_Test:nnnnn { ABC += (P.1+1)~~^^A(
% ) } { ABC += (P.1+1)~~ } {{ABC}, {}, {}} {(P.1+1)} {4}
% \BNVS_Test:nnnnn { ?!ABC += 421 } {} {{?!ABC}, {?!}, {}} {421} {5}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1 } {} {{?!ABC}, {?!}, {}} {1+P.1} {6}
% \BNVS_Test:nnnnn { ?!ABC += 1+P.1~X } {?!ABC += 1+P.1~} {{?!ABC}, {?!}, {}} {1+P.1} {7}
% \BNVS_Test:nnnnn { ?!ABC += (P.1+1)~~^^A(
% ) } {?!ABC += (P.1+1)~~} {{?!ABC}, {?!}, {}} {(P.1+1)} {8}
% \end{bnvs.test}
%   \item 9: the post increment
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      | (\+)\+
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\c__bnvs_split_regex{/:...++}, noigre}
% \BNVS_set:bpn { :nnnn } #1 #2 #3 #4 {
%   \banner:n { #4 }
%   \BNVS_TEST_extract:Nnnn \c__bnvs_split_regex
%     { #1 }
%     { {#2},{},{},{},#3,{},{},{+}} { 9-#4~(...++) } 
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 {
%   \tl_set:Nx \l__bnvs_a_tl { \tl_if_empty:nTF { #2 } {
%     \exp_not:n { #1 }
%  } {
%     \exp_not:n { #2 }
%  } }
%   \exp_args:NnV
%   \BNVS_:nnnn { #1 } \l__bnvs_a_tl
% }
% \BNVS_Test:nnnn { ABC++ } {} {{ABC},{},{}} {a}
% \BNVS_Test:nnnn { ABC.1.2++~~ } {} {{ABC},{},{.1.2}} {b}
% \BNVS_Test:nnnn { ?!ABC++ } {} {{?!ABC},{?!},{}} {c}
% \BNVS_Test:nnnn { ?!ABC.1.2++~~ } {} {{?!ABC},{?!},{.1.2}} {d}
% \BNVS_Test:nnnn { ?!ABC.1.2++~X~ } {?!ABC.1.2++~} {{?!ABC},{?!},{.1.2}} {e}
% \end{bnvs.test}
% \end{myList}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    )?
  ) \s*
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\c__bnvs_split_regex/split, noigre}
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%     { 1/#1/2 } { 1/,#2,{},{},{},{},{},{},/2 } { split-#3 }
% }
% \BNVS_Test:nnn { ++A }     {{A},{},{}} { 1-a }
% \BNVS_Test:nnn { ++?!A }   {{?!A},{?!},{}} { 1-b }
% \BNVS_Test:nnn { ++A.3 }   {{A},{},{.3}} { 1-c }
% \BNVS_Test:nnn { ++?!A.3 } {{?!A},{?!},{.3}} { 1-d }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \BNVS_TEST_split:Nnnn \c__bnvs_split_regex
%  { 1/#1/2 } { 1/,{},{},{},#2,/2 } { split-#3 }
% }
% \BNVS_Test:nnn { A.++n }   {{A},{},{},{+},{},{}} { 2-a' }
% \BNVS_Test:nnn { ?!A.++n } {{?!A},{?!},{},{+},{},{}} { 2-b' }
% \BNVS_Test:nnn { A.3.++n } {{A},{},{.3},{+},{},{}} { 2-c' }
% \BNVS_Test:nnn {?!A.3.++n} {{?!A},{?!},{.3},{+},{},{}} { 2-d' }
% \BNVS_Test:nnn { A }   {{A},{},{},{},{},{}} { 2-a }
% \BNVS_Test:nnn { A.n } {{A},{},{.n},{},{},{}} { 2-b }
% \BNVS_Test:nnn { ?!A } {{?!A},{?!},{},{},{},{}} { 2-c }
% \BNVS_Test:nnn { ?!A.n } {{?!A},{?!},{.n},{},{},{}} { 2-d }
% \BNVS_Test:nnn { A.3 } {{A},{},{.3},{},{},{}} { 2-e }
% \BNVS_Test:nnn { A.3.n } {{A},{},{.3.n},{},{},{}} { 2-f }
% \BNVS_Test:nnn { A.N.3.n } {{A},{},{.N.3.n},{},{},{}} { 2-f' }
% \BNVS_Test:nnn { ?!A.3 } {{?!A},{?!},{.3},{},{},{}} { 2-g }
% \BNVS_Test:nnn { ?!A.3.n } {{?!A},{?!},{.3.n},{},{},{}} { 2-h }
% \BNVS_Test:nnn { A++ }   {{A},{},{},{},{},{+}} { 3-a }
% \BNVS_Test:nnn { A.n++ }   {{A},{},{.n},{},{},{+}} { 3-b }
% \BNVS_Test:nnn { ?!A++ } {{?!A},{?!},{},{},{},{+}} { 3-c }
% \BNVS_Test:nnn { ?!A.n++ } {{?!A},{?!},{.n},{},{},{+}} { 3-d }
% \BNVS_Test:nnn { A.3++ } {{A},{},{.3},{},{},{+}} { 3-e }
% \BNVS_Test:nnn { A.3.n++ } {{A},{},{.3.n},{},{},{+}} { 3-f }
% \BNVS_Test:nnn { ?!A.3++ } {{?!A},{?!},{.3},{},{},{+}} { 3-g }
% \BNVS_Test:nnn { ?!A.3.n++ } {{?!A},{?!},{.3.n},{},{},{+}} { 3-h }
% \BNVS_Test:nnn { A.length } {{A},{},{.length},{},{},{}} { 4-a }
% \BNVS_Test:nnn { A.3.length } {{A},{},{.3.length},{},{},{}} { 4-b }
% \BNVS_Test:nnn { ?!A.length } {{?!A},{?!},{.length},{},{},{}} { 4-c }
% \BNVS_Test:nnn { ?!A.3.length } {{?!A},{?!},{.3.length},{},{},{}} { 4-d }
% \BNVS_Test:nnn { A.last } {{A},{},{.last},{},{},{}} { 5-a }
% \BNVS_Test:nnn { ?!A.last } {{?!A},{?!},{.last},{},{},{}} { 5-b }
% \BNVS_Test:nnn { A.3.last } {{A},{},{.3.last},{},{},{}} { 5-c }
% \BNVS_Test:nnn { ?!A.3.last } {{?!A},{?!},{.3.last},{},{},{}} { 5-d }
% \BNVS_Test:nnn { A.previous } {{A},{},{.previous},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.previous } {{?!A},{?!},{.previous},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.previous } {{A},{},{.3.previous},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.previous } {{?!A},{?!},{.3.previous},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.next } {{A},{},{.next},{},{},{}} { 6-a }
% \BNVS_Test:nnn { ?!A.next } {{?!A},{?!},{.next},{},{},{}} { 6-b }
% \BNVS_Test:nnn { A.3.next } {{A},{},{.3.next},{},{},{}} { 6-c }
% \BNVS_Test:nnn { ?!A.3.next } {{?!A},{?!},{.3.next},{},{},{}} { 6-d }
% \BNVS_Test:nnn { A.range } {{A},{},{.range},{},{},{}} { 7-a }
% \BNVS_Test:nnn { ?!A.range } {{?!A},{?!},{.range},{},{},{}} { 7-b }
% \BNVS_Test:nnn { A.3.range } {{A},{},{.3.range},{},{},{}} { 7-c }
% \BNVS_Test:nnn { ?!A.3.range } {{?!A},{?!},{.3.range},{},{},{}} { 7-d }
% \end{bnvs.test}
% \end{variable}
%
% \subsection{\pkg{beamer.cls} interface}
% Work in progress.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\RequirePackage{keyval}
\define@key{beamerframe}{beanoves~id}[]{
  \tl_set:Nx \l__bnvs_id_last_tl { #1 ! }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_KEY} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/before}{
  \BNVS_n_gclear:
  \BNVS_v_gclear:
  \bool_set_true:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_BEFORE} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\AddToHook{env/beamer@frameslide/after}{
  \bool_set_false:N \l__bnvs_in_frame_bool
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
  \BNVS_log_a:nn {THIS_IS_AFTER} {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Defining named slide ranges}
%
% \begin{function}[TF]{\BNVS_range_set:cccn}
%   \begin{syntax}
%     \cs{BNVS_range_set:cccnTF} \meta{core first}  \meta{core end} \meta{core length} \marg{tl} \marg{yes code} \marg{no code}
%   \end{syntax}
% Parse \meta{tl} as a range according to \cs{c__bnvs_colons_regex} and set the variables accordingly.
% \meta{tl} is expected to only contain colons and integers.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { split_pop_left:v } #1 { T, F, TF } {
  \BNVS_seq_pop_left:iiTF { split } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { split_pop_left:vTF } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { split_pop_left:vTF } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { range_set:cccn } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { range_set:cccnTF } {
  \BNVS_DEBUG_log_tl:c { #1 }
  \BNVS_DEBUG_log_tl:c { #2 }
  \BNVS_DEBUG_log_tl:c { #3 }
  \BNVS_DEBUG_log_arg:nn { IN } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_range_set_cccnTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_tl_clear:i { a }
  \BNVS_tl_clear:i { b }
  \BNVS_tl_clear:i { c }
  \BNVS_regex_split:inTF { colons } { #4 } {
    \BNVS_seq_pop_left:iiT { split } { a } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The variable |a| contains the \meta{start}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_seq_pop_left:iiT { split } { b } {
        \BNVS_tl_if_empty:iTF { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a one colon range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \BNVS_split_pop_left:vTF { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The variable |b| contains the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \BNVS_seq_pop_left:iiT { split } { c } {
              \BNVS_tl_if_empty:iTF { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% A |::| was expected:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                \BNVS_error:n { Invalid~range~expression(1):~#4 }
              } {
                \int_compare:nNnT { \BNVS_tl_count:v { c } } > { 1 } {
                  \BNVS_error:n { Invalid~range~expression(2):~#4 }
                }
                \BNVS_split_pop_left:vTF { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The variable |c| may contain the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                  \BNVS_seq_if_empty:iF { split } {
                    \BNVS_error:n { Invalid~range~expression(3):~#4 }
                  }
                } {
                  \BNVS_error:n { Internal~error }
                }
              }
            } 
          } {
          }
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a two colon range component.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \int_compare:nNnT { \BNVS_tl_count:v { b } } > { 1 } {
            \BNVS_error:n { Invalid~range~expression(4):~#4 }
          }
          \BNVS_seq_pop_left:iiT { split } { c } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The variable |c| contains the \meta{length}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
            \BNVS_split_pop_left:vTF { b } {
              \BNVS_tl_if_empty:iTF { b } {
                \BNVS_seq_pop_left:ii { split } { b }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The variable |b| contains the \meta{end}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                \BNVS_seq_if_empty:iF { split } {
                  \BNVS_error:n { Invalid~range~expression(5):~#4 }
                }
              } {
                \BNVS_error:n { Invalid~range~expression(6):~#4 }
              }
            } {
              \BNVS_tl_clear:i { b }
            }
          }
        }
      }
    }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Providing both the \meta{start}, \meta{length} and \meta{end} of a range
% is not allowed, even if they happen to be consistent.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \cs_set:Npn \BNVS_next: { }
    \BNVS_tl_if_empty:iT { a } {
      \BNVS_tl_if_empty:iT { b } {
        \BNVS_tl_if_empty:iT { c } {
          \cs_set:Npn \BNVS_next: {
            \BNVS_error:n { Invalid~range~expression(7):~#3 }
          }
        }
      }
    }
    \BNVS_next:
    \cs_set:Npn \BNVS_:nnn ##1 ##2 ##3 {
      \BNVS_end:
      \BNVS_tl_set:in { #1 } { ##1 }
      \BNVS_tl_set:in { #2 } { ##2 }
      \BNVS_tl_set:in { #3 } { ##3 }
    }
    \BNVS_tl_use:Niii \BNVS_:nnn { a } { b } { c }
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_set_cccnTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_range_set:cccnTF, noigre}
% \BNVS_range_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_tl_clear:i { a }
%   \BNVS_tl_clear:i { b }
%   \BNVS_tl_clear:i { c }
%   \BNVS_use:b { range_set:cccn#1 } { a } { b } { c } { #2 }
% }
% \BNVS_Test:nn { TF } { } { \test_fail:n { A } } { }
% \BNVS_Test:nn { T  } { } { \test_fail:n { A } }
% \BNVS_Test:nn {  F } { }                          { }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \BNVS_tl_if_eq:vnTF { a } { #1 } {
%     \BNVS_tl_if_eq:vnTF { b } { #2 } {
%       \BNVS_tl_if_eq:vnF { c } { #3 } {
%         \test_fail:n { #4/c }
%       }
%     } {
%       \test_fail:n { #4/b }
%     }
%   } {
%     \test_fail:n { #4/a }
%   }
% }
% \BNVS_Test:nnnn { } { } { } { X }
% \BNVS_range_set:cccnTF { a } { b } { c } { 1:2 } { } { }
% \BNVS_Test:nn { TF } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } } { \test_fail:n { B/a } }
% \BNVS_Test:nn { T  } { 1:2 } { \BNVS_Test:nnnn { 1 } { 2 } { } { B } }
% \BNVS_Test:nn {  F } { 1:2 }     { \test_fail:n { #4/a } }
% \BNVS_Test:nn { TF } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } } { \test_fail:n { C/a } }
% \BNVS_Test:nn { T  } { 1::3 } { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn {  F } { 1::3 }     { \BNVS_Test:nnnn { 1 } { } { 3 } { C } }
% \BNVS_Test:nn { TF } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } } { \test_fail:n { D/a } }
% \BNVS_Test:nn { T  } { :2::3 } { \BNVS_Test:nnnn { } { 2 } { 3 } { D } }
% \BNVS_Test:nn {  F } { :2::3 }     { \test_fail:n { #4/a } }
% \cs_undefine:N \BNVS_Test:nn
% \cs_undefine:N \BNVS_Test:nnnn
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \BNVS_range:nnnn,
%   \BNVS_range:nvvv,
% }
%   \begin{syntax}
%     \cs{BNVS_range:nnnn} \marg{key} \marg{start} \marg{end} \marg{length}
%   \end{syntax}
% Auxiliary function called within a group.
% Setup the model to define a range.
% Takes care of the profile mode.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { range:nnnn } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnn { range:nnnn } { KEY } { #1 }
\BNVS_DEBUG_log_range_nnnn:nn { } { ... }
\BNVS_DEBUG_log_gprop:n {}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_if_provide:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { ...PROVIDE... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_if_in:nnTF A { #1 } {
      \use_none:nnn
    } {
      \BNVS_if_in:nnTF Z { #1 } {
        \use_none:nnn
      } {
        \BNVS_if_in:nnTF L { #1 } {
          \use_none:nnn
        } {
          \BNVS_do_range:nnnn { #1 }
        }
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_nnnn:nn { ... } { .../DO~RANGE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_do_range:nnnn { #1 }
  }
}
\BNVS_new:bpn { range:nvvv } #1 #2 #3 #4 {
  \BNVS_tl_use:ni {
    \BNVS_tl_use:ni {
      \BNVS_tl_use:ni {
        \BNVS_use:b { range:nnnn } { #1 }
      } { #2 }
    } { #3 }
  } { #4 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \BNVS_parse_record:n,
%   \BNVS_parse_record:v,
%   \BNVS_parse_record:nn,
%   \BNVS_parse_record:xn,
%   \BNVS_parse_record:vn,
%   \BNVS_n_parse_record:n,
%   \BNVS_n_parse_record:v,
%   \BNVS_n_parse_record:nn,
%   \BNVS_n_parse_record:xn,
%   \BNVS_n_parse_record:vn
% }
%   \begin{syntax}
%     \cs{BNVS_parse_record:n} \marg{full name}
%     \cs{BNVS_parse_record:nn} \marg{full name} \marg{value}
%     \cs{BNVS_n_parse_record:n} \marg{full name}
%     \cs{BNVS_n_parse_record:nn} \marg{full name} \marg{value}
%   \end{syntax}
% Auxiliary function for \cs{BNVS_parse:n} and \cs{BNVS_parse:nn} below.
% If \meta{value} does not correspond to a range,
% the \texttt{V} key is used.
% The \texttt{_n} variant concerns the index counter.
% This is a bottleneck.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { parse_record:n }  #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnn { parse_record_n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_record_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_if_provide:TF {
    \BNVS_gprovide:nnnT V { #1 } { 1 } {
      \BNVS_gclear:n { #1 }
    }
  } {
    \BNVS_gclear:n { #1 }
    \BNVS_gput:nnn V { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_n:nn { ... } { ...END }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \BNVS_parse_record:n { V }
\BNVS_new:bpn { parse_record:v } {
  \BNVS_tl_use:ni {
    \BNVS_parse_record:V
  }
}
\BNVS_new:bpn { parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnn { parse_record:nn }
  { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_record_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_range_set:cccnTF { a } { b } { c } { #2 } {
    \BNVS_range:nvvv { #1 } { a } { b } { c }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...RANGE... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \BNVS_if_provide:TF {
      \BNVS_gprovide:nnnT V { #1 } { #2 } {
        \BNVS_gclear_all:n { #1 }
      }
    } {
      \BNVS_gclear_all:n { #1 }
      \BNVS_gput:nnn V { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_record_nn:nn { ... } { ...VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \BNVS_parse_record:nn { x, V }
\BNVS_new:bpn { parse_record:vn } {
  \BNVS_tl_use:ni {
    \BNVS_parse_record:Vn
  }
}
\BNVS_new:bpn { n_parse_record:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnn { n_parse_record:n } { KEY } { #1 }
\BNVS_DEBUG_log_n_parse_record_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \bool_if:NTF \l__bnvs_n_provide_bool {
    \BNVS_n_gprovide:nn
  } {
    \BNVS_n_gput:nn
  }
  { #1 } { 1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_n:nn { ... } { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_generate_variant:Nn \BNVS_n_parse_record:n { V }
\BNVS_new:bpn { n_parse_record:v } {
  \BNVS_tl_use:ni {
    \BNVS_n_parse_record:V
  }
}
\BNVS_new:bpn { n_parse_record:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnn
  { n_parse_record:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_n_parse_record_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_range_set:cccnTF { a } { b } { c } { #2 } {
    \BNVS_error:n { Unexpected~range:~#2 }
  } {
    \BNVS_if_provide:TF {
      \BNVS_n_gprovide:nn { #1 } { #2 }
    } {
      \BNVS_n_gput:nn { #1 } { #2 }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_parse_record_nn:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
\cs_generate_variant:Nn \BNVS_n_parse_record:nn { x, V }
\BNVS_new:bpn { n_parse_record:vn } {
  \BNVS_tl_use:Ni \BNVS_n_parse_record:Vn
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.test}{:N=\BNVS_n_parse_record:nn, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \banner:n { #1 }
%   \assert_equal:xxn {\BNVS_n_item:n {X} } {#1} {a}
% }
% \BNVS_provide_on:
% \BNVS_n_parse_record:nn {X} {A}
% \BNVS_log:n { 111 }
% {
%   \BNVS_set:bpn { error:n } #1 {
%     \cs_set:Npn \test_fail:n ##1 { }
%   }
%   \BNVS_log:n { 111 }
%   \BNVS_n_parse_record:nn {X} {A::C}
% }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \BNVS_name_id_n_get:n,
%   \BNVS_name_id_n_get:v,
% }
% \begin{syntax}
% \cs{BNVS_name_id_n_set:nTF} \marg{key} \marg{ yes code} \marg{ no code}
% \end{syntax}
% If the \meta{key} is a key, put the name it defines into the |key| |tl| variable,
% the frame id in the |id| |tl| variable, then
% execute \meta{yes code}.
% The ``|n|'' |tl| variable is empty except when \meta{key} ends with \texttt{.n}.
% Otherwise execute \meta{no code}.
% If \meta{key} does not contain a frame id,
% then |key| is prepended with
% then |id_last| and |id| is set to this value as well.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { name_id_n_end_export: } {
  \cs_set:Npn \BNVS_:nnn ##1 ##2 ##3 {
    \BNVS_end:
    \BNVS_tl_set:in { key } { ##1 }
    \BNVS_tl_set:in { id } { ##2 }
    \BNVS_tl_set:in { n } { ##3 }
  }
  \BNVS_tl_if_empty:iTF { id } {
    \BNVS_tl_use:Niii \BNVS_:nnn { key } { id_last } { n }
    \BNVS_tl_put_left:cv { key } { id_last }
  } {
    \BNVS_tl_use:Niii \BNVS_:nnn { key } { id } { n }
    \BNVS_tl_set:vv { id_last } { id }
  }
}
\BNVS_new_conditional:bpnn { name_id_n_get:n } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { name_id_n_get:n } { 
  \BNVS_DEBUG_log_arg:nn { IN } { #1 }
  \BNVS_DEBUG_tl:i { key }
  \BNVS_DEBUG_tl:i { id }
  \BNVS_DEBUG_tl:i { n }
  \BNVS_DEBUG_tl:i { id_last }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_extract_once:NnTF \c__bnvs_TEST_A_key_n_Z_regex { #1 } {
    \BNVS_match_pop_left:iTF { key } {
      \BNVS_match_pop_left:iTF { key } {
        \BNVS_match_pop_left:iTF { id } {
          \BNVS_match_pop_left:iTF { n } {
            \BNVS_name_id_n_end_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_name_id_n_get_n:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_end:
            \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/n }
            \prg_return_false:
          }
        } {
          \BNVS_end:
          \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/id }
          \prg_return_false:
        }
      } {
        \BNVS_end:
        \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/name }
        \prg_return_false:
      }      
    } {
      \BNVS_end:
      \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/n }
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_name_id_n_get_n:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional:bpnn { name_id_n_get:v } #1 { T, F, TF } {
  \BNVS_tl_use:ni { \BNVS_use:b { name_id_n_get:nTF } } { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_name_id_n_get:nTF, noigre, noigre}
% \BNVS_extract_once:NnTF \c__bnvs_TEST_A_key_n_Z_regex { ?!X } { } { }
% \BNVS_name_id_n_get:nTF { ?!X } { } { }
% \cs_set:Npn \BNVS_Test:nnnnnn #1 #2 #3 #4 #5 #6 {
%   \banner:n { #6 }
%   \tl_if_empty:nTF { #2 } {
%     \BNVS_name_id_n_get:nT { #1 } {
%       \test_fail:n { FAIL }
%     }
%   } {
%     \BNVS_name_id_n_get:nTF { #1 } {
%       \assert_equal_tl:vnn { key } { #2 } { #6-name }
%       \assert_equal_tl:vnn { id } { #3 } { #6-id }
%       \assert_equal_tl:vnn { n } { #4 } { #6-n }
%       \assert_equal_tl:vnn { id_last } { #5 } { #6-last }
%     } {
%       \test_fail:n { FAIL(bis) }
%     }
%   }
% }
% \BNVS_Test:nnnnnn { X    } { ?!X  } { ?! }  { } { ?! } { 1 }
% \BNVS_Test:nnnnnn { X.1  } { ?!X.1 } { ?! } { } { ?! } { 2 }
% \BNVS_Test:nnnnnn { F!X  } { F!X } { F!  } { } { F! } { 3 }
% \BNVS_Test:nnnnnn { X    } { F!X } { F!  } { } { F! } { 4 }
% \BNVS_Test:nnnnnn { X!X  } { X!X } { X!  } { } { X! } { 5 }
% \BNVS_Test:nnnnnn { Y!X.1 } { Y!X.1 } { Y! } { } { Y! } { 6 }
% \BNVS_Test:nnnnnn { Y!X.n } { Y!X } { Y! } { .n } { Y! } { 7 }
% \BNVS_Test:nnnnnn { Y!X.1.n } { Y!X.1 } { Y! } { .n } { Y! } { 8 }
% \BNVS_Test:nnnnnn { ?!!X.1 } { } { } { } { } { 9 }
% \cs_undefine:N \BNVS_Test:nnnnnn
% \end{bnvs.test}
%
% \begin{function}{\BNVS_parse:n, \BNVS_parse:nn}
%   \begin{syntax}
%     \cs{BNVS_parse:n} \marg{key}
%     \cs{BNVS_parse:nn} \marg{key} \marg{definition}
%   \end{syntax}
% Auxiliary functions called within a group by |\keyval_parse:nnn|.
% \meta{key} is the overlay reference key, 
% including eventually a dotted path and a frame identifier,
% \meta{definition} is the corresponding definition.
% \begin{variable}{\l__bnvs_match_seq}
% Local storage for the match result.
% \end{variable}
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { parse:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnn { parse:n } { KEY } { #1 }
\BNVS_DEBUG_log_parse_n:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \peek_remove_spaces:n {
    \peek_catcode:NTF \c_group_begin_token {
      \BNVS_tl_if_empty:iTF { root } {
        \BNVS_error:n { Unexpected~list~at~top~level. }
      }
      \BNVS_begin:
      \BNVS_int_incr:c { }
      \BNVS_tl_set:vx { root } { \BNVS_int_use:c { } . }
      \cs_set:Npn \bnvs:nw ####1 ####2 \s_stop {
        \regex_match:nnT { \S* } { ####2 } {
          \BNVS_error:n { Unexpected~####2 }
        }
        \keyval_parse:nnn {
          \BNVS_parse:n
        } {
          \BNVS_parse:nn
        } { ####1 }
        \BNVS_end:
      }
      \bnvs:nw
    } {
      \BNVS_tl_if_empty:iTF { root } {
        \BNVS_name_id_n_get:nTF { #1 } {
          \BNVS_tl_if_empty:iTF { n } {
            \BNVS_parse_record:v
          } {
            \BNVS_n_parse_record:v
          }
          { key }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...COMPLETE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        } {
          \BNVS_error:n { Unexpected~key:~#1 }
        }
      } {
        \BNVS_int_incr:c { }
        \BNVS_tl_if_empty:iTF { n } {
          \BNVS_parse_record:xn
        } {
          \BNVS_n_parse_record:xn
        } {
          \BNVS_tl_use:v { root } . \BNVS_int_use:c { }
        } { #1 }
      }
      \use_none_delimit_by_s_stop:w
    }
  }
  #1 \s_stop
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_n:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_parse:n, noigre}
% \BNVS_provide_off:
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_ASSERT_equal:xxn { \BNVS_item:nn V { ?!#1 } } { #2 } { #1 }
% }
% \BNVS_parse_record:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \BNVS_gclear:n { ?!X }
% \BNVS_parse:n { ?!X }
% \BNVS_Test:nn { X } { 1 }
% \BNVS_gput:nnn V { ?!Y } { 2 }
% \BNVS_Test:nn { Y } { 2 }
% \BNVS_parse:n { ?!Y }
% \BNVS_Test:nn { Y } { 1 }
% \BNVS_gput:nnn V { ?!Z } { 2 }
% \BNVS_Test:nn { Z } { 2 }
% \BNVS_provide_on:
% \BNVS_parse:n { ?!Z }
% \BNVS_Test:nn { Z } { 2 }
% \end{bnvs.test}
%
%    \begin{macrocode}
\BNVS_new:bpn { do_range:nnnn } #1 #2 #3 #4 {
    \BNVS_gclear_all:n { #1 }
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_range:nnnn, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \BNVS_ASSERT_equal:xxn { \BNVS_item:nn A {#1} } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } {#8~A }
%   \BNVS_ASSERT_equal:xxn { \BNVS_item:nn Z {#1} } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } {#8~Z }
%   \BNVS_ASSERT_equal:xxn { \BNVS_item:nn L {#1} } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } {#8~L }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \BNVS_provide_off:
%   \BNVS_range:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \BNVS_provide_on:
%   \BNVS_range:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \BNVS_range:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \BNVS_range:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \BNVS_range:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \BNVS_range:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \BNVS_range:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \BNVS_range:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=range:nvvv, noigre}
% \cs_set:Npn \BNVS_Test:nnnnnnnn #1 #2 #3 #4 #5 #6 #7 #8 {
%   \banner:n {#1/#2/#3/#4}
%   \assert_equal:xxn { \BNVS_item:nn A { #1 } } {
%     \tl_if_empty:nTF { #5 } { #2 } { #5 } } { #8/A }
%   \assert_equal:xxn { \BNVS_item:nn Z { #1 } } { 
%     \tl_if_empty:nTF { #6 } { #3 } { #6 } } { #8/Z }
%   \assert_equal:xxn { \BNVS_item:nn L { #1 } } { 
%     \tl_if_empty:nTF { #7 } { #4 } { #7 } } { #8/L }
% }
% \cs_set:Npn \BNVS_Test:nnnn #1 #2 #3 #4 {
%   \BNVS_tl_set:in { TEST_A } { #2 }
%   \BNVS_tl_set:in { TEST_B } { #3 }
%   \BNVS_tl_set:in { TEST_C } { #4 }
%   \BNVS_range:nvvv  { #1 } { TEST_A } { TEST_B } { TEST_C }
% }
% \cs_set:Npn \BNVS_Test:nnnnnnn #1 #2 #3 #4 #5 #6 #7 {
%   \BNVS_provide_off:
%   \BNVS_Test:nnnn { #1 } { #2 } { #3 } { #4 }
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 1 }
%   \BNVS_provide_on:
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 2 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 3 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 4 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 5 }
%   \BNVS_Test:nnnn {#1} {FIRST'} {} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 6 }
%   \BNVS_Test:nnnn {#1} {} {} {LENGTH'}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 7 }
%   \BNVS_Test:nnnn {#1} {} {LAST'} {}
%   \BNVS_Test:nnnnnnnn {#1} {#2} {#3} {#4} {#5} {#6} {#7} { 8 }
% }
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {FIRST} {    } {      } {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {    } {LENGTH} {} {} {}
% \BNVS_Test:nnnnnnn {X.1} {     } {LAST} {      } {} {} {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {    } {LENGTH} {} { \exp_not:N\q_nil } {}
% \BNVS_Test:nnnnnnn { X } {FIRST} {LAST} {      } {} {} { \exp_not:N\q_nil }
% \BNVS_Test:nnnnnnn { X } {     } {LAST} {LENGTH} { \exp_not:N\q_nil } {} {}
% \cs_undefine:N \BNVS_Test:nnnn
% \cs_undefine:N \BNVS_Test:nnnnnnn
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { do_range:nnnn } {
  \BNVS_DEBUG_log_arg:nn { KEY } { #1 }
  \BNVS_DEBUG_log_arg:nn { FIRST } { #2 }
  \BNVS_DEBUG_log_arg:nn { LAST } { #3 }
  \BNVS_DEBUG_log_arg:nn { LENGTH } { #4 }
  \BNVS_DEBUG_log_gprop:n {}
}
\BNVS_DEBUG_log_do_range_nnnn:nn {  } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #4 } {
    \tl_if_empty:nTF { #2 } {
      \tl_if_empty:nTF { #3 } {
        \BNVS_error:n { Not~a~range:~:~#1 }
      } {
        \BNVS_gput:nnn Z { #1 } { #3 }
        \BNVS_gput_nil:ii V { #1 }
      }
    } {
      \BNVS_gput:nnn A { #1 } { #2 }
      \BNVS_gput_nil:ii V { #1 }
      \tl_if_empty:nF { #3 } {
        \BNVS_gput:nnn Z { #1 } { #3 }
        \BNVS_gput_nil:ii L { #1 }
      }
    }
  } {
    \tl_if_empty:nTF { #2 } {
      \BNVS_gput:nnn L { #1 } { #4 }
      \tl_if_empty:nF { #3 } {
        \BNVS_gput:nnn Z { #1 } { #3 }
        \BNVS_gput_nil:ii A { #1 }
        \BNVS_gput_nil:ii V { #1 }
      }
    } {
      \BNVS_gput:nnn A { #1 } { #2 }
      \BNVS_gput:nnn L { #1 } { #4 }
      \BNVS_gput_nil:ii Z { #1 }
      \BNVS_gput_nil:ii V { #1 }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_do_range_nnnn:nn { ... } { ...DONE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
\cs_new:Npn \BNVS_exp_args:NNcv #1 #2 #3 #4 {
  \BNVS_tl_use:ni { \exp_args:NNnV #1 #2 { #3 } }
    { #4 }
}
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_exp_args:NNcv, noigre}
% \tl_set:Nn \l__bnvs_TEST_A_tl { A }
% \cs_set:Npn \BNVS_Test:cnn  #1 #2 #3 {
%   \tl_if_eq:nnF { #1 } { #2 } {
%     \test_fail:n { #3 }
%   }
% }
% \BNVS_exp_args:NNcv \relax \BNVS_Test:cnn { A } { TEST_A } { A }
% \cs_undefine:N \BNVS_Test:cnn
% \end{bnvs.test}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_set:ii #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_end: \BNVS_tl_set:in { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { parse:nn } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnn { parse:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_parse_nn:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_tl_set:in { a } { #1 }
  \BNVS_tl_put_left:cv { a } { root }
  \BNVS_name_id_n_get:vTF { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \regex_match:nnTF { \S } { #2 } {
      \peek_remove_spaces:n {
        \peek_catcode:NTF \c_group_begin_token {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The value is a comma separated list, go recursive.
% But before we warn about an unexpected \texttt{.n} suffix, if any.
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/list}, noigre}
%   \BNVS_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \BNVS_tl_set:in { a } { ?!X/#1 }
%     \BNVS_get:nniF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%     }
%   }
%   \BNVS_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \BNVS_tl_set:in { a } { ?!X/#1 }
%     \BNVS_get:nniT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%     }
%   }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \BNVS_tl_if_empty:iF { n } {
\BNVS_warning:n { Ignoring~unexpected~suffix~.n:~#1 }
          }
          \BNVS_begin:
          \BNVS_tl_set:vv { root } { key }
          \int_set:Nn \l__bnvs_int { 0 }
          \cs_set:Npn \BNVS:nn ##1 ##2 \s_stop {
            \regex_match:nnT { \S } { ##2 } {
              \BNVS_error:n { Unexpected~value~#2 }
            }
            \keyval_parse:nnn {
              \BNVS_parse:n
            } {
              \BNVS_parse:nn
            } { ##1 }
            \BNVS_end:
          }
          \BNVS:nn
        } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/KEY=VALUE}, noigre}
% \BNVS_parse:nn { X } { FIRST: }
% \BNVS_get:nniTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \BNVS_parse:nn { X } { FIRST::LENGTH }
% \BNVS_get:nniTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \BNVS_DEBUG_log_gprop:n { 100 }
% \BNVS_get:nniTF L { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LENGTH } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/L }
% }
% \BNVS_parse:nn { X } { FIRST:LAST }
% \BNVS_get:nniTF A { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { FIRST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/A }
% }
% \BNVS_get:nniTF Z { ?!X } { a } {
%   \assert_equal:xxn { \l__bnvs_a_tl } { LAST } {1}
% } {
%   \test_fail:n { MISSING~KEY~?!X/Z }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \BNVS_tl_if_empty:iTF { n } {
            \BNVS_parse_record:vn
          } {
            \BNVS_n_parse_record:vn
          }
          { key } { #2 }
          \use_none_delimit_by_s_stop:w
        }
      }
      #2 \s_stop
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Empty value given: remove the reference.
% \begin{bnvs.test}{bnvs:cn={parse:nn}{/empty~value}, noigre}
%   \BNVS_range:nnnn { ?!X } { 1 } { 2 } { }
%   \clist_map_inline:nn { A, L, Z } {
%     \BNVS_tl_set:in { a } { ?!X/#1 }
%     \BNVS_get:nniF { #1 } { ?!X } { b } {
%       \test_fail:n { Missing~key~\l__bnvs_a_tl }
%    }
%  }
%   \BNVS_parse:nn {X} {}
%   \clist_map_inline:nn { A, L, Z } {
%     \BNVS_tl_set:in { a } { ?!X/#1 }
%     \BNVS_get:nniT { #1 } { ?!X } { b } {
%       \test_fail:n { Unexpected~key~\l__bnvs_a_tl }
%    }
%  }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/1... }
\BNVS_DEBUG_log_tl:c { key }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_tl_if_empty:iTF { n } {
        \BNVS_gclear:v
      } {
        \BNVS_n_gremove:v
      }
      { key }
    }
  } {
    \BNVS_error:n { Invalid~key:~#2 }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We export \cs{l__bnvs_id_last_tl}:
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_parse_nn:nn { ... } { ...REMOVE/2... }
\BNVS_DEBUG_log_tl:c { key }
\BNVS_DEBUG_log_tl:c { id }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_end_tl_set:ii { id_last } { id_last }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_parse_prepare:N, noigre}
% \BNVS_tl_set:in { a } {A[B]C}
% \BNVS_parse_prepare:N \l__bnvs_a_tl
% \assert_equal:xxn { \tl_to_str:V \l__bnvs_a_tl } { \tl_to_str:n { A {{B}} C } } {1}
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { parse_prepare:N } #1 {
  \tl_set:Nx #1 #1
  \bool_set_false:N \l__bnvs_parse_bool
  \bool_do_until:Nn \l__bnvs_parse_bool {
    \tl_if_in:NnTF #1 {%---[
    ]} {
      \regex_replace_all:nnNF { \[ ([^\]%---)
      ]*%---[(
      ) \] } { { { \1 } } } #1 {
        \bool_set_true:N \l__bnvs_parse_bool
      }
    } {
      \bool_set_true:N \l__bnvs_parse_bool
    }
  }
  \tl_if_in:NnTF #1 {%---[
  ]} {
    \BNVS_error:n { Unbalanced~%---[
    ]}
  } {
    \tl_if_in:NnT #1 { [%---]
    } {
      \BNVS_error:n { Unbalanced~[ %---]
      }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{
%   bnvs:cn={parse:nn}{/+\token_to_str:N\BNVS_item:n}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \BNVS_provide_off:
%   \banner:n { #5 }
%   \BNVS_parse:nn {X} {#1}
%   \assert_equal:xxn {\BNVS_item:nn A {?!X} } {#2} {#5-a}
%   \assert_equal:xxn {\BNVS_item:nn Z {?!X} } {#3} {#5-c}
%   \assert_equal:xxn {\BNVS_item:nn L {?!X} } {#4} {#5-b}
%   \BNVS_provide_on:
%   \clist_map_inline:nn {D, D:E, D::F, :E::F} {
%     \BNVS_parse:nn {X} { ##1 }
%     \assert_equal:xxn {\BNVS_item:nn A {?!X} } {#2} {#5-a(##1)}
%     \assert_equal:xxn {\BNVS_item:nn Z {?!X} } {#3} {#5-c(##1)}
%     \assert_equal:xxn {\BNVS_item:nn L {?!X} } {#4} {#5-b(##1)}
%  }
% }
% \BNVS_Test:nnnnn {A:   } {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B  } {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C } {A} { \exp_not:N \q_nil } {C} {3}
% \BNVS_Test:nnnnn {:B::C} { \exp_not:N \q_nil } {B} {C} {4}
% \end{bnvs.test}
% \begin{bnvs.test}{
%   bnvs:cn={parse:nn}{+\cs{BNVS_item:n}}, noigre
% }
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \BNVS_parse:nn {X.1.2} {#1}
%   \assert_equal:xxn {\BNVS_item:nn A {?!X.1.2} } {#2} {#5-A}
%   \assert_equal:xxn {\BNVS_item:nn Z {?!X.1.2} } {#3} {#5-Z}
%   \assert_equal:xxn {\BNVS_item:nn L {?!X.1.2} } {#4} {#5-L}
% }
% \BNVS_Test:nnnnn {A:} {A} {} {} {1}
% \BNVS_Test:nnnnn {A:B} {A} {B} { \exp_not:N \q_nil } {2}
% \BNVS_Test:nnnnn {A::C} {A} { \exp_not:N \q_nil } {C} {3}
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={parse:n}{/:nn}, noigre}
% \cs_set:Npn \BNVS_Test:nnnnn #1 #2 #3 #4 #5 {
%   \banner:n { #5 }
%   \BNVS_if_in:nnTF A {?!X.#5} {
%     \assert_equal:xxn {\BNVS_item:nn A {?!X.#5} } {#1} {#4-a}
%     \assert_equal:xxn {\BNVS_item:nn Z {?!X.#5} } {#2} {#4-b}
%     \assert_equal:xxn {\BNVS_item:nn L {?!X.#5} } {#3} {#4-c}
%   } {
%     \BNVS_if_in:nnTF V {?!X.#5} {
%       \assert_equal:xxn {\BNVS_item:nn V {?!X.#5} } {#1} {#4-v}
%     } {
%       \test_fail:n {#4-F}
%     }
%   }
% }
% \BNVS_parse:nn {X.3} {::C:B}
% \BNVS_parse:nn {X.3} {{A:,A:B,A::C,:B::C,::C:B, D}}
% \BNVS_Test:nnnnn {A} {} {} {4-1} {3.1}
% \BNVS_Test:nnnnn {A} {B} { \exp_not:N \q_nil } {4-2} {3.2}
% \BNVS_Test:nnnnn {A} { \exp_not:N \q_nil } {C} {4-3} {3.3}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-4} {3.4}
% \BNVS_Test:nnnnn { \exp_not:N \q_nil } {B} {C} {4-5} {3.5}
% \BNVS_Test:nnnnn {D} {} {} {4-6} {3.6}
% \cs_undefine:N \BNVS_Test:nnnnn
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={parse:...}{[...]}, noigre}
% \end{bnvs.test}
% \begin{function}{\Beanoves}
%   \begin{syntax}
%     \cs{Beanoves} \marg{key--value list}
%   \end{syntax}
%   The keys are the slide overlay references.
% When no value is provided, it defaults to |1|.
% On the contrary, \meta{key--value} items are parsed by \cs{BNVS_parse:nn}.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_tl_put_right:ii #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_tl_put_right:in { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_v_gput:nc #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_v_gput:nn { #1 }
  } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \Beanoves { sm } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { \token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_arg:nn { IN } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF \@currenvir {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We are most certainly in the preamble,
% record the definitions globally for later use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \seq_gput_right:Nn \g__bnvs_def_seq { #2 }
  } {
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, clear everything.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_gclear:
    }
    \BNVS_begin:
    \BNVS_tl_clear:i { root }
    \int_zero:N \l__bnvs_int
    \BNVS_tl_set:in { a } { #2 }
    \tl_if_eq:NnT \@currenvir { document } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% At the top level, use the global definitions.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \seq_if_empty:NF \g__bnvs_def_seq {
        \BNVS_tl_put_left:cx { a } {
          \seq_use:Nn \g__bnvs_def_seq , ,
        }
      }
    }
    \BNVS_parse_prepare:N \l__bnvs_a_tl
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ...\token_to_str:N \Beanoves \IfBooleanT {#1} { * }... }
\BNVS_DEBUG_log_tl:c { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \IfBooleanTF {#1} {
      \BNVS_provide_on:
    } {
      \BNVS_provide_off:
    }
    \BNVS_tl_use:ni {
      \keyval_parse:nnn { \BNVS_parse:n } { \BNVS_parse:nn }
    } { a }
    \BNVS_end_tl_set:ii { id_last } { id_last }
    \ignorespaces
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% If we use the frame \texttt{beanoves} option, we can provide default values
% to the various name ranges.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\define@key{beamerframe}{beanoves}{\Beanoves*{#1}}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Scanning named overlay specifications}
% Patch some beamer commands to support |?(...)| instructions in overlay specifications.
% \begin{function}{\beamer@frame, \beamer@masterdecode}
% \begin{syntax}
% \cs{beamer@frame} \marg{overlay specification}
% \cs{beamer@masterdecode} \marg{overlay specification}
% \end{syntax}
% Preprocess \meta{overlay specification} before \pkg{beamer} reads it.
% \begin{variable}{\l__bnvs_ans_tl}
%   Storage for the translated overlay specification, where |?(...)| instructions are replaced by their static counterparts.
% \end{variable}
% \end{function}
% Save the original macro \cs{beamer@masterdecode} and then override it
% to properly preprocess the argument.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_set_eq:NN \BNVS_beamer@frame \beamer@frame
\cs_set:Npn \beamer@frame < #1 > {
  \BNVS_begin:
  \BNVS_tl_clear:i { ans }
  \BNVS_scan:nNi { #1 } \BNVS_eval:ni { ans }
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_beamer@frame <
  } { ans } >
}
\cs_set_eq:NN \BNVS_beamer@masterdecode \beamer@masterdecode
\cs_set:Npn \beamer@masterdecode #1 {
  \BNVS_begin:
  \BNVS_tl_clear:i { ans }
  \BNVS_scan:nNi { #1 } \BNVS_eval:ni { ans }
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_beamer@masterdecode
  } { ans }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{\BNVS_scan:nNi}
% \begin{syntax}
% \cs{BNVS_scan:nNi} \marg{named overlay expression} \meta{eval} \meta{tl core}
% \end{syntax}
% Scan the \meta{named overlay expression} argument and feed the \meta{tl variable} replacing |?(...)| instructions by their static counterpart
% with help from the \meta{eval} function, which is \cs{BNVS_eval:nN}.
% A group is created to use local variables:
% \begin{variable}{\l__bnvs_ans_tl}
% The token list that will be appended to \meta{tl variable} on return.
% \end{variable}
% \begin{variable}{\l__bnvs_int}
% Store the depth level in parenthesis grouping used when finding
%     the proper closing parenthesis balancing the opening parenthesis that
%     follows immediately a question mark in a \texttt{?(...)} instruction.
% \end{variable}
% \begin{variable}{\l__bnvs_query_tl}
% Storage for the overlay query expression to be evaluated.
% \end{variable}
% \begin{variable}{\l__bnvs_token_seq}
% The \meta{overlay expression} is split into the sequence of its tokens.
% \end{variable}
% \begin{variable}{\l__bnvs_token_tl}
% Storage for just one token.
% \end{variable}
% \end{function}
% Next are helpers.
% \begin{function}{
%   \BNVS_scan_question:T
% }
% \begin{syntax}
% \cs{BNVS_scan_question:T} \marg{code}
% \end{syntax}
% At top level state, scan the tokens of the
% \meta{named overlay expression} looking for a `|?|' character.
% If a `|?(...)|' is found, then the \meta{code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { scan_question:T } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { scan_question:T } { }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_seq_pop_left:iiT { token } { token } {
    \BNVS_tl_if_eq:vnTF { token } { ? } {
      \BNVS_scan_require_open:
      #1
    } {
      \BNVS_tl_put_right:ii { ans } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}    }
    }
    \BNVS_scan_question:T { #1 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_scan_require_open:
% }
% \begin{syntax}
% \cs{require_open:}
% \end{syntax}
% We just found a `|?|',
% we first gobble tokens until the next `|(|', ^^A ---)
% whatever they may be. In general, no tokens should be silently ignored.
% \end{function}
%    \begin{macrocode}
\BNVS_new:bpn { scan_require_open: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { scan_require_open: } { }
%</!final>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_seq_pop_left:iiTF { token } { token } {
    \tl_if_eq:NnTF \l__bnvs_token_tl { ( %)
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found the `|(|` after the `|?|'. ^^A---)
% Set the parenthesis depth to 1 (on first passage).
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_int_set:cn { } { 1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Record the forthcomming content in
% the \cs{l__bnvs_query_tl} variable, ^^A(---
% up to the next balancing `|)|`.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_tl_clear:i { query }
        \BNVS_scan_require_close:
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Ignore this token and loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_scan_require_open:
      }
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% End reached but no opening parenthesis found, raise.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_fatal:x {Missing~'('%---)
      ~after~a~? }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_scan_require_close:
% }
% \begin{syntax}
% \cs{require_close:}
% \end{syntax}
% We found a `|?(|', we record the forthcomming content in the |query| variable,
% up to the next balancing `|)|`.
% \end{function}
%    \begin{macrocode}
\BNVS_new:bpn { scan_require_close: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { scan_require_close: } { }
%</!final>
% \end{bnvs.gobble}
% Get next token.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_seq_pop_left:iiTF { token } { token } {
    \BNVS_tl_if_eq:vnTF { token } { ( %---)
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a `|(|', ^^A---)
% increment the depth and append the token to |query|,
% then scan again for a^^A---(
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_int_incr:c { }
      \BNVS_tl_put_right:ii { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_scan_require_close:
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is not a `|(|'.^^A---)
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_tl_if_eq:vnTF { token } { %(---
        )
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We found a balancing ^^A(---
% `|)|', we decrement and test the depth.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_int_decr:c {}
        \int_compare:nNnTF { \BNVS_int_use:c {} } = 0 {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth level has reached 0: we found our balancing parenthesis
% of the |?(...)| instruction.
% We can append the evaluated slide ranges token list to |ans|
% and look for the next |?|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The depth has not yet reached level 0. ^^A(---
% We append the `|)|' to |query| because it is not yet the
% end of sequence marker.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \BNVS_tl_put_right:ii { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \BNVS_scan_require_close:
        }
      } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The scanned token is not a `|(|' nor a `|)|',
% we append it as is to |query|
% and look for a balancing^^A(---
% |)|.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_tl_put_right:ii { query } { token }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_scan_require_close:
      }
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Above ends the code for Not a  `|(|'. ^^A---)
% We reached the end of the sequence and the token list with no closing ^^A(---
% `|)|'.
% We raise and terminate.
% As recovery we feed |query| with the missing ^^A(---
% `|)|'.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_error:x { Missing~%(---
      `)' }
    \BNVS_tl_put_right:ix { query } {
      \prg_replicate:nn { \l__bnvs_int } {%(---
      )}
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c={scan:nNi}, noigre}
% \cs_set:Npn \BNVS_TEST_eval:ni #1 #2 {
%   \BNVS_tl_put_right:in { #2 } { !(#1) }
% }
% \BNVS_tl_clear:i { a }
% \BNVS_scan:nNi {1+1} \BNVS_TEST_eval:ni { a }
% \BNVS_scan:nNi {?(A)} \BNVS_TEST_eval:ni { a }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 {
%   \banner:n { Test:~scan/#3/#1/}
%   \BNVS_tl_clear:i { a }
%   \BNVS_scan:nNi { #1 } \BNVS_TEST_eval:ni { a }
%   \assert_equal_tl:vnn { a } { #2 } { #3 }
% }
% \BNVS_Test:nnn {} {} {1}
% \BNVS_Test:nnn {1+1} {1+1} {2}
% \BNVS_Test:nnn {1?(+)1} {1!(+)1} {3}
% \BNVS_Test:nnn {1?(+((X)(X))-)1} {1!(+((X)(X))-)1} {4}
% \cs_undefine:N \BNVS_TEST_eval:ni
% \cs_undefine:N \BNVS_Test:nnn
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { scan:nNi } #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_ensure_signed:nN { in } #2
\BNVS_DEBUG_log_set:bn { scan:nNi } {
  \BNVS_DEBUG_log_arg:nn { WHAT } { #1 }
  \BNVS_DEBUG_log_cs:nN { CMD } #2
  \BNVS_DEBUG_log_arg:nc { IN } { #3 }
}
\BNVS_DEBUG_log_scan_nNc:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_set:bpn { fatal:x } ##1 {
    \msg_fatal:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \BNVS_set:bpn { error:x } ##1 {
    \msg_error:nnx { beanoves } { :n }
      { \tl_to_str:n { #1 }:~##1}
  }
  \BNVS_tl_set:in { scan } { #1 }
  \BNVS_tl_clear:i { ans }
  \BNVS_seq_clear:i { token }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Explode the \meta{named overlay expression} into a list of individual tokens:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:nnN { } { #1 } \l__bnvs_token_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Run the top level loop to scan for a `|?|' character:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_scan_question:T {
    \BNVS_tl_use_n:ni { #2 { ans } } { query }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { ans }
\BNVS_DEBUG_tl:i { query }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  }
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_tl_put_right:in { #3 }
  } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_scan_nNc:nn { ... } { ...DONE }
\BNVS_DEBUG_tl:i { #3 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Resolution}
%
% Given a name, a frame id and an integer path,
% we resolve any intermediate standalone reference.
% For example, with |A=B| and |B=C|, |A| is resolved in |C|.
% But with |A=B+1| and |B=C|, |A| is not resolved in |C+1|.
% With |A=B:D| and |B=C|, |A| is not resolved in |C:D| as well.
%
% \begin{function}[TF]{
%   \BNVS_kip:ccc
% }
% \begin{syntax}
% \cs{BNVS_kip:cccTF} \marg{key} \marg{id} \marg{path} \marg{yes code} \marg{no code}
% \end{syntax}
% Auxiliary function. On input,
% the \meta{key} variable contains a set name whereas
% the \meta{id} contains a frame id.
% If \meta{key} contents is a recorded key, on return,
% it is the resolved name,
% \meta{id} contains the used frame id and
% the \marg{path} sequence variable is prepended with new dotted path components,
% \meta{yes code} is executed.
% Otherwise |key|, |id| and |path| sequence are left unchanged
% and \meta{no code} is executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_kip_export:nnnccc #1 #2 #3 #4 #5 #6 {
  \BNVS_end:
  \tl_if_empty:nTF { #2 } {
    \BNVS_tl_set:in { #4 } { #1 }
    \BNVS_tl_put_left:cv { #4 } { #5 }
  } {
    \BNVS_tl_set:in { #4 } { #1 }
    \BNVS_tl_set:in { #5 } { #2 }
  }
  \BNVS_seq_set_from_flat:cn { #6 } { #3 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_kip_export:iiiccc #1 #2 #3 {
  \PROBLEM
  \BNVS_seq_use_n:ni {
    \BNVS_tl_use_n:ni {
      \BNVS_tl_use_n:Ni \BNVS_end_kip_export:nnnccc { #1 }
    } { #2 }
  } { #3 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_kip_export:ccc {
  \exp_args:Nnnx \BNVS_tl_use:ni {
    \BNVS_tl_use:Ni \BNVS_end_kip_export:nnnccc { key }
  } { id } {
    \BNVS_seq_use:in { path } { \q__bnvs }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { match_pop_kip: } { T, F, TF } {
  \BNVS_match_pop_left:iTF { key } {
    \BNVS_match_pop_left:iTF { key } {
      \BNVS_match_pop_left:iTF { id } {
        \BNVS_match_pop_left:iTF { path } {
          \BNVS_seq_set_split:inv { path } { . } { path }
          \BNVS_seq_remove_all:vn { path } { }
          \prg_return_true:
        } {
          \prg_return_false:
        }
      } {
        \prg_return_false:
      }
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip:ccc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip:cccTF } {
  \BNVS_DEBUG_log_tl:c  { #1 }
  \BNVS_DEBUG_log_tl:c  { #2 }
  \BNVS_DEBUG_log_seq:i { #3 }
}
\BNVS_DEBUG_log_kip_cccTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_extract_once:NiTF \c__bnvs_A_key_Z_regex { #1 } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is a correct key, update the path sequence accordingly.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_match_pop_kip:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_cccTF:nn { } {...ID...}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_end_kip_export:ccc { #1 } { #2 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_cccTF:nn {...} {...TRUE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_cccTF:nn {...} {...UNREACHABLE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_cccTF:nn {...} {...FALSE/NOT~A~KEY}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_if_kip_resolve:n,
% }
% \begin{syntax}
% \cs{BNVS_if_kip_resolve:nTF} \mark{key} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
%
% \begin{function}[TF]{
%   \BNVS_kip_n_path_resolve:,
%   \BNVS_kip_x_path_resolve:,
% }
% \begin{syntax}
% \cs{BNVS_kip_n_path_resolve:TF} \marg{yes code} \marg{no code}
% \cs{BNVS_kip_x_path_resolve:TF} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% \marg{yes code} will be executed once resolution has occurred,
% \marg{no code} otherwise.
% The |key| and |id| variables as well as the |path| sequence
% are meant to contain proper information on input and on output as well.
% On input, |key| contains a slide range name, 
% |id| contains a frame id and the |path| sequence
% contains the components of a dotted path, possibly empty.
% On return, the variable |key| contains the resolved range name,
% |id| contains the frame id used and the |path| sequence contains
% the sequence of dotted path components that could not be resolved.
%
% To resolve one level of a named one slide specification like
% \meta{qualified name}.\meta{i_1}...\meta{i_n}, we replace
% the longest \meta{qualified name}.\meta{i_1}...\meta{i_k} where 0$≤$k$≤$n
% by its definition \meta{qualified name'}.\meta{j_1}...\meta{j_p}
% if any.
%
% \begin{enumerate}
% \item If the ``|key|'' tl variable contains the name of an unlimited range,
% and the first item of this range is exactly another name range with
% eventually a heading frame identifier or a trailing integer path,
% then the ``|key|'' tl variable is replaced by this name,
% the ``|id|'' variable is uodated accordingly and
% the ``|path|'' seq variable is prepended with the integer path.
% \item If the ``|path|'' seq variable is not empty,
% append it to the right of the ``|key|'' tl variable after a separating dot,
% all its left elements but the last one and loop.
% Otherwise return.
%
% In the |_n| variant, the resolution is driven only when there is a non empty
% dotted path.
%
% In the |_x| variant, the resolution is driven one step further:
% if the ``|path|'' seq variable is empty, \meta{name tl var} can contain anything,
% including an integer for example.
% \end{enumerate}
% \begin{function}{
%   \BNVS_kip_x_path_resolve:TFF
% }
% \begin{syntax}
% \cs{BNVS_kip_x_path_resolve:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{bnvs.test}{bnvs:c={kip_n_path_resolve:TF}, noigre}
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { } { X } { } { 1A }
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { 1 } { X } { 1 } { 2A }
% \Test_kip_n_path_resolve:nnnnnn { X } { X } { 1.2.3 } { X } { 1.2.3 } { 3A }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y } { X } { } { X } { } { 1B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y } { X } { 1.2.3 } { Y } { 1.2.3 } { 2B' }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { } { X } { } { 3B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y,Y=Z, Z } { X } { 1.2.3 } { Z } { 1.2.3 } { 4B }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1 } { Y } { } { 1C' }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2 } { Y } { } { 2C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2 } { Y } { 2 } { 3C }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, X.1.2=Z, Z } { X } { 1.2 } { Z } { } { 3C' }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y } { X } { 1.2.3 } { Y } { 2.3 } { 4C }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3 } { Y } { 3 } { 5C }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y } { X } { 1.2.3.4 } { Y } { 3.4 } { 6C }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2.3.4=Z, Z } { X } { 1.2.3.4 } { Z } { } { 7A }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2.3=Z } { X } { 1.2.3.4 } { Z } { 4 } { 7B }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7C }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y.1=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7D }
% \Test_kip_n_path_resolve:nnnnnn { X=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 1.2.3.4 } { 7E }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7F }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7G }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y.2=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7H }
% \Test_kip_n_path_resolve:nnnnnn { X.1=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 2.3.4 } { 7I }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7J1 }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { Y } { 3.4 } { 7J2 }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y.3=Z, Z } { X } { 1.2.3.4 } { Z } { 4 } { 7K }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2=Y, Y=Z, Z } { X } { 1.2.3.4 } { Z } { 3.4 } { 7L }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2.3=Y, X.1.2=Z, Z } { X } { 1.2.3.4 } { Y } { 4 } { 8A }
% \Test_kip_n_path_resolve:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Y } { } { 9A' }
% \end{bnvs.test}
%
% \begin{bnvs.test}{bnvs:c={kip_x_path_resolve:TF}, noigre}
% \Test_x_path_resolve:nnnnnn { X.1=Y } { X } { 1 } { Y } { } { 1C }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y=12 } { X } { 1 } { 12 } { } { 1C' }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y=123 } { X } { 1.2 } { 123 } { } { 2C }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2 = 1234 } { X } { 1.2 } { 1234 } { } { 3C }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3=12 } { X } { 1.2.3 } { 12 } { } { 5C }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 6C }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2.3.4=Z, Z = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7A }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2.3=Z, Z.4 = 123 } { X } { 1.2.3.4 } { 123 } { } { 7B }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1.2=Z, Z.3.4=34 } { X } { 1.2.3.4 } { 34 } { } { 7C }
% \Test_x_path_resolve:nnnnnn { X=Y, Y.1=Z, Z.2.3.4 = 234} { X } { 1.2.3.4 } { 234 } { } { 7D }
% \Test_x_path_resolve:nnnnnn { X=Y, Y=Z,Z.1.2.3.4 = 1234 } { X } { 1.2.3.4 } { 1234 } { } { 7D }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7E }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2.3=Z, Z.4=4 } { X } { 1.2.3.4 } { 4 } { } { 7F }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y.2=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7G }
% \Test_x_path_resolve:nnnnnn { X.1=Y, Y=Z, Z.2.3.4 = 234 } { X } { 1.2.3.4 } { 234 } { } { 7H }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=Z } { X } { 1.2.3.4 } { Z } { } { 7I1 }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3.4=123 } { X } { 1.2.3.4 } { 123 } { } { 7I2 }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y.3=Z, Z.4 = 4, } { X } { 1.2.3.4 } { 4 } { } { 7J }
% \Test_x_path_resolve:nnnnnn { X.1.2=Y, Y=Z, Z.3.4 = 34 } { X } { 1.2.3.4 } { 34 } { } { 7K }
% \Test_x_path_resolve:nnnnnn { X.1.2.3=Y, X.1.2=Z, Y.4=4 } { X } { 1.2.3.4 } { 4 } { } { 8A }
% \Test_x_path_resolve:nnnnnn { X.1.2.3=Y, Y=Z } { X } { 1.2.3 } { Z } { } { 9A }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve:TFF } #1 #2 {
  \BNVS_kip_x_path_resolve:TF {
    \BNVS_seq_if_empty:iTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables:
% \begin{itemize}
% \item \cs{l__bnvs_a_tl} contains the name with a partial index path currently resolved.
% \item \cs{l__bnvs_a_seq} contains the index path components currently resolved.
% \item \cs{l__bnvs_b_tl} contains the resolution.
% \item \cs{l__bnvs_b_seq} contains the index path components to be resolved.
% \end{itemize}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { end_kip_export: } {
  \exp_args:Nnnx
  \BNVS_tl_use:ni {
    \BNVS_tl_use:Ni \BNVS_end_kip_export:nnnccc { key }
  } { id } {
    \BNVS_seq_use:in { path } { \q__bnvs }
  } { key } { id } { path }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve:nFF } #1 #2 #3 {
  \BNVS_get:nvcTF #1 { a } { b } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_kip:cccTF { b } { id } { path } {
      \BNVS_tl_set_eq:ii { key } { b }
      \BNVS_seq_merge:cc { path } { b }
      \BNVS_seq_clear:i { b }
      \BNVS_seq_set_eq:vv { a } { path }
      \BNVS_kip_x_path_resolve_loop_or_end_return:
    } {
      \BNVS_seq_if_empty:iTF { b } {
        \BNVS_tl_set_eq:ii { key } { b }
        \BNVS_seq_clear:i { path }
        \BNVS_seq_clear:i { a }
        \BNVS_kip_x_path_resolve_loop_or_end_return:
      } {
        #2
      }
    }
  } {
    #3
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve_VALZ_loop_or_end_return:F } #1 {
  \BNVS_kip_x_path_resolve:nFF V { #1 } {
    \BNVS_kip_x_path_resolve:nFF A { #1 } {
      \BNVS_kip_x_path_resolve:nFF L { #1 } { #1 }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve_end_return_true: } {
  \BNVS_seq_pop_left:iiTF { path } { a } {
    \BNVS_seq_if_empty:iTF { path } {
      \BNVS_tl_clear:i { b }
      \BNVS_index_can:vTF { key } {
        \BNVS_index_append:vvcTF { key } { a } { b } {
          \BNVS_tl_set:vv { key } { b }
        } {
          \BNVS_tl_set:vv { key } { a }
        }
      } {
        \BNVS_tl_set:vv { key } { a }
      }
    } {
      \BNVS_error:x { Path~too~long~.\BNVS_tl_use:i { a }
        .\BNVS_seq_use:in { path } . }
    }
  } {
    \BNVS_V_resolve:vvT { key } { key } {}
  }
  \BNVS_end_kip_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_x_path_resolve: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip_x_path_resolve:TF } {
  \BNVS_DEBUG_log_tl:c { key }
  \BNVS_DEBUG_log_tl:c { id }
  \BNVS_DEBUG_log_seq:i { path }
}
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_seq_set_eq:vv { a } { path }
  \BNVS_seq_clear:i { b }
  \BNVS_kip_x_path_resolve_loop_or_end_return:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve_loop_or_end_return: } {
  \BNVS_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... }  { ...LOOP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_tl_set_eq:ii { a } { key }
    \BNVS_seq_if_empty:iTF { a } {
      \BNVS_kip_x_path_resolve_VALZ_loop_or_end_return:F {
        \BNVS_kip_x_path_resolve_end_return_true:
      }
    } {
      \BNVS_tl_put_right:ix { a } { . \BNVS_seq_use:in { a } . }
      \BNVS_kip_x_path_resolve_VALZ_loop_or_end_return:F {
        \BNVS_seq_pop_right:ccT { a } { c } {
          \BNVS_seq_put_left:vv { b } { c }
        }
        \BNVS_kip_x_path_resolve_loop_or_end_return:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_x_path_resolve_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_b_or_end_return: } {
  \BNVS_kip:cccTF { b } { id } { path } {
    \BNVS_tl_set_eq:ii { key } { b }
    \BNVS_seq_merge:cc { path } { b }
    \BNVS_seq_set_eq:vv { a } { path }
    \BNVS_seq_clear:i { b }
    \BNVS_kip_n_path_resolve_loop_or_end_return:
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% This is not a key, if this is |nil| we already have computed something
% otherwise we can evaluate the content normally, when not empty. 
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_tl_if_empty:iTF { b } {
      \BNVS_seq_pop_right:ccTF { a } { c } {
        \BNVS_seq_put_left:vv { b } { c }
        \BNVS_kip_n_path_resolve_loop_or_end_return:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...Unknown~key... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_kip_n_path_resolve_end_return_true:
      }
    } {
      \BNVS_if_resolve:iiTF { b } { a } {
        \BNVS_end_tl_put_right:ii { ans } { a }
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...Unknown~key... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_kip_n_path_resolve_end_return_false:
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_error_end_return_false:n #1 {
  \BNVS_error:x { #1 }
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_unreachable_return_false:n #1 {
  \BNVS_error_end_return_false:n { UNREACHABLE/#1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_or_end_return:nF } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...RESOLUTION/#1... }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_get:nvcTF { #1 } { a } { b } {
    \BNVS_quark_if_nil:iTF { b } {
      \BNVS_cache_get:nvcTF { #1 } { a } { b } {
        \BNVS_kip_n_path_resolve_b_or_end_return: 
      } {
        \BNVS_error_end_return_false:n { Circular~definition... }
      }
    } {
      \BNVS_kip_n_path_resolve_b_or_end_return:
    }
  } {
    #2
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_VALZ_loop_or_end_return: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...VALZ... }
\BNVS_DEBUG_log_tl:c { b }
\BNVS_DEBUG_log_seq:i { b }
\BNVS_DEBUG_log_tl:c { a }
\BNVS_DEBUG_log_seq:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_kip_n_path_resolve_or_end_return:nF V {
    \BNVS_kip_n_path_resolve_or_end_return:nF A {
      \BNVS_kip_n_path_resolve_or_end_return:nF L {
        \BNVS_kip_n_path_resolve_or_end_return:nF Z {
          \BNVS_seq_pop_right:ccTF { a } { c } {
            \BNVS_seq_put_left:vv { b } { c }
            \BNVS_kip_n_path_resolve_loop_or_end_return:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...Unknown~key... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \BNVS_kip_n_path_resolve_end_return_true:
          }
        }
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_end_return_false: } {
  \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_end_return_true: } {
  \BNVS_end_kip_export:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_kip_n_path_resolve_loop_or_end_return:
% }
% Loop to resolve the path.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { kip_n_path_resolve_loop_or_end_return: } {
  \BNVS_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...LOOP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_tl_set_eq:ii { a } { key }
    \BNVS_seq_if_empty:iF { a } {
      \BNVS_tl_put_right:ix { a } { . \BNVS_seq_use:in { a } . }
    }
    \BNVS_kip_n_path_resolve_VALZ_loop_or_end_return:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_kip_n_path_resolve:
% }
% This is the entry point to resolve the path.
% Local variables:
% \begin{itemize}
% \item |key|, |id| and |path| sequence contain the resolution.
% \item |a| contains the name with a partial dotted path currently resolved.
% \item |a| sequence contains the dotted path components to be resolved.
% It equals |path| sequence at the beginning 
% \item |b| is used as well to store the dotted components that were not resolved.
% Initially empty.
% \end{itemize}
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...kip_if_resolve_end_export:
%    \begin{macrocode}
\BNVS_new:bpn { kip_if_resolve_end_export: } {
  \BNVS_seq_pop_right:ccTF { a } { c } {
    \BNVS_seq_put_left:vv { b } { c }
    \BNVS_kip_if_resolve_end_return:
   } {
    \BNVS_end_kip_export:vvvccc { a } { id } { a } { key } { id } { path }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_current:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%^^A:\...kip_if_resolve_end_return:
%    \begin{macrocode}
\BNVS_new:bpn { kip_if_resolve_end_return: } {
  \BNVS_call:TF {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_if_resolve_nTF:nn { ... } { ...LOOP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_tl_set_eq:ii { a } { key }
    \BNVS_seq_if_empty:iF { a } {
      \BNVS_tl_put_right:ix { a } { . \BNVS_seq_use:in { a } . }
    }
    \BNVS_kip_get:vcccTF { a } { a } { id } { a } {
      \BNVS_seq_use:nnc {
        \BNVS_seq_merge:cnn { a } { \q__bnvs }
      } { \q__bnvs } { a }
      \BNVS_kip_if_resolve_end_return:
    } {
      \BNVS_V_resolve:vvTF { a } { c } {
        \BNVS_extract_once:NiTF \c__bnvs_A_key_Z_regex { c } {
          \BNVS_match_pop_left:iTF { key } {
            \BNVS_match_pop_left:iTF { key } {
              \BNVS_match_pop_left:iTF { id } {
                \BNVS_match_pop_left:iTF { path } {
                  \BNVS_seq_set_split:inv { path } { . } { path }
                  \BNVS_seq_remove_all:vn { path } { }
                  \BNVS_kip_gput:vvvv { a } { key } { id } { path }
                  \BNVS_seq_set_eq:vv { a } { path }
                  \BNVS_seq_clear:i { b }
                  \BNVS_kip_if_resolve_end_return:
                } {
                  \BNVS_fatal:n { LOGICALLY_UNREACHABLE_A_key_n_Z/path }
                }
              } {
                \BNVS_fatal:n { LOGICALLY_UNREACHABLE_A_key_n_Z/id }
              }
            } {
              \BNVS_fatal:n { LOGICALLY_UNREACHABLE_A_key_n_Z/key }
            }
          } {
            \BNVS_fatal:n { LOGICALLY_UNREACHABLE_A_key_n_Z }
          }
        } {
          \BNVS_kip_if_resolve_end_export:
        }
      } {
        \BNVS_kip_if_resolve_end_export:
      }
    }
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_kip_if_resolve_nTF:nn { ... } { ...FALSE/TOO~MANY~CALLS }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A:\...kip_if_resolve:TF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_if_resolve: } { T, F, TF } {
    \BNVS_begin:
    \BNVS_tl_set_eq:ii { a } { key }
    \BNVS_seq_if_empty:iF { a } {
      \BNVS_tl_put_right:ix { a } { . \BNVS_seq_use:in { a } . }
    }
    \BNVS_kip_if_resolve_end_return:
}
%    \end{macrocode}
%^^A:\...kip_if_resolve:nTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_if_resolve:n } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip_if_resolve:nTF } {
  \BNVS_DEBUG_arg:nn { KEY } { #1 }
}
\BNVS_DEBUG_log_kip_if_resolve_nTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_kip_get:ncccTF { #1 } { key } { id } { path } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip_if_resolve:nTF } {
  \BNVS_DEBUG_tl:i      { key  }
  \BNVS_DEBUG_tl:i      { id   }
  \BNVS_DEBUG_log_seq:i { path }
}
\BNVS_DEBUG_log_kip_if_resolve_nTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_extract_once:NnTF \c__bnvs_A_key_Z_regex { #1 } {
      \BNVS_match_pop_left:iTF { key } {
        \BNVS_match_pop_left:iTF { key } {
          \BNVS_match_pop_left:iTF { id } {
            \BNVS_match_pop_left:iTF { path } {
              \BNVS_seq_set_split:inv { path } { . } { path }
              \BNVS_seq_remove_all:vn { path } { }
              \BNVS_begin:
              \BNVS_seq_set_eq:vv { a } { path }
              \BNVS_seq_clear:i { b }
              \BNVS_kip_if_resolve_end_return:
            } {
              \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/path }
              \prg_return_false:
            }
          } {
            \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/id }
            \prg_return_false:
          }
        } {
          \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z/key }
          \prg_return_false:
        }
      } {
        \BNVS_error:n { LOGICALLY_UNREACHABLE_A_key_n_Z }
        \prg_return_false:
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip_if_resolve:nTF } {
  \BNVS_DEBUG_tl:i      { key  }
  \BNVS_DEBUG_tl:i      { id   }
  \BNVS_DEBUG_log_seq:i { path }
}
\BNVS_DEBUG_log_kip_if_resolve_nTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { kip_n_path_resolve: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bn { kip_n_path_resolve:TF } {
  \BNVS_DEBUG_tl:i { key }
  \BNVS_DEBUG_tl:i { id   }
  \BNVS_DEBUG_log_seq:i { path }
}
\BNVS_DEBUG_log_kip_n_path_resolve_TF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_seq_set_eq:vv { a } { path }
  \BNVS_seq_clear:i { b }
  \BNVS_kip_n_path_resolve_loop_or_end_return:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Evaluation bricks}
% We start by helpers.
% \begin{function}{
%  \BNVS_round_ans:n,
%  \BNVS_round:c,
%  \BNVS_round_ans:
%}
% \begin{syntax}
% \cs{BNVS_round:c} \meta{tl core name}
% \cs{BNVS_round_ans:}
% \cs{BNVS_round_ans:n} \marg{expression}
% \end{syntax}
% The first function replaces the variable content
% with its rounded floating point evaluation.
% The second function replaces |ans| tl variable content
% with its rounded floating point evaluation.
% The last function appends to the |ans| tl variable
% the rounded floating point evaluation of the argument.
% \end{function}
% \begin{bnvs.test}{bnvs:c={round_ans:n}, noigre}
% \banner:n {1}
% \BNVS_tl_clear:i { ans }
% \BNVS_round_ans:n {11+(1)-111}
% \assert_equal_tl:vnn { ans } { -99 } { 1 }
% \BNVS_round_ans:n { }
% \assert_equal_tl:vnn { ans } { -990 } { 2 }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=round:c, noigre}
% \banner:n {1}
% \BNVS_tl_set:in { a } {11+(1)-111}
% \BNVS_round:c { a }
% \assert_equal:xxn { \l__bnvs_a_tl } { -99 } { 1 }
% \BNVS_tl_clear:i { a }
% \BNVS_round:c { a }
% \assert_equal_tl:vnn { a } { 0 } { 2 }
% \BNVS_tl_set:in { ans } {11+(1)-111}
% \BNVS_round_ans:
% \assert_equal_tl:vnn { ans } { -99 } { 3 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { round_ans:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { round_ans:n } { }
\BNVS_DEBUG_log_arg:nn { IN } { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:nTF { #1 } {
    \BNVS_tl_put_right:in { ans } { 0 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { EMPTY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \BNVS_tl_put_right:ix { ans } { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_tl:nc { OUT } { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { round:N } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_f:nbn { } { round:N } { }
\BNVS_log:x { \token_to_str:N #1 -> / \tl_to_str:V #1 / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \tl_if_empty:NTF #1 {
    \tl_set:Nn #1 { 0 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { EMPTY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  } {
    \tl_set:Nx #1 { \fp_eval:n { round(#1) } }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { OUT -> / \tl_to_str:V #1 / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { round:c } {
  \BNVS_tl_use:Ni \BNVS_round:N
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_end_return_false:,
%   \BNVS_end_return_false:x
% }
% \begin{syntax}
% \cs{BNVS_end_return_false:}
% \cs{BNVS_end_return_false:x} \marg{message}
% \end{syntax}
% End a group and calls \cs{prg_return_false:}.
% The message is for debugging only.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false: {
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \BNVS_end_return_false:x #1 {
  \BNVS_error:x { #1 }
  \BNVS_end_return_false:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_V_resolve:in,
%   \BNVS_V_resolve:ii,
%   \BNVS_V_append:in,
%   \BNVS_V_append:ii
% }
% \begin{syntax}
% \cs{BNVS_V_resolve:NnTF} \meta{tl variable} \marg{key} \marg{yes code} \marg{no code}
% \cs{BNVS_V_append:NnTF} \meta{tl variable} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the content of the \meta{key} value counter
% into the \meta{tl variable} or
% append this value to the right of the variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% Inside the \meta{no code} branch,
% the content of the \meta{tl variable} is undefined.
% Implementation detail: we return the first in the cache for subkey V
% and in the general prop for subkey V.
% Once we have found a value, we feed the previous items
% such that the next search stops at the first item.
% The cache contains an integer which is the computed value from the general prop.
% A group is created while appending but not while resolving.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...end_tl_put_right:ii
%    \begin{macrocode}
\BNVS_new:bpn { end_tl_put_right:ii } #1 #2 {
  \BNVS_tl_use:ni {
    \BNVS_end:
    \BNVS_tl_put_right:in { #2 }
  } { #1 }
}
%    \end{macrocode}
%^^A:\...V_resolve_return:iiiT
%    \begin{macrocode}
\BNVS_new:bpn { V_resolve_return:iiiT } #1 #2 #3 #4 {
  \BNVS_tl_if_empty:iTF { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_resolve_inTF:nn { ... } { ...FALSE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } {
    \BNVS_cache_gput:nni V { #2 } { #3 }
    #4
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_resolve_inTF:nn { ... } { ...TRUE/#1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%^^A:\...V_resolve:inTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { V_resolve:in } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnin { V_resolve:inTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_V_resolve_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF V { #2 } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_resolve_inTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_get:nniTF V { #2 } { #1 } {
      \BNVS_quark_if_nil:iTF { #1 } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% We can retrieve the value from either the first or last index.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_gput_no_value:nn V { #2 }
        \BNVS_A_resolve:inTF { #1 } { #2 } {
          \BNVS_V_resolve_return:iiiT A { #2 } { #1 } {
            \BNVS_gput_nil:ii V { #2 }
          }
        } {
          \BNVS_Z_resolve:inTF { #1 } { #2 } {
            \BNVS_V_resolve_return:iiiT Z { #2 } { #1 } {
              \BNVS_gput_nil:ii V { #2 }
            }
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_resolve_inTF:nn { ... } { ...FALSE/#2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \BNVS_gput_nil:ii V { #2 }
            \prg_return_false:
          }
        }
      } {
        \BNVS_quark_if_no_value:iTF { #1 } {
          \BNVS_fatal:n {Circular~definition:~#2}
        } {
          \BNVS_gput_no_value:nnv V { #2 } { #1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Possible recursive call.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          \BNVS_if_resolve:iiTF { #2 } { #2 } {
            \BNVS_V_resolve_return:iiiT V { #1 } { #2 } {
              \BNVS_gput_nil:ii V { #1 }
            }
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_resolve_inTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \BNVS_gput_nil:ii V { #1 }
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_gprop:n {}
\BNVS_DEBUG_log_f:nbn { ... } { V_resolve:inTF } { ...FALSE/RESOLVE }
\BNVS_DEBUG_log_arg:nnnc { UNKNOWN~KEY } { #1 } { IN } { #2 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%^^A:\...V_append:niTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { V_append:in } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnin { V_append:inTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_V_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_V_resolve:inTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #1 } { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_V_append_inTF:nn { ... } { ...TRUE(FAILED) }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_wrap:btn { V_append } { tl } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c=V_append:inTF, noigre}
% \Test_what_append_X_ncTF:nnnn { V } { 222 } { 222 } { 1 }
% \reset:n { YES }
% \BNVS_DEBUG_log_gprop:n { }
% \BNVS_DEBUG_tl:i { ans }
% \BNVS_if_resolve:niF { FIRST } { ans } {
%   \assert_equal_ans:nn { 222 } { NO_WAY }
% }
% \Test_what_append_X_ncTF:nnnn { value } { FIRST } { 222 } { 2 }
% \cs_new:Npn \BNVS_Test:nn #1 #2 {
%   \BNVS_V_resolve:inTF { X } { ans } {
%     \assert_equal_tl:vnn { ans } { #1 } { #2/A }
%     \BNVS_cache_get:nniTF V { X } { ans } {
%       \assert_equal_tl:vnn { ans } { #1 } { #2/B }
%     } {
%       \test_fail:n { #2/C }
%     } 
%   } {
%     \test_fail:n { #2/D }
%   }
% }
% \BNVS_gput:nnn V { X } { 421 }
% \BNVS_Test:nn { 421 } { 1 }
% \BNVS_gclear_all:n { X }
% \BNVS_gput:nnn A { X } { 422 }
% \BNVS_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 422 } { 2 }
% \BNVS_gclear_all:n { X }
% \BNVS_gput:nnn Z { X } { 423 }
% \BNVS_gput:nnn V { X } { \q_nil }
% \BNVS_Test:nn { 423 } { 3 }
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \BNVS_A_resolve:in,
%   \BNVS_A_resolve:ix,
%   \BNVS_A_resolve:iv,
%   \BNVS_A_append:in,
%   \BNVS_A_append:ix,
%   \BNVS_A_append:iv
% }
% \begin{syntax}
% \cs{BNVS_A_resolve:inTF} \marg{tl core} \marg{key} \marg{yes code} \marg{no code}
% \cs{BNVS_A_append:ncTF} \meta{tl core} \marg{key} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the first index of the \meta{key} slide range
% into the \meta{tl core} variable or
% append the first index of the \meta{key} slide range
% to the \meta{tl core} variable.
% If no resolution occurs the content of the
% \meta{tl core} variable is undefined in the first case
% and unmodified in the second.
% Cache the result.
% Execute \meta{yes code} when there is a \meta{first}, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...A_resolve:inTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { A_resolve:in } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnin { A_resolve:inTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_A_resolve_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF A { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_A_resolve:inTF/C, noigre}
% \BNVS_cache_gput:iin A { X } { 421 }
% \BNVS_A_resolve:inTF { ans } { X } {
%   \assert_equal_ans:nn { 421 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_get:nniTF A { #1 } { #2 } {
      \BNVS_quark_if_nil:iTF { #2 } {
        \BNVS_gput_no_value:nn A { #1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The first index must be computed separately from the length and the last index.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...BUILD... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_Z_resolve:inTF { #1 } { #2 } {
          \BNVS_tl_put_right:in { #2 } { - }
          \BNVS_L_append:ncTF { #1 } { #2 } {
            \BNVS_tl_put_right:in { #2 } { + 1 }
            \BNVS_round:c { #2 }
            \BNVS_tl_if_empty:iTF { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
              \BNVS_gput_nil:ii A { #1 }
              \prg_return_false:
            } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_A_resolve:inTF/q_nil-ZL, noigre}
% \BNVS_gput:nnn A { X } { \q_nil }
% \BNVS_gput:nnn Z { X } { 666 }
% \BNVS_gput:nnn L { X } { 445 }
% \BNVS_A_resolve:inTF { ans } { X } {
%   \assert_equal_ans:nn { 222 } { OK }
% } {
%    \test_fail:n { LOST }
% }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
              \BNVS_gput_nil:ii A { #1 }
              \BNVS_cache_gput:nni A { #1 } { #2 }
              \prg_return_true:
            }
          } {
            \BNVS_error:n {
Unavailable~length~for~#1~(\token_to_str:N\BNVS_A_resolve:inTF/2) }
            \BNVS_gput_nil:ii A { #1 }
            \prg_return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\token_to_str:N\BNVS_A_resolve:inTF/1) }
          \BNVS_gput_nil:ii A { #1 }
          \prg_return_false:
        }
      } {
        \BNVS_gput_nil:ii A { #1 }
        \BNVS_quark_if_no_value:iTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \bnvs_gput_no_value:nnv A { #1 } { #2 }
          \BNVS_if_resolve:iiTF { #2 } { #2 } {
            \BNVS_cache_gput:nni A { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_gprop:n {}
\BNVS_DEBUG_log_A_resolve_inTF:nn { ... } { ...FALSE/C^^J Unknown~KEY = / #1 / A / }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%^^A:\...A_append:ncTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { A_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { A_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_A_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_A_resolve:inTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_A_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_A_append:ncTF, noigre}
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1 }
% \Test_what_append_X_ncTF:nnnn { first } { 222: } { 222 } { 1' }
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST: } { 222 } { 2' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST::LENGTH } { 222 } { 3' }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4 }
% \Test_what_append_X_ncTF:nnnn { first } { FIRST:LAST } { 222 } { 4' }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5 }
% \Test_what_append_X_ncTF:nnnn { first } { ::LENGTH:LAST } { 222 } { 5' }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6 }
% \Test_what_append_X_ncTF:nnnn { first } { :LAST::LENGTH } { 222 } { 6' }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%   \BNVS_Z_resolve:in,
%   \BNVS_Z_append:nc
% }
% \begin{syntax}
% \cs{BNVS_Z_resolve:inTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_Z_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the last index of the fully qualified \meta{key} range
% into or to the right of the right of the \meta{tl variable}, when possible.
% Execute \meta{yes code} when a last index was given,
% \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...Z_resolve:inTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { Z_resolve:in } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { Z_resolve:inTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF Z { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }  {
    \BNVS_get:nniTF Z { #1 } { #2 } {
      \BNVS_quark_if_nil:iTF { #2 } {
        \BNVS_gput_no_value:nn Z { #1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The last index must be computed separately from the start and the length.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...A+L... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_A_resolve:inTF { #1 } { #2 } {          
          \BNVS_tl_put_right:in { #2 } { + }
          \BNVS_L_append:ncTF { #1 } { #2 } {
            \BNVS_tl_put_right:in { #2 } { - 1 }
            \BNVS_round:c { #2 }
            \BNVS_cache_gput:nni Z { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \BNVS_gput_nil:ii Z { #1 }
            \prg_return_true:
          } {
            \BNVS_error:x {
 Unavailable~length~for~#1~(\token_to_str:N \BNVS_Z_resolve:inTF/1) }
            \BNVS_gput_nil:ii Z { #1 }
            \prg_return_false:
          }
        } {
          \BNVS_error:x {
Unavailable~first~for~#1~(\token_to_str:N \BNVS_Z_resolve:inTF/1) }
          \BNVS_gput_nil:ii Z { #1 }
          \prg_return_false:
        }
      } {
        \BNVS_quark_if_no_value:iTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \BNVS_if_resolve:iiTF { #2 } { #2 } {
            \BNVS_cache_gput:nni Z { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...TRUE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_Z_resolve:inTF { T, F, TF }
%    \end{macrocode}
%^^A:\...Z_append:ncTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { Z_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { Z_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_Z_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_Z_resolve:inTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_Z_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_Z_append:ncTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{banner=last, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 1 }
% \Test_what_append_X_ncTF:nnnn { last } { :666 } { 666 } { 2 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 3 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST } { 666 } { 4 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 5 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST:LAST } { 666 } { 6 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 7 }
% \Test_what_append_X_ncTF:nnnn { last } { ::LENGTH:LAST } { 666 } { 8 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 9 }
% \Test_what_append_X_ncTF:nnnn { last } { :LAST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 10 }
% \Test_what_append_X_ncTF:nnnn { last } { FIRST::LENGTH } { 666 } { 11 }
% \end{bnvs.test}
% \begin{function}[TF]{\BNVS_L_resolve:ni, \BNVS_L_append:nc}
% \begin{syntax}
% \cs{BNVS_L_resolve:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_L_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the length of the \meta{key} slide range into \meta{tl variable},
% or append the length of the \meta{key} slide range to \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{length}, \meta{no code} otherwise.
% \end{function}
% \begin{bnvs.test}{bnvs:c=append_length:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { L } { ::445 } { 445 } { 1 }
% \Test_what_append_X_ncTF:nnnn { L } { ::445 } { 445 } { 2 }
% \Test_what_append_X_ncTF:nnnn { L } { ::LENGTH } { 445 } { 3 }
% \Test_what_append_X_ncTF:nnnn { L } { ::LENGTH } { 445 } { 4 }
% \Test_what_append_X_ncTF:nnnn { L } { FIRST::LENGTH } { 445 } { 5 }
% \Test_what_append_X_ncTF:nnnn { L } { FIRST::LENGTH } { 445 } { 6 }
% \Test_what_append_X_ncTF:nnnn { L } { ::LENGTH:LAST } { 445 } { 7 }
% \Test_what_append_X_ncTF:nnnn { L } { ::LENGTH:LAST } { 445 } { 8 }
% \Test_what_append_X_ncTF:nnnn { L } { :LAST::LENGTH } { 445 } { 9 }
% \Test_what_append_X_ncTF:nnnn { L } { :LAST::LENGTH } { 445 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=if_resolve:niTF, noigre}
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { A }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:c=if_append:niTF, noigre}
% \Test_if_append:nnnn { 222:666 } { X.last } { 666 } { A }
% \Test_if_append:nnnn { 222:666 } { X.1 } { 222 } { B }
% \Test_if_append:nnnn { 222:666 } { X.last - X.1 } { 444 } { C }
% \Test_if_append:nnnn { 222:666 } { X.last - (X.1) } { 444 } { D }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 0 } { A2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 0 } { B2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 0 } { C2i }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 0 } { D2i }
% \reset:n { Y }
% \Test_if_append:nnnn { FIRST:LAST } { X.last } { 666 } { A2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.1 } { 222 } { B2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - X.1 } { 444 } { C2 }
% \Test_if_append:nnnn { FIRST:LAST } { X.last - (X.1) } { 444 } { D2 }
% \Test_what_append_X_ncTF:nnnn { L } { FIRST:LAST } { 445 } { 11 }
% \Test_what_append_X_ncTF:nnnn { L } { FIRST:LAST } { 445 } { 12 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { L_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { L_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_L_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF L { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_get:nniTF L { #2 } { #1 } {
      \BNVS_quark_if_nil:iTF { #2 } {
        \BNVS_gput_no_value:nn L { #1 }
%    \end{macrocode}
% \end{bnvs.macrocode}
% The length must be computed separately from the start and the last index.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { ... } { ...BUILD... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_Z_resolve:inTF { #1 } { #2 } {
          \BNVS_tl_put_right:in { #2 } { - }
          \BNVS_A_append:ncTF { #1 } { #2 } {
            \BNVS_tl_put_right:in { #2 } { + 1 }
            \BNVS_round:c { #2 }
            \BNVS_gput_nil:ii L { #1 }
            \BNVS_cache_gput:nni L { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
            \BNVS_error:n {
Unavailable~first~for~#1~(\BNVS_L_resolve:niTF/2) }
            \prg_return_false:
          }
        } {
          \BNVS_error:n {
Unavailable~last~for~#1~(\BNVS_L_resolve:niTF/1) }
          \prg_return_false:
        }
      } {
        \BNVS_quark_if_no_value:iTF { #2 } {
          \BNVS_fatal:n {Circular~definition:~#1}
        } {
          \BNVS_if_resolve:iiTF { #2 } { #2 } {
            \BNVS_cache_gput:nni L { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
            \prg_return_false:
          }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_resolve_ncTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_L_resolve:niTF { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { L_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { L_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_L_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_L_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_append_inTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_L_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_L_append:ncTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_range_resolve:ni,
%   \BNVS_range_append:nc,
% }
% \begin{syntax}
% \cs{BNVS_range_resolve:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_range_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the range of the \meta{key} slide range into the \meta{tl variable}
% or append this range to the \meta{tl variable}.
% Execute \meta{yes code} when there is a \meta{range}, \meta{no code} otherwise, in that latter case
% the content the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { range_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { range_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_range_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_A_resolve:inTF { a } { #1 } {
    \BNVS_tl_use:Ni \int_compare:nNnT { a } < 0 {
      \BNVS_tl_set:in { a } { 0 }
    }
    \BNVS_Z_resolve:inTF { #1 } { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from above and below.
% \begin{bnvs.test}{bnvs:cn={range_append:ncTF}{A-Z}, noigre}
% \Test_range_append:nnn { 222:666 } { 222-666 } { 3 }
% \Test_range_append:nnn { 222::445 } { 222-666 } { 4 }
% \Test_range_append:nnn { ::445:666 } { 222-666 } { 5 }
% \Test_range_append:nnn { :666::445 } { 222-666 } { 6 }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST:LAST } { 222-666 } { 3 }
% ^^A\Test_range_append:nnn { FIRST::LENGTH } { 222-666 } { 4 }
% \Test_range_append:nnn { ::LENGTH:LAST } { 222-666 } { 5 }
% \Test_range_append:nnn { :LAST::LENGTH } { 222-666 } { 6 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Ni \int_compare:nNnT { b } < 0 {
        \BNVS_tl_set:in { b } { 0 }
      }
      \BNVS_tl_put_right:in { a } { - }
      \BNVS_tl_put_right:ii { a } { b }
      \BNVS_end_tl_put_right:ii { #2 } { a }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_inTF:nn { ... } { ...TRUE/A-Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from below.
% \begin{bnvs.test}{:N=\BNVS_range_append:ncTF/A-, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { 222 } { 222- } { 1 }
% \Test_range_append:nnn { 222: } { 222- } { 1' }
% \Test_range_append:nnn { 222:: } { 222- } { 1'' }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST } { 222- } { 1 }
% \Test_range_append:nnn { FIRST: } { 222- } { 1' }
% \Test_range_append:nnn { FIRST:: } { 222- } { 1'' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_end_tl_put_right:ii { #2 } { a }
      \BNVS_tl_put_right:in { #2 } { - }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_inTF:nn { ... } { ...TRUE/A- }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \BNVS_Z_resolve:inTF { #1 } { b } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited from above.
% \begin{bnvs.test}{:N=\BNVS_range_append:ncTF/-Z, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { :666 } { -666 } { 1 }
% \reset:n { Y }
% \Test_range_append:nnn { :LAST } { -666 } { 1' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_tl_use:Ni \int_compare:nNnT { b } < 0 {
        \BNVS_tl_set:in { b } { 0 }
      }
      \BNVS_tl_put_left:in { b } { - }
      \BNVS_end_tl_put_right:ii { #2 } { b }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_inTF:nn { ... } { ...TRUE/-Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_V_resolve:inTF { #1 } { b } {
      \BNVS_tl_use:Ni \int_compare:nNnT { b } < 0 {
        \BNVS_tl_set:in { b } { 0 }
      }
%    \end{macrocode}
% \end{bnvs.macrocode}
% Unlimited range.
% \begin{bnvs.test}{:Nn=\BNVS_range_append:ncTF{/:-}, noigre}
% \reset:n { Y }
% \Test_range_append:nnn { 222 } { 222- } { 1 }
% \reset:n { Y }
% \Test_range_append:nnn { FIRST } { 222- } { 1' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_end_tl_put_right:ii { #2 } { b }
        \BNVS_tl_put_right:in { #2 } { - }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_inTF:nn { ... } { ...TRUE/V }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_end:
        \prg_return_false:
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_range_append:ncTF { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { range_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { range_resolve_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_range_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_tl_clear:i { #2 }
  \BNVS_range_append:ncTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_range_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  } 
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_range_resolve:niTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_previous_resolve:ni,
%   \BNVS_previous_append:nc
% }
% \begin{syntax}
% \cs{BNVS_previous_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to the variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the \meta{tl variable} is undefined
% on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\BNVS_previous_append:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { previous } { 222: } { 221 } { 2 }
% \Test_what_append_X_ncTF:nnnn { previous } { 222:: } { 221 } { 3 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST: } { 221 } { 2' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:: } { 221 } { 3' }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5 }
% \Test_what_append_X_ncTF:nnnn { previous } { FIRST:LAST } { 221 } { 5' }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6 }
% \Test_what_append_X_ncTF:nnnn { previous } { ::LENGTH:LAST } { 221 } { 6' }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_previous_append:ncTF, noigre}
% \reset:n { Y }
% \Beanoves { X = :LAST::LENGTH }
% \Test_what_append_X_ncTF:nnnn { last } { } { 666 } { A }
% \Test_what_append_X_ncTF:nnnn { length } { } { 445 } { B }
% \Test_what_append_X_ncTF:nnnn { first } { } { 222 } { C }
% \Test_what_append_X_ncTF:nnnn { previous } {  } { 221 } { 7 }
% \Test_what_append_X_ncTF:nnnn { previous } { :LAST+1::LENGTH } { 222 } { 7' }
% \Beanoves {X=:LAST}
% \BNVS_tl_clear:i { a }
% \BNVS_previous_append:ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \BNVS_tl_clear:i { a }
% \BNVS_previous_append:ncT { ?!X } { a } {
%   \test_fail:n {Unexpected~previous}
% }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { previous_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { previous_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF P { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_A_resolve:inTF { #1 } { #2 } {
      \BNVS_tl_put_right:in { #2 } { -1 }
      \BNVS_round:c { #2 }
      \BNVS_cache_gput:nni P { #1 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_previous_resolve:niTF { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { previous_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { previous_append_ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_previous_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_previous_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_previous_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_previous_append:ncTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_next_resolve:ni,
%   \BNVS_next_append:nc,
% }
% \begin{syntax}
% \cs{BNVS_next_resolve:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_next_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index after the \meta{key} slide range into the \meta{tl variable},
% or append this index to this variable.
% Execute \meta{yes code} when there is a \meta{next} index, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\BNVS_next_append:ncTF, noigre}
% \reset:n { Y }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 1 }
% \Test_what_append_X_ncTF:nnnn { next } { :666 } { 667 } { 2 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 3 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST } { 667 } { 4 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 5 }
% \Test_what_append_X_ncTF:nnnn { next } { FIRST:LAST } { 667 } { 6 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 7 }
% \Test_what_append_X_ncTF:nnnn { next } { ::LENGTH:LAST } { 667 } { 8 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 9 }
% \Test_what_append_X_ncTF:nnnn { next } { :LAST::LENGTH } { 667 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { next_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { next_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_next_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_cache_get:nniTF N { #2 } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...TRUE/CACHED }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_Z_resolve:inTF { #1 } { #2 } {
      \BNVS_tl_put_right:in { #1 } { +1 }
      \BNVS_round:c { #2 }
      \BNVS_cache_gput:nni N { #2 } { #1 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_resolve_ncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_next_append:ncTF { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { next_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { next_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_next_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_next_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_next_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_next_append:ncTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_v_resolve:ni,
%   \BNVS_v_append:nc
% }
% \begin{syntax}
% \cs{BNVS_v_resolve:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_v_append:ncTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the value of the \meta{key} overlay set
% into the \meta{tl variable} or
% append this value to the right of this variable.
% Execute \meta{yes code} when there is a \meta{value}, \meta{no code} otherwise.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only. 
% \end{function}
% \begin{bnvs.test}{:N=\BNVS_v_resolve:niTF, noigre}
% \reset:n { Y }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { v_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_v_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_v_get:niTF { #1 } { #2 } {
    \BNVS_quark_if_no_value:iTF { #2 } {
      \BNVS_fatal:n {Circular~definition:~#1}
      \prg_return_false:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/ALREADY }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    }
  } {
    \BNVS_v_gput:nn { #1 } { \q_no_value }
    \BNVS_V_resolve:inTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_v_resolve:niTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_resolve_ncTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_DEBUG_log_gprop:n { 100 }
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_v_append:ncTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_inTF:nnnnn { v } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_inTF:nnnnn { v } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_v_gput:nv { #1 } { #2 }
      \prg_return_true:
    } {
      \BNVS_A_resolve:inTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_v_gput:nv { #1 } { #2 }
        \prg_return_true:
      } {
        \BNVS_Z_resolve:inTF { #1 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...TRUE/Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_v_gput:nv { #1 } { #2 }
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_resolve_ncTF:nn { ... } { ...FALSE/Z }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \BNVS_v_gremove:n { #1 }
          \prg_return_false:
        }
      }
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_v_resolve:niTF { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_append:nc } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { v_append:ncTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_v_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_v_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:N=\BNVS_V_append:niTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_inTF:nnnnn { V } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { X1   }
% \BNVS_Test:n { X2   }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_V_append:niTF, noigre}
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_inTF:nnnnn { V } {} { ?!#1 } { 222 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_what_append_inTF:nnnnn { V } {} { ?!#1 } { 666 } { #1 }
% }
% \BNVS_Test:n { Z1   }
% \BNVS_Test:n { Z2   }
% \end{bnvs.test}
%    \begin{macrocode}
    \BNVS_end:
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_v_append:ncTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_index_can:n,
%   \BNVS_index_can:v,
%   \BNVS_index_resolve:nnc,
%   \BNVS_index_resolve:vvc,
%   \BNVS_index_append:nnc,
%   \BNVS_index_append:vvc
% }
% \begin{syntax}
% \cs{BNVS_index_can:nTF} \marg{key} \marg{yes code} \marg{no code}
% \cs{BNVS_index_resolve:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \cs{BNVS_index_append:nncTF} \marg{key} \marg{integer} \meta{tl core name} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index associated to the \meta{key} and \meta{integer} slide range
% into the \meta{tl variable} or
% append this index to the right of this variable.
% When \meta{integer} is 1, this is the first index,
% when \meta{integer} is 2, this is the second index, and so on.
% When \meta{integer} is 0, this is the index, before the first one,
% and so on.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined, on resolution only.
% The computation may fail when too many recursion calls are made.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_can:n } #1 { p, T, F, TF } {
  \bool_if:nTF {
       \BNVS_if_in_p:nn V { #1 }
    || \BNVS_if_in_p:nn A { #1 }
    || \BNVS_if_in_p:nn Z { #1 }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnn { index_can:nTF } { KEY } { #1 }
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...TRUE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_can_nTF:nn { } { ...FALSE}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_can:v } #1 { p, T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_index_can:nTF { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_resolve:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { index_resolve:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_index_resolve_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \exp_args:Nx \BNVS_V_resolve:inTF { #1.#2 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
  } {
    \BNVS_A_resolve:inTF { #1 } { #3 } {
      \BNVS_tl_put_right:in { #3 } { + #2 - 1 }
         \BNVS_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/FIRST }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Limited overlay set.
% \begin{bnvs.test}{bnvs:c=index_resolve:nncTF, noigre}
% \Test_index_resolve:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_index_resolve:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_index_resolve:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_index_resolve:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_resolve:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_resolve:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_index_resolve:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \cs_undefine:N \BNVS_Test:n
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    } {
      \BNVS_Z_resolve:inTF { #1 } { #3 } {
        \BNVS_tl_put_right:in { #3 } { + #2 - 1 }
          \BNVS_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/LAST }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \BNVS_V_resolve:inTF { #1 } { #3 } {
          \BNVS_tl_put_right:in { #3 } { + #2 - 1 }
            \BNVS_round:c { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...TRUE/VALUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_resolve_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_false:
        }
      }
  }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_resolve:nvv } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:ni {
    \BNVS_index_resolve:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_resolve:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:ni {
    \BNVS_tl_use:Ni \BNVS_index_resolve:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_append:nnc } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { index_append:nncTF } { KEY } { #1 } { INDEX } { #2 } { #3 }
\BNVS_DEBUG_log_index_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_index_resolve:nncTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
%    \end{macrocode}
% \begin{bnvs.test}{:N=\BNVS_index_append:nncTF, noigre}
% \Test_index_append:nnnnn { 3 } {} { -2 } {  0 } { A-1 }
% \Test_index_append:nnnnn { } {} { 0 } { 2 } { A-2 }
% \Test_index_append:nnnnn { } {} { 1 } { 3 } { A-3 }
% \Test_index_append:nnnnn { } {} { 2 } { 4 } { A-4 }
% \reset:n { Y }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 219 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 221 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 222 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 223 } { #1-4 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_index_append:nnnnn { } { ?!#1 } { -2 } { 663 } { #1-1 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  0 } { 665 } { #1-2 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  1 } { 666 } { #1-3 }
%   \Test_index_append:nnnnn { } { ?!#1 } {  2 } { 667 } { #1-4 }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
%    \begin{macrocode}
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_index_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { index_append:vvc } #1 #2 #3 { T, F, TF } {
  \BNVS_tl_use:ni {
    \BNVS_tl_use:Ni \BNVS_index_append:nncTF { #1 }
  } { #2 } { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \subsubsection{Index counter}
% \begin{function}[TF]{\BNVS_n_resolve:nv,\BNVS_n_append:ni, \BNVS_n_append:Vc}
% \begin{syntax}
% \cs{BNVS_n_resolve:niTF} \marg{key} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluate the n counter associated to the \marg{key} overlay set
% into \meta{tl variable}.
% Initialize this counter to 1 on the first use.
% \meta{no code} is never executed.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { n_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_resolve_ncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_n_get:niF { #1 } { #2 } {
    \BNVS_tl_set:in { #2 } { 1 }
    \BNVS_n_gput:nn { #1 } { 1 }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_resolve_ncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \prg_return_true:
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_append:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { n_append:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_append_inTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_append_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ia_wrap:Nn \BNVS_n_append:niTF { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_n_append:niTF, noigre}
% \Test_n_append_X:nnn { 1 } { 1 } { 1 }
% \BNVS_n_gput:nn { ?!X } { 123 }
% \Test_n_append_X:nnn { } { 123 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_append:nnnn { } { ?!#1 } { 1 } { #1 }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
%
% \begin{function}[TF]{
%  \BNVS_n_index_resolve:nv,
%  \BNVS_n_index_resolve:nnv,
%  \BNVS_n_index_append:nv,
%  \BNVS_n_index_append:nni,
%  \BNVS_n_index_append:vvv,
% }
% \begin{syntax}
% \cs{BNVS_n_index_resolve:niTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_index_append:niTF} \marg{key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_index_resolve:nnvTF} \marg{key} \marg{base key} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_index_append:nniTF} \marg{key} \marg{base key} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Resolve the index for the value of the n counter associated to the
% \marg{key} overlay set into the \meta{tl variable} or
% append this value the right of this variable.
% Initialize this counter to 1 on the first use.
% If the computation is possible, \meta{yes code} is executed, otherwise
% \meta{no code} is executed.
% In the latter case, the content of the \meta{tl variable}
% is undefined on resolution only.
% \end{function}
% \begin{bnvs.test}{:N=\BNVS_n_index_resolve:niTF, noigre}
% \reset:n { YES }
% \Test_n_index_resolve_X:nnn { FIRST } { 222 } { 1 }
% \BNVS_n_gput:nn { ?!X } { 445 }
% \Test_n_index_resolve_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \BNVS_n_gput:nn { ?!#1 } { 445 }
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \BNVS_n_gput:nn { ?!#1 } { -443 }
%   \Test_n_index_resolve:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
% \begin{bnvs.test}{:N=\BNVS_n_index_append:niTF, noigre}
% \reset:n { YES }
% \Test_n_index_append_X:nnn { FIRST } { 222 } { 1 }
% \BNVS_n_gput:nn { ?!X } { 445 }
% \Test_n_index_append_X:nnn { } { 666 } { 2 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_append:nnnn { } { ?!#1 } { 222 } { #1-A }
%   \BNVS_n_gput:nn { ?!#1 } { 445 }
%   \Test_n_index_append:nnnn { } { ?!#1 } { 666 } { #1-B }
% }
% \reset_X:
% \BNVS_Test:n { A1   }
% \BNVS_Test:n { A2   }
% \BNVS_Test:n { AA1  }
% \BNVS_Test:n { AA2  }
% \BNVS_Test:n { AL11 }
% \BNVS_Test:n { AL12 }
% \BNVS_Test:n { AL21 }
% \BNVS_Test:n { AL22 }
% \BNVS_Test:n { AZ11 }
% \BNVS_Test:n { AZ12 }
% \BNVS_Test:n { AZ21 }
% \BNVS_Test:n { AZ22 }
% \BNVS_Test:n { LZ11 }
% \BNVS_Test:n { LZ12 }
% \BNVS_Test:n { LZ21 }
% \BNVS_Test:n { LZ22 }
% \cs_set:Npn \BNVS_Test:n #1 {
%   \Test_n_index_append:nnnn { } { ?!#1 } { 666 } { #1-A }
%   \BNVS_n_gput:nn { ?!#1 } { -443 }
%   \Test_n_index_append:nnnn { } { ?!#1 } { 222 } { #1-B }
% }
% \BNVS_Test:n { Z1 }
% \BNVS_Test:n { Z2 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_index_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { n_index_resolve:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_index_resolve_niTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_n_resolve:niTF { #1 } { #2 } {
    \BNVS_index_resolve:nvvTF { #1 } { #2 } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_niTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_niTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_niTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_index_resolve:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_index_resolve:nnvTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_n_index_resolve_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_n_resolve:niTF { #1 } { #3 } {
    \BNVS_tl_put_left:in { #3 } { #2. }
    \BNVS_if_resolve:iiTF { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nnvTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nnvTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_resolve_nnvTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_index_append:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { n_index_append:niTF } { KEY } { #1 } { #2 }
\BNVS_DEBUG_log_n_index_append_niTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_index_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_niTF:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_niTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_index_append:nni } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_index_append:nniTF } { KEY } { #1 } { BASE } { #2 } { #3 }
\BNVS_DEBUG_log_n_index_append_nniTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_index_resolve:nnvTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_nnvTF:nn { } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_index_append_nnvTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional_ii_wrap:Nntt \BNVS_n_index_append:nni { tl } { tl }
\BNVS_new_conditional_tl_vvv:cn { n_index_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BNVS_n_index_append:niTF, noigre}
% \reset:n { YES }
% \Test_n_index_append_X:nnn { FIRST } { 222 } { 1 }
% \BNVS_n_gput:nn { ?!X } { 445 }
% \Test_n_append_X:nnn { } { 445 } { 2 }
% \Test_n_index_append_X:nnn { } { 666 } { 1 }
% \end{bnvs.test}
%
% \subsubsection{Value counter}
% \begin{function} [TF] {
%   \BNVS_v_incr_resolve:nnv,
%   \BNVS_v_incr_append:nnv,
%   \BNVS_v_incr_append:VnN,
%   \BNVS_v_incr_append:VVN
% }
% \begin{syntax}
% \cs{BNVS_v_incr_resolve:nnvTF} \marg{key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_v_incr_append:nnvTF} \marg{key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Increment the value counter position accordingly.
% When requested, put the result in the \meta{tl variable}.
% In the second version, the result will lay within the declared range.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_incr_resolve:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { v_incr_resolve_nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_if_resolve:niTF { #2 } { #3 } {
    \BNVS_tl_use:Ni \int_compare:nNnTF { #3 } = 0 {
      \BNVS_v_resolve:niTF { #1 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_incr_resolve:nnvTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_v_incr_resolve:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_incr_resolve:nnvTF{/:2}, noigre}
% \reset:n { Y }
% \BNVS_v_incr_resolve:nnvT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    } {
      \BNVS_tl_put_right:in { #3 } { + }
      \BNVS_v_append:ncTF { #1 } { #3 } {
        \BNVS_round:c { #3 }
        \BNVS_v_gput:nv { #1 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { ... } { ...TRUE/<>0 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_incr_resolve:nnvTF{/:3}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_v_incr_resolve:nnvTF { ?!X } { 444 } { ans } {
%   \assert_equal_ans:nn { 666 } { 3 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_resolve_nnvTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional:bpnn { v_incr_append:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { v_incr_append_nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_incr_append_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_v_incr_resolve:nnvTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_append_nnvTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_incr_append:nnvTF{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_v_incr_append:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_incr_append_nnvTF:nn { } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_incr_append:nnvTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_v_incr_append:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } { 2 }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_tl_vvv:cn { v_incr_append } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_post_resolve:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { v_post_resolve:nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_post_resolve_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_v_resolve:niTF { #1 } { #3 } {
    \BNVS_begin:
    \BNVS_if_resolve:niTF { #2 } { a } {
      \BNVS_tl_use:Ni \int_compare:nNnTF { a } = 0 {
        \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nnvTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nnvTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_v_post_resolve:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      } {
        \BNVS_tl_put_right:in { a } { + }
        \BNVS_tl_put_right:ii { a } { #3 }
        \BNVS_round:c { a }
        \BNVS_end_v_gput:nc { #1 } { a }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nnvTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nnvTF}{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_v_post_resolve:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_tl:vnn { ans } { 222 } { 1 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_tl:vnn { ans } { 2222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_true:
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nnvTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nnvTF}{/:2}, noigre}
% \reset:n { Y }
% \end{bnvs.test}
%    \begin{macrocode}
      \BNVS_end:
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_resolve_nnvTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_resolve:nnvTF}{/:2}, noigre}
% \reset:n { Y }
% \BNVS_v_post_resolve:nnvT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
      \prg_return_false:
  }
}
\BNVS_new_conditional_tl_vvv:cn { v_post_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { v_post_append:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { v_post_append:nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_v_post_append_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_v_post_resolve:nnvTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_append_nnvTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:c { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={v_post_append:nnvTF}{/:1}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_v_post_append:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 1 }
%   \BNVS_tl_set:in { ans } { 2 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } { 1' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_v_post_append_nnvTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_v_post_append:nnvTF{/:2}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_v_post_append:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { 2 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { 2' }
%   } {
%     \test_fail:n { NO_WAY' }
%   }
% } {
%   \test_fail:n { NO_WAY }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  }
}
\BNVS_new_conditional_vnv:cn { v_post_append } { T, F, TF }
\BNVS_new_conditional_tl_vvv:cn { v_post_append } { T, F, TF }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:cn={v_post_append:nnvTF}{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 9 }
% \BNVS_v_post_append:nnvTF { ?!X } { 8000 } { ans } {
%   \assert_equal_ans:nn { 9222 } { A }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { A' }
%   } {
%     \test_fail:n { NO_WAY-A' }
%   }
% } {
%   \test_fail:n { NO_WAY-A }
% }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 9 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_v_post_append:vncTF { a } { 8000 }  { ans } {
%   \assert_equal_ans:nn { 9222 } { B }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 8222 } { B' }
%   } {
%     \test_fail:n { NO_WAY-B' }
%   }
% } {
%   \test_fail:n { NO_WAY-B }
% }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_tl_set:in { b } { 2000 }
% \BNVS_v_post_append:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C' }
%   } {
%     \test_fail:n { NO_WAY-C' }
%   }
% } {
%   \test_fail:n { NO_WAY-C }
% }
% \end{bnvs.test}
% \begin{function} [TF] {
%   \BNVS_n_incr_resolve:nnv,
%   \BNVS_n_incr_resolve:nnnv,
%   \BNVS_n_incr_append:nnv,
%   \BNVS_n_incr_append:vnv,
%   \BNVS_n_incr_append:vvv,
%   \BNVS_n_incr_append:nnnv,
%   \BNVS_n_post_resolve:nni,
%   \BNVS_n_post_append:nni
%   }
% \begin{syntax}
% \cs{BNVS_n_incr_resolve:nnvTF} \marg{key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_incr_resolve:nnnvTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_incr_append:nnvTF} \marg{key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_n_incr_append:nnnvTF} \marg{key} \marg{base key} \marg{offset} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% Increment the implicit n counter accordingly.
% When requested, put the resulting index in the variable with \meta{tl core name}.
% \end{function}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnv}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves{ X = 123 }
% \BNVS_n_resolve:niTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 1 } { A }
% } {
%   \test_fail:n { NO_WAY }
% }
% \BNVS_n_index_resolve:niTF { ?!X } { ans } {
%   \assert_equal_ans:nn { 123 } { B }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Beanoves{ X = 123 }
% \BNVS_n_incr_resolve:nnvTF { ?!X } { 123 } { ans } {
%   \assert_equal_ans:nn { 246 } { C }
% } {
%   \test_fail:n { NO_WAY }
% }
% \Test_n_incr_append:nnnnn { 123 } {} { 123 } { 246 } { 1 }
% \Test_n_get:nnnn {} {} { 124 } { 2 }
% \Test_n_incr_append:nnnnn { 123 } {} { 500+40+3 } { 666 } { 3 }
% \reset:n { YES }
% \Test_n_incr_append:nnnnn { FIRST } {} { LENGTH-1 } { 666 } { 4 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_incr_resolve:nnnv } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnnnc { n_incr_resolve:nnnvTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_if_resolve:niTF { #3 } { #4 } {
    \BNVS_tl_use:Ni \int_compare:nNnTF { #4 } = 0 {
      \BNVS_n_resolve:niTF { #1 } { #4 } {
        \BNVS_index_resolve:nvvTF { #1 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:c { #4 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnnvTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_incr_resolve:nnnvTF { ?!X } { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnvTF}{/:2}, noigre}
% \reset:n{ YES }
% \BNVS_n_incr_resolve:nnnvT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \BNVS_tl_put_right:in { #4 } { + }
      \BNVS_n_append:niTF { #1 } { #4 } {
        \BNVS_round:c { #4 }
        \BNVS_n_gput:nv { #1 } { #4 }
        \BNVS_index_resolve:nvvTF { #2 } { #4 } { #4 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:i { #4 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnnvTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_incr_resolve:nnnvTF { ?!X } { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnnvTF}{/:4}, noigre}
% \reset:n{ YES }
% \BNVS_n_incr_resolve:nnnvT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bvs:cn={n_incr_resolve:nnnvTF}{/:5}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnnvTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnnvTF}{/:6}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_incr_resolve:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_incr_resolve_nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_if_resolve:niTF { #2 } { #3 } {
    \BNVS_tl_use:Ni \int_compare:nNnTF { #3 } = 0 {
      \BNVS_n_resolve:niTF { #1 } { #3 } {
        \BNVS_index_resolve:nvvTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:i { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnvTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_incr_resolve:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:         
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:         
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnvTF}{/:2}, noigre}
% \reset:n{ YES }
% \BNVS_n_incr_resolve:nnvT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }   
    } {
      \BNVS_tl_put_right:in { #3 } { + }
      \BNVS_n_append:niTF { #1 } { #3 } {
        \BNVS_round:c { #3 }
        \BNVS_n_gput:nv { #1 } { #3 }
        \BNVS_index_resolve:nvvTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:i { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_resolve:nnvTF}{/:3}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_incr_resolve:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {3-A}
% } {
%   \test_fail:n { NO_WAY/3-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...FALSE/INDEX }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_incr_resolve:nnvTF{/:4}, noigre}
% \reset:n{ YES }
% \BNVS_n_incr_resolve:nnvT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...FALSE/APPEND }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_incr_resolve:nnvTF{/:5}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
        \prg_return_false:
      }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_resolve_nnvTF:nn { ... } { ...FALSE/RESOLVE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_incr_resolve:nnvTF{/:6}, noigre}
% \reset:n{ YES }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnv:cn { n_incr_resolve } { T, F, TF }
\BNVS_new_conditional_tl_vvv:cn { n_incr_resolve } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_incr_append:nnnv } #1 #2 #3 #4 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnnnc { n_incr_append:nnnvTF } { KEY } { #1 } { BASE } { #2 } { INCR } { #3 } { #4 }
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_incr_resolve:nnnvTF { #1 } { #2 } { #3 } { #4 }{
    \BNVS_end_tl_put_right:ii { #4 } { #4 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnvTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nnncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnnvTF}{/:2}, noigre}
% \reset:n{ YES }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnnvT { ?!X } { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnnvT { ?!X } { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vvnv:cn { n_incr_append } { T, F, TF }
\BNVS_new_conditional_vvvv:cn { n_incr_append } { T, F, TF }
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_incr_append:nnv } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_incr_append:nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_incr_resolve:nnvTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnvTF}{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 22222 } {1-C}
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_incr_append_nncTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:nnvTF}{/:2}, noigre}
% \reset:n{ YES }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/2-A }
% }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_incr_append:nnvT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-B }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_vnv:cn { n_incr_append } { T, F, TF }
\BNVS_new_conditional_tl_vvv:cn { n_incr_append } { T, F, TF }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={n_incr_append:vnvTF}{/:*}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_n_incr_append:vnvTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_tl_set:in { b } { 2000 }
% \BNVS_n_incr_append:vvvTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 22222 } {1-A}
% } {
%   \test_fail:n { NO_WAY/1-B }
% }
% \end{bnvs.test}
% \end{bnvs.macrocode}
% \begin{function} [TF] {
%   \BNVS_v_post_resolve:nnv,
%   \BNVS_v_post_resolve:vvc,
%   \BNVS_v_post_append:nnv,
%   \BNVS_v_post_append:vnN,
%   \BNVS_v_post_append:vvN
% }
% \begin{syntax}
% \cs{BNVS_v_post_resolve:nnvTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \cs{BNVS_v_post_append:nnvTF} \marg{key} \marg{offset} \meta{tl variable} \marg{yes code} \marg{no code}
% \end{syntax}
% \end{function}
% Resolve the value of the free counter for the given \meta{key} into
% the \meta{tl variable} then increment this free counter position
% accordingly.
% The append version, appends the value to the right of the \meta{tl variable}.
% The content of the \meta{tl variable} is undefined
% while in the \marg{no code} branch and on resolution only.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_post_resolve:nni } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_post_resolve_nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_n_resolve:niTF { #1 } { #3 } {
    \BNVS_begin:
    \BNVS_if_resolve:niTF { #2 } { #3 } {
      \BNVS_tl_use:Ni \int_compare:nNnTF { #3 } = 0 {
        \BNVS_end:
        \BNVS_index_resolve:nvvTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...TRUE/0 }
\BNVS_DEBUG_log_tl:i { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_append:nniTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_post_resolve:nniTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 222 } {1-A}
%   \BNVS_n_index_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_true:
        } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...FALSE/UNREACHABLE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \prg_return_false:
        }
      } {
        \BNVS_tl_put_right:in { #3 } { + }
        \BNVS_n_append:niTF { #1 } { #3 } {
          \BNVS_round:c { #3 }
          \BNVS_n_gput:nv { #1 } { #3 }
          \BNVS_end:
          \BNVS_index_resolve:nvvTF { #1 } { #3 } { #3 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...TRUE/<>0 }
\BNVS_DEBUG_log_tl:i { #3 }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_append:nniTF{/:2}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_n_post_resolve:nniTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 222 } {2-A}
%   \BNVS_n_index_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
            \prg_return_true:
          } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...FALSE/A }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_append:nniTF{/:22'}, noigre}
% \reset:n{ YES }
% \BNVS_n_post_resolve:nniT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
            \prg_return_false:
          }
        } {
          \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...FALSE/B }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_resolve:nniTF{/:3}, noigre}
% \reset:n{ YES }
% \BNVS_n_post_resolve:nniT { ?! } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
          \prg_return_false:
        }
      }
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...FALSE/C }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_resolve:nniTF{/:4}, noigre}
% \reset:n{ YES }
% \BNVS_n_post_resolve:nniT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_resolve_nnvTF:nn { ... } { ...FALSE/D }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_resolve:nniTF{/:5}, noigre}
% \reset:n{ YES }
% \BNVS_n_post_resolve:nniT { ?! } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/5-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { n_post_append:nni } #1 #2 #3 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnnnnc { n_post_append_nnvTF } { KEY } { #1 } { INCR } { #2 } { #3 }
\BNVS_DEBUG_log_n_post_append_nnvTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_n_post_resolve:nniTF { #1 } { #2 } { #3 } {
    \BNVS_end_tl_put_right:ii { #3 } { #3 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_append_nniTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_append:nniTF{/:1}, noigre}
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_post_append:nniTF { ?!X } { 0 } { ans } {
%   \assert_equal_ans:nn { 2222 } {1-A}
%   \BNVS_n_index_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 222 } {1-B}
%   } {
%     \test_fail:n { NO_WAY/1-C }
%   }
% } {
%   \test_fail:n { NO_WAY/1-D }
% }
% \reset:n{ YES }
% \Beanoves { X=FIRST }
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_n_post_append:nniTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } {2-A}
%   \BNVS_n_index_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } {2-B}
%   } {
%     \test_fail:n { NO_WAY/2-C }
%   }
% } {
%   \test_fail:n { NO_WAY/2-D }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_n_post_append_nniTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{:Nn=\BNVS_n_post_append:nniTF{/:2}, noigre}
% \reset:n{ YES }
% \BNVS_n_post_append:nniT { ?!X } { 0 } { ans } {
%   \test_fail:n { NO_WAY/3-A }
% }
% \reset:n{ YES }
% \BNVS_n_post_append:nniT { ?!X } { 2000 } { ans } {
%   \test_fail:n { NO_WAY/4-A }
% }
% \end{bnvs.test}
%    \begin{macrocode}
    \prg_return_false:
  }
}
\BNVS_new_conditional_i_wrap:Nnt \BNVS_n_post_append:nni { T, F, TF } { tl }
\BNVS_new_conditional_ii_wrap:Nntt \BNVS_n_post_append:nni { T, F, TF } { tl } { tl }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:Nn=\BNVS_v_post_append:nnvTF{/:*}, noigre}
% \reset:n { Y }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_v_post_append:nnvTF { ?!X } { 2000 } { ans } {
%   \assert_equal_ans:nn { 2222 } { A-1 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { A-2 }
%   } {
%     \test_fail:n { NO_WAY-A-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-A-4 }
% }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_v_post_append:vncTF { a } { 2000 }  { ans } {
%   \assert_equal_ans:nn { 2222 } { B-1 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { B-2 }
%   } {
%     \test_fail:n { NO_WAY-B-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-B-4 }
% }
% \Beanoves { X=FIRST}
% \BNVS_tl_set:in { ans } { 2 }
% \BNVS_tl_set:in { a } { ?!X }
% \BNVS_tl_set:in { b } { 2000 }
% \BNVS_v_post_append:vvcTF { a }  { b }  { ans } {
%   \assert_equal_ans:nn { 2222 } { C-1 }
%   \BNVS_v_resolve:niTF { ?!X } { ans } {
%     \assert_equal_ans:nn { 2222 } { C-2 }
%   } {
%     \test_fail:n { NO_WAY-C-3 }
%   }
% } {
%   \test_fail:n { NO_WAY-C-4 }
% }
% \end{bnvs.test}
%
% \subsubsection{Evaluation}
%
%^^A:\...round_ans:
% \begin{function}{\BNVS_round_ans:}
% \begin{syntax}
% \cs{BNVS_round_ans:}
% \end{syntax}
% Helper function to round the |\l__bnvs_ans_tl| variable.
% When managing ranges, this will be set to |\prg_do_nothing:|, 
% because we do not want to interpret the |-| sign as a minus operator.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_new:bpn { round_ans: } {
  \BNVS_round:c { ans }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \subsubsection{Functions for the resolution}
% They manily start with |\BNVS_if_resolve_|
%
% \begin{function}{
%   \BNVS_path_resolve_n:TFF,
% }
% \begin{syntax}
% \cs{BNVS_path_resolve_n:TFF} \marg{yes code} \marg{no code 1} \marg{no code 2}
% \end{syntax}
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...path_resolve_n:TFF
%    \begin{macrocode}
\BNVS_new:bpn { path_resolve_n:TFF } #1 #2 {
  \BNVS_kip_n_path_resolve:TF {
    \BNVS_seq_if_empty:iTF { path } { #1 } { #2 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function} {
%   \BNVS_path_resolve_n:T
% }
% \begin{syntax}
% \cs{BNVS_path_resolve_n:T} \marg{yes code}
% \end{syntax}
% Resolve the path and execute \meta{yes code} on success.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...path_resolve_n:TF
%    \begin{macrocode}
\BNVS_new:bpn { path_resolve_n:TF } #1 #2 {
  \BNVS_path_resolve_n:TFF {
    #1
  } {
    #2
  } {
    \BNVS_if_resolve_end_return_false:n {
      Unknown~dotted~path
    }
  }
}
\BNVS_new:bpn { path_resolve_n:T } #1 {
  \BNVS_path_resolve_n:TFF {
    #1
  } {
    \BNVS_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \BNVS_if_resolve_end_return_false:n {
      Unknown~dotted~path
    }
  }
}
%    \end{macrocode}
%^^A:\...resolve_x:T
%    \begin{macrocode}
\BNVS_new:bpn { resolve_x:T } #1 {
  \BNVS_kip_x_path_resolve:TFF {
    #1
  } {
    \BNVS_if_resolve_end_return_false:n {
      Too~many~dotted~components
    }
  } {
    \BNVS_if_resolve_end_return_false:n { Unknown~dotted~path }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_path_suffix:n,
% }
% \begin{syntax}
% \cs{BNVS_path_suffix:nTF} \marg{tl} \marg{yes code} \marg{no code}
% \end{syntax}
% If the last item of |\l__bnvs_path_seq| is \meta{suffix},
% then execute \meta{yes code} otherwise execute \meta{no code}.
% The suffix is |n| in the second case.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...path_pop_right:cTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { path_pop_right:c } #1 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c=path_pop_right:cTF, noigre}
% \BNVS_seq_clear:i { path }
% \BNVS_path_pop_right:cTF { a } {
%   \test_fail:n { NO~WAY/1 }
% } {
% }
% \BNVS_seq_set_split:inn { path } { . } { 1.2.3 }
% \BNVS_seq_set_split:inn { path } { . } { n }
%   \BNVS_path_pop_right:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/2 }
% }
% \BNVS_seq_set_split:inn { path } { . } { 1.2.3.n }
% \BNVS_path_pop_right:cTF { a } {
% } {
%   \test_fail:n { NO~WAY/3 }
% }
% \end{bnvs.test}
%    \begin{macrocode}
  \BNVS_seq_pop_right:ccTF { path } { #1 }
    { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{\BNVS_if_resolve_end_return_false:n}
% \begin{syntax}
% \cs{BNVS_if_resolve_end_return_false:n} \marg{message}
% \end{syntax}
% Close one \TeX\ group, display a message and return false.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_end_return_false:n
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...FALSE/#1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \BNVS_if_resolve_pop_kip:TTF,
%   \BNVS_if_resolve_pop_complete_white:T,
%   \BNVS_if_resolve_pop_complete_black:T,
% }
% \begin{syntax}
% \cs{BNVS_if_resolve_pop_kip:TTF} \marg{blank code} \marg{black code} \marg{end code}
% \cs{BNVS_if_resolve_pop_complete_white:T} \marg{blank code}
% \cs{BNVS_if_resolve_pop_complete_black:T} \marg{black code}
% \end{syntax}
% For |\BNVS_if_resolve_pop_kip:TTF|.
% If the |split| sequence is empty, execute \meta{end code}.
% Otherwise pops the 3 heading items of the
% |split| sequence into the three |tl| variables |key|, |id|, |path|.
% If |key| is blank then execute \meta{blank code}, otherwise execute
% \meta{black code}.
%
% For |\BNVS_if_resolve_pop_complete_white:T|: pops the three heading items of
% the |split| sequence into the three variables
% |n_incr|, |incr|, |post|.
% Then execute \meta{blank code}.
%
% For |\BNVS_if_resolve_pop_complete_black:T|: pops the six heading items of
% the |split| sequence then execute \meta{blank code}.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_pop_kip_complete:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_pop_kip_complete: } {
  \BNVS_tl_if_blank:vT { id } {
    \BNVS_tl_put_left:cv { key } { id_last }
    \BNVS_tl_set:vv { id } { id_last }
  }
  \BNVS_tl_if_blank:vTF { path } {
    \BNVS_seq_clear:i { path }
  } {
    \BNVS_seq_set_split:inv { path } { . } { path }
    \BNVS_seq_remove_all:vn { path } { }
  }
  \BNVS_tl_set_eq:ii { key_base } { key }
  \BNVS_seq_set_eq:vv { path_base } { path }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...COMPLETE... }
\BNVS_DEBUG_log_tl:i { key }
\BNVS_DEBUG_log_tl:i { id }
\BNVS_DEBUG_log_seq:xi { \BNVS_tl_use:i { path } } { path }
\BNVS_DEBUG_log_tl:i { key_base }
\BNVS_DEBUG_log_seq:i { path_base }
\BNVS_DEBUG_log_tl:i { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%^^A:\...if_resolve_pop_kip:TTF
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_pop_kip:TTF } #1 #2 #3 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...POP... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_split_pop_left:vTF { key } {
    \BNVS_split_pop_left:vTF { id } {
      \BNVS_split_pop_left:vTF { path } {
        \BNVS_tl_if_blank:vTF { key } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% The first 3 capture groups are empty,
% and the 3 next ones are expected to contain the expected information.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
          #1
        } {
          \BNVS_if_resolve_pop_kip_complete:
          #2
        }
      } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/2 }
      }
    } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_kip:TTF/1 }
    }
  } { #3 }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}{
%   \BNVS_if_resolve_pop_complete:nNT
% }
% \begin{syntax}
% \cs{BNVS_if_resolve_pop_kip:FFTF} \marg{empty key code} \marg{no id code} \marg{true code} \marg{no capture code}
% \cs{BNVS_if_resolve_pop_complete:nNT} \marg{tl} \meta{tl var} \marg{true code}
% \end{syntax}
% \meta{tl} and \meta{tl var} are the arguments of the \cs{BNVS_if_resolve:ni} conditionals.
% conditional variants.
%
% \cs{BNVS_if_resolve_pop_kip:FFTF} locally
% sets the |key|, |id| and |path| |tl| variables
% to the 3 heading items of the split sequence,
% which correspond to the 3 eponym capture groups.
% If no capture group is available, \meta{no capture code} is executed.
% If the capture group for the key is empty, then \meta{empty key code} is executed.
% If there is no capture group for the id, then \meta{no id code} is executed.
% Otherwise \meta{true code} is executed.
%
% \cs{BNVS_rslv_pop_end:T} locally
% sets the three |tl| variables |n_incr|, |incr| and |post|
% to the three heading items of the split sequence,
% which correspond to the last 3 eponym capture groups.
% \end{function}
% \begin{bnvs.test}{bnvs:c=if_resolve_pop_kip:TTF, noigre}
% \cs_set:Npn \BNVS_DEBUG_log_if_resolve_niTF:nn #1 #2 {}
% \cs_set:Npn \BNVS_end_unreachable_return_false:n #1 {
%   \BNVS_tl_set:in { ans } { #1 }
% }
% \cs_set:Npn \BNVS_Test:nnn #1 #2 #3 #4 #5 #6 {
%   \BNVS_tl_clear:i { ans  }
%   \BNVS_tl_clear:i { key  }
%   \BNVS_tl_clear:i { id   }
%   \BNVS_tl_clear:i { path }
%   \BNVS_seq_set_split:inn { split } { . } { #1 }
%   \BNVS_seq_pop_left:ii { split } { a }
%   \BNVS_if_resolve_pop_kip:TTF {
%     \BNVS_tl_set:in { ans } { FIRST  }
%   } {
%     \BNVS_tl_set:in { ans } { SECOND }
%   } {
%     \BNVS_tl_set:in { ans } { THIRD  }
%   }
%   \assert_equal_ans:nn { #2 } { #6/ans }
%   \assert_equal_tl:vnn { key  } { #3 } { #6/key  }
%   \assert_equal_tl:vnn { id   } { #4 } { #6/id   }
%   \assert_equal_tl:vnn { path } { #5 } { #6/path }
% }
% \BNVS_Test:nnn { .  .2.3 } { FIRST  } {   } { 2 } { 3 } { 1 }
% \BNVS_Test:nnn { . 1.2.3 } { SECOND } { 1 } { 2 } { 3 } { 2 }
% \BNVS_Test:nnn {         } { THIRD  } {   } {  } {  } { 3 }
% \BNVS_Test:nnn { . 1     } { if_resolve_pop_kip:TTF/1 } { 1 } { } { } { 4 }
% \BNVS_Test:nnn { . 1.2   } { if_resolve_pop_kip:TTF/2 } { 1 } { 2 } { } { 5 }
% \cs_undefine:N \BNVS_Test:nnn
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_pop_complete_white:T
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_pop_complete_white:T } #1 {
  \BNVS_split_pop_left:vTF { n_incr } {
    \BNVS_split_pop_left:vTF { incr } {
      \BNVS_split_pop_left:vTF { post } {
        #1
      } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/3 }
      }
    } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/2 }
    }
  } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_white:T/1 }
  }
}
%    \end{macrocode}
%^^A:\...if_resolve_pop_complete_black:T
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_pop_complete_black:T } #1 {
  \BNVS_split_pop_left:vTF { a } {
    \BNVS_split_pop_left:vTF { a } {
      \BNVS_split_pop_left:vTF { a } {
        \BNVS_split_pop_left:vTF { a } {
          \BNVS_split_pop_left:vTF { a } {
            \BNVS_split_pop_left:vTF { a } {
              #1
            } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/6 }
            }
          } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/5 }
          }
        } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/4 }
        }
      } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/3 }
      }
    } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/2 }
    }
  } {
\BNVS_end_unreachable_return_false:n { if_resolve_pop_complete_black:T/1 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{function}[TF]{
%   \BNVS_if_resolve:ni,
%   \BNVS_if_resolve:ii,
%   \BNVS_if_append:nv,
%   \BNVS_if_append:ii,
% }
% \begin{syntax}
% \cs{BNVS_if_resolve:niTF} \marg{expression} \meta{tl core} \marg{yes code} \marg{no code}
% \cs{BNVS_if_append:niTF} \marg{expression} \meta{tl core} \marg{yes code} \marg{no code}
% \end{syntax}
% This is a central function.
% Evaluates the \meta{expression},
% replacing all the named overlay specifications by their static
% counterpart then put the rounded result in \meta{tl core} variable when resolving or to
% the right of the \meta{tl core} variable when appending.
% Heavily used by \cs{BNVS_query_eval:in}, where \meta{integer expression}
% was initially enclosed inside `|?(...)|'.
% Executed within a \TeX\ group when appending.
% Local variables: 
% \begin{variable}{\l__bnvs_ans_tl}
% To feed \meta{tl variable} with.
% \end{variable}
% \begin{variable}{\l__bnvs_split_seq}
% The sequence of catched query groups and non queries.
% \end{variable}
% \begin{variable}{\l__bnvs_split_int }
%  Is the index of the non queries, before all the catched groups.
% \end{variable}
% Managing infinite loops and recursive calls.
% As soon as we try to resolve a path, this path is locked such that
% any attempt to resolve the very same path before the resolution
% is complete will raise a fatal error due to a circular reference.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\BNVS_int_new:v { split }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{variable}{\l__bnvs_key_tl}
%    Storage for |split| sequence items that represent names.
% \end{variable}
% \begin{variable}{\l__bnvs_path_tl}
%    Storage for |split| sequence items that represent integer paths.
% \end{variable}
% Catch circular definitions.
% Open a main \TeX\ group to define local functions and variables,
% sometimes another grouping level is used.
% The main \TeX\ group is closed in the various \cs{...end_return...} functions.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...kip_x_path_resolve_or_end_return_false:nT
%    \begin{macrocode}
\BNVS_new:bpn { kip_x_path_resolve_or_end_return_false:nT } #1 #2 {
  \BNVS_kip_x_path_resolve:TFF {
    #2
  } {
    \BNVS_end_return_false:x { Too~many~dotted~components:~#1 }
  } {
    \BNVS_end_return_false:x { Unknown~dotted~path:~#1 }
  }
}
%    \end{macrocode}
%^^A:\...if_append:nv
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_append:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { if_append:niTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_append_niTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
  \BNVS_if_resolve:niTF { #1 } { #2 } {
    \BNVS_end_tl_put_right:ii { #2 } { #2 }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_niTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
    \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_append_niTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A:\...if_resolve:nv
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { if_resolve:ni } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnni { if_resolve:niTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_if_resolve_niTF:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_call:TF {
    \BNVS_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% This \TeX\ group will be closed just before returning.
% Implementation:
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_set:bpn { if_resolve_warning:n } ##1 {
      \BNVS_warning:n { #1:~##1 }
      \BNVS_set:bpn { if_resolve_warning:n } {
        \use_none:n
      }
    }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_regex_split:inTF { split } { #1 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...SPLIT... }
\BNVS_DEBUG_log_seq:i { split }
%</!final>
% \end{bnvs.gobble}
% \end{bnvs.macrocode}
% The leftmost item is not a special item: we start feeding |\l__bnvs_ans_tl| with it.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
      \BNVS_set:bpn { if_resolve_end_return_true: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Normal and unique end of the loop.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
        \BNVS_if_resolve_round_ans:
        \BNVS_end_tl_set:ii { #2 } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \prg_return_true:
      }
      \BNVS_set:bpn { if_resolve_round_ans: } { \BNVS_round_ans: }
      \BNVS_tl_clear:i { ans }
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_tl_clear:i { ans }
      \BNVS_round_ans:n { #1 }
      \BNVS_end_tl_set:ii { #2 } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { } { ...TRUE/DIRECT }
\BNVS_DEBUG_log_tl:i { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:     
    }
  } {
    \BNVS_error:n { TOO_MANY_NESTED_CALLS/Resolution }
    \prg_return_false:
  }
}
\BNVS_new_conditional:bpnn { if_append:ii } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_if_append:niTF { #1 } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\BNVS_new_conditional:bpnn { if_resolve:ii } #1 #2 { T, F, TF } {
  \BNVS_tl_use:Ni \BNVS_if_resolve:niTF { #1 } { #2 } {
    \prg_return_true:     
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Next functions are helpers for the \cs{BNVS_if_resolve:ni} conditional variants.
% When present, their two first arguments \meta{tl} and \meta{tl var}
% are exactly the ones given to the variants.
%
% \begin{function}{
%   \BNVS_if_resolve_loop_or_end_return:
% }
% \begin{syntax}
% \cs{BNVS_if_resolve_loop_or_end_return:}
% \end{syntax}
% May call itself at the end.
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_loop_or_end_return:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...LOOP... }
\BNVS_DEBUG_log_seq:i { split }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_split_pop_left:vTF { a } {
    \BNVS_tl_put_right:ii { ans } { a }
    \BNVS_if_resolve_pop_kip:TTF {
      \BNVS_if_resolve_pop_kip:TTF {
\BNVS_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/3 }
      } {
        \BNVS_if_resolve_pop_complete_white:T {
          \BNVS_tl_if_blank:vTF { n_incr } {
            \BNVS_tl_if_blank:vTF { incr } {
              \BNVS_tl_if_blank:vTF { post } {
                \BNVS_if_resolve_kip_end_return_true:F {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Only the dotted path: branch according to the last component.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
                  \BNVS_path_pop_right:cTF { a } {
                    \BNVS_tl_use:Ni \str_case:nnF { a } {
{ n         } { \BNVS_use:b { if_resolve_loop_or_end_return[.n]: } }
{ length    } { \BNVS_use:b { if_resolve_loop_or_end_return[.length]: } }
{ last      } { \BNVS_use:b { if_resolve_loop_or_end_return[.last]:  } }
{ range     } { \BNVS_use:b { if_resolve_loop_or_end_return[.range]: } }
{ previous  } { \BNVS_use:b { if_resolve_loop_or_end_return[.previous]: } }
{ next      } { \BNVS_use:b { if_resolve_loop_or_end_return[.next]:  } }
{ reset     } { \BNVS_use:b { if_resolve_loop_or_end_return[.reset]: } }
{ reset_all } { \BNVS_use:b { if_resolve_loop_or_end_return[.reset_all]: } }
                    } {
\BNVS_use:b { if_resolve_loop_or_end_return[...<integer>]: }
                    }
                  } {
\BNVS_use:b { if_resolve_loop_or_end_return[...]: }
                  }
                }
              } {
\BNVS_use:b { if_resolve_loop_or_end_return[...++]: }
              }
            } {
              \BNVS_path_suffix:nTF { n } {
\BNVS_use:b { if_resolve_loop_or_end_return[...n+=...]: }
              } {
\BNVS_use:b { if_resolve_loop_or_end_return[...+=...]: }
              }
            }
          } {
\BNVS_use:b { if_resolve_loop_or_end_return[...++n]: }
          }
        }
      } {
\BNVS_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/2 }
      }
    } {
      \BNVS_if_resolve_pop_complete_black:T {
        \BNVS_path_suffix:nTF { n } {
\BNVS_use:b { if_resolve_loop_or_end_return[++...n]: }
        } {
\BNVS_use:b { if_resolve_loop_or_end_return[++...]: }
        }
      }
    } {
      \BNVS_if_resolve_end_return_true:
    }
  } {
\BNVS_end_unreachable_return_false:n { if_resolve_loop_or_end_return:/1 }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% Next function starts with properly set |key|, |id| and |path| sequence.
% We try to resolve this one dotted component at a time.
% |a| is used to store the full key to resolve, with corresponding eponymm sequence.
% |b| sequence contains the dotted components that could not be resolved so far.
% 
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_kip_loop_or_end_return_true:F
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_kip_loop_or_end_return_true:F } #1 {
%  \BNVS_tl_set_from_kp:cvv { a } { key } { path }
  \BNVS_tl_set:vx { a } {
    \BNVS_tl_use:i { key } . \BNVS_seq_use:cn { path } { . }}
  \BNVS_v_resolve:vcTF { a } { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...TRUE/DIRECT(v) }
\BNVS_DEBUG_log_tl:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_tl_put_right:ii { ans } { a }
    \BNVS_if_resolve_loop_or_end_return:
  } {
    \BNVS_V_resolve:vvTF { a } { a } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...TRUE/DIRECT(V) }
\BNVS_DEBUG_log_tl:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_tl_put_right:ii { ans } { a }
      \BNVS_if_resolve_loop_or_end_return:
    } {
      #1
    }
  }
}
%    \end{macrocode}
%^^A:\...tl_set_from_kp:cvvTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { tl_set_from_kp:cvv } #1 #2 #3 { T, F, TF } {
  \BNVS_seq_if_empty:iTF { #2 } {
    \BNVS_tl_set:vx { #1 } {
      \BNVS_tl_use:i { #2 } . \BNVS_seq_use:cn { #3 } { . }
    }
    \prg_return_true:
  } {
    \BNVS_tl_set_eq:ii { a } { key }
    \prg_return_false:
  }
}
\BNVS_new:bpn { tl_set_from_kp:cvv } #1 #2 #3 {
  \BNVS_tl_set_from_kp:cvvT { #1 } { #2 } { #3 } { }
}
%    \end{macrocode}
%^^A:\...if_resolve_kip_end_return_true:F
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_kip_end_return_true:F } {
  \BNVS_seq_clear:i { b }
  \BNVS_seq_set_eq:vv { a } { path }
  \BNVS_if_resolve_kip_loop_or_end_return_true:F
}
%    \end{macrocode}
%^^A:\...end_return_error:n
%    \begin{macrocode}
\BNVS_new:bpn { end_return_error:n } #1 {
      \BNVS_error:n { #1 }
      \BNVS_end:
      \prg_return_false:
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.macrocode}
%^^A:\...if_resolve_loop_or_end_return
%^^A::\...if_resolve_loop_or_end_return[.n]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item Case \texttt{...n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n } { 222 } { 1-a }
% \Test_if_resolve:nnnn { FIRST+1 } { X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { LENGTH-1 } { X.n } { 444 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.n } { 666 } { 1-d }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { path }
\BNVS_DEBUG_log_seq:i { path }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_base_resolve_n:
    \BNVS_n_index_append:vvvTF { key } { key_base } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...n }
\BNVS_DEBUG_log_tl:i { b }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_end_return_error:n {
        Undefined~dotted~path
      }
    }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
%
% \begin{bnvs.macrocode}
%^^A::\...path_suffix:nTF
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { path_suffix:n } #1 { T, F, TF } {
  \BNVS_seq_get_right:ccTF { path } { a } {
    \BNVS_tl_if_eq:vnTF { a } { #1 } {
      \BNVS_seq_pop_right:ccT { path } { a } { }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.length]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.length]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...length}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...length }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/length}, noigre}
% \Test_if_resolve:nnnn { 222::445 } { X.length } { 445 } { 1 }
% \Test_if_resolve:nnnn { 222:666 } { X.length } { 445 } { 2 }
% \Test_if_resolve:nnnn { ::445:666 } { X.length } { 445 } { 3 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length } { 445 } { 4 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length } { 445 } { 5 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length } { 445 } { 6 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222::445 } { X.length+X.length } { 890 } { 1' }
% \Test_if_resolve:nnnn { 222:666 } { X.length+X.length } { 890 } { 2' }
% \Test_if_resolve:nnnn { ::445:666 } { X.length+X.length } { 890 } { 3' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.length+X.length } { 890 } { 4' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.length+X.length } { 890 } { 5' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.length+X.length } { 890 } { 6' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_L_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../length }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~length }
    } 
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.last]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.last]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...last}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...last }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.last}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.last } { 666 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.last } { 666 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.last } { 666 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.last } { 666 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last } { 666 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last } { 666 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last } { 666 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last } { 666 } { 8 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :666 } { X.last / 2 } { 333 } { 1' }
% \Test_if_resolve:nnnn { 222::445 } { X.last / 2 } { 333 } { 2' }
% \Test_if_resolve:nnnn { 222:666 } { X.last / 2 } { 333 } { 3' }
% \Test_if_resolve:nnnn { ::445:666 } { X.last / 2 } { 333 } { 4' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { :LAST } { X.last / 2 } { 333 } { 5' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.last / 2 } { 333 } { 6' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.last / 2 } { 333 } { 7' }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.last / 2 } { 333 } { 8' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_Z_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../last }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_end_return_false:x { NO~last }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.range]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.range]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...range}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...range }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.range}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.range } { 222- } { 1 }
% \Test_if_resolve:nnnn { 222: } { X.range } { 222- } { 1' }
% \Test_if_resolve:nnnn { 222:: } { X.range } { 222- } { 1'' }
% \Test_if_resolve:nnnn { :666 } { X.range } { -666 } { 2 }
% \Test_if_resolve:nnnn { 222::445 } { X.range } { 222-666 } { 3 }
% \Test_if_resolve:nnnn { 222:666 } { X.range } { 222-666 } { 4 }
% \Test_if_resolve:nnnn { ::445:666 } { X.range } { 222-666 } { 5 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.range } { 222- } { 6 }
% \Test_if_resolve:nnnn { FIRST: } { X.range } { 222- } { 6' }
% \Test_if_resolve:nnnn { FIRST:: } { X.range } { 222- } { 6'' }
% \Test_if_resolve:nnnn { :LAST } { X.range } { -666 } { 7 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.range } { 222-666 } { 8 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.range } { 222-666 } { 9 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.range } { 222-666 } { 10 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_range_append:vcTF { key } { ans } {
      \BNVS_set:bpn { if_resolve_round_ans: } { \prg_do_nothing: }
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../range }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~range }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.previous]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.previous]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...previous}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...previous }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.previous}, noigre}
% \Test_if_resolve:nnnn { 222: } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::' } { X.previous } { 221 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.previous } { 221 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.previous } { 221 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.previous } { 221 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5 }
% \Test_if_resolve:nnnn { FIRST: } { X.previous } { 221 } { 5' }
% \Test_if_resolve:nnnn { FIRST:LENGTH } { X.previous } { 221 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.previous } { 221 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.previous } { 221 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_previous_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../previous }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~previous }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.next]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.next]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...next}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...next }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.next}, noigre}
% \Test_if_resolve:nnnn { :666 } { X.next } { 667 } { 1 }
% \Test_if_resolve:nnnn { 222::445 } { X.next } { 667 } { 2 }
% \Test_if_resolve:nnnn { 222:666 } { X.next } { 667 } { 3 }
% \Test_if_resolve:nnnn { ::445:666 } { X.next } { 667 } { 4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { X.next } { 667 } { 5 }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.next } { 667 } { 6 }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.next } { 667 } { 7 }
% \Test_if_resolve:nnnn { ::LENGTH:LAST } { X.next } { 667 } { 8 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_next_append:vcTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../next }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~next }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.reset]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.reset]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...reset}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...reset }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.reset}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset } { 666 } { b-3 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_v_greset:vnT { key } { } { }
    \BNVS_V_append:vvTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../v_greset }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[.reset_all]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[.reset_all]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...reset\_all}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...reset_all }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/.reset_all}, noigre}
% \reset:n { }
% \Test_if_resolve:nnnn { :666 } { ++X } { 667 } { a-1 }
% \Test_if_resolve:nnnn { } { X.2 } { 667 } { a-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-3 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { a-4 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { b-1 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { b-3 }
% \reset:n { }
% \Test_if_resolve:nnnn { :LAST } { ++X } { 667 } { c-1 }
% \Test_if_resolve:nnnn { } { LAST+=333 } { 999 } { c-2 }
% \Test_if_resolve:nnnn { } { X.reset_all } { 666 } { c-3 }
% \Test_if_resolve:nnnn { } { X } { 666 } { c-4 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_greset_all:vnT { key } { } { }
    \BNVS_V_append:vvTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../greset_all }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~reset }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...<integer>]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...<integer>]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...<integer> }
\BNVS_DEBUG_log_tl:i { a }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/Counter/.<integer>}, noigre}
% \Test_if_resolve:nnnn { 222 } { X.1 } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X.1 } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X.1 } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X.1 } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X.1 } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X.1 } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.1 } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X.1 } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X.1 } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X.1 } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X.1 } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X.1 } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X.1 } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X.1 } { 666 } { 1-d' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:TF {
    \BNVS_index_append:vvcTF { key } { a } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../<integer> }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~integer }
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_tl:i { ans }
\BNVS_DEBUG_tl:i { a }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_tl_put_right:in { ans } { -1+ }
    \BNVS_tl_put_right:ii { ans } { a }
    \BNVS_round_ans:
    \BNVS_if_resolve_end_return_true:
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/Counter/...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X } { 222 } { 1-a }
% \Test_if_resolve:nnnn { 222: } { X } { 222 } { 1-a' }
% \Test_if_resolve:nnnn { 222::445 } { X } { 222 } { 1-a'' }
% \Test_if_resolve:nnnn { 222:: } { X } { 222 } { 1-a''' }
% \Test_if_resolve:nnnn { 222:666 } { X } { 222 } { 1-a'''' }
% \Test_if_resolve:nnnn { :666 } { X } { 666 } { 1-a''''' }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X } { 222 } { 1-b }
% \Test_if_resolve:nnnn { FIRST: } { X } { 222 } { 1-b' }
% \Test_if_resolve:nnnn { FIRST:: } { X } { 222 } { 1-b'' }
% \Test_if_resolve:nnnn { FIRST::LENGTH } { X } { 222 } { 1-b''' }
% \Test_if_resolve:nnnn { FIRST:LAST } { X } { 222 } { 1-b'''' }
% \Test_if_resolve:nnnn { LENGTH } { X } { 445 } { 1-c }
% \Test_if_resolve:nnnn { LAST } { X } { 666 } { 1-d }
% \Test_if_resolve:nnnn { :LAST } { X } { 666 } { 1-d' }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_V_append:vvTF { key } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../... }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~value }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...++]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...++]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...++ }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_suffix:nTF { reset } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...reset++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...reset++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_path_resolve_n:T {
      \BNVS_v_greset:vnT { key } { } { }
      \BNVS_v_post_append:vncTF { key } { 1 }  { ans } {
        \BNVS_if_resolve_loop_or_end_return:
      } {
        \BNVS_if_resolve_end_return_false:n { NO~post }
      }
    }
  } {
    \BNVS_path_suffix:nTF { reset_all } {
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...reset_all++}, noigre}
% \Test_if_resolve:nnnn { 222 } { X ++ } { 222 } { 1-a }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-a }
% \reset:n { }
% \Test_if_resolve:nnnn { FIRST } { X ++ } { 222 } { 1-b }
% \Test_if_resolve:nnnn { } { X++ } { 223 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { X.reset_all++  } { 222 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 5-b }
% \end{bnvs.test}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...reset_all++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_path_resolve_n:T {
        \BNVS_greset_all:vnT { key } { } { }
        \BNVS_v_post_append:vncTF { key } { 1 }  { ans } {
          \BNVS_if_resolve_loop_or_end_return:
        } {
          \BNVS_if_resolve_end_return_false:n { NO~post }
        }
      }
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...++ }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_path_resolve_n:T {
        \BNVS_v_post_append:vncTF { key } { 1 }  { ans } {
          \BNVS_if_resolve_loop_or_end_return:
        } {
          \BNVS_if_resolve_end_return_false:n { NO~post }
        }
      }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...n+=...]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...n+=...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{....n+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...n+=... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...n+=...}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.n += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.n += 444 } { 666 } { B }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { C }
% \Test_if_resolve:nnnn { } { X.n += -444 } { 222 } { D }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { E }
% \Test_if_resolve:nnnn { } { X.n += (LENGTH - 1) } { 666 } { F }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { G }
% \Test_if_resolve:nnnn { } { X.n += (-(LENGTH-1)) } { 222 } { H }
% \Test_if_resolve:nnnn { } { X.n } { 222 } { I }
% \Test_if_resolve:nnnn { } { X.n += LENGTH - 1 } { 666 } { J }
% \Test_if_resolve:nnnn { } { X.n } { 666 } { K }
% \Test_if_resolve:nnnn { } { X.n += -444~4 } { 2224 } { L }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_base_resolve_n:
    \BNVS_n_incr_append:vvvcTF { key } { key_base }  { incr }  { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...n+=... }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n {
        NO~n~incrementation
      }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...+=...]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...+=...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{A+=\meta{integer}}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...+=... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...+=...}, noigre}
% \Test_if_resolve:nnnn { 222 } { X += 444 } { 666 } { 1 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 2 }
% \Test_if_resolve:nnnn { } { X += -444 } { 222 } { 3 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 4 }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X += 444 } { 666 } { A }
% \Test_if_resolve:nnnn { } { FIRST } { 222 } { B }
% \Test_if_resolve:nnnn { FIRST } { X += (LENGTH - 1) } { 666 } { 7 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 8 }
% \Test_if_resolve:nnnn { } { X += (-(LENGTH-1)) } { 222 } { 9 }
% \Test_if_resolve:nnnn { } { X } { 222 } { 10 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH - 1 } { 666 } { 11 }
% \Test_if_resolve:nnnn { } { X } { 666 } { 12 }
% \Test_if_resolve:nnnn { FIRST } { X += LENGTH ~ - 1 } { 666 } { 16 }
% \Test_if_resolve:nnnn { } { X } { 667 } { 13 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_v_incr_append:vvcTF { key }  { incr }  { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...+=... }
%</!final>
% \end{bnvs.gobble}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n {
        NO~incremented~value
      }
    }
  }
}
%    \end{macrocode}
%^^A::\...base_resolve_n: } {
%    \begin{macrocode}
\BNVS_new:bpn { base_resolve_n: } {
  \BNVS_seq_if_empty:iF { path_base } {
    \BNVS_seq_pop_right:cc { path_base } { a }
    \BNVS_seq_if_empty:iF { path_base } {
      \BNVS_tl_put_right:ix { key_base } {
        . \BNVS_seq_use:in { path_base } { . }
      }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...BASE~n... }
\BNVS_DEBUG_log_tl:i { key }
\BNVS_DEBUG_log_tl:i { id }
\BNVS_DEBUG_log_seq:xi { \BNVS_tl_use:i { path } } { path }
\BNVS_DEBUG_log_tl:i { key_base }
\BNVS_DEBUG_log_seq:i { path_base }
\BNVS_DEBUG_log_tl:i { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%^^A::\...base_resolve:
%    \begin{macrocode}
\BNVS_new:bpn { base_resolve: } {
  \BNVS_seq_if_empty:iF { path_base } {
    \BNVS_tl_put_right:ix { key_base } {
      . \BNVS_seq_use:in { path_base } { . }
    }
  }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { ...BASE... }
\BNVS_DEBUG_log_tl:i { key }
\BNVS_DEBUG_log_tl:i { id }
\BNVS_DEBUG_log_seq:xi { \BNVS_tl_use:i { path } } { path }
\BNVS_DEBUG_log_tl:i { key_base }
\BNVS_DEBUG_log_seq:i { path_base }
\BNVS_DEBUG_log_tl:i { ans }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[...++n]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[...++n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{...++n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~...++n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/...++n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { X.++n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { X.++n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { X.3.N.++n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_base_resolve:
    \BNVS_n_incr_append:iiniTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../...++n }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~...++n }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[++...n]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[++...n]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{++...n}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:x { ▃▃▃▃▃~CASE~++...n }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.test}{bnvs:cn={if_resolve:niTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.test}{bnvs:cn={if_append:niTF}{/++...n}, noigre}
% \reset:n { YES }
% \Test_if_append:nnnn { 222 } { ++X.n } { 223 } { 1-a }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_append:nnnn { FIRST } { ++X.n } { 223 } { 1-b }
% \Test_if_append:nnnn { } { X.n  } { 223 } { 2-b }
% \Test_if_append:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N.n } { 555 } { 3-b }
% \Test_if_append:nnnn { } { X.3.N.n } { 555 } { 4-b }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_resolve_n:T {
    \BNVS_base_resolve_n:
    \BNVS_n_incr_append:iiniTF { key } { key_base } { 1 }  { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../++...n }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \BNVS_if_resolve_loop_or_end_return:
    } {
      \BNVS_if_resolve_end_return_false:n { NO~++...n }
    }
  }
}
%    \end{macrocode}
%^^A::\...if_resolve_loop_or_end_return[++...]:
%    \begin{macrocode}
\BNVS_new:bpn { if_resolve_loop_or_end_return[++...]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item Case \texttt{++...}.
% \begin{bnvs.gobble}
%<*!final>
\BNVS_log:n { ▃▃▃▃▃~CASE~++... }
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_path_suffix:nTF { reset } {
    \BNVS_path_resolve_n:T {
      \BNVS_v_incr_append:iniTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../++...reset }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
        \BNVS_v_greset:vnT { key } { } { }
        \BNVS_if_resolve_loop_or_end_return:
      } {
        \BNVS_v_greset:vnT { key } { } { }
        \BNVS_if_resolve_end_return_false:n { No~increment }
      }
    }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
  } {
    \BNVS_path_suffix:nTF { reset_all } {
      \BNVS_path_resolve_n:T {
        \BNVS_v_incr_append:iniTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../++...reset_all }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \BNVS_greset_all:vnT { key } { } { }
          \BNVS_if_resolve_loop_or_end_return:
        } {
          \BNVS_greset_all:vnT { key } { } { }
          \BNVS_if_resolve_end_return_false:n { No~increment }
        }
      }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:cn={if_resolve_loop_or_end_return[++...]:}{/reset_all}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-a }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-a }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-a }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { ++X } { 224 } { 2-b }
% \Test_if_resolve:nnnn { } { X  } { 224 } { 3-b }
% \Test_if_resolve:nnnn { } { ++X.reset_all } { 225 } { 4-b }
% \Test_if_resolve:nnnn { } { X  } { 222 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
    } {
      \BNVS_path_resolve_n:T {
        \BNVS_v_incr_append:iniTF { key } { 1 } { ans } {
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_if_resolve_niTF:nn { ... } { .../++... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
          \BNVS_if_resolve_loop_or_end_return:
        } {
          \BNVS_if_resolve_end_return_false:n { No~increment }
        }
      }
    }
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c={if_resolve_loop_or_end_return[++...]:}, noigre}
% \reset:n { YES }
% \Test_if_resolve:nnnn { 222 } { ++X } { 223 } { 1-a }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-a }
% \reset:n { YES }
% \Test_if_resolve:nnnn { FIRST } { ++X } { 223 } { 1-b }
% \Test_if_resolve:nnnn { } { X  } { 223 } { 2-b }
% \Test_if_resolve:nnnn { A,X.3.N=B,B=111,X.3.N.2=555 } { ++X.3.N } { 112 } { 3-b }
% \Test_if_resolve:nnnn { } { X.3.N } { 112 } { 4-b }
% \Test_if_resolve:nnnn { } { B } { 112 } { 5-b }
% \end{bnvs.test}
%    \begin{macrocode}
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
%
% \begin{function}[TF]{
%   \BNVS_query_eval:in
% }
% \begin{syntax}
% \cs{BNVS_query_eval:inTF} \marg{tl core} \marg{overlay query} \marg{yes code} \marg{no code}
% \end{syntax}
% Evaluates the single \meta{overlay query}, 
% which is expected to contain no comma.
% Extract a range specification from the argument,
% replaces all the \emph{named overlay specifications} by their static counterparts,
% make the computation then append the result to 
% the right of |\l__bnvs_ans_tl|.
% Ranges are supported with the colon syntax.
% This is executed within a local \TeX\ group managed by the caller.
% Below are local variables and constants.
% \begin{variable}{\l__bnvs_V_tl}
% Storage for a single value out of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_TEST_A_tl}
% Storage for the first component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_Z_tl}
% Storage for the last component of a range.
% \end{variable}
% \begin{variable}{\l__bnvs_L_tl}
% Storage for the length component of a range.
% \end{variable}
% \begin{variable}{\c__bnvs_A_cln_Z_regex}
% Used to parse slide range overlay specifications.
% A, A:Z, A::L on one side, :Z, :Z::L and ::L:Z on the other sides.
% Next are the capture groups.
% \end{variable}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_A_cln_Z_regex {
  \A \s* (?:
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{myList}
% \item 2: V
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    ( [^:]+? )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 3, 4, 5: A : Z? or A :: L?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | ( [^:]+? ) \s* : (?: ( \s* [^:]*? ) | : ( \s* [^:]*? ) )
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 6, 7: ::(L:Z)?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | :: \s* (?: ( [^:]+? ) \s* : \s* ( [^:]+? ) )?
%    \end{macrocode}
% \end{bnvs.macrocode}
% \item 8, 9: :(Z::L)?
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    | : \s* (?: ( [^:]+? ) \s* :: \s* ( [^:]*? ) )?
  )
  \s* \Z
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{myList}
% \begin{bnvs.test}{:N=\c__bnvs_A_cln_Z_regex, noigre}
% \Test_regex:cnnn { A_cln_Z } {V    } {{},{V},{ },{ },{ },{ },{ },{ },{ }} {1}
% \Test_regex:cnnn { A_cln_Z } {A:Z  } {{},{ },{A},{Z},{ },{ },{ },{ },{ }} {2}
% \Test_regex:cnnn { A_cln_Z } {A:   } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {3}
% \Test_regex:cnnn { A_cln_Z } {A::L } {{},{ },{A},{ },{L},{ },{ },{ },{ }} {4}
% \Test_regex:cnnn { A_cln_Z } {A::  } {{},{ },{A},{ },{ },{ },{ },{ },{ }} {5}
% \Test_regex:cnnn { A_cln_Z } {::L:Z} {{},{ },{ },{ },{ },{L},{Z},{ },{ }} {6}
% \Test_regex:cnnn { A_cln_Z } {::   } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {7}
% \Test_regex:cnnn { A_cln_Z } {:Z::L} {{},{ },{ },{ },{ },{ },{ },{Z},{L}} {8}
% \Test_regex:cnnn { A_cln_Z } {:Z:: } {{},{ },{ },{ },{ },{ },{ },{Z},{ }} {9}
% \Test_regex:cnnn { A_cln_Z } {:    } {{},{ },{ },{ },{ },{ },{ },{ },{ }} {10}
% \end{bnvs.test}
% \end{function}
% \begin{bnvs.macrocode}
%^^A:\...eval:ni
%^^A::\...query_eval_end_return_true:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_end_return_true: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \group_end:
  \prg_return_true:
}
%    \end{macrocode}
%^^A::\...query_eval_end_return_false:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_end_return_false: } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%^^A::\...query_eval_end_return_false:n
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_end_return_false:n } #1 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_end:
  \prg_return_false:
}
%    \end{macrocode}
%^^A::\...query_eval_error_end_return_false:n
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_error_end_return_false:n } #1 {
  \BNVS_error:x { #1 }
  \BNVS_query_eval_end_return_false:
}
%    \end{macrocode}
%^^A::\...query_eval_unreachable:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_unreachable: } {
  \BNVS_query_eval_error_end_return_false:n { UNREACHABLE }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{function}[TF]{
%   \BNVS_query_eval_match_branch:
% }
% \begin{syntax}
% \cs{BNVS_query_eval_match_branch:TF} \marg{true code} \marg{false code}
% \end{syntax}
% Puts the proper items of |\l__bnvs_match_seq| in
% |\l__bnvs_V_tl|, |\l__bnvs_TEST_A_tl|, |\l__bnvs_Z_tl|, |\l__bnvs_L_tl|
% then branches accordingly on one of the returning 
% |\BNVS_query_eval_return[|\meta{description}|]:| functions.
% All these functions properly set the |...ans_tl| variable and they end with either
% |\prg_return_true:| or |\prg_return_false:|.
% This is not inlined for readability.
% \end{function}
% \begin{bnvs.macrocode}
%^^A::\...query_eval_match_branch:
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { query_eval_match_branch: } { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...MATCH... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_match_pop_left:iT V {
    \BNVS_match_pop_left:iT V {
      \BNVS_tl_if_blank:vTF V {
        \BNVS_match_pop_left:iT A {
          \BNVS_match_pop_left:iT Z {
            \BNVS_match_pop_left:iT L {
              \BNVS_tl_if_blank:vTF A {
                \BNVS_match_pop_left:iT L {
                  \BNVS_match_pop_left:iT Z {
                    \BNVS_tl_if_blank:vTF Z {
                      \BNVS_tl_if_blank:vTF L {
                        \BNVS_match_pop_left:iT Z {
                          \BNVS_match_pop_left:iT L {
                            \BNVS_tl_if_blank:vTF L {
                              \BNVS_tl_if_blank:vTF Z {
                                \BNVS_use:b { query_eval_return[:]: }
                              } {
                                \BNVS_use:b { query_eval_return[:Z]: }
                              }
                            } {
                              \BNVS_tl_if_blank:vTF Z {
\BNVS_query_eval_error_end_return_false:n { Missing~first~or~last }
                              } {
                                \BNVS_use:b { query_eval_return[:Z::L]: }
                              }
                            }
                          }
                        }
                      } {
\BNVS_query_eval_error_end_return_false:n { Missing~first~or~last }
                      }
                    } {
                      \BNVS_tl_if_blank:vTF L {
                        \BNVS_query_eval_unreachable:
                      } {
                        \BNVS_use:b { query_eval_return[:Z::L]: }
                      }
                    }
                  }
                }
              } {
                \BNVS_tl_if_blank:vTF Z {
                  \BNVS_tl_if_blank:vTF L {
                    \BNVS_use:b { query_eval_return[A:]: }
                  } {
                    \BNVS_use:b { query_eval_return[A::L]: }
                  }
                } {
                  \BNVS_tl_if_blank:vTF L {
                    \BNVS_use:b { query_eval_return[A:Z]: }
                  } {
                    \BNVS_query_eval_error_end_return_false:n {
                      Only~two~of~first,~last~or~length
                    }
                  }
                }
              }
            }
          }
        }
      } {
        \BNVS_use:b { query_eval_return[V]: }
      }
    }
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[V]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[V]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} Single value
% \begin{bnvs.test}{bnvs:c={query_eval_return[V]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { V } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[V]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { 666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_if_resolve:iiTF { V } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...[V]...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_true:
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...[V]...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[A:Z]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[A:Z]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:\meta{last}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A:Z]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { A } { LAST - LENGTH + 1}
% \BNVS_tl_set:in { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[A:Z]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_if_resolve:iiTF { A } { ans } {
    \BNVS_tl_put_right:in { ans } { - }
    \BNVS_if_append:iiTF { Z } { ans } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...[A:Z]...TRUE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...[A:Z]...FALSE/A }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[A::L]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[A::L]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}::\meta{length}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A::L]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { A } { LAST - LENGTH + 1}
% \BNVS_tl_set:in { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[A::L]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_if_resolve:iiTF { A } { A } {
    \BNVS_if_resolve:iiTF { L } { ans } {
      \BNVS_tl_put_right:in { ans } { + }
      \BNVS_tl_put_right:ii { ans } { A }
      \BNVS_tl_put_right:in { ans } { -1 }
      \BNVS_round_ans:
      \BNVS_tl_put_left:in { ans } { - }
      \BNVS_tl_put_left:cv { ans } { A }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[A:]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[A:]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{\meta{first}:} and \texttt{\meta{first}::} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[A:]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { A } { LAST - LENGTH + 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[A:]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { 222- } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_if_resolve:iiTF { A } { ans } {
    \BNVS_tl_put_right:in { ans } { - }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[:Z::L]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[:Z::L]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{:Z::L} or \texttt{::L:Z} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:Z::L]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { Z } { FIRST + LENGTH - 1}
% \BNVS_tl_set:in { L } { LAST - FIRST + 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[:Z::L]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { 222-666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_if_resolve:iiTF { Z } { Z } {
    \BNVS_if_resolve:iiTF { L } { ans } {
      \BNVS_tl_put_left:in  { ans } { 1-}
      \BNVS_tl_put_right:in { ans } { + }
      \BNVS_tl_put_right:ii { ans } { Z }
      \BNVS_round_ans:
      \BNVS_tl_put_right:in { ans } { - }
      \BNVS_tl_put_right:ii { ans } { Z }
      \prg_return_true:
    } {
      \prg_return_false:
    }
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval_return[:]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[:]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{:} or \texttt{::} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:]:}, noigre}
% \reset:n { Y }
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[:]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { - } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_tl_set:in { ans } { - }
  \prg_return_true:
}
%    \end{macrocode}
%^^A::\...query_eval_return[:Z]:
%    \begin{macrocode}
\BNVS_new:bpn { query_eval_return[:Z]: } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% \emoji{left-speech-bubble} \texttt{::\meta{last}} range
% \begin{bnvs.test}{bnvs:c={query_eval_return[:Z]:}, noigre}
% \reset:n { Y }
% \BNVS_tl_set:in { Z } { FIRST + LENGTH - 1}
% \BNVS_new_conditional:bpnn { TEST: } { TF } {
%   \BNVS_use:b { query_eval_return[:Z]: }
% }
% \BNVS_TEST:TF {
%   \assert_equal_ans:nn { -666 } { 1 }
% } {
%    \test_fail:n { NO~WAY }
% }
% \cs_undefine:N \BNVS_TEST:TF
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_tl_set:in { ans } { - }
  \BNVS_if_append:iiTF { Z } { ans } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
%^^A::\...query_eval:in
%    \begin{macrocode}
\BNVS_new_conditional:bpnn { query_eval:in } #1 #2 { T, F, TF } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnin { query_eval:inTF } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_query_eval_inTF:nn { } { ... }
\BNVS_set:bpn { error:n } ##1 {
  \msg_error:nnn { beanoves } { :n } { #1 / ##1 }
}
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_call_greset:
  \BNVS_extract_once:inTF { A_cln_Z } { #2 } {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...MATCH... }
\BNVS_DEBUG_log_seq:i { match }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
    \BNVS_begin:
    \BNVS_query_eval_match_branch:TF {
      \BNVS_end_tl_set:ii { #1 } { ans }
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...TRUE }
\BNVS_DEBUG_log_tl:i { #1 }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_true:
    } {
      \BNVS_end:
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_query_eval_inTF:nn { ... } { ...FALSE }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
      \prg_return_false:
    }
  } {
%    \end{macrocode}
% \end{bnvs.macrocode}
% Error
% \begin{bnvs.macrocode}
%    \begin{macrocode}
    \BNVS_error:n { Syntax~error:~#2 }
    \prg_return_false:
  }
}
%    \end{macrocode}
% \begin{bnvs.test}{bnvs:c={query_eval:inTF}, noigre}
% \Test_query:nnnn { 100 } { 1 } { 1 } { 1 }
% \Test_query:nnnn { } { 1+1 } { 2 } { 2 }
% \Test_query:nnnn { } { X.1 } { 100 } { 3a }
% \Test_query:nnnn { } { X.11 } { 110 } { 3b }
% \Test_query:nnnn { } { X.1+X.11 } { 210 } { 3c }
% \Test_query:nnnn { } { X.111 } { 210 } { 4a }
% \Test_query:nnnn { } { X.1:X.111 } { 100-210 } { 4b }
% \Test_query:nnnn { } { X.1::111 } { 100-210 } { 5 }
% \Test_query:nnnn { 4 } { X.1 } { 4 } { 6 }
% \Test_query:nnnn { } { X.0 } { 3 } { 7 }
% \Test_query:nnnn { } { X.-1 } { 2 } { 8 }
% \Test_query:nnnn { } { X.-2 } { 1 } { 9 }
% \Test_query:nnnn { } { X.-3 } { 0 } { 10 }
% \end{bnvs.test}
% \end{bnvs.macrocode}
%
% \begin{function}{
%   \BNVS_eval:in
% }
% \begin{syntax}
% \cs{BNVS_eval:in} \meta{tl core} \marg{overlay query list}
% \end{syntax}
% This is called by the \emph{named overlay specifications} scanner.
% Evaluates the comma separated list of \meta{overlay query}'s,
% replacing all the named overlay specifications and integer expressions
% by their static counterparts by calling \cs{BNVS_query_eval:inTF},
% then append the result to the right of the \meta{tl variable}.
% This is executed within a local group.
% Below are local variables and constants used
% throughout the body of this function.
% \begin{variable}{\l__bnvs_query_seq}
% Storage for a sequence of \meta{query}'s obtained by splitting a comma separated list.
% \end{variable}
% \begin{variable}{\l__bnvs_ans_seq}
% Storage of the evaluated result.
% \end{variable}
% \begin{variable}{\c__bnvs_comma_regex}
% Used to parse slide range overlay specifications.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\regex_const:Nn \c__bnvs_comma_regex { \s* , \s* }
%    \end{macrocode}
% \end{bnvs.macrocode}
% \end{variable}
% No other variable is used.
% \end{function}
% \begin{bnvs.macrocode}
%^^A::\...eval:ni
%    \begin{macrocode}
\BNVS_new:bpn { eval:in } #1 #2 {
%    \end{macrocode}
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_log_set:bnin { eval:in } { QUERY } { #1 } { #2 }
\BNVS_DEBUG_log_eval_nc:nn { } { ... }
%</!final>
% \end{bnvs.gobble}
%    \begin{macrocode}
  \BNVS_begin:
%    \end{macrocode}
% \end{bnvs.macrocode}
% Local variables declaration
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_seq_clear:i { query }
  \BNVS_seq_clear:i { ans }
%    \end{macrocode}
% \end{bnvs.macrocode}
% In this main evaluation step, we evaluate the integer expression and put
% the result in a variable which content will be copied after the group is closed.
% We authorize comma separated expressions
% and \texttt{\meta{first}::\meta{last}} range expressions as well.
% We first split the expression around commas, into \cs{l_query_seq}.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \regex_split:NnN \c__bnvs_comma_regex { #2 } \l__bnvs_query_seq
%    \end{macrocode}
% \end{bnvs.macrocode}
% Then each component is evaluated and the result is stored in \cs{l__bnvs_ans_seq}
% that we have clear before use.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_seq_map_inline:in { query } {
    \BNVS_tl_clear:i { ans }
    \BNVS_query_eval:inTF { ans } { ##1 } {
      \BNVS_seq_put_right:ii { ans } { ans }
    } {
      \seq_map_break:n {
        \BNVS_error:n { Circular/Undefined~dependency~in~#2}
      }
    }
  }
%    \end{macrocode}
% \end{bnvs.macrocode}
% We have managed all the comma separated components, we collect them back
% and append them to the tl variable.
% \begin{bnvs.macrocode}
%    \begin{macrocode}
  \BNVS_seq_use:nin {
    \BNVS_end: \BNVS_tl_put_right:in { #1 }
  } { ans } ,
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{bnvs:c={eval:in}, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BNVS_DEBUG_log_tl:i { ans }
% \BNVS_tl_clear:i { ans }
% \BNVS_eval:in { ans } {X.1}
% \assert_equal_ans:nn { 222 } { 1 }
% \end{bnvs.test}
%
% \begin{function}{\BeanovesEval}
%   \begin{syntax}
%     \cs{BeanovesEval} \oarg{tl variable} \marg{overlay queries}
%   \end{syntax}
% \meta{overlay queries} is the argument of |?(...)| instructions.
% This is a comma separated list of single \meta{overlay query}'s.
%
% This function evaluates the \meta{overlay queries} and store the result in the \meta{tl variable} when provided
% or leave the result in the input stream. Forwards to \cs{BNVS_eval:ni}
% within a group. \cs{...ans_tl} is used locally to store the result.
% \end{function}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesEval { O{} m } {
  \BNVS_begin:
  \keys_define:nn { BeanovesEval } {
    in:N .tl_set:N = \l__bnvs_BeanovesEval_tl,
    in:N .initial:n = { },
    see .bool_set:N = \l__bnvs_BeanovesEval_bool,
    see .default:n = true,
    see .initial:n = false,
  }
  \keys_set:nn { BeanovesEval } { #1 }
  \BNVS_tl_clear:i { ans }
  \BNVS_eval:in { ans } { #2 }
  \BNVS_tl_if_empty:iTF { BeanovesEval } {
    \BNVS_bool_if:iTF { BeanovesEval } {
      \BNVS_tl_use_n:Ni \BNVS_end: { ans }
    } {
      \BNVS_end:
    }
  } {
    \BNVS_bool_if:iTF { BeanovesEval } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
        \BNVS_end:
        \tl_set:Nn ##1 { ##2 }
        ##2
      }
    } {
      \cs_set:Npn \BNVS_end:Nn ##1 ##2 {
        \BNVS_end:
        \tl_set:Nn ##1 { ##2 }
      }
    }
    \BNVS_tl_use:ni {
      \BNVS_tl_use:Ni \BNVS_end:Nn { BeanovesEval }
    } { ans }
  }
}
%    \end{macrocode}
% \end{bnvs.macrocode}
% \begin{bnvs.test}{:N=\BeanovesEval, noigre}
% \reset:n { }
% \Test_if_append:nnnn { 222 } { X.1 } { 222 } { A }
% \BeanovesEval[in:N=\l__bnvs_TEST_A_tl]{X.2}
% \assert_equal_tl:vnn { TEST_A } { 223 } { 1 }
% \end{bnvs.test}
%
% \subsubsection{Reseting counters}
% \begin{function}{\BeanovesReset, \BeanovesReset*}
%   \begin{syntax}
%     \cs{beanovesReset} \oarg{first value} \marg{key}
%     \cs{beanovesReset}* \oarg{first value} \marg{key}
%   \end{syntax}
% Forwards to \cs{BNVS_v_greset:nnF} or \cs{BNVS_greset_all:nnF} when starred.
% \end{function}
% \begin{bnvs.test}{:N=\BeanovesReset, noigre}
% \reset:n { YES }
% \Test_what_append_X_ncTF:nnnn { V } { FIRST } { 222 } { 1 }
% \Test_v_incr_append:nnnnn { } { ?!X } { 123 } { 345 } { 1 }
% \BeanovesReset{X}
% \Test_what_append_X_ncTF:nnnn { V }{ } { 222 } { 1 }
% \end{bnvs.test}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\NewDocumentCommand \BeanovesReset { s O{} m } {
  \BNVS_name_id_n_get:nTF { #3 } {
    \BNVS_tl_use:ni {
      \IfBooleanTF { #1 } {
        \BNVS_greset_all:nnF
      } {
        \BNVS_v_greset:nnF
      }
    } { key } { #2 } {
%      \BNVS_warning:n { Unknown~name:~#3 }
    }
  } {
    \BNVS_warning:n { Bad~name:~#3 }
  }
  \ignorespaces
}
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.gobble}
%<*!final>
\BNVS_DEBUG_off:
%</!final>
% \end{bnvs.gobble}
% \begin{bnvs.macrocode}
%    \begin{macrocode}
\makeatother
\ExplSyntaxOff
%    \end{macrocode}
% \end{bnvs.macrocode}
%
% \begin{bnvs.test}{banner=misc, noigre}
% \cs_set:Npn \BNVS_Test:nn #1 #2 {
%   \banner:n { #1 => #2}
%   \BNVS_if_resolve:niTF { #1 } { ans } {
%     \assert_equal_ans:nn { #2 } { A }
%   } {
%     \test_fail:n { B }
%   }
% }
% \Beanoves {
%   Air      = 1 : Gannet.last,
%   Chameleo = Air.2::1,
%   Gannet   = Chameleo.next::1,
%   Water    = Air.next : Picasso.last,
%   Octopus  = Water.2::1,
%   Starfish = Octopus.next::1,
%   StickyStarfish = Starfish.1::1,
%   Picasso = Starfish.next::1,
%   PicassoTrans = 1 : Picasso.previous,
%   Summary  = Water.next::1,
% }
% \BNVS_Test:nn { Chameleo.previous } {1}
% \BNVS_Test:nn { Gannet.previous } {2}
% \BNVS_Test:nn { Water.previous } {3}
% \BNVS_Test:nn { Octopus.previous } {4}
% \BNVS_Test:nn { Starfish.previous } {5}
% \BNVS_Test:nn { PicassoTrans.range } {1-6}
% \BNVS_Test:nn { Air.range } {1-3}
% \BNVS_Test:nn { Chameleo.1 } {2}
% \BNVS_Test:nn { Gannet.1 } {3}
% \BNVS_Test:nn { Water.range } {4-7}
% \BNVS_Test:nn { Octopus.1 } {5}
% \BNVS_Test:nn { Starfish.1 } {6}
% \BNVS_Test:nn { Picasso.range } {7-7}
% \BNVS_Test:nn { Summary.range } {8-8}
% \BNVS_Test:nn { Picasso.1 } {7}
% \BNVS_Test:nn { Air.last } {3}
% \BNVS_Test:nn { StickyStarfish.range } {6-6}
% \cs_undefine:N \BNVS_Test:nn
% \end{bnvs.test}
%
% \end{implementation}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex }
%
%\Finale
%
% \begin{bnvs.gobble}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%<*internal>
\iffalse
%</internal>
%^^A:test-lua
%<*test-lua>
local Command = {}
Command.__index = Command

function Command:clear()
  self.all__ = {}
  self.by_name__ = {}
  self.output__ = {}
end

Command:clear()

function Command:output(message)
  if message == true then
    self.output__ = {}
  elseif message then
    self.output__[#self.output__+1] = message
  end
  return self.output__
end

function Command:already(name, signature) --> Command?
  if signature then
    name = name..":"..signature
  end
  return self.by_name__[name]
end

function Command:base_signature(name) --> String, String?
  local pattern = "^([a-zA-Z_@]*):([NncVvoxefpwDTF]*)"
  local base, signature = name:match(pattern)
  if base then
    return base, signature
  end
  return name
end

function Command:make(name, signature) --> Command?
  -- self:output("name: "..name..", signature: "..(signature or "")..", "..(name:find("bnvs") and "OK" or "KO"))
  if not name:find("bnvs") then
    return nil
  end
  if name:find("q__") then
    return nil
  end
  if name:find("DEBUG") then
    return nil
  end
  if name:len()<7 then
    return nil
  end
  if signature then
    name = name..":"..signature
  end
  local o = self.by_name__[name]
  if o then
    return o
  end
  local base, signature = self:base_signature(name)
  o = {
    name = name,
    base = base,
    signature = signature,
  }
  setmetatable(o, self)
  table.insert(self.all__, o)
  self.by_name__[name] = o
  if name:match("^c__") then
    o.is_constant = true
  elseif name:match("^[lg]__") then
    o.is_variable = true
  else
    o.is_function = true
  end
  return o
end

function iter (a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function Command:sorted()
  table.sort(self.all__, function(l, r) return l.name < r.name end)
  return iter, self.all__, 0
end

function Command:sorted_functions()
  local t = {}
  for _,cmd in self:sorted() do
    if cmd.is_function then
      t[#t+1] = cmd
    end
  end
  return iter, t, 0
end

function Command:parse_all(s)
  local n = 0
  local pattern = "%f[\\]"..--
"\\([a-zA-Z_@:]+)"
  for name in string.gmatch (s, pattern) do
    if not self:already(name) and self:make(name) then
      n = n+1
    end
  end
  pattern = "%f[\\]"..--
"\\BNVS_use:b%s*{%s*"..--
"([a-zA-Z_@:]+)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_"..name
    if not self:already(name) and self:make(name) then
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs commands parsed")
end

function Command:parse_set_eq(s)
  local n = 0
  local pattern = "\\cs_set_eq:NN%s*"..
"\\([a-zA-Z_@:]+)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command copy")
end

function Command:parse_action(s, action)
  local n = 0
  local pattern = "\\cs_"..action..":Np?n%s+"..
"\\([a-zA-Z_@:]*)"
  for name in string.gmatch (s, pattern) do
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." command definition "..action)
end

function Command:parse_BNVS_action(s, action)
  local n = 0
  local pattern = "\\BNVS_"..action..":cpn%s*{%s*"..
"([a-zA-Z_@:]*)%s*}"
  local status = 1
  for name in string.gmatch ([[
ABCD
]].."\\BNVS_"..action..":cpn "..
"{ match_pop_left:iT } #1 #2 { ... }"..[[
]], pattern) do
    status = 0
    if name ~= "match_pop_left:iT" then
      status = 1
    end
  end
  if status == 1 then
    error("Bad pattern")
  end
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_"..name
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs command definition "..action)
end

function Command:parse_BNVS_new_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_"..signature..":ncn?%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for module, name in string.gmatch (s, pattern) do
    name = "__bnvs_"..module.."_"..name
    local cmd = self:make(name..":"..signature)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new definition "..signature)
end

function Command:parse_BNVS_new_tl_signed(s, signature)
  local n = 0
  local pattern = "\\BNVS_new_tl_"..signature..":c?%s*{%s*"..
"([a-zA-Z_@]*)%s*}"
  for name in string.gmatch (s, pattern) do
    name = "__bnvs_tl_"..name..":"..signature
    local cmd = self:make(name)
    if cmd then
      cmd.is_defined = true
      n = n+1
    end
  end
  self:output("-> "..n.." bnvs new tl definition "..signature)
end

function Command:complete_variant(variant, signature) --> String
  if #variant < #signature then
    local ans = {}
    for i=1,#signature do
      ans[#ans+1] = signature:sub(i, i)
    end
    for i=1,#variant do
      ans[i] = variant:sub(i, i)
    end
    return table.concat(ans)
  end
  return variant
end

function Command:parse_generate_variant(s)
  local n = 0
  local pattern = "\\cs_generate_variant:Nn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_BNVS_generate_variant(s)
  local n = 0
  local pattern = "\\BNVS_generate_variant:bn%s*"..
"{%s*"..
"([a-zA-Z_@:]*)%s*}%s*"..
"{([NncVvoxefpwDTF,%s]-)}"
  for core, variants in string.gmatch (s, pattern) do
    core = "__bnvs_"..core
    local cmd = self:already(core)
    if cmd then
      cmd.is_core = true
    end
    local base, signature = self:base_signature(core)
    if signature then
      for v in variants:gmatch("([NncVvoxefpwDTF]+)") do
        v = self:complete_variant(v, signature)
        local name = base..":"..v
        local generated = self:already(name)
        if generated then
          generated.is_defined = true
          generated.core = core
        else
          generated = self:make(name)
          if generated then
            generated.is_defined = true
            generated.is_unused = true
            generated.core = core
          end
        end
        n = n+1
      end
    else
      self:output("INCONSISTENCY, No signature: "..core)
    end
  end
  self:output("-> "..n.." bnvs variants generated")
end

function Command:parse_new_conditional(s)
  local n = 0
  local pattern = "\\prg_new_conditional:Npnn%s*"..
"\\([a-zA-Z_@:]*)%s*"..
"[^{"..--}
"]*{([pTF,%s]-)}"
  for core, conditionals in string.gmatch (s, pattern) do
    local from = self:already(core)
    if from then
      from.is_conditional_core = true
    end
    local base, signature = self:base_signature(core)
    for c in conditionals:gmatch("([pTF]+)") do
      local name = c == "p" and (signature and base.."_p:"..signature or core.."_p") or core..c
      local generated = self:make(name)
      if generated then
        generated.is_defined = true
        generated.conditional_core = core
        n = n+1
      end
    end
  end
  self:output("-> "..n.." raw bnvs conditional generated")
end

function Command:parse_BNVS_new_conditional_cpnn(s)
  local n = 0
  local pattern = "BNVS_new_conditional:cpnn%s*{%s*"..
"([a-zA-Z_@]*):([a-zA-Z_@]*)%s*}[^{"..--}
"]*{%s*"..
"([pTF,%s]*)%s*}"
  local pattern_pTF = "([pTF]+)"
  for base, signature, pTFs in string.gmatch(s, pattern) do
    for pTF in string.gmatch(pTFs, pattern_pTF) do
      local name = "__bnvs_"..base
      if pTF == "p" then
        name = name.."_p:"..signature
      else
        name = name..":"..signature..pTF
      end
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = pTF == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = pTF == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs raw conditional variants generated")
end

function Command:parse_BNVS_new_conditional_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*"..
"[^{"..--}
"]*{([pTF,%s]*)}"
  local pattern_TF = "([TF]+)"
  for base, TFs in string.gmatch (s, pattern) do
    for c in string.gmatch (TFs, pattern_TF) do
      local name = "__bnvs_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." "..signature.." bnvs conditional generated")
end

function Command:parse_BNVS_new_conditional_module_signed(s, signature)
  local n = 0
  local pattern = "BNVS_new_conditional_"..signature..":ncn*%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*"..
"[^{"..--}
"]*{([pTF,%s]*)}"
  local pattern_pTF = "([pTF]+)"
  for module, base, pTFs in string.gmatch (s, pattern) do
    for c in string.gmatch (pTFs, pattern_pTF) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs "..signature.." conditional variants generated")
end

function Command:parse_BNVS_new_conditional_nc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_([a-z]*):ncn?%s*{%s*"..
"([a-z]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*"..
"[^{"..--}
"]*{([pTF,%s]*)}"
  local pattern_pTF = "([pTF]+)"
  for signature, module, base, pTFs in string.gmatch (s, pattern) do
    for c in string.gmatch (pTFs, pattern_pTF) do
      local name = "__bnvs_"..module.."_"..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs ncn conditional variants generated")
end

function Command:parse_BNVS_new_conditional_module_cc(s)
  local n = 0
  local pattern = "BNVS_new_conditional_cc:ncnn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
".-}%s*{%s*"..
"([pTF,%s]-)%s*}"
  local pattern_pTF = "([pTF]+)"
  local status = 1
  for module, base, pTFs in string.gmatch ([[
ABCD
\\BNVS_new_conditional_cc:ncnn { module } { base } { tl } { pTF }
EFGH
]], pattern) do
    status = 0
    if module ~= "module" then
      status = 1
    end
    if base ~= "base" then
      status = 1
    end
    if pTFs ~= "pTF" then
      status = 1
    end
  end
  if status ~= 0 then
    error("Bad pattern cc")
  end
  for module, base, pTFs in string.gmatch (s, pattern) do
    for c in string.gmatch (pTFs, pattern_pTF) do
      local name = "__bnvs_"..module.."_"..base..":cc"..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs cc conditional variants generated")
end

function Command:parse_BNVS_new_conditional_tl_signed(s, signature, is_tl)
  is_tl = is_tl == nil and false or is_tl
  local n = 0
  local pattern = "\\BNVS_new_conditional_tl_"..signature..":cn%s*{%s*"..
"([a-zA-Z_@]*)%s*}%s*{%s*"..
"([pTF,%s]-)%s*}"
  local pattern_pTF = "([pTF]+)"
  local prefix = is_tl and "__bnvs_tl_" or "__bnvs_"
  for base, pTFs in string.gmatch (s, pattern) do
    for c in string.gmatch (pTFs, pattern_pTF) do
      local name = prefix..base..":"..signature..c
      local generated = self:already(name)
      if generated then
        generated.is_defined = true
        generated.is_TF = c == "TF"
        n = n+1
      else
        generated = self:make(name)
        if generated then
          generated.is_defined = true
          generated.is_TF = c == "TF"
          generated.is_unused_conditional = true
          n = n+1
        end
      end
    end
  end
  self:output("-> "..n.." bnvs tl "..signature.." conditional variants generated")
end

function Command:check_unused_variants()
  self:output("-> check for unused variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused variants...DONE")
end

function Command:check_unused_conditional_variants(skip)
  if skip then
    return
  end
  self:output("-> check for unused conditional variants...")
  for _,cmd in self:sorted_functions() do
    if cmd.is_unused_conditional then
      self:output("  -> "..cmd.name)
    end
  end
  self:output("-> check for unused conditional variants...DONE")
end

function Command:check_undefined()
  self:output("-> check for undefined...")
  for _,cmd in self:sorted_functions() do
    if not cmd.is_defined and not cmd.is_conditional_core then
      if cmd.name:len() > 7 then
        self:output("!!!! "..cmd.name)
      end
    end
  end
  self:output("-> check for undefined...DONE")
end

function Command:check_variants(s) --> [String]
  self:clear()
  self:parse_all(s)
  self:parse_set_eq(s)
  self:parse_action(s,"new")
  self:parse_action(s,"set")
  self:parse_BNVS_action(s,"new")
  self:parse_BNVS_action(s,"set")
  self:parse_generate_variant(s)
  self:parse_BNVS_generate_variant(s)
  self:parse_new_conditional(s)
  self:parse_BNVS_new_signed(s, "c")
  self:parse_BNVS_new_signed(s, "cc")
  self:parse_BNVS_new_signed(s, "cn")
  self:parse_BNVS_new_signed(s, "cv")
  self:parse_BNVS_new_signed(s, "cnn")
  self:parse_BNVS_new_signed(s, "cnv")
  self:parse_BNVS_new_signed(s, "cnx")
  self:parse_BNVS_new_tl_signed(s, "c")
  self:parse_BNVS_new_tl_signed(s, "cn")
  self:parse_BNVS_new_tl_signed(s, "cv")
  self:parse_BNVS_new_conditional_cpnn(s)
  self:parse_BNVS_new_conditional_signed(s, "vc")
  self:parse_BNVS_new_conditional_signed(s, "vnc")
  self:parse_BNVS_new_conditional_signed(s, "nvc")
  self:parse_BNVS_new_conditional_signed(s, "vvnc")
  self:parse_BNVS_new_conditional_signed(s, "vvvc")
  self:parse_BNVS_new_conditional_module_signed(s, "c")
  self:parse_BNVS_new_conditional_module_signed(s, "cn")
  self:parse_BNVS_new_conditional_module_signed(s, "cv")
  self:parse_BNVS_new_conditional_module_signed(s, "vn")
  self:parse_BNVS_new_conditional_module_signed(s, "vv")
  self:parse_BNVS_new_conditional_tl_signed(s, "vvc", false)
  self:parse_BNVS_new_conditional_module_cc(s)
  self:check_unused_variants()
  self:check_unused_conditional_variants(true)
  self:check_undefined()
  return self:output()
end
local function check_variants (path) --> string?
  local file = io.open(path, "r")
  if file == nil then
    return nil
  end
  local s = file:read("a")
  file:close()
  local ra1 = Command:check_variants([[
\BNVS_set:bpn { v_gput:nn } #1 #2 {
  \prop_gput:Nnn \g__bnvs_v_prop { #1 } { #2 }
\BNVS_DEBUG_log_f:bnnnn { v_gput:nn } { KEY } { #1 } { VALUE } { #2 }
\BNVS_DEBUG_log_gprop:n {}
}
\cs_generate_variant:Nn \BNVS_v_gput:nn { nV }
\bnvs_TEST_A:n
\bnvs_TEST_B:nn
\cs_set:Npn \bnvs_TEST_B:nn {}
\cs_new:Npn \bnvs_C:nn {}
\BNVS_new_conditional:bpnn { get:nnc } #1 #2 #3 { p, T, F, TF } {}
\_generate_conditional_variant:Nnn
  \BNVS_get:nnix {nV} { p, T, F, TF }
]])
  local ra2 = Command:check_variants(s)
  for _,v in ipairs(ra2) do
    ra1[#ra1+1] = v
  end
  return ra2
end
return {
  __INFO__ = "beanoves dedicated table for DEBUGGING",
  check_variants  = check_variants,
  Command__ = Command,
}
%</test-lua>
%<*internal>
\fi
%</internal>
% \end{bnvs.gobble}
